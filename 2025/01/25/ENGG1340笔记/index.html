<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>ENGG1340笔记 - ntcs&#039; blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ntcs&#039; blog"><meta name="msapplication-TileImage" content="img/icon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ntcs&#039; blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="自学ENGG1340写的笔记"><meta property="og:type" content="article"><meta property="og:title" content="ENGG1340笔记"><meta property="og:url" content="http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="ntcs&#039; blog"><meta property="og:description" content="自学ENGG1340写的笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB3d38757cff77704b4b626c7e77a8299a?method=download&amp;amp;shareKey=7d62b9dd7d9765da3fbbc8ff1020e3f9"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB2e57509e464b685521f221612db841b6?method=download&amp;amp;shareKey=980a26dccb73b17e40f57a8a8bbfb599"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEBfe2c1fb97579cb3ac7600cc5974e5bb8?method=download&amp;amp;shareKey=866755676c9de499cfa8e00e7cad5101"><meta property="article:published_time" content="2025-01-25T06:18:50.000Z"><meta property="article:modified_time" content="2025-02-05T15:29:22.863Z"><meta property="article:author" content="ntcs"><meta property="article:tag" content="笔记"><meta property="article:tag" content="计算机"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"},"headline":"ntcs' blog","image":[],"datePublished":"2025-01-25T06:18:50.000Z","dateModified":"2025-02-05T15:29:22.863Z","author":{"@type":"Person","name":"ntcs"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"自学ENGG1340写的笔记"}</script><link rel="canonical" href="http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/icon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/&gt; all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="ntcs' blog" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-01-25  <a class="commentCountImg" href="/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">/2025/01/25/ENGG1340笔记/</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="81cf628bb0f4d3d5adbb6fdbb4cc8f4a">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>17.5 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">ENGG1340笔记</h1><div class="content"><blockquote>
<p>自学ENGG1340写的笔记<br><span id="more"></span></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>惊讶的发现这学期ENGG1340是自学课，没有Lecture。讲道理挺舒服的。</p>
<p>ENGG1340期望你拥有Python编程知识作为基础，然后逐渐引入更深层的新内容，包括Linux / Bash Shell，版本控制（Git），C/C++语言等。</p>
<p>叠甲先：笔记可能出错所以轻喷。内容是根据课上发的笔记转写的，所以本文算是个人梳理吧</p>
<hr>
<h1 id="Module-1-Linux-Environment"><a href="#Module-1-Linux-Environment" class="headerlink" title="Module 1: Linux Environment"></a>Module 1: Linux Environment</h1><p>Linux如同Windows一样是操作系统。Linux是开源的，这导致Linux相较于其他操作系统拥有更多长处，例如：可自定义程度较强，安全性也比较高（因为你可以直接读到源代码）。<br>因为Linux是开源的，所以使用Linux也是免费的。在一些相对低价的电子产品上，使用Linux作为操作系统就很划算。</p>
<p>Linux存在不同的发行版，例如Ubuntu, CentOS, Debian等。</p>
<p>在ENGG1340中我们将会使用Ubuntu，虽然现阶段不同发行版不会对课程大纲产生太多影响。</p>
<hr>
<h2 id="Linux-Shell"><a href="#Linux-Shell" class="headerlink" title="Linux Shell"></a>Linux Shell</h2><p>Shell 是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Linux中有不同种类的shell，比如Korn Shell, Bourne Shell, C Shell，以及Bash Shell。<br>不同的Shell之间命令可能有些许区别，例如Korn Shell使用<code>print</code>命令输出一个字符串，而Bash Shell使用<code>echo</code>命令。</p>
<p>在ENGG1340里我们主要使用Bash Shell。</p>
<hr>
<h3 id="Shell-Commands"><a href="#Shell-Commands" class="headerlink" title="Shell Commands"></a>Shell Commands</h3><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>向命令行中输入<code>date</code>，Shell会返回当前系统的时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Sat Jan 25 14:51:19 HKT 2025</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="文件与路径操作"><a href="#文件与路径操作" class="headerlink" title="文件与路径操作"></a>文件与路径操作</h4><p><code>ls</code>命令列举当前目录下的所有文件和路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span> </span><br><span class="line">Documents/  logon.bat*  public_html/  t.txt  Downloads/ </span><br><span class="line">Pictures/  Templates/    </span><br><span class="line">Videos/    </span><br><span class="line">Music/      </span><br><span class="line">Desktop/  engg1340/ </span><br><span class="line">Public/    </span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>命令变体</strong>：</p>
<ul>
<li><code>ls -l</code>  以长字符方式输出，包含额外信息如文件大小，文件拥有者，上次编辑日期等</li>
<li><code>ls -a</code>  输出路径下所有内容，包含隐藏的文件和目录。隐藏的内容会以一点开头<code>.</code>。</li>
<li><code>ls -la</code>  就是<code>ls -l -a</code></li>
</ul>
</blockquote>
<hr>
<p><code>cd</code>命令用来重定向当前目录。例如我们想要访问当前目录下的engg1340路径，直接敲<code>cd engg1340</code>就行：</p>
<blockquote>
<p>命令变体：<br><code>cd ..</code> 前往当前目录的父级路径<br><code>cd ~</code>  前往当前用户的主目录<br><code>cd ~username</code>  前往指定用户的主目录<br><code>cd .</code> 前往当前目录 （虽说没啥效果就是了）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> engg1340</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span> </span><br><span class="line">lab1/  lab2/  lab3/ </span><br></pre></td></tr></table></figure>
<hr>
<p><code>pwd</code>命令将会输出当前的工作目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/home/d003/h978645312</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h4><p>Shell里面有许多命令，能将所有命令记住基本上是不现实的。因此，Shell提供了<code>man</code>命令（Manual的缩写），能够返回命令的详细解释。</p>
<p>例如我想要查看ls命令的详细解释，就可以使用<code>man ls</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LS(1)                                               User Commands                                               LS(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       ls - list directory contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       ls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       List  information  about the FILEs (the current directory by default).  Sort entries alphabetically if none of</span><br><span class="line">       -cftuvSUX nor --sort is specified.</span><br><span class="line"></span><br><span class="line">       Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line"></span><br><span class="line">       -a, --all</span><br><span class="line">              do not ignore entries starting with .</span><br><span class="line"></span><br><span class="line">       -A, --almost-all</span><br><span class="line">              do not list implied . and ..</span><br><span class="line"></span><br><span class="line">       --author</span><br><span class="line">              with -l, print the author of each file</span><br><span class="line"></span><br><span class="line">       -b, --escape</span><br><span class="line">              print C-style escapes for nongraphic characters</span><br><span class="line"></span><br><span class="line">       --block-size=SIZE</span><br><span class="line">              with -l, scale sizes by SIZE when printing them; e.g., '--block-size=M'; see SIZE format below</span><br><span class="line"></span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line"></span><br><span class="line">        -l     use a long listing format</span><br><span class="line"></span><br><span class="line"> Manual page ls(1) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure>
<p>从NAME区域我们可以得知<code>ls</code>的解释为”list directory contents”。<br>从DESCRIPTION区域得知，如果在ls后面加入可选参数<code>-l</code>，代表”use a long listing format”。这会在普通<code>ls</code>的基础上显示更多信息，包括文件大小，文件拥有者，上次编辑日期等等：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 26044</span><br><span class="line">drwxr-xr-x 17 1000 1000     4096 Nov  4 01:17 Python-3.11.0</span><br><span class="line">-rw-r--r--  1 root root 26333656 Oct 24  2022 Python-3.11.0.tgz</span><br><span class="line">drwxr-xr-x  4 root root     4096 Nov  1 13:25 napcat</span><br><span class="line">-rw-------  1 root root   317274 Nov  4 01:38 nohup.out</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="路径和文件管理"><a href="#路径和文件管理" class="headerlink" title="路径和文件管理"></a>路径和文件管理</h2><p>在Linux中根目录用<code>/</code>表示。根目录包含所有的文件和路径。</p>
<p>例如在根目录下有一个”home”路径，”home”下有另一个路径”kit”，那么这个”kit”路径的绝对路径就是：<code>/home/kit</code></p>
<p>有关相对路径和绝对路径的内容一会介绍。</p>
<hr>
<h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>绝对路径总是以<code>/</code>打头。举几个简单的例子：</p>
<ul>
<li><code>/home/file3</code>是在home路径下的文件file3的绝对路径。</li>
<li><code>/home/kit/Desktop/file4</code>是file4的绝对路径。</li>
</ul>
<p>而相对路径和当前的工作目录有联系，相对路径不会以<code>/</code>打头。</p>
<p>例如我们使用上面的file3做例子，如果当前的工作目录为<code>/home</code>，则file3的相对路径为<code>file3</code>。注意看刚才这个file3的路径不以<code>/</code>打头，所以能判断出这是一个相对路径。</p>
<p>file4同理。如果当前工作目录是<code>/home/kit</code>，那么file4的相对路径就是<code>Desktop/file4</code>。</p>
<hr>
<p>如果目录A包含另一个目录B，则A称为B的父目录，B称为A的子目录。例如在刚才的例子中，kit是home的子目录，home是kit的父目录。</p>
<p>一旦shell启动，它当前的工作目录就是主目录。我们总是可以通过命令pwd获得当前的工作目录。</p>
<hr>
<h3 id="主目录"><a href="#主目录" class="headerlink" title="主目录"></a>主目录</h3><p>对于任何用户，都有一个属于该用户的主目录。例如，用户 kit 的主目录位于<code>/home/kit</code></p>
<p><code>~</code>用来表示用户的主目录。你可以使用<code>cd ~</code>命令回到当前用户的主目录，也可以使用<code>cd ~username</code>来前往其他用户的主目录。</p>
<h3 id="路径管理"><a href="#路径管理" class="headerlink" title="路径管理"></a>路径管理</h3><h4 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h4><p><code>mkdir</code>命令可以用来创建路径   <del>新建文件夹</del></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> lab</span></span><br></pre></td></tr></table></figure>
<p>上面的命令会在当前的工作目录下创建一个lab路径。</p>
<p>如果你想在当前工作目录下创建多个路径，可以直接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> lab1 lab2</span></span><br></pre></td></tr></table></figure>
<p>如果想在路径名中包括空格，可以在创建路径时将路径名用引号引起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="string">"lab 1"</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="移除路径"><a href="#移除路径" class="headerlink" title="移除路径"></a>移除路径</h4><p><code>rmdir</code>命令可以用来移除空路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> lab</span></span><br></pre></td></tr></table></figure>
<p>如果想要移除的路径不是空路径，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab1</span></span><br><span class="line">file1.txt  file2.txt</span><br></pre></td></tr></table></figure>
<p>就需要使用<code>rm -rf</code>或者<code>rm -r -f</code>来移除整个路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -r -f lab1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab1</span></span><br><span class="line">ls: cannot access 'lab1': No such file or directory</span><br></pre></td></tr></table></figure>
<p>可以看到路径被成功移除了。</p>
<p><code>-r</code>参数代表系统会按照递归方式向下遍历目标路径下的文件和路径，而<code>-f</code>可以确保删除过程不需要你来进行确认。如果当前路径下文件巨多，不带<code>-f</code>就会很麻烦了。</p>
<hr>
<h4 id="重命名路径"><a href="#重命名路径" class="headerlink" title="重命名路径"></a>重命名路径</h4><p><code>mv</code>命令虽然叫move，但是也可以用来重命名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> lab <span class="string">"lab 1"</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令会把<code>lab</code>路径重命名至<code>lab 1</code>。</p>
<p>如果<code>mv</code>命令下第一个参数和第二个参数的类型一致，例如参数1和参数2都是文件类型，则该命令会将参数1重命名至参数2。</p>
<hr>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p><code>touch</code>命令可以用来创建一个空文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file1.txt</span></span><br></pre></td></tr></table></figure>
<p>可以创建一个名叫”file1.txt”的空文件。</p>
<hr>
<h4 id="展示文件内容"><a href="#展示文件内容" class="headerlink" title="展示文件内容"></a>展示文件内容</h4><p><code>cat</code>，命令可以用来展示文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1.txt</span></span><br><span class="line">Hello, this is the content of file1.txt</span><br><span class="line">Bye Bye!</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p><code>mv</code>命令也可以用来移动文件或者路径位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello.txt mydir</span></span><br></pre></td></tr></table></figure>
<p>好比说这串命令会将hello.txt移动到<code>mydir</code>路径下。</p>
<p>如果文件拥有同样的前缀，你可以使用星号(<em>)来选中所有符合条件的项。<br>例如：将所有拥有“ <em>*myfile</em></em> ”前缀的文件移动到lab路径下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">myfile1.txt  myfile2.txt lab/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> myfile* lab</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">lab/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab</span></span><br><span class="line">myfile1.txt  myfile2.txt</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p>除此之外还有其他关于文件操作的命令集合：</p>
<p><code>cp</code> 命令用于复制文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2</span></span><br></pre></td></tr></table></figure>
<p>会将”file1”复制至”file2”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r dir1 dir2</span></span><br></pre></td></tr></table></figure>
<p>会将<code>dir1</code>路径包括路径下的所有内容复制到dir2中。</p>
<hr>
<h3 id="使用vi编辑器"><a href="#使用vi编辑器" class="headerlink" title="使用vi编辑器"></a>使用vi编辑器</h3><p>vi编辑器用来创建并编辑文本。就好比Windows上的记事本，或Linux上的gedit，但是他没有图形用户界面，完全在命令行中使用。</p>
<p>vi编辑器中有两个功能：</p>
<ol>
<li>插入模式(Insert mode)：在这个模式中你可以编辑文件内容</li>
<li>命令模式(Command mode)：命令模式用来执行文件操作，比如保存文件等</li>
</ol>
<p>要使用vi编辑器打开一个文件，只需要敲入<code>vi</code>命令即可。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi file2.txt</span></span><br></pre></td></tr></table></figure>
<p>将会打开工作目录下的”file2.txt”文件。如果该文件不存在，编辑器会帮你自动创建一个。</p>
<p>!()[<a target="_blank" rel="noopener" href="https://note.youdao.com/yws/api/personal/file/WEB851884414ef36fe09b4feda45b512323?method=download&amp;shareKey=cbca8ca352f134b3e06ba8e53e65b13c">https://note.youdao.com/yws/api/personal/file/WEB851884414ef36fe09b4feda45b512323?method=download&amp;shareKey=cbca8ca352f134b3e06ba8e53e65b13c</a>]</p>
<p>进入vi编辑器后默认为命令模式。因为我们的路径下没有file2.txt，如你所见编辑器目前显示的是空白文件。</p>
<p><strong>按”I”键切换至插入模式</strong>。当你在插入模式时，你可以在界面的左下角看到<code>-- INSERT --</code>：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909" alt=""></p>
<p>在插入模式中你可以按照我们熟悉的样子编辑文件。如果编辑完成想要保存文件，则需要退回至命令模式。</p>
<p>在插入模式时，<strong>按”esc”以回到命令模式</strong>。当你回到命令模式后，你将不会再左下角看到<code>-- INSERT --</code>字样。这时输入<code>:wq</code>并按下Enter，你会退出vi编辑器，同时你的文件会被保存。</p>
<hr>
<h4 id="命令模式下的命令"><a href="#命令模式下的命令" class="headerlink" title="命令模式下的命令"></a>命令模式下的命令</h4><p>除了“保存并关闭”(<code>:wq</code>)命令外，还有下面这些常见命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">执行的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>:wq</code></td>
<td style="text-align:center">保存并退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:w</code></td>
<td style="text-align:center">保存（但不退出vi编辑器）</td>
</tr>
<tr>
<td style="text-align:center"><code>:w filename</code></td>
<td style="text-align:center">保存到名叫”filename”的新文件下</td>
</tr>
<tr>
<td style="text-align:center"><code>:q</code></td>
<td style="text-align:center">退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:q!</code></td>
<td style="text-align:center">不保存并退出vi编辑器</td>
</tr>
</tbody>
</table>
</div>
<p>想要查阅完整的命令列表的话<a target="_blank" rel="noopener" href="https://www.cs.colostate.edu/helpdocs/vi.html">点我</a></p>
<p>或者你也可以查阅这张Cheatsheet：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3d38757cff77704b4b626c7e77a8299a?method=download&amp;shareKey=7d62b9dd7d9765da3fbbc8ff1020e3f9" alt="Cheatsheet"></p>
<hr>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>Linux系统中的每个文件或目录都被分配了3种类型的所有者。</p>
<ul>
<li><strong>用户（User）</strong>：用户可以作为文件的拥有者</li>
<li><strong>用户组（Group）</strong>：用户组中可以包含多个用户。若用户组拥有一个文件的权限，则组中的每个用户都有该文件的权限。</li>
<li><strong>其他（Other）</strong>：有权访问文件的任何其他用户。它既没有创建文件，也不属于拥有该文件的组。</li>
</ul>
<p>每个用户对于上面的三种所有者定义了三种不同的文件权限：</p>
<ul>
<li><strong>读取（Read）</strong>：拥有文件读取权限的个体可以打开并读取文件中的内容。拥有路径读取权限的个体可以列举出该路径下的内容。</li>
<li><strong>写入（Write）</strong>：拥有文件写入权限的个体可以更改文件中的内容。拥有路径读取权限的个体可以在路径中添加，移除或者重命名内容。</li>
<li><strong>执行（Execute）</strong>：执行权限允许个体来运行程序</li>
</ul>
<hr>
<p>不如举个例子看看：使用之前提到过的<code>ls -l</code>命令来列举出路径下的内容，里面会告诉你文件权限的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 10</span><br><span class="line">-rw------- 1 cklai ra 50 Jul 30 17:07 file1.txt</span><br><span class="line">-rw------- 1 cklai ra 48 Jul 31 15:14 file2.txt</span><br><span class="line">drwx------ 2 cklai ra  2 Jul 30 17:00 lab/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="权限指示"><a href="#权限指示" class="headerlink" title="权限指示"></a>权限指示</h3><p>借用上面的例子，我们来仔细讲讲刚才的输出是啥意思：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total 10</span><br><span class="line">-rw------- 1 cklai ra 50 Jul 30 17:07 file1.txt</span><br></pre></td></tr></table></figure>
<p><code>total 10</code>代表文件在文件系统中占用了多大空间，单位为千字节（kilobytes）。<br>由左至右分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">条目</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-rw-------</code></td>
<td style="text-align:center">代表<strong>文件权限</strong>。具体的释义马上就解释（</td>
</tr>
<tr>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">代表<strong>文件拥有的硬链接数量</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>cklai</code></td>
<td style="text-align:center">代表<strong>文件拥有者</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>ra</code></td>
<td style="text-align:center">文件拥有者存在的用户组</td>
</tr>
<tr>
<td style="text-align:center"><code>50</code></td>
<td style="text-align:center"><strong>文件大小</strong>，单位为字节（byte）</td>
</tr>
<tr>
<td style="text-align:center"><code>Jul 23 17:07</code></td>
<td style="text-align:center"><strong>上次修改时间</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>file1.txt</code></td>
<td style="text-align:center"><strong>文件名</strong></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>现在我们来讲讲权限指示该怎么解读。<br>权限指示（Permission indicator）是一个十字符长的字符串，通常分为四部分：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e57509e464b685521f221612db841b6?method=download&amp;shareKey=980a26dccb73b17e40f57a8a8bbfb599" alt=""></p>
<p>这玩意可以分成四部分解读，<strong>Type</strong>, <strong>User permissions</strong>, <strong>Group permission</strong>和<strong>Other permission</strong>。</p>
<hr>
<p><strong>Type</strong>:</p>
<p>代指权限指示的第一个字符。</p>
<ul>
<li>如果第一个字符是<strong>短横线 “-“</strong>，则代表它是一个<strong>正常文件</strong>。</li>
<li>如果第一个字符是<strong>字母d “d”</strong>，则代表这是一个路径。</li>
</ul>
<p>还有其他的类型不过这里涵盖不到。可以自己上网查询。</p>
<hr>
<p><strong>User permissions</strong></p>
<p>第2-4个字符表示用户的权限。三个位置会显示”r”, “w”或者”x”。</p>
<p>比如这里显示了”rw-“，就代表：</p>
<ul>
<li>可以读取文件 (read, r)</li>
<li>可以写入文件 (write, w)</li>
<li>但是<em>不能</em>执行文件。如果文件可以被执行，第三个位置会显示”x”</li>
</ul>
<hr>
<p><strong>Group permission</strong></p>
<p>5-7个字符表示了用户组的权限。同样用rwx表示权限。</p>
<hr>
<p><strong>Other permission</strong></p>
<p>最后三位表示了文件对其他所有人的权限。</p>
<p>如果显示”—-“，则表示其他人都不可以读取(r)，写入(w)，并且也不能执行(x)</p>
<hr>
<h3 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h3><p>你可以使用<code>chmod</code>命令来更改你拥有的文件或者路径的权限：</p>
<p><code>chmod</code>命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> [<span class="built_in">who</span>][operator][permissions] filename</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>who</code></li>
</ul>
<p>在参数<code>who</code>内，可以键入四个不同的字母来指定要更改的对象群体：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>u</strong></td>
<td style="text-align:center">指定<strong>用户</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>g</strong></td>
<td style="text-align:center">指定<strong>用户组</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>o</strong></td>
<td style="text-align:center">指定<strong>其他</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>a</strong></td>
<td style="text-align:center">指定<strong>所有群体</strong>的权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<ul>
<li><code>operator</code></li>
</ul>
<p>在参数<code>operator</code>内，共有三个运算符，用来代指具体的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center"><strong>增加</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>-</strong></td>
<td style="text-align:center"><strong>移除</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>=</strong></td>
<td style="text-align:center"><strong>设定</strong>权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<ul>
<li><code>permission</code></li>
</ul>
<p>在参数<code>permission</code>内，就是我们熟悉的r, w和x了。这些参数用指定要用来增加或者减少的权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>r</strong></td>
<td style="text-align:center"><strong>读取</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>w</strong></td>
<td style="text-align:center"><strong>写入</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>x</strong></td>
<td style="text-align:center"><strong>运行</strong>权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><strong>Example 1：更改权限</strong></p>
<p>在Linux中，可以首先使用<code>touch</code>创建一个新文件。<code>touch</code>命令创建的文件对用户的默认权限为可读可写(rw-)。<br>想要更改权限，就可以使用<code>chmod</code>来指定文件的权限。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 26</span><br><span class="line">-rw------- 1 cklai ra   0 Aug  1 11:48 file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o+w file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 26</span><br><span class="line">-rw-----w- 1 cklai ra   0 Aug  1 11:48 file</span><br></pre></td></tr></table></figure>
<p>其中，<code>chmod o+w file</code>意思是对于其他用户(o)授予(+)写入(w)权限。</p>
<hr>
<p><strong>Example 2： 更改多个权限</strong></p>
<p>可以在<code>permission</code>参数内键入多个值来一次性设置多个权限。就刚才的例子往下继续：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">-rw-----w- 1 cklai ra   0 Aug  1 11:48 file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o+rx file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">-rw----rwx 1 cklai ra   0 Aug  1 11:48 file*</span><br></pre></td></tr></table></figure>
<p><code>chmod o+rx file</code>的释义为：对其他用户(o)授予(+)读取(r)和运行(x)权限。</p>
<p>可以看到更新完权限后，文件名后面出现了一个星号”*”，这代表文件现在是可执行的。</p>
<hr>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p>这里会介绍很多新的命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>grep 'abc' file</code></td>
<td style="text-align:left">返回在文件中包含”abc”的行。可以使用更高级的描述来实现更复杂的搜索。</td>
</tr>
<tr>
<td style="text-align:center"><code>cut -d, -f2 file</code></td>
<td style="text-align:left">返回特定的数据列。<br>它根据标志-d指定的定界符分隔每行，并返回标志-f指定的列（字段编号从1开始）。</td>
</tr>
<tr>
<td style="text-align:center"><code>diff file1 file2</code></td>
<td style="text-align:left">显示两个文件的区别。</td>
</tr>
<tr>
<td style="text-align:center"><code>wc file</code></td>
<td style="text-align:left">返回文件中的行数，字数和字符数。</td>
</tr>
<tr>
<td style="text-align:center"><code>sort file</code></td>
<td style="text-align:left">按照字母顺序将文件中的每行进行排序</td>
</tr>
<tr>
<td style="text-align:center"><code>uniq file</code></td>
<td style="text-align:left">用于删除相邻的重复行，最后只会留下一个重复行。</td>
</tr>
<tr>
<td style="text-align:center"><code>spell file</code></td>
<td style="text-align:left">检查文件中所有的拼写错误。</td>
</tr>
<tr>
<td style="text-align:center"><code>su</code></td>
<td style="text-align:left">将用户模式更改为超级用户模式。</td>
</tr>
<tr>
<td style="text-align:center"><code>yum install prog</code><br>或者<br><code>apt-get install prog</code></td>
<td style="text-align:left">这个命令会链接特定服务器来下载并安装程序。<br>一般来讲你需要先运行<code>su</code>才能使用这些命令来安装程序。</td>
</tr>
<tr>
<td style="text-align:center"><code>man cmd</code></td>
<td style="text-align:left">显示命令<code>cmd</code>的手册页。找到使用命令的其他选项对您非常有用。</td>
</tr>
</tbody>
</table>
</div>
<p>接下来我们会细致介绍这些命令的用法</p>
<hr>
<h3 id="文件内搜索-grep"><a href="#文件内搜索-grep" class="headerlink" title="文件内搜索 (grep)"></a>文件内搜索 (grep)</h3><p><code>grep</code>命令适用于搜索文件内的行。</p>
<p>例如这里有一个”<em>example1.txt</em>“文件包含如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 Apple 3.5</span><br><span class="line">4 Chicken 50</span><br><span class="line">1 Coke 5.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">3 Chocolate 15</span><br><span class="line">2 Milk 8</span><br></pre></td></tr></table></figure>
<p>运行下面的命令将会返回文件内所有包含”ke”的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'ke'</span> example1.txt</span></span><br><span class="line">4 Chicken 50</span><br><span class="line">1 Coke 5.5</span><br></pre></td></tr></table></figure>
<p>搜索是很大的一块内容。这里仅用来介绍。后面我们会在搜索章节一起将文件内文件外搜索一并讲清楚的。  </p>
<p><br></p>
<hr>
<h3 id="文件字数-wc"><a href="#文件字数-wc" class="headerlink" title="文件字数 (wc)"></a>文件字数 (wc)</h3><p>同样使用”example1.txt”作为例子：</p>
<p>运行该命令则会返回如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> example1.txt</span></span><br><span class="line"> 6 18 71 example1.txt</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>第一个数字代表<strong>行数</strong>，也就是文件共有六行</li>
<li>第二个数字代表<strong>词数</strong>，表明文件中有18个词</li>
<li>第三个数字代表<strong>文件大小</strong>，代指文件大小为71字节</li>
</ul>
<p>搭配参数<code>-l</code>使用可以仅仅返回行数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -l example1.txt</span></span><br><span class="line">6 example1.txt</span><br></pre></td></tr></table></figure>
<p>搭配参数<code>-w</code>使用可以仅仅返回词数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -w example1.txt</span></span><br><span class="line">18 example1.txt</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用<code>sort</code>命令来对文件内容排序。如果没有指定任何输入参数，则默认排序方式按照<strong>字母表顺序排列</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> example1.txt</span></span><br><span class="line">1 Coke 5.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br><span class="line">5 Apple 3.5</span><br></pre></td></tr></table></figure>
<p>你可以使用不同的传入参数来指定排序方法。例如：</p>
<ul>
<li>使用<code>-n</code>则按照数字顺序排序：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -n example1.txt</span></span><br><span class="line">1 Coke 5.5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br><span class="line">5 Apple 3.5</span><br><span class="line">10 Jelly 5</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-r</code>则按照倒序顺序排序:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -n -r example1.txt</span></span><br><span class="line">10 Jelly 5</span><br><span class="line">5 Apple 3.5</span><br><span class="line">4 Chicken 50</span><br><span class="line">3 Chocolate 15</span><br><span class="line">2 Milk 8</span><br><span class="line">1 Coke 5.5</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-k</code>则按照字段排序。需要注意排序字段ID从1开始，而不是0。</li>
</ul>
<p>例如，将文件按照第三个字段进行排序。在”example1.txt”中，每行最后的那组数字就是第三字段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -k3 -n example1.txt</span></span><br><span class="line">5 Apple 3.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">1 Coke 5.5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-t</code>用来告诉排序程序，我们使用分隔符并非空格而是逗号。</li>
</ul>
<p>例如我们有一个”example1.txt”的变体，”example1_comma.txt”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example1_comma.txt</span></span><br><span class="line">5,Apple,3.5</span><br><span class="line">4,Chicken,50</span><br><span class="line">1,Coke,5.5</span><br><span class="line">10,Jelly,5</span><br><span class="line">3,Chocolate,15</span><br><span class="line">2,Milk,8</span><br></pre></td></tr></table></figure>
<p>需要在使用<code>sort</code>时加入参数<code>-t</code>来指定分隔符为逗号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -t, -k3 -n example1_comma.txt</span></span><br><span class="line">5,Apple,3.5 </span><br><span class="line">10,Jelly,5 </span><br><span class="line">1,Coke,5.5 </span><br><span class="line">2,Milk,8 </span><br><span class="line">3,Chocolate,15 </span><br><span class="line">4,Chicken,50</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="剪切文件"><a href="#剪切文件" class="headerlink" title="剪切文件"></a>剪切文件</h3><p>这里指的不是我们熟悉的剪切文件到其他目录，而是直接在文件内剪掉一部分内容。</p>
<p><code>cut</code>命令将会修剪文件并返回特定的内容。要使用这个命令，我们需要向<code>cut</code>命令指定分隔符。</p>
<p>指定分隔符的参数为<code>-d</code>，代表delimiter，注意不要和之前的<code>sort</code>命令搞混了！该参数不是可选的，即便分隔符为空格，你也需要指定参数<code>-d</code>。</p>
<p>使用参数<code>-f</code>来告诉程序你想要返回的字段，说白了就是列。和<code>sort</code>一样，字段ID从1开始而不是0。</p>
<p>例如，返回”example1.txt”文件内的第一字段和第三字段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d <span class="string">' '</span> -f 1,3 example1.txt</span></span><br><span class="line">5 3.5 </span><br><span class="line">4 50 </span><br><span class="line">1 5.5 </span><br><span class="line">10 5 </span><br><span class="line">3 15 </span><br><span class="line">2 8</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="移除重复行"><a href="#移除重复行" class="headerlink" title="移除重复行"></a>移除重复行</h3><p><code>uniq</code>命令删除相邻的重复行，只保留一个重复行。  </p>
<p>注意咯，它只删除相邻的重复项。</p>
<p>“example2.txt”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Apple </span><br><span class="line">Apple pie </span><br><span class="line">Apple pie </span><br><span class="line">Apple </span><br><span class="line">Apple </span><br><span class="line">Apple pie</span><br></pre></td></tr></table></figure>
<p>想要移除在”example2.txt”中多余的相邻重复行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uniq</span> example2.txt</span> </span><br><span class="line">Apple </span><br><span class="line">Apple pie </span><br><span class="line">Apple </span><br><span class="line">Apple pie</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h3><p><code>spell</code>命令返回文件中所有可能出现拼写错误的词：</p>
<p>“example3.txt”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">It's a beautiffful day!</span><br><span class="line">I am so happpy todday.</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spell example3.txt</span></span><br><span class="line">beautiffful </span><br><span class="line">happpy </span><br><span class="line">todday</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>如果你自己的Linux机子运行这个命令报错，那么你的系统很有可能没有安装需要的软件包。按照下面的步骤修复这个问题吧：</p>
<ol>
<li>切换到Superuser账号：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br></pre></td></tr></table></figure>
<p>还记得我们之前说过安装软件包之前需要切换到su账号吗</p>
<ol>
<li>安装<code>aspell</code>包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install aspell</span></span><br></pre></td></tr></table></figure>
<ol>
<li>退回到你当前的账户：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件差异"><a href="#文件差异" class="headerlink" title="文件差异"></a>文件差异</h3><p><code>diff</code>命令用来显示两个文件的区别。</p>
<p>“fileA.txt”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>
<p>“fileB.txt”:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eee</span><br><span class="line">aaa</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure></p>
<p>下面的命令则会返回将”fileA.txt”转化为”fileB.txt”的步骤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff fileA.txt fileB.txt</span></span><br><span class="line">0a1 </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eee</span> </span><br><span class="line">2,3c3 </span><br><span class="line">&lt; bbb </span><br><span class="line">&lt; ccc</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ddd</span> </span><br></pre></td></tr></table></figure>
<p>这里我们需要一点解释了。</p>
<p><strong>0a1</strong>：  </p>
<p>在<em>fileA</em>的第<strong>0</strong>行之后添加(<strong>a</strong>, add)一行，添加的内容由下一行<strong>&gt; eee</strong>表示</p>
<p><strong>2, 3c3</strong>：  </p>
<p>将<em>fileA</em>中的第<strong>2, 3</strong>行变成(<strong>c</strong>, change)<em>fileB</em>的第三行。<br>完成这一步需要先删除掉两行，由<strong>&lt;</strong>表示：</p>
<p><strong>&lt; bbb</strong><br><strong>&lt; ccc</strong><br>代表删除掉这两行。</p>
<p>分割线隔开后出现了<strong>&gt;</strong>。这代表我们需要在删除后再次添加一行：</p>
<p><strong>&gt; ddd</strong></p>
<p>代表再添加文本”ddd”</p>
<p>这样就能把”fileA.txt”变成”fileB.txt”了。</p>
<hr>
<p>再举另一个例子把：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff fileB.txt fileA.txt</span> </span><br><span class="line">1d0 </span><br><span class="line">&lt; eee </span><br><span class="line">3c2,3 </span><br><span class="line">&lt; ddd </span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">bbb</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ccc</span> </span><br></pre></td></tr></table></figure>
<p>刚才是由A变B，现在是由B变A了。</p>
<p><strong>1d0</strong>：  </p>
<p>在<em>fileB</em>中删除(<strong>d</strong>, delete)第一行，随后的内容就会在第<strong>0</strong>行被对齐。</p>
<p><strong>&lt; eee</strong>表示我们删除了”eee”</p>
<p><strong>3c2,3</strong>：  </p>
<p>和刚才刚好反过来，将<em>fileB</em>中的第<strong>3</strong>行变为<em>fileA</em>的<strong>2,3</strong>行。先删去”ddd”，然后加入”bbb”和”ccc”</p>
<hr>
<h2 id="标准I-O，文件重定向和管道"><a href="#标准I-O，文件重定向和管道" class="headerlink" title="标准I/O，文件重定向和管道"></a>标准I/O，文件重定向和管道</h2><h3 id="标准IO和文件重定向"><a href="#标准IO和文件重定向" class="headerlink" title="标准IO和文件重定向"></a>标准IO和文件重定向</h3><h4 id="标准输入，输出和标准错误"><a href="#标准输入，输出和标准错误" class="headerlink" title="标准输入，输出和标准错误"></a>标准输入，输出和标准错误</h4><p>在Shell中使用命令时，Shell将每个进程与一些打开的文件关联起来，并使用称为<strong>文件描述符</strong> (File descriptors)的数字引用这些打开的文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件描述符</th>
<th style="text-align:left">文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">标准输入(stdin) - 输入文件</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">标准输出(stdout) - 输出文件</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">标准错误(stderr) - 输出错误的文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="重定向运算符"><a href="#重定向运算符" class="headerlink" title="重定向运算符"></a>重定向运算符</h4><p>一般来讲当我们执行命令时，输出会在屏幕上通过Shell打印出来。我们可以使用<strong>重定向运算符</strong> (Redirection operator) “<strong>&gt;</strong>“ 来重定向输出到一个文件内。  </p>
<p>例如，下面的命令将会保存路径中的文件到”file.txt”中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l 1&gt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>或者也可以用这样的短格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>如果使用了上述命令，则输出将不会显示在屏幕上，而是会被记录到文件”files.txt”中。当用来排查数据，debug或者就是简单保存信息时，这招很有用。</p>
<blockquote>
<p>如果多次执行上述命令，系统可能会显示”<strong>cannot overwrite existing file</strong>“。<br>为了解决这个问题，可以先手动删除已有的文件，或者使用<strong>&gt;|</strong>强制写入文件。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt;| files.txt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<hr>
<p>下面是一些常见的重定向运算符和他们的释义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>command 1&gt; file</code><br>或者<br><code>command &gt; file</code></td>
<td style="text-align:left">将标准输出<strong>发送到</strong> <em>file</em>中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 1&gt;&gt; file</code><br>或者<br><code>command &gt;&gt; file</code></td>
<td style="text-align:left">将标准输出<strong>追加到</strong> <em>file</em>中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 2&gt; file</code></td>
<td style="text-align:left">将标准错误<strong>发送到*</strong>file*中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 2&gt;&gt; file</code></td>
<td style="text-align:left">将标准错误<strong>追加到*</strong>file*中</td>
</tr>
<tr>
<td style="text-align:center"><code>command &lt; fileA &gt; fileB 2&gt;fileC</code></td>
<td style="text-align:left">首先命令会从<em>fileA</em>中读取，执行后将输出发送到<em>fileB</em>，将标准错误发送到<em>fileC</em></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong>&gt;</strong>和<strong>&gt;&gt;</strong>的区别在于，”&gt;”将会在每次执行时覆盖文件内容，而”&gt;&gt;”则会在文件后面追加内容。</p>
<hr>
<p>如果我们这里有一个C++程序，我们也可以使用这样的运算符来进行操作。例如下面的程序”add.cpp”会由两个输入，将两个输入加起来之后获得一个输出：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="type">int</span> a;</span><br><span class="line">       <span class="type">int</span> b;</span><br><span class="line">       std::cin &gt;&gt; a;</span><br><span class="line">       std::cin &gt;&gt; b;</span><br><span class="line">       std::cout &lt;&lt; a+b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编译文件为一个叫做”add”的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ add.cpp -o add</span></span><br></pre></td></tr></table></figure>
<p>这时你可以将自己的输入写到文件内，如”input.txt”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>然后使用”&lt;”传入参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./add &lt; input.txt</span></span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>或者你可以更进一步，将输入和输出都独立出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./add &lt; input.txt &gt; output.txt</span></span><br></pre></td></tr></table></figure>
<p>为何不能使用 <code>input.txt &gt; ./add &gt; output.txt</code>这种写法？因为Shell会尝试执行input.txt。  </p>
<p><br></p>
<hr>
<h4 id="管线"><a href="#管线" class="headerlink" title="管线"></a>管线</h4><p>有时候我们需要将一个程序的输出换做另一个程序的输入，我们可以创建并且利用管线来优雅地解决这个问题。  </p>
<p>“|”是管线的符号。这个符号用来重定向一个程序的输出到另一个程序的输入，没有中间商赚差价。所谓中间商就是刚才用到的输入输出文本文件。  </p>
<p>举个例子，如下是两行命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt; files.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">"Jan 26"</span> &lt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>简而言之就是使用<code>ls</code>命令列出所有内容到”files.txt”中，然后从”files.txt”中搜索所有含有”Jan 26”的行。  </p>
<p>太复杂了。  </p>
<p>整个操作可以换做下面的一行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep <span class="string">"Jan 26"</span></span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>|</code>，可以将<code>|</code>之前的命令输出直接当作<code>|</code>后面的命令传入。在这个例子中具体是将<code>ls -l</code>的输出当作<code>grep</code>命令的传入来用了。  </p>
<hr>
<p>举几个例子吧。  </p>
<p><strong>Example 1</strong>:</p>
<p>假设我们现在有一个”data.txt”文件，我们需要按照价格将其排序，然后仅仅将商品的名称和价格保存到”result.txt”文件夹中，要求只能使用一行命令。  </p>
<p>来看看标准题解：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -k3 -n data.txt | <span class="built_in">cut</span> -d<span class="string">' '</span> -f2,3 &gt; result.txt</span></span><br></pre></td></tr></table></figure>
<p>首先我们使用<code>sort</code>命令，对”data.txt”的<strong>第三个字段(-k3)</strong>按照<strong>数字顺序(n)</strong>进行排序。<br>然后你看见了<code>|</code>。这代表这一步的输出即将被传入到下一个命令，也就是<code>cut</code>。<br>在<code>cut</code>中我们以<strong>空格作为分隔符(-d’ ‘)</strong>，并<strong>保留第二第三字段(-f2,3)</strong>，最后存入到”result.txt”中。  </p>
<p>还是很简单的。下面是这个过程的视觉表述方式：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfe2c1fb97579cb3ac7600cc5974e5bb8?method=download&amp;shareKey=866755676c9de499cfa8e00e7cad5101" alt=""></p>
<hr>
<p><strong>Example 2</strong>:</p>
<p>目标是在当前路径下对用户，用户组和其他人有运行权限的文件和路径。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 190</span><br><span class="line">-rwx--x--x    1   kit  gopher   0   Sep  12 10:30  add.o</span><br></pre></td></tr></table></figure>
<p>对于所有目标都有执行权限的话，则权限指示的第4, 7, 10位应该是x。但是我们应该如何检索呢？看看下面这行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^...x..x..x'</span> [传入]</span></span><br></pre></td></tr></table></figure>
<p>使用<code>-E</code>参数可以告诉Shell我们需要做样式匹配搜索了。对于<code>'^...x..x..x'</code>来讲：  </p>
<ul>
<li>“^”表示从行首开始匹配。</li>
<li>“.”表示可以匹配任意字符。</li>
</ul>
<p>加在一起的话，<code>'^...x..x..x'</code>的意思大概就是，从行首开始匹配，返回在第4, 7, 10个位置有字母”x”的行。  </p>
<p>那么一行就能解决了：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep -E <span class="string">'^...x..x..x'</span></span></span><br></pre></td></tr></table></figure>
<p>结构上和上一个例子一样所以这里不解释了。  </p>
<p><br></p>
<hr>
<p><strong>Example 3</strong></p>
<p>加入你想移除文件里的某几列，然后将其输入到程序里。举个例子，”mark.txt”，包含学生信息的单行数据：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> mark.txt</span></span><br><span class="line">2011111111 John M 98.5 100 62.5 88 75.5</span><br></pre></td></tr></table></figure>
<p>对应格式是：[UID, 名称，性别，分数1，分数2，分数3，分数4，分数5]</p>
<p>然后我们同样有一个C++程序用来处理信息，用于计算平均分：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mark.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> main {</span><br><span class="line">       <span class="type">double</span> a1, a2, a3, a4, a5;</span><br><span class="line">       std::cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a3 &gt;&gt; a4 &gt;&gt; a5;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">"The overall mark the student get is: "</span>;</span><br><span class="line">       std::cout &lt;&lt; (a1 + a2 + a3 + a4 + a5) / <span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>程序的问题是输入仅有五项成绩，但是我们的”mark.txt”文件内包含UID在内的其他多余信息。  </p>
<p>那这就很坏了。  </p>
<p>一种方法是我们可以使用管线来先处理”mark.txt”，然后传入程序。我们可以使用<code>cut</code>命令处理一下：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d<span class="string">' '</span> -f-8 mark.txt</span></span><br><span class="line">98.5 100 62.5 88 75.5</span><br></pre></td></tr></table></figure>
<p>然后编译程序运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ mark.cpp -o mark</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d<span class="string">' '</span> -f4-8 mark.txt | ./mark &gt; result.txt</span></span><br></pre></td></tr></table></figure>
<p>这样程序的输出就会被记录到”result.txt”中：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> result.txt</span></span><br><span class="line">The overall marks the student get is: 84.9</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="搜索文件或路径-find"><a href="#搜索文件或路径-find" class="headerlink" title="搜索文件或路径 (find)"></a>搜索文件或路径 (find)</h3><p>各位应该在Windows或MacOS中使用过搜索功能。你也可以在Linux中实现对文件或路径的搜索操作：  </p>
<p>使用<code>find</code>命令可以用来搜索文件或路径。<code>find</code>命令的格式为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [path] [-name] [-type]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[path]</code>告诉系统你想从哪里开始搜索操作。  </li>
<li><code>[name]</code>是你想要搜索的文件或路径的名字。  </li>
<li><code>[type]</code>是可选参数，参数包含：  <ul>
<li><code>-type f</code>代表仅搜索文件 (<em>files</em>)</li>
<li><code>-type d</code>命令之搜索路径 (<em>directory</em>)</li>
</ul>
</li>
</ul>
<hr>
<p>举个例子，假如在当前位置有下面这几个文件和路径：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">hello/  hello.cpp  hello.txt</span><br></pre></td></tr></table></figure>
<p>那么在当前目录下搜索”hello.txt”的方法即为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello.txt"</span> -<span class="built_in">type</span> f</span></span><br><span class="line">./hello.txt</span><br></pre></td></tr></table></figure>
<p>上面的命令<br>在上面的命令中，<code>.</code>代表<strong>当前目录</strong>。指定当前目录后<code>find</code>会在这个目录为基础向下寻找文件。  </p>
<p><br></p>
<p>或者我们也可以在当前位置下搜索”hello”打头的文件：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello.*"</span> -<span class="built_in">type</span> f</span></span><br><span class="line">./hello.cpp</span><br><span class="line">./hello.txt</span><br></pre></td></tr></table></figure>
<p>…或者是搜索路径：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello"</span> -<span class="built_in">type</span> d</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件内搜索-grep-1"><a href="#文件内搜索-grep-1" class="headerlink" title="文件内搜索 (grep)"></a>文件内搜索 (grep)</h3><p><code>grep</code> (Global Regular Expression Print)命令之前已经介绍过了。这里介绍更多细节：  </p>
<p>之前用的是不带<code>-E</code>的使用方式，只是用来返回文件内的匹配行：  </p>
<p>“example1.txt”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello how are you?</span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'hell'</span> example1.txt</span></span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<p><code>grep</code>命令<strong>区分大小写！</strong>这就是为什么返回的是包含”shell”的第二行，而不是包含”Hello”的第一行。  </p>
<hr>
<p><code>grep</code>可以加入可选参数<code>-E</code>，代表按样式匹配。格式为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E [regular experssion] [filename]</span><br></pre></td></tr></table></figure>
<p>在<code>regular expression</code>中，你可以按照下面的符号来进行自定义匹配：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:left">匹配任何<strong>单个字符</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:left">仅从<strong>行首</strong>开始匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:left">仅从<strong>行尾</strong>开始匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:left">一个字符后面跟一个”?”，则该字符可被匹配<strong>0次或1次</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:left">一个字符后面跟一个”+”，则该字符可被匹配<strong>1次或多次</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">一个字符后面跟一个”<em>“，则该字符可被匹配<em>*0次或多次</em></em></td>
</tr>
<tr>
<td style="text-align:center"><code>[]</code></td>
<td style="text-align:left">被”[]”括起来的字符会被<strong>全字匹配</strong><br>括起来的字符可以是单个字符，也可以是多个字符<br>你可以用”-“符号来自定义区间<br>例如，与其使用[12345]，可以使用[1-5]代替</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:left"><strong>转义符</strong><br>使用转义符来取消特殊字符的特殊效用<br>例如我们想要寻找”.”而不发挥它“匹配单个字符的属性”，就写成<code>\.</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n}</code></td>
<td style="text-align:left">匹配”n”次出现的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n,}</code></td>
<td style="text-align:left">匹配<em>至少</em>“n”次出现的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n,m}</code></td>
<td style="text-align:left">匹配出现”n”和”m”次数之间的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>(ab){3}</code></td>
<td style="text-align:left">出现三次”ab”排列<br>例如(ab){3}会被匹配做”ababab”，不是”abbb”</td>
</tr>
</tbody>
</table>
</div>
<p>接下来我们使用刚才”example1.txt”，挑重点解释。  </p>
<hr>
<h4 id="任意单字符匹配"><a href="#任意单字符匹配" class="headerlink" title="任意单字符匹配"></a>任意单字符匹配</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'.ell'</span> example1.txt</span></span><br><span class="line">Hello how are you?</span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<p>‘.ell’代表”.”处可以匹配任何单个字符，例如”Cell”, “cell”, “bell”会被匹配。<br>如果如果你想要在”.”处搜索的字母仅仅是大小写H，则可以使用<code>[Hh]ell</code>。  </p>
<hr>
<h4 id="行首-行尾匹配"><a href="#行首-行尾匹配" class="headerlink" title="行首/行尾匹配"></a>行首/行尾匹配</h4><p>这里启用”example2.txt”：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'apple'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>使用”^”从行首开始匹配：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^apple'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>而使用”$”从行尾开始匹配：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'apple$'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>由此可知，使用”^”和”$”也可以全字匹配某一行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^apple$'</span> example2.txt</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>或者使用”^”, “$”配合”.”来返回只有五个字符的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^.....$'</span> example2.txt</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>
<hr>
<h4 id=""><a href="#" class="headerlink" title="?, +, *"></a>?, +, *</h4><p><strong>“?”</strong></p>
<p>“example3.txt”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">coco</span><br><span class="line">cherries</span><br><span class="line">orange</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap?'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<p>没看懂？首先”^”确保行首开始匹配，随后：  </p>
<ul>
<li>“<strong>ap</strong>ple”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了1次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了1次</li>
<li>“<strong>a</strong>ngel”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了0次</li>
</ul>
<p>那么接下来的东西，”+”和”*”，原理上基本上是一样的了。</p>
<hr>
<p><strong>+</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap+'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br></pre></td></tr></table></figure>
<ul>
<li>“<strong>app</strong>le”会被返回，因为在表达式中的p要求出现1次或者多次，这里出现了多次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现1次或者多次，这里出现了1次</li>
<li>“angel”没有被返回，因为在表达式中的p要求出现1次或者多次，这里出现了0次</li>
</ul>
<hr>
<p><strong>*</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap*+*'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<ul>
<li>“<strong>app</strong>le”会被返回，因为在表达式中的p要求出现0次或者多次，这里出现了多次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现0次或者多次，这里出现了1次</li>
<li>“<strong>a</strong>ngel”会被被返回，因为在表达式中的p要求出现0次或者多次，这里出现了0次</li>
</ul>
<hr>
<p>接下来是一些进阶一点的用法了：</p>
<p><strong>整合”.”和”*“</strong></p>
<p>如果我们想要匹配字符”a”，然后后方跟随任意字符，直到”ge”再次出现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'a.*ge'</span> example3.txt</span></span><br><span class="line">orange</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<p>“<em>“跟在”.”之后，所以”任意字符匹配”可以被匹配多次，这就是为什么”or<strong>ange</strong>“和”<em>*ang</em></em>el”能被返回的原因。  </p>
<hr>
<p><strong>使用括号”()”</strong></p>
<p>我们可以使用括号来整合子字符串。例如我们想要寻找字符串”co”出现过一次或多次的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'(co)+'</span> example3.txt</span></span><br><span class="line">coco</span><br></pre></td></tr></table></figure>
<p>为什么要用括号呢，看看如果不用括号会发生什么：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'co*'</span> example3.txt</span></span><br><span class="line">coco</span><br><span class="line">cherries</span><br></pre></td></tr></table></figure>
<p>因为”*”只会应用到它的前一个字符。没加括号的话就会被应用到”o”，而不是整个子字符串”co”。  </p>
<hr>
<h4 id="匹配集合"><a href="#匹配集合" class="headerlink" title="匹配集合"></a>匹配集合</h4><p>可以使用方括号 “[ ]”来定义一个集合，随后进行搜索。你可以按照下面的格式定义集合：  </p>
<ul>
<li><strong>[0123456789]</strong>或者<strong>[0-9]</strong>用来匹配任意单个数字</li>
<li><strong>[A-Z]</strong>用来匹配任何单个大写字母</li>
<li><strong>[a-z]</strong>用来匹配任何单个小写字母</li>
<li><strong>[A-Za-z]</strong>用来匹配任何单个字母，包括大写和小写字母。  </li>
</ul>
<p>例如我们有一个”example4.txt”：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple Juice HKD13</span><br><span class="line">apple pie USD 4</span><br><span class="line">Banana phone HKD</span><br></pre></td></tr></table></figure>
<p>查找包含”apple”或者”Apple”的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'[Aa]pple'</span> example4.txt</span></span><br><span class="line">Apple Juice HKD13</span><br><span class="line">apple pie USD 4</span><br></pre></td></tr></table></figure>
<p>查找包含”HKD”，并在其后跟随一个或者多个数字的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'HKD[0-9]*'</span> example4.txt</span></span><br><span class="line">Apple Juice HKD13</span><br><span class="line">Banana phone HKD</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="匹配序列"><a href="#匹配序列" class="headerlink" title="匹配序列"></a>匹配序列</h4><p>可以使用”{ }”来匹配一个序列 (pattern)。  </p>
<p>上”example5.txt”：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2April2013</span><br><span class="line">30-1-2013</span><br><span class="line">13December2013</span><br></pre></td></tr></table></figure>
<p>如果我们想要查找一个日月年的格式，并且日为2个字符，月至少为3个字符，年为4个字符，你可以整成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^[0-9]{1,2}[a-zA-Z]{3,}[0-9]{4}'</span> example5.txt</span></span><br><span class="line">2April2013</span><br><span class="line">13December2013</span><br></pre></td></tr></table></figure>
<p>这很抽象，所以我们需要简单讲讲：  </p>
<ul>
<li><strong>[0-9]{1,2}</strong>定义一个数字集合，并且需要至少出现一次，最多出现2次</li>
<li><strong>[a-zA-Z]{3,}</strong>定义一个字母（包含大小写）集合，并且需要至少3个字符长</li>
<li><strong>[0-9]{4}</strong>定义一个数字集合，并且必须要是正正好好4个字符长</li>
</ul>
<p>加上行首匹配”^”就ok了。  </p>
<hr>
<h4 id="其他常用匹配写法"><a href="#其他常用匹配写法" class="headerlink" title="其他常用匹配写法"></a>其他常用匹配写法</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表述</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[a-z]*</code></td>
<td style="text-align:left">匹配任意数量字符的小写字母</td>
</tr>
<tr>
<td style="text-align:center"><code>....$</code></td>
<td style="text-align:left">匹配包含四个字符的行</td>
</tr>
<tr>
<td style="text-align:center"><code>abc.*abc</code></td>
<td style="text-align:left">匹配出现两次”abc”的行。两个”abc”之间可以有任意数量的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]{2}-[0-9]{2}-[0-9]{4}</code></td>
<td style="text-align:left">匹配<code>dd-mm-yyyy</code>格式。请注意这不会验证日期是否合法！</td>
</tr>
<tr>
<td style="text-align:center"><code>^.{n,m}$</code></td>
<td style="text-align:left">匹配行长介于n和m个字符之间的行</td>
</tr>
<tr>
<td style="text-align:center"><code>(bye)+</code></td>
<td style="text-align:left">匹配一次或多次出现过”bye”的行，例如”bye”, “byebye”, “byebyebye”，空行不会被匹配。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><br></p>
<p><strong>至此，Module 1全部完结！</strong> </p>
<p><br></p>
<hr>
<h1 id="Module-2-Shell-Script-amp-Version-Control"><a href="#Module-2-Shell-Script-amp-Version-Control" class="headerlink" title="Module 2: Shell Script & Version Control"></a>Module 2: Shell Script &amp; Version Control</h1><p>先来深入一下Shell脚本把。  </p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>Shell 脚本 (Shell Script, .sh) 是一种由 Linux shell 运行的计算机程序。<br>Shell Script是一种解释型语言，而不是编译型语言。因此与 C++ 不同，我们不需要在执行程序之前将 shell 编译为二进制可执行格式。<br>相反，每次执行用 Shell 脚本编写的程序时，shell 都会对其进行解析和解释。  </p>
<p>解释型语言允许我们通过简单地编辑脚本来更快地修改程序。但是，程序通常较慢，因为在执行期间需要进行解析和解释。<br>假设我们有一系列 Shell 命令，我们不想在每次要执行时重新输入这些命令。我们可以将它们保存在一个文件中，并将其称为 shell 脚本。  </p>
<blockquote>
<p><strong>注意注意↑！</strong><br>在 Windows 中编辑脚本文件并导入到 Linux 可能会导致执行失败，因为 Windows 中使用的行尾 (EOL) 不同。<br>  你应该在 Linux 系统内创建和编辑脚本文件（例如，在 SSH 中使用 vi 编辑器，在 X2Go 中使用 gedit）。否则，如果从 Windows 导入脚本文件，则需要确保 Windows 环境中的文本编辑器中的行尾选项设置为 UNIX 格式 (LF) 而不是 Windows 格式 (CRLF)。  </p>
</blockquote>
<p><br></p>
<hr>
<p>我们先来创建一个<code>hello.sh</code>脚本写个典中典Hello world：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi hello.sh</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello world!"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Welcome to ENGG1340"</span></span><br></pre></td></tr></table></figure>
<p><code>echo</code>命令用来向控制台输出一行。行中内容可以是变量值，也可以是字符串。  </p>
<p>保存并退出，随后我们需要使得文件可以被用户运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x hello.sh</span></span><br></pre></td></tr></table></figure>
<p>然后直接运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello.sh</span></span><br><span class="line">Hello world!</span><br><span class="line">Welcome to ENGG1340</span><br></pre></td></tr></table></figure>
<hr>
<p>所有脚本都应以<code>#!</code>开头，这表示系统应使用哪个程序来处理 shell 脚本。在本例中，它是 bash 程序的路径。<br>从Module 1 中我们知道有许多不同的 shell（例如，C shell、Korn shell、Bash shell）。而由于我们使用 Bash shell，因此我们需要提供 bash 程序的路径，以便操作系统知道如何解释 bash shell 命令。<br>在本例中，Bash shell的路径为 /bin/bash。  </p>
<p>你也可以使用<code>which -a</code>命令来找到Bash shell的具体位置： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> -a bash</span></span><br><span class="line">/usr/local/bin/bash</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>参数<code>-a</code>代指返回bash的所有路径。如你所见返回的路径不止一个，这代表Bash的路径可能有多个。在本例中我们使用<code>/bin/bash</code>路径下的那个。  </p>
<hr>
<p>来看看另一个例子。这里我们引入<code>echo</code>命令的新参数<code>-n</code>看看会发生什么不同的情况：  </p>
<p><em>ex1_1.sh</em>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Hello world!"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Welcome to ENGG1340"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bye"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex1_1.sh</span></span><br><span class="line">Hello world!Welcome to ENGG1340</span><br><span class="line">bye</span><br></pre></td></tr></table></figure>
<p><code>-n</code>可以表示”no trailing”使下一行直接继续打印在上一行的末尾。  </p>
<hr>
<p>这次我们来看个带C++的例子：  </p>
<p>“<em>add.cpp</em>“</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="type">int</span> a;</span><br><span class="line">       <span class="type">int</span> b;</span><br><span class="line">       std::cin &gt;&gt; a;</span><br><span class="line">       std::cin &gt;&gt; b;</span><br><span class="line">       std::cout &lt;&lt; a + b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>“<em>input.txt</em>“:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>之前我们使用管线可以封装好整个自动化，不过这里我们试着用Shell脚本： </p>
<p>“<em>ex1_2.sh</em>“:  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile the code</span></span><br><span class="line">g++ add.cpp -o add</span><br><span class="line"><span class="comment"># Run the code and display result</span></span><br><span class="line">./add &lt; input.txt &gt; output.txt</span><br><span class="line"><span class="built_in">cat</span> output.txt</span><br></pre></td></tr></table></figure>
<p>运行：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./ex1_2.sh</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>在Shell脚本中只有一种变量类型，那就是字符串。  </p>
<p>变量名区分大小写，只支持包含大小写字母，数字和下划线 (_)。  </p>
<hr>
<h4 id="定义并访问变量"><a href="#定义并访问变量" class="headerlink" title="定义并访问变量"></a>定义并访问变量</h4><p>我们可以通过这种方式来定义并赋予变量一个值：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet=<span class="string">"dog"</span></span><br></pre></td></tr></table></figure>
<p>等号前后不能有空格。  </p>
<p>如果我们需要取用变量中的内容，则需要使用美元符号：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">pet=<span class="string">"dog"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pet</span></span><br></pre></td></tr></table></figure>
<p>输出为<code>dog</code>。  </p>
<hr>
<h4 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h4><p><code>read</code>命令用来等待用户在控制台向脚本提供输入： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"What is your name?"</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$name</span>"</span></span><br></pre></td></tr></table></figure>
<p>当用户输入完值之后，会被自动存储到变量<code>name</code>中。  </p>
<p>比如我们来看这个程序的具体例子：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_2.sh</span></span><br><span class="line">What is your name?</span><br><span class="line">Kit</span><br><span class="line">Hello, Kit</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>在Shell脚本中区分引用很重要。我们可以用三种方式来确定一个字符串值，分别是<strong>不引用</strong>，<strong>单引号引用</strong>和<strong>双引号引用</strong>。  </p>
<hr>
<p><strong>不引用</strong>  </p>
<p>我们可以在定义字符串的时候不加任何引用，但是这个方法仅在需要定义的字符串是一个整体，没有空格的情况下才可用：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">cat</span></span><br></pre></td></tr></table></figure>
<p>下面这种情况就会报错：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=Apple pie</span><br></pre></td></tr></table></figure>
<p>因为 程序会将Apple当作一个指令来看待，而不是一个字符串。  </p>
<hr>
<p><strong>单引号引用</strong>  </p>
<p>在单引号引用情况下，带空格的字符串可以被成功处理，但是没办法做到变量替换。  </p>
<p>变量替换功能是双引号引用的功能： </p>
<hr>
<p><strong>双引号引用</strong></p>
<p>双引号引用相比单引号引用支持更多功能，其中一个就是变量替换：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:left">变量替换</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:left">转义符</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code>``</td>
<td style="text-align:left">包含bash命令</td>
</tr>
</tbody>
</table>
</div>
<p>看不懂？就着下面的例子看看：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">name=<span class="string">"Apple"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Hello, $name'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"\$name = <span class="variable">$name</span>"</span></span><br></pre></td></tr></table></figure>
<p>运行后可以得到： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_3.sh</span></span><br><span class="line">Hello, $name</span><br><span class="line">Hello, Apple</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">name = Apple</span></span><br></pre></td></tr></table></figure>
<p>第一行会被输出为<code>Hello, $name</code>，因为我们使用了单引号引用，<code>name</code>变量不会被替换。<br>第二行会被输出为<code>Hello Apple</code>，因为双引号引用下<code>$name</code>会被替换为变量<code>name</code>。<br>第三行会被输出为<script type="math/tex">name = Apple`，因为我们使用转义符取消了第一个`$name`中`</script>的替换功能，而第二个<code>$name</code>会被保持原状正常替换。  </p>
<p><br></p>
<hr>
<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>前面提到过一嘴，不过我们决定在这里展开相关说明。  </p>
<p>使用反引号(`)，一般是esc键下面的那个键，我们可以在脚本中向变量保存Shell命令的输出，来实现进一步的处理：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"`cat file.txt`"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">b=<span class="string">"`wc -l file.txt | cut -d\" \""</span> -f1`<span class="string">"</span></span><br><span class="line"><span class="string">echo "</span>There are <span class="variable">$b</span> lines <span class="keyword">in</span> file<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>“<em>file.txt</em>“:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Cherry</span><br></pre></td></tr></table></figure>
<p>运行输出为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_4.sh</span></span><br><span class="line">Apple Banana Cherry</span><br><span class="line">There are 3 lines in file</span><br></pre></td></tr></table></figure>
<p>接下来我们解读一下。在变量b中，首先<code>wc</code>命令返回<code>3 file.txt</code>，告诉我们一共有三行。接着我们使用<code>cut</code>命令截去后面多余的部分，返回一个”3”。  </p>
<p>注意在<code>cut</code>命令的参数部分我们使用了转义符，因为原本是<code>cut -d" " -f1</code>，但问题在于外面已经有一对双引号了。解决这个问题只能去转义里面的两个引号。  </p>
<p><br></p>
<hr>
<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>如果我们想要获得一个字符串的长度：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"Apple"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${#a}</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./ex2_5_1.sh</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>`$</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>ENGG1340笔记</p><p><a href="http://naughtychas.github.io/2025/01/25/ENGG1340笔记/">http://naughtychas.github.io/2025/01/25/ENGG1340笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://NaughtyChas.github.io"><p>ntcs</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-01-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-02-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2024/12/11/Exam%20Notes%20for%20ENGG1330/" target="_blank" rel="noreferrer">Exam Notes for ENGG 1330</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/" target="_blank" rel="noreferrer">邈想日集</a><br></span><span>  2.<a class="is-size-6" href="/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ENGG1340笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/" target="_blank" rel="noreferrer">浅谈今年CAIE的POE考试</a><br></span><span>  6.<a class="is-size-6" href="/2022/09/05/%E4%BD%A0%E8%AF%B4%E5%BE%97%E5%AF%B9/" target="_blank" rel="noreferrer">收集&quot;你说得对&quot;</a><br></span></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/12/11/Exam%20Notes%20for%20ENGG1330/"><span class="level-item">Exam Notes for ENGG 1330</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://giscus.app/client.js" data-repo="NaughtyChas/NaughtyChas.github.io" data-repo-id="R_kgDOHzXKqQ" data-category="Announcements" data-category-id="DIC_kwDOHzXKqc4CmXAk" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#前言"><span class="mr-2">1</span><span>前言</span></a></li><li><a class="is-flex is-mobile" href="#Module-1-Linux-Environment"><span class="mr-2">2</span><span>Module 1: Linux Environment</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Linux-Shell"><span class="mr-2">2.1</span><span>Linux Shell</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#命令使用说明"><span class="mr-2">2.1.1</span><span>命令使用说明</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#路径和文件管理"><span class="mr-2">2.2</span><span>路径和文件管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#相对路径和绝对路径"><span class="mr-2">2.2.1</span><span>相对路径和绝对路径</span></a></li><li><a class="is-flex is-mobile" href="#主目录"><span class="mr-2">2.2.2</span><span>主目录</span></a></li><li><a class="is-flex is-mobile" href="#重命名路径"><span class="mr-2">2.2.3</span><span>重命名路径</span></a></li><li><a class="is-flex is-mobile" href="#复制文件"><span class="mr-2">2.2.4</span><span>复制文件</span></a></li><li><a class="is-flex is-mobile" href="#命令模式下的命令"><span class="mr-2">2.2.5</span><span>命令模式下的命令</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文件权限"><span class="mr-2">2.3</span><span>文件权限</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#权限指示"><span class="mr-2">2.3.1</span><span>权限指示</span></a></li><li><a class="is-flex is-mobile" href="#举例"><span class="mr-2">2.3.2</span><span>举例</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#其他常用命令"><span class="mr-2">2.4</span><span>其他常用命令</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#文件内搜索-grep"><span class="mr-2">2.4.1</span><span>文件内搜索 (grep)</span></a></li><li><a class="is-flex is-mobile" href="#文件字数-wc"><span class="mr-2">2.4.2</span><span>文件字数 (wc)</span></a></li><li><a class="is-flex is-mobile" href="#排序"><span class="mr-2">2.4.3</span><span>排序</span></a></li><li><a class="is-flex is-mobile" href="#剪切文件"><span class="mr-2">2.4.4</span><span>剪切文件</span></a></li><li><a class="is-flex is-mobile" href="#移除重复行"><span class="mr-2">2.4.5</span><span>移除重复行</span></a></li><li><a class="is-flex is-mobile" href="#拼写检查"><span class="mr-2">2.4.6</span><span>拼写检查</span></a></li><li><a class="is-flex is-mobile" href="#文件差异"><span class="mr-2">2.4.7</span><span>文件差异</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#标准I-O，文件重定向和管道"><span class="mr-2">2.5</span><span>标准I/O，文件重定向和管道</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#管线"><span class="mr-2">2.5.1</span><span>管线</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#搜索"><span class="mr-2">2.6</span><span>搜索</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#搜索文件或路径-find"><span class="mr-2">2.6.1</span><span>搜索文件或路径 (find)</span></a></li><li><a class="is-flex is-mobile" href="#其他常用匹配写法"><span class="mr-2">2.6.2</span><span>其他常用匹配写法</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#Module-2-Shell-Script-amp-Version-Control"><span class="mr-2">3</span><span>Module 2: Shell Script &amp; Version Control</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Shell脚本"><span class="mr-2">3.1</span><span>Shell脚本</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#命令替换"><span class="mr-2">3.1.1</span><span>命令替换</span></a></li><li><a class="is-flex is-mobile" href="#字符串处理"><span class="mr-2">3.1.2</span><span>字符串处理</span></a></li></ul></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a><p class="size-small"><span>&copy; 2025 ntcs</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noreferrer">Icarus</a> &amp; <a href="https://github.com/LittleYe233/hexo-theme-amazingremake" target="_blank" rel="noreferrer">Amazing-Remake</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022.8.11 17:07:12')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/LittleYe233/hexo-theme-amazingremake"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    enabled: true,
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { // 加载mathjax
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    autoload: {
                        color: [],
                        colorv2: ['color']
                    },
                    packages: {'[+]': ['noerrors']}
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                },
                loader: {
                    load: ['input/asciimath', '[tex]/noerrors']
                }
            };
            $.getScript('//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('undefined','undefined','undefined','undefined',undefined);});
            }
            if('undefined' === 'mathjax'){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>