<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>ENGG1340笔记 - ntcs&#039; blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ntcs&#039; blog"><meta name="msapplication-TileImage" content="img/icon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ntcs&#039; blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="自学ENGG1340写的笔记"><meta property="og:type" content="article"><meta property="og:title" content="ENGG1340笔记"><meta property="og:url" content="http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="ntcs&#039; blog"><meta property="og:description" content="自学ENGG1340写的笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB3d38757cff77704b4b626c7e77a8299a?method=download&amp;amp;shareKey=7d62b9dd7d9765da3fbbc8ff1020e3f9"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB2e57509e464b685521f221612db841b6?method=download&amp;amp;shareKey=980a26dccb73b17e40f57a8a8bbfb599"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEBfe2c1fb97579cb3ac7600cc5974e5bb8?method=download&amp;amp;shareKey=866755676c9de499cfa8e00e7cad5101"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEBed6b622ab401c9305753c7e2623a767f?method=download&amp;amp;shareKey=b90b1091d05ac2a4898119d43ae308e9"><meta property="article:published_time" content="2025-01-25T06:18:50.000Z"><meta property="article:modified_time" content="2025-03-18T06:59:55.935Z"><meta property="article:author" content="ntcs"><meta property="article:tag" content="笔记"><meta property="article:tag" content="计算机"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"},"headline":"ntcs' blog","image":[],"datePublished":"2025-01-25T06:18:50.000Z","dateModified":"2025-03-18T06:59:55.935Z","author":{"@type":"Person","name":"ntcs"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"自学ENGG1340写的笔记"}</script><link rel="canonical" href="http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/icon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/&gt; all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="ntcs' blog" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-01-25  <a class="commentCountImg" href="/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">/2025/01/25/ENGG1340笔记/</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="81cf628bb0f4d3d5adbb6fdbb4cc8f4a">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>4 小时  <i class="fas fa-pencil-alt"> </i>36.8 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">ENGG1340笔记</h1><div class="content"><blockquote>
<p>自学ENGG1340写的笔记<br><span id="more"></span></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>惊讶的发现这学期ENGG1340是自学课，没有Lecture。讲道理挺舒服的。</p>
<p>ENGG1340期望你拥有Python编程知识作为基础，然后逐渐引入更深层的新内容，包括Linux / Bash Shell，版本控制（Git），C/C++语言等。</p>
<p>叠甲先：笔记可能出错所以轻喷。内容是根据课上发的笔记转写的，所以本文算是个人梳理吧</p>
<hr>
<h1 id="Module-1-Linux-Environment"><a href="#Module-1-Linux-Environment" class="headerlink" title="Module 1: Linux Environment"></a>Module 1: Linux Environment</h1><p>Linux如同Windows一样是操作系统。Linux是开源的，这导致Linux相较于其他操作系统拥有更多长处，例如：可自定义程度较强，安全性也比较高（因为你可以直接读到源代码）。<br>因为Linux是开源的，所以使用Linux也是免费的。在一些相对低价的电子产品上，使用Linux作为操作系统就很划算。</p>
<p>Linux存在不同的发行版，例如Ubuntu, CentOS, Debian等。</p>
<p>在ENGG1340中我们将会使用Ubuntu，虽然现阶段不同发行版不会对课程大纲产生太多影响。</p>
<hr>
<h2 id="Linux-Shell"><a href="#Linux-Shell" class="headerlink" title="Linux Shell"></a>Linux Shell</h2><p>Shell 是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Linux中有不同种类的shell，比如Korn Shell, Bourne Shell, C Shell，以及Bash Shell。<br>不同的Shell之间命令可能有些许区别，例如Korn Shell使用<code>print</code>命令输出一个字符串，而Bash Shell使用<code>echo</code>命令。</p>
<p>在ENGG1340里我们主要使用Bash Shell。</p>
<hr>
<h3 id="Shell-Commands"><a href="#Shell-Commands" class="headerlink" title="Shell Commands"></a>Shell Commands</h3><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>向命令行中输入<code>date</code>，Shell会返回当前系统的时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Sat Jan 25 14:51:19 HKT 2025</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="文件与路径操作"><a href="#文件与路径操作" class="headerlink" title="文件与路径操作"></a>文件与路径操作</h4><p><code>ls</code>命令列举当前目录下的所有文件和路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span> </span><br><span class="line">Documents/  logon.bat*  public_html/  t.txt  Downloads/ </span><br><span class="line">Pictures/  Templates/    </span><br><span class="line">Videos/    </span><br><span class="line">Music/      </span><br><span class="line">Desktop/  engg1340/ </span><br><span class="line">Public/    </span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>命令变体</strong>：</p>
<ul>
<li><code>ls -l</code>  以长字符方式输出，包含额外信息如文件大小，文件拥有者，上次编辑日期等</li>
<li><code>ls -a</code>  输出路径下所有内容，包含隐藏的文件和目录。隐藏的内容会以一点开头<code>.</code>。</li>
<li><code>ls -la</code>  就是<code>ls -l -a</code></li>
</ul>
</blockquote>
<hr>
<p><code>cd</code>命令用来重定向当前目录。例如我们想要访问当前目录下的engg1340路径，直接敲<code>cd engg1340</code>就行：</p>
<blockquote>
<p>命令变体：<br><code>cd ..</code> 前往当前目录的父级路径<br><code>cd ~</code>  前往当前用户的主目录<br><code>cd ~username</code>  前往指定用户的主目录<br><code>cd .</code> 前往当前目录 （虽说没啥效果就是了）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> engg1340</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span> </span><br><span class="line">lab1/  lab2/  lab3/ </span><br></pre></td></tr></table></figure>
<hr>
<p><code>pwd</code>命令将会输出当前的工作目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/home/d003/h978645312</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h4><p>Shell里面有许多命令，能将所有命令记住基本上是不现实的。因此，Shell提供了<code>man</code>命令（Manual的缩写），能够返回命令的详细解释。</p>
<p>例如我想要查看ls命令的详细解释，就可以使用<code>man ls</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LS(1)                                               User Commands                                               LS(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       ls - list directory contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       ls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       List  information  about the FILEs (the current directory by default).  Sort entries alphabetically if none of</span><br><span class="line">       -cftuvSUX nor --sort is specified.</span><br><span class="line"></span><br><span class="line">       Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line"></span><br><span class="line">       -a, --all</span><br><span class="line">              do not ignore entries starting with .</span><br><span class="line"></span><br><span class="line">       -A, --almost-all</span><br><span class="line">              do not list implied . and ..</span><br><span class="line"></span><br><span class="line">       --author</span><br><span class="line">              with -l, print the author of each file</span><br><span class="line"></span><br><span class="line">       -b, --escape</span><br><span class="line">              print C-style escapes for nongraphic characters</span><br><span class="line"></span><br><span class="line">       --block-size=SIZE</span><br><span class="line">              with -l, scale sizes by SIZE when printing them; e.g., '--block-size=M'; see SIZE format below</span><br><span class="line"></span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line"></span><br><span class="line">        -l     use a long listing format</span><br><span class="line"></span><br><span class="line"> Manual page ls(1) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure>
<p>从NAME区域我们可以得知<code>ls</code>的解释为”list directory contents”。<br>从DESCRIPTION区域得知，如果在ls后面加入可选参数<code>-l</code>，代表”use a long listing format”。这会在普通<code>ls</code>的基础上显示更多信息，包括文件大小，文件拥有者，上次编辑日期等等：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 26044</span><br><span class="line">drwxr-xr-x 17 1000 1000     4096 Nov  4 01:17 Python-3.11.0</span><br><span class="line">-rw-r--r--  1 root root 26333656 Oct 24  2022 Python-3.11.0.tgz</span><br><span class="line">drwxr-xr-x  4 root root     4096 Nov  1 13:25 napcat</span><br><span class="line">-rw-------  1 root root   317274 Nov  4 01:38 nohup.out</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="路径和文件管理"><a href="#路径和文件管理" class="headerlink" title="路径和文件管理"></a>路径和文件管理</h2><p>在Linux中根目录用<code>/</code>表示。根目录包含所有的文件和路径。</p>
<p>例如在根目录下有一个”home”路径，”home”下有另一个路径”kit”，那么这个”kit”路径的绝对路径就是：<code>/home/kit</code></p>
<p>有关相对路径和绝对路径的内容一会介绍。</p>
<hr>
<h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>绝对路径总是以<code>/</code>打头。举几个简单的例子：</p>
<ul>
<li><code>/home/file3</code>是在home路径下的文件file3的绝对路径。</li>
<li><code>/home/kit/Desktop/file4</code>是file4的绝对路径。</li>
</ul>
<p>而相对路径和当前的工作目录有联系，相对路径不会以<code>/</code>打头。</p>
<p>例如我们使用上面的file3做例子，如果当前的工作目录为<code>/home</code>，则file3的相对路径为<code>file3</code>。注意看刚才这个file3的路径不以<code>/</code>打头，所以能判断出这是一个相对路径。</p>
<p>file4同理。如果当前工作目录是<code>/home/kit</code>，那么file4的相对路径就是<code>Desktop/file4</code>。</p>
<hr>
<p>如果目录A包含另一个目录B，则A称为B的父目录，B称为A的子目录。例如在刚才的例子中，kit是home的子目录，home是kit的父目录。</p>
<p>一旦shell启动，它当前的工作目录就是主目录。我们总是可以通过命令pwd获得当前的工作目录。</p>
<hr>
<h3 id="主目录"><a href="#主目录" class="headerlink" title="主目录"></a>主目录</h3><p>对于任何用户，都有一个属于该用户的主目录。例如，用户 kit 的主目录位于<code>/home/kit</code></p>
<p><code>~</code>用来表示用户的主目录。你可以使用<code>cd ~</code>命令回到当前用户的主目录，也可以使用<code>cd ~username</code>来前往其他用户的主目录。</p>
<h3 id="路径管理"><a href="#路径管理" class="headerlink" title="路径管理"></a>路径管理</h3><h4 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h4><p><code>mkdir</code>命令可以用来创建路径   <del>新建文件夹</del></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> lab</span></span><br></pre></td></tr></table></figure>
<p>上面的命令会在当前的工作目录下创建一个lab路径。</p>
<p>如果你想在当前工作目录下创建多个路径，可以直接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> lab1 lab2</span></span><br></pre></td></tr></table></figure>
<p>如果想在路径名中包括空格，可以在创建路径时将路径名用引号引起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="string">"lab 1"</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="移除路径"><a href="#移除路径" class="headerlink" title="移除路径"></a>移除路径</h4><p><code>rmdir</code>命令可以用来移除空路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> lab</span></span><br></pre></td></tr></table></figure>
<p>如果想要移除的路径不是空路径，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab1</span></span><br><span class="line">file1.txt  file2.txt</span><br></pre></td></tr></table></figure>
<p>就需要使用<code>rm -rf</code>或者<code>rm -r -f</code>来移除整个路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -r -f lab1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab1</span></span><br><span class="line">ls: cannot access 'lab1': No such file or directory</span><br></pre></td></tr></table></figure>
<p>可以看到路径被成功移除了。</p>
<p><code>-r</code>参数代表系统会按照递归方式向下遍历目标路径下的文件和路径，而<code>-f</code>可以确保删除过程不需要你来进行确认。如果当前路径下文件巨多，不带<code>-f</code>就会很麻烦了。</p>
<hr>
<h4 id="重命名路径"><a href="#重命名路径" class="headerlink" title="重命名路径"></a>重命名路径</h4><p><code>mv</code>命令虽然叫move，但是也可以用来重命名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> lab <span class="string">"lab 1"</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令会把<code>lab</code>路径重命名至<code>lab 1</code>。</p>
<p>如果<code>mv</code>命令下第一个参数和第二个参数的类型一致，例如参数1和参数2都是文件类型，则该命令会将参数1重命名至参数2。</p>
<hr>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p><code>touch</code>命令可以用来创建一个空文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file1.txt</span></span><br></pre></td></tr></table></figure>
<p>可以创建一个名叫”file1.txt”的空文件。</p>
<hr>
<h4 id="展示文件内容"><a href="#展示文件内容" class="headerlink" title="展示文件内容"></a>展示文件内容</h4><p><code>cat</code>，命令可以用来展示文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1.txt</span></span><br><span class="line">Hello, this is the content of file1.txt</span><br><span class="line">Bye Bye!</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p><code>mv</code>命令也可以用来移动文件或者路径位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello.txt mydir</span></span><br></pre></td></tr></table></figure>
<p>好比说这串命令会将hello.txt移动到<code>mydir</code>路径下。</p>
<p>如果文件拥有同样的前缀，你可以使用星号(<em>)来选中所有符合条件的项。<br>例如：将所有拥有“ <em>*myfile</em></em> ”前缀的文件移动到lab路径下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">myfile1.txt  myfile2.txt lab/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> myfile* lab</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">lab/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab</span></span><br><span class="line">myfile1.txt  myfile2.txt</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p>除此之外还有其他关于文件操作的命令集合：</p>
<p><code>cp</code> 命令用于复制文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2</span></span><br></pre></td></tr></table></figure>
<p>会将”file1”复制至”file2”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r dir1 dir2</span></span><br></pre></td></tr></table></figure>
<p>会将<code>dir1</code>路径包括路径下的所有内容复制到dir2中。</p>
<hr>
<h3 id="使用vi编辑器"><a href="#使用vi编辑器" class="headerlink" title="使用vi编辑器"></a>使用vi编辑器</h3><p>vi编辑器用来创建并编辑文本。就好比Windows上的记事本，或Linux上的gedit，但是他没有图形用户界面，完全在命令行中使用。</p>
<p>vi编辑器中有两个功能：</p>
<ol>
<li>插入模式(Insert mode)：在这个模式中你可以编辑文件内容</li>
<li>命令模式(Command mode)：命令模式用来执行文件操作，比如保存文件等</li>
</ol>
<p>要使用vi编辑器打开一个文件，只需要敲入<code>vi</code>命令即可。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi file2.txt</span></span><br></pre></td></tr></table></figure>
<p>将会打开工作目录下的”file2.txt”文件。如果该文件不存在，编辑器会帮你自动创建一个。</p>
<p>!()[<a target="_blank" rel="noopener" href="https://note.youdao.com/yws/api/personal/file/WEB851884414ef36fe09b4feda45b512323?method=download&amp;shareKey=cbca8ca352f134b3e06ba8e53e65b13c">https://note.youdao.com/yws/api/personal/file/WEB851884414ef36fe09b4feda45b512323?method=download&amp;shareKey=cbca8ca352f134b3e06ba8e53e65b13c</a>]</p>
<p>进入vi编辑器后默认为命令模式。因为我们的路径下没有file2.txt，如你所见编辑器目前显示的是空白文件。</p>
<p><strong>按”I”键切换至插入模式</strong>。当你在插入模式时，你可以在界面的左下角看到<code>-- INSERT --</code>：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909" alt=""></p>
<p>在插入模式中你可以按照我们熟悉的样子编辑文件。如果编辑完成想要保存文件，则需要退回至命令模式。</p>
<p>在插入模式时，<strong>按”esc”以回到命令模式</strong>。当你回到命令模式后，你将不会再左下角看到<code>-- INSERT --</code>字样。这时输入<code>:wq</code>并按下Enter，你会退出vi编辑器，同时你的文件会被保存。</p>
<hr>
<h4 id="命令模式下的命令"><a href="#命令模式下的命令" class="headerlink" title="命令模式下的命令"></a>命令模式下的命令</h4><p>除了“保存并关闭”(<code>:wq</code>)命令外，还有下面这些常见命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">执行的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>:wq</code></td>
<td style="text-align:center">保存并退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:w</code></td>
<td style="text-align:center">保存（但不退出vi编辑器）</td>
</tr>
<tr>
<td style="text-align:center"><code>:w filename</code></td>
<td style="text-align:center">保存到名叫”filename”的新文件下</td>
</tr>
<tr>
<td style="text-align:center"><code>:q</code></td>
<td style="text-align:center">退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:q!</code></td>
<td style="text-align:center">不保存并退出vi编辑器</td>
</tr>
</tbody>
</table>
</div>
<p>想要查阅完整的命令列表的话<a target="_blank" rel="noopener" href="https://www.cs.colostate.edu/helpdocs/vi.html">点我</a></p>
<p>或者你也可以查阅这张Cheatsheet：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3d38757cff77704b4b626c7e77a8299a?method=download&amp;shareKey=7d62b9dd7d9765da3fbbc8ff1020e3f9" alt="Cheatsheet"></p>
<hr>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>Linux系统中的每个文件或目录都被分配了3种类型的所有者。</p>
<ul>
<li><strong>用户（User）</strong>：用户可以作为文件的拥有者</li>
<li><strong>用户组（Group）</strong>：用户组中可以包含多个用户。若用户组拥有一个文件的权限，则组中的每个用户都有该文件的权限。</li>
<li><strong>其他（Other）</strong>：有权访问文件的任何其他用户。它既没有创建文件，也不属于拥有该文件的组。</li>
</ul>
<p>每个用户对于上面的三种所有者定义了三种不同的文件权限：</p>
<ul>
<li><strong>读取（Read）</strong>：拥有文件读取权限的个体可以打开并读取文件中的内容。拥有路径读取权限的个体可以列举出该路径下的内容。</li>
<li><strong>写入（Write）</strong>：拥有文件写入权限的个体可以更改文件中的内容。拥有路径读取权限的个体可以在路径中添加，移除或者重命名内容。</li>
<li><strong>执行（Execute）</strong>：执行权限允许个体来运行程序</li>
</ul>
<hr>
<p>不如举个例子看看：使用之前提到过的<code>ls -l</code>命令来列举出路径下的内容，里面会告诉你文件权限的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 10</span><br><span class="line">-rw------- 1 cklai ra 50 Jul 30 17:07 file1.txt</span><br><span class="line">-rw------- 1 cklai ra 48 Jul 31 15:14 file2.txt</span><br><span class="line">drwx------ 2 cklai ra  2 Jul 30 17:00 lab/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="权限指示"><a href="#权限指示" class="headerlink" title="权限指示"></a>权限指示</h3><p>借用上面的例子，我们来仔细讲讲刚才的输出是啥意思：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total 10</span><br><span class="line">-rw------- 1 cklai ra 50 Jul 30 17:07 file1.txt</span><br></pre></td></tr></table></figure>
<p><code>total 10</code>代表文件在文件系统中占用了多大空间，单位为千字节（kilobytes）。<br>由左至右分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">条目</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-rw-------</code></td>
<td style="text-align:center">代表<strong>文件权限</strong>。具体的释义马上就解释（</td>
</tr>
<tr>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">代表<strong>文件拥有的硬链接数量</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>cklai</code></td>
<td style="text-align:center">代表<strong>文件拥有者</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>ra</code></td>
<td style="text-align:center">文件拥有者存在的用户组</td>
</tr>
<tr>
<td style="text-align:center"><code>50</code></td>
<td style="text-align:center"><strong>文件大小</strong>，单位为字节（byte）</td>
</tr>
<tr>
<td style="text-align:center"><code>Jul 23 17:07</code></td>
<td style="text-align:center"><strong>上次修改时间</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>file1.txt</code></td>
<td style="text-align:center"><strong>文件名</strong></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>现在我们来讲讲权限指示该怎么解读。<br>权限指示（Permission indicator）是一个十字符长的字符串，通常分为四部分：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e57509e464b685521f221612db841b6?method=download&amp;shareKey=980a26dccb73b17e40f57a8a8bbfb599" alt=""></p>
<p>这玩意可以分成四部分解读，<strong>Type</strong>, <strong>User permissions</strong>, <strong>Group permission</strong>和<strong>Other permission</strong>。</p>
<hr>
<p><strong>Type</strong>:</p>
<p>代指权限指示的第一个字符。</p>
<ul>
<li>如果第一个字符是<strong>短横线 “-“</strong>，则代表它是一个<strong>正常文件</strong>。</li>
<li>如果第一个字符是<strong>字母d “d”</strong>，则代表这是一个路径。</li>
</ul>
<p>还有其他的类型不过这里涵盖不到。可以自己上网查询。</p>
<hr>
<p><strong>User permissions</strong></p>
<p>第2-4个字符表示用户的权限。三个位置会显示”r”, “w”或者”x”。</p>
<p>比如这里显示了”rw-“，就代表：</p>
<ul>
<li>可以读取文件 (read, r)</li>
<li>可以写入文件 (write, w)</li>
<li>但是<em>不能</em>执行文件。如果文件可以被执行，第三个位置会显示”x”</li>
</ul>
<hr>
<p><strong>Group permission</strong></p>
<p>5-7个字符表示了用户组的权限。同样用rwx表示权限。</p>
<hr>
<p><strong>Other permission</strong></p>
<p>最后三位表示了文件对其他所有人的权限。</p>
<p>如果显示”—-“，则表示其他人都不可以读取(r)，写入(w)，并且也不能执行(x)</p>
<hr>
<h3 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h3><p>你可以使用<code>chmod</code>命令来更改你拥有的文件或者路径的权限：</p>
<p><code>chmod</code>命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> [<span class="built_in">who</span>][operator][permissions] filename</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>who</code></li>
</ul>
<p>在参数<code>who</code>内，可以键入四个不同的字母来指定要更改的对象群体：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>u</strong></td>
<td style="text-align:center">指定<strong>用户</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>g</strong></td>
<td style="text-align:center">指定<strong>用户组</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>o</strong></td>
<td style="text-align:center">指定<strong>其他</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>a</strong></td>
<td style="text-align:center">指定<strong>所有群体</strong>的权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<ul>
<li><code>operator</code></li>
</ul>
<p>在参数<code>operator</code>内，共有三个运算符，用来代指具体的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center"><strong>增加</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>-</strong></td>
<td style="text-align:center"><strong>移除</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>=</strong></td>
<td style="text-align:center"><strong>设定</strong>权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<ul>
<li><code>permission</code></li>
</ul>
<p>在参数<code>permission</code>内，就是我们熟悉的r, w和x了。这些参数用指定要用来增加或者减少的权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>r</strong></td>
<td style="text-align:center"><strong>读取</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>w</strong></td>
<td style="text-align:center"><strong>写入</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>x</strong></td>
<td style="text-align:center"><strong>运行</strong>权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><strong>Example 1：更改权限</strong></p>
<p>在Linux中，可以首先使用<code>touch</code>创建一个新文件。<code>touch</code>命令创建的文件对用户的默认权限为可读可写(rw-)。<br>想要更改权限，就可以使用<code>chmod</code>来指定文件的权限。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 26</span><br><span class="line">-rw------- 1 cklai ra   0 Aug  1 11:48 file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o+w file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 26</span><br><span class="line">-rw-----w- 1 cklai ra   0 Aug  1 11:48 file</span><br></pre></td></tr></table></figure>
<p>其中，<code>chmod o+w file</code>意思是对于其他用户(o)授予(+)写入(w)权限。</p>
<hr>
<p><strong>Example 2： 更改多个权限</strong></p>
<p>可以在<code>permission</code>参数内键入多个值来一次性设置多个权限。就刚才的例子往下继续：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">-rw-----w- 1 cklai ra   0 Aug  1 11:48 file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o+rx file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">-rw----rwx 1 cklai ra   0 Aug  1 11:48 file*</span><br></pre></td></tr></table></figure>
<p><code>chmod o+rx file</code>的释义为：对其他用户(o)授予(+)读取(r)和运行(x)权限。</p>
<p>可以看到更新完权限后，文件名后面出现了一个星号”*”，这代表文件现在是可执行的。</p>
<hr>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p>这里会介绍很多新的命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>grep 'abc' file</code></td>
<td style="text-align:left">返回在文件中包含”abc”的行。可以使用更高级的描述来实现更复杂的搜索。</td>
</tr>
<tr>
<td style="text-align:center"><code>cut -d, -f2 file</code></td>
<td style="text-align:left">返回特定的数据列。<br>它根据标志-d指定的定界符分隔每行，并返回标志-f指定的列（字段编号从1开始）。</td>
</tr>
<tr>
<td style="text-align:center"><code>diff file1 file2</code></td>
<td style="text-align:left">显示两个文件的区别。</td>
</tr>
<tr>
<td style="text-align:center"><code>wc file</code></td>
<td style="text-align:left">返回文件中的行数，字数和字符数。</td>
</tr>
<tr>
<td style="text-align:center"><code>sort file</code></td>
<td style="text-align:left">按照字母顺序将文件中的每行进行排序</td>
</tr>
<tr>
<td style="text-align:center"><code>uniq file</code></td>
<td style="text-align:left">用于删除相邻的重复行，最后只会留下一个重复行。</td>
</tr>
<tr>
<td style="text-align:center"><code>spell file</code></td>
<td style="text-align:left">检查文件中所有的拼写错误。</td>
</tr>
<tr>
<td style="text-align:center"><code>su</code></td>
<td style="text-align:left">将用户模式更改为超级用户模式。</td>
</tr>
<tr>
<td style="text-align:center"><code>yum install prog</code><br>或者<br><code>apt-get install prog</code></td>
<td style="text-align:left">这个命令会链接特定服务器来下载并安装程序。<br>一般来讲你需要先运行<code>su</code>才能使用这些命令来安装程序。</td>
</tr>
<tr>
<td style="text-align:center"><code>man cmd</code></td>
<td style="text-align:left">显示命令<code>cmd</code>的手册页。找到使用命令的其他选项对您非常有用。</td>
</tr>
</tbody>
</table>
</div>
<p>接下来我们会细致介绍这些命令的用法</p>
<hr>
<h3 id="文件内搜索-grep"><a href="#文件内搜索-grep" class="headerlink" title="文件内搜索 (grep)"></a>文件内搜索 (grep)</h3><p><code>grep</code>命令适用于搜索文件内的行。</p>
<p>例如这里有一个”<em>example1.txt</em>“文件包含如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 Apple 3.5</span><br><span class="line">4 Chicken 50</span><br><span class="line">1 Coke 5.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">3 Chocolate 15</span><br><span class="line">2 Milk 8</span><br></pre></td></tr></table></figure>
<p>运行下面的命令将会返回文件内所有包含”ke”的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'ke'</span> example1.txt</span></span><br><span class="line">4 Chicken 50</span><br><span class="line">1 Coke 5.5</span><br></pre></td></tr></table></figure>
<p>搜索是很大的一块内容。这里仅用来介绍。后面我们会在搜索章节一起将文件内文件外搜索一并讲清楚的。  </p>
<p><br></p>
<hr>
<h3 id="文件字数-wc"><a href="#文件字数-wc" class="headerlink" title="文件字数 (wc)"></a>文件字数 (wc)</h3><p>同样使用”example1.txt”作为例子：</p>
<p>运行该命令则会返回如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> example1.txt</span></span><br><span class="line"> 6 18 71 example1.txt</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>第一个数字代表<strong>行数</strong>，也就是文件共有六行</li>
<li>第二个数字代表<strong>词数</strong>，表明文件中有18个词</li>
<li>第三个数字代表<strong>文件大小</strong>，代指文件大小为71字节</li>
</ul>
<p>搭配参数<code>-l</code>使用可以仅仅返回行数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -l example1.txt</span></span><br><span class="line">6 example1.txt</span><br></pre></td></tr></table></figure>
<p>搭配参数<code>-w</code>使用可以仅仅返回词数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -w example1.txt</span></span><br><span class="line">18 example1.txt</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用<code>sort</code>命令来对文件内容排序。如果没有指定任何输入参数，则默认排序方式按照<strong>字母表顺序排列</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> example1.txt</span></span><br><span class="line">1 Coke 5.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br><span class="line">5 Apple 3.5</span><br></pre></td></tr></table></figure>
<p>你可以使用不同的传入参数来指定排序方法。例如：</p>
<ul>
<li>使用<code>-n</code>则按照数字顺序排序：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -n example1.txt</span></span><br><span class="line">1 Coke 5.5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br><span class="line">5 Apple 3.5</span><br><span class="line">10 Jelly 5</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-r</code>则按照倒序顺序排序:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -n -r example1.txt</span></span><br><span class="line">10 Jelly 5</span><br><span class="line">5 Apple 3.5</span><br><span class="line">4 Chicken 50</span><br><span class="line">3 Chocolate 15</span><br><span class="line">2 Milk 8</span><br><span class="line">1 Coke 5.5</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-k</code>则按照字段排序。需要注意排序字段ID从1开始，而不是0。</li>
</ul>
<p>例如，将文件按照第三个字段进行排序。在”example1.txt”中，每行最后的那组数字就是第三字段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -k3 -n example1.txt</span></span><br><span class="line">5 Apple 3.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">1 Coke 5.5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-t</code>用来告诉排序程序，我们使用分隔符并非空格而是逗号。</li>
</ul>
<p>例如我们有一个”example1.txt”的变体，”example1_comma.txt”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example1_comma.txt</span></span><br><span class="line">5,Apple,3.5</span><br><span class="line">4,Chicken,50</span><br><span class="line">1,Coke,5.5</span><br><span class="line">10,Jelly,5</span><br><span class="line">3,Chocolate,15</span><br><span class="line">2,Milk,8</span><br></pre></td></tr></table></figure>
<p>需要在使用<code>sort</code>时加入参数<code>-t</code>来指定分隔符为逗号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -t, -k3 -n example1_comma.txt</span></span><br><span class="line">5,Apple,3.5 </span><br><span class="line">10,Jelly,5 </span><br><span class="line">1,Coke,5.5 </span><br><span class="line">2,Milk,8 </span><br><span class="line">3,Chocolate,15 </span><br><span class="line">4,Chicken,50</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="剪切文件"><a href="#剪切文件" class="headerlink" title="剪切文件"></a>剪切文件</h3><p>这里指的不是我们熟悉的剪切文件到其他目录，而是直接在文件内剪掉一部分内容。</p>
<p><code>cut</code>命令将会修剪文件并返回特定的内容。要使用这个命令，我们需要向<code>cut</code>命令指定分隔符。</p>
<p>指定分隔符的参数为<code>-d</code>，代表delimiter，注意不要和之前的<code>sort</code>命令搞混了！该参数不是可选的，即便分隔符为空格，你也需要指定参数<code>-d</code>。</p>
<p>使用参数<code>-f</code>来告诉程序你想要返回的字段，说白了就是列。和<code>sort</code>一样，字段ID从1开始而不是0。</p>
<p>例如，返回”example1.txt”文件内的第一字段和第三字段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d <span class="string">' '</span> -f 1,3 example1.txt</span></span><br><span class="line">5 3.5 </span><br><span class="line">4 50 </span><br><span class="line">1 5.5 </span><br><span class="line">10 5 </span><br><span class="line">3 15 </span><br><span class="line">2 8</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="移除重复行"><a href="#移除重复行" class="headerlink" title="移除重复行"></a>移除重复行</h3><p><code>uniq</code>命令删除相邻的重复行，只保留一个重复行。  </p>
<p>注意咯，它只删除相邻的重复项。</p>
<p>“example2.txt”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Apple </span><br><span class="line">Apple pie </span><br><span class="line">Apple pie </span><br><span class="line">Apple </span><br><span class="line">Apple </span><br><span class="line">Apple pie</span><br></pre></td></tr></table></figure>
<p>想要移除在”example2.txt”中多余的相邻重复行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uniq</span> example2.txt</span> </span><br><span class="line">Apple </span><br><span class="line">Apple pie </span><br><span class="line">Apple </span><br><span class="line">Apple pie</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h3><p><code>spell</code>命令返回文件中所有可能出现拼写错误的词：</p>
<p>“example3.txt”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">It's a beautiffful day!</span><br><span class="line">I am so happpy todday.</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spell example3.txt</span></span><br><span class="line">beautiffful </span><br><span class="line">happpy </span><br><span class="line">todday</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>如果你自己的Linux机子运行这个命令报错，那么你的系统很有可能没有安装需要的软件包。按照下面的步骤修复这个问题吧：</p>
<ol>
<li>切换到Superuser账号：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br></pre></td></tr></table></figure>
<p>还记得我们之前说过安装软件包之前需要切换到su账号吗</p>
<ol>
<li>安装<code>aspell</code>包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install aspell</span></span><br></pre></td></tr></table></figure>
<ol>
<li>退回到你当前的账户：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件差异"><a href="#文件差异" class="headerlink" title="文件差异"></a>文件差异</h3><p><code>diff</code>命令用来显示两个文件的区别。</p>
<p>“fileA.txt”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>
<p>“fileB.txt”:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eee</span><br><span class="line">aaa</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure></p>
<p>下面的命令则会返回将”fileA.txt”转化为”fileB.txt”的步骤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff fileA.txt fileB.txt</span></span><br><span class="line">0a1 </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eee</span> </span><br><span class="line">2,3c3 </span><br><span class="line">&lt; bbb </span><br><span class="line">&lt; ccc</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ddd</span> </span><br></pre></td></tr></table></figure>
<p>这里我们需要一点解释了。</p>
<p><strong>0a1</strong>：  </p>
<p>在<em>fileA</em>的第<strong>0</strong>行之后添加(<strong>a</strong>, add)一行，添加的内容由下一行<strong>&gt; eee</strong>表示</p>
<p><strong>2, 3c3</strong>：  </p>
<p>将<em>fileA</em>中的第<strong>2, 3</strong>行变成(<strong>c</strong>, change)<em>fileB</em>的第三行。<br>完成这一步需要先删除掉两行，由<strong>&lt;</strong>表示：</p>
<p><strong>&lt; bbb</strong><br><strong>&lt; ccc</strong><br>代表删除掉这两行。</p>
<p>分割线隔开后出现了<strong>&gt;</strong>。这代表我们需要在删除后再次添加一行：</p>
<p><strong>&gt; ddd</strong></p>
<p>代表再添加文本”ddd”</p>
<p>这样就能把”fileA.txt”变成”fileB.txt”了。</p>
<hr>
<p>再举另一个例子把：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff fileB.txt fileA.txt</span> </span><br><span class="line">1d0 </span><br><span class="line">&lt; eee </span><br><span class="line">3c2,3 </span><br><span class="line">&lt; ddd </span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">bbb</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ccc</span> </span><br></pre></td></tr></table></figure>
<p>刚才是由A变B，现在是由B变A了。</p>
<p><strong>1d0</strong>：  </p>
<p>在<em>fileB</em>中删除(<strong>d</strong>, delete)第一行，随后的内容就会在第<strong>0</strong>行被对齐。</p>
<p><strong>&lt; eee</strong>表示我们删除了”eee”</p>
<p><strong>3c2,3</strong>：  </p>
<p>和刚才刚好反过来，将<em>fileB</em>中的第<strong>3</strong>行变为<em>fileA</em>的<strong>2,3</strong>行。先删去”ddd”，然后加入”bbb”和”ccc”</p>
<hr>
<h2 id="标准I-O，文件重定向和管道"><a href="#标准I-O，文件重定向和管道" class="headerlink" title="标准I/O，文件重定向和管道"></a>标准I/O，文件重定向和管道</h2><h3 id="标准IO和文件重定向"><a href="#标准IO和文件重定向" class="headerlink" title="标准IO和文件重定向"></a>标准IO和文件重定向</h3><h4 id="标准输入，输出和标准错误"><a href="#标准输入，输出和标准错误" class="headerlink" title="标准输入，输出和标准错误"></a>标准输入，输出和标准错误</h4><p>在Shell中使用命令时，Shell将每个进程与一些打开的文件关联起来，并使用称为<strong>文件描述符</strong> (File descriptors)的数字引用这些打开的文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件描述符</th>
<th style="text-align:left">文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">标准输入(stdin) - 输入文件</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">标准输出(stdout) - 输出文件</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">标准错误(stderr) - 输出错误的文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="重定向运算符"><a href="#重定向运算符" class="headerlink" title="重定向运算符"></a>重定向运算符</h4><p>一般来讲当我们执行命令时，输出会在屏幕上通过Shell打印出来。我们可以使用<strong>重定向运算符</strong> (Redirection operator) “<strong>&gt;</strong>“ 来重定向输出到一个文件内。  </p>
<p>例如，下面的命令将会保存路径中的文件到”file.txt”中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l 1&gt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>或者也可以用这样的短格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>如果使用了上述命令，则输出将不会显示在屏幕上，而是会被记录到文件”files.txt”中。当用来排查数据，debug或者就是简单保存信息时，这招很有用。</p>
<blockquote>
<p>如果多次执行上述命令，系统可能会显示”<strong>cannot overwrite existing file</strong>“。<br>为了解决这个问题，可以先手动删除已有的文件，或者使用<strong>&gt;|</strong>强制写入文件。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt;| files.txt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<hr>
<p>下面是一些常见的重定向运算符和他们的释义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>command 1&gt; file</code><br>或者<br><code>command &gt; file</code></td>
<td style="text-align:left">将标准输出<strong>发送到</strong> <em>file</em>中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 1&gt;&gt; file</code><br>或者<br><code>command &gt;&gt; file</code></td>
<td style="text-align:left">将标准输出<strong>追加到</strong> <em>file</em>中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 2&gt; file</code></td>
<td style="text-align:left">将标准错误<strong>发送到*</strong>file*中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 2&gt;&gt; file</code></td>
<td style="text-align:left">将标准错误<strong>追加到*</strong>file*中</td>
</tr>
<tr>
<td style="text-align:center"><code>command &lt; fileA &gt; fileB 2&gt;fileC</code></td>
<td style="text-align:left">首先命令会从<em>fileA</em>中读取，执行后将输出发送到<em>fileB</em>，将标准错误发送到<em>fileC</em></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong>&gt;</strong>和<strong>&gt;&gt;</strong>的区别在于，”&gt;”将会在每次执行时覆盖文件内容，而”&gt;&gt;”则会在文件后面追加内容。</p>
<hr>
<p>如果我们这里有一个C++程序，我们也可以使用这样的运算符来进行操作。例如下面的程序”add.cpp”会由两个输入，将两个输入加起来之后获得一个输出：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="type">int</span> a;</span><br><span class="line">       <span class="type">int</span> b;</span><br><span class="line">       std::cin &gt;&gt; a;</span><br><span class="line">       std::cin &gt;&gt; b;</span><br><span class="line">       std::cout &lt;&lt; a+b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编译文件为一个叫做”add”的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ add.cpp -o add</span></span><br></pre></td></tr></table></figure>
<p>这时你可以将自己的输入写到文件内，如”input.txt”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>然后使用”&lt;”传入参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./add &lt; input.txt</span></span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>或者你可以更进一步，将输入和输出都独立出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./add &lt; input.txt &gt; output.txt</span></span><br></pre></td></tr></table></figure>
<p>为何不能使用 <code>input.txt &gt; ./add &gt; output.txt</code>这种写法？因为Shell会尝试执行input.txt。  </p>
<p><br></p>
<hr>
<h4 id="管线"><a href="#管线" class="headerlink" title="管线"></a>管线</h4><p>有时候我们需要将一个程序的输出换做另一个程序的输入，我们可以创建并且利用管线来优雅地解决这个问题。  </p>
<p>“|”是管线的符号。这个符号用来重定向一个程序的输出到另一个程序的输入，没有中间商赚差价。所谓中间商就是刚才用到的输入输出文本文件。  </p>
<p>举个例子，如下是两行命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt; files.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">"Jan 26"</span> &lt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>简而言之就是使用<code>ls</code>命令列出所有内容到”files.txt”中，然后从”files.txt”中搜索所有含有”Jan 26”的行。  </p>
<p>太复杂了。  </p>
<p>整个操作可以换做下面的一行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep <span class="string">"Jan 26"</span></span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>|</code>，可以将<code>|</code>之前的命令输出直接当作<code>|</code>后面的命令传入。在这个例子中具体是将<code>ls -l</code>的输出当作<code>grep</code>命令的传入来用了。  </p>
<hr>
<p>举几个例子吧。  </p>
<p><strong>Example 1</strong>:</p>
<p>假设我们现在有一个”data.txt”文件，我们需要按照价格将其排序，然后仅仅将商品的名称和价格保存到”result.txt”文件夹中，要求只能使用一行命令。  </p>
<p>来看看标准题解：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -k3 -n data.txt | <span class="built_in">cut</span> -d<span class="string">' '</span> -f2,3 &gt; result.txt</span></span><br></pre></td></tr></table></figure>
<p>首先我们使用<code>sort</code>命令，对”data.txt”的<strong>第三个字段(-k3)</strong>按照<strong>数字顺序(n)</strong>进行排序。<br>然后你看见了<code>|</code>。这代表这一步的输出即将被传入到下一个命令，也就是<code>cut</code>。<br>在<code>cut</code>中我们以<strong>空格作为分隔符(-d’ ‘)</strong>，并<strong>保留第二第三字段(-f2,3)</strong>，最后存入到”result.txt”中。  </p>
<p>还是很简单的。下面是这个过程的视觉表述方式：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfe2c1fb97579cb3ac7600cc5974e5bb8?method=download&amp;shareKey=866755676c9de499cfa8e00e7cad5101" alt=""></p>
<hr>
<p><strong>Example 2</strong>:</p>
<p>目标是在当前路径下对用户，用户组和其他人有运行权限的文件和路径。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 190</span><br><span class="line">-rwx--x--x    1   kit  gopher   0   Sep  12 10:30  add.o</span><br></pre></td></tr></table></figure>
<p>对于所有目标都有执行权限的话，则权限指示的第4, 7, 10位应该是x。但是我们应该如何检索呢？看看下面这行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^...x..x..x'</span> [传入]</span></span><br></pre></td></tr></table></figure>
<p>使用<code>-E</code>参数可以告诉Shell我们需要做样式匹配搜索了。对于<code>'^...x..x..x'</code>来讲：  </p>
<ul>
<li>“^”表示从行首开始匹配。</li>
<li>“.”表示可以匹配任意字符。</li>
</ul>
<p>加在一起的话，<code>'^...x..x..x'</code>的意思大概就是，从行首开始匹配，返回在第4, 7, 10个位置有字母”x”的行。  </p>
<p>那么一行就能解决了：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep -E <span class="string">'^...x..x..x'</span></span></span><br></pre></td></tr></table></figure>
<p>结构上和上一个例子一样所以这里不解释了。  </p>
<p><br></p>
<hr>
<p><strong>Example 3</strong></p>
<p>加入你想移除文件里的某几列，然后将其输入到程序里。举个例子，”mark.txt”，包含学生信息的单行数据：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> mark.txt</span></span><br><span class="line">2011111111 John M 98.5 100 62.5 88 75.5</span><br></pre></td></tr></table></figure>
<p>对应格式是：[UID, 名称，性别，分数1，分数2，分数3，分数4，分数5]</p>
<p>然后我们同样有一个C++程序用来处理信息，用于计算平均分：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mark.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> main {</span><br><span class="line">       <span class="type">double</span> a1, a2, a3, a4, a5;</span><br><span class="line">       std::cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a3 &gt;&gt; a4 &gt;&gt; a5;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">"The overall mark the student get is: "</span>;</span><br><span class="line">       std::cout &lt;&lt; (a1 + a2 + a3 + a4 + a5) / <span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>程序的问题是输入仅有五项成绩，但是我们的”mark.txt”文件内包含UID在内的其他多余信息。  </p>
<p>那这就很坏了。  </p>
<p>一种方法是我们可以使用管线来先处理”mark.txt”，然后传入程序。我们可以使用<code>cut</code>命令处理一下：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d<span class="string">' '</span> -f-8 mark.txt</span></span><br><span class="line">98.5 100 62.5 88 75.5</span><br></pre></td></tr></table></figure>
<p>然后编译程序运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ mark.cpp -o mark</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d<span class="string">' '</span> -f4-8 mark.txt | ./mark &gt; result.txt</span></span><br></pre></td></tr></table></figure>
<p>这样程序的输出就会被记录到”result.txt”中：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> result.txt</span></span><br><span class="line">The overall marks the student get is: 84.9</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="搜索文件或路径-find"><a href="#搜索文件或路径-find" class="headerlink" title="搜索文件或路径 (find)"></a>搜索文件或路径 (find)</h3><p>各位应该在Windows或MacOS中使用过搜索功能。你也可以在Linux中实现对文件或路径的搜索操作：  </p>
<p>使用<code>find</code>命令可以用来搜索文件或路径。<code>find</code>命令的格式为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [path] [-name] [-type]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[path]</code>告诉系统你想从哪里开始搜索操作。  </li>
<li><code>[name]</code>是你想要搜索的文件或路径的名字。  </li>
<li><code>[type]</code>是可选参数，参数包含：  <ul>
<li><code>-type f</code>代表仅搜索文件 (<em>files</em>)</li>
<li><code>-type d</code>命令之搜索路径 (<em>directory</em>)</li>
</ul>
</li>
</ul>
<hr>
<p>举个例子，假如在当前位置有下面这几个文件和路径：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">hello/  hello.cpp  hello.txt</span><br></pre></td></tr></table></figure>
<p>那么在当前目录下搜索”hello.txt”的方法即为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello.txt"</span> -<span class="built_in">type</span> f</span></span><br><span class="line">./hello.txt</span><br></pre></td></tr></table></figure>
<p>上面的命令<br>在上面的命令中，<code>.</code>代表<strong>当前目录</strong>。指定当前目录后<code>find</code>会在这个目录为基础向下寻找文件。  </p>
<p><br></p>
<p>或者我们也可以在当前位置下搜索”hello”打头的文件：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello.*"</span> -<span class="built_in">type</span> f</span></span><br><span class="line">./hello.cpp</span><br><span class="line">./hello.txt</span><br></pre></td></tr></table></figure>
<p>…或者是搜索路径：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello"</span> -<span class="built_in">type</span> d</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件内搜索-grep-1"><a href="#文件内搜索-grep-1" class="headerlink" title="文件内搜索 (grep)"></a>文件内搜索 (grep)</h3><p><code>grep</code> (Global Regular Expression Print)命令之前已经介绍过了。这里介绍更多细节：  </p>
<p>之前用的是不带<code>-E</code>的使用方式，只是用来返回文件内的匹配行：  </p>
<p>“example1.txt”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello how are you?</span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'hell'</span> example1.txt</span></span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<p><code>grep</code>命令<strong>区分大小写！</strong>这就是为什么返回的是包含”shell”的第二行，而不是包含”Hello”的第一行。  </p>
<hr>
<p><code>grep</code>可以加入可选参数<code>-E</code>，代表按样式匹配。格式为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E [regular experssion] [filename]</span><br></pre></td></tr></table></figure>
<p>在<code>regular expression</code>中，你可以按照下面的符号来进行自定义匹配：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:left">匹配任何<strong>单个字符</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:left">仅从<strong>行首</strong>开始匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:left">仅从<strong>行尾</strong>开始匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:left">一个字符后面跟一个”?”，则该字符可被匹配<strong>0次或1次</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:left">一个字符后面跟一个”+”，则该字符可被匹配<strong>1次或多次</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">一个字符后面跟一个”<em>“，则该字符可被匹配<em>*0次或多次</em></em></td>
</tr>
<tr>
<td style="text-align:center"><code>[]</code></td>
<td style="text-align:left">被”[]”括起来的字符会被<strong>全字匹配</strong><br>括起来的字符可以是单个字符，也可以是多个字符<br>你可以用”-“符号来自定义区间<br>例如，与其使用[12345]，可以使用[1-5]代替</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:left"><strong>转义符</strong><br>使用转义符来取消特殊字符的特殊效用<br>例如我们想要寻找”.”而不发挥它“匹配单个字符的属性”，就写成<code>\.</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n}</code></td>
<td style="text-align:left">匹配”n”次出现的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n,}</code></td>
<td style="text-align:left">匹配<em>至少</em>“n”次出现的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n,m}</code></td>
<td style="text-align:left">匹配出现”n”和”m”次数之间的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>(ab){3}</code></td>
<td style="text-align:left">出现三次”ab”排列<br>例如(ab){3}会被匹配做”ababab”，不是”abbb”</td>
</tr>
</tbody>
</table>
</div>
<p>接下来我们使用刚才”example1.txt”，挑重点解释。  </p>
<hr>
<h4 id="任意单字符匹配"><a href="#任意单字符匹配" class="headerlink" title="任意单字符匹配"></a>任意单字符匹配</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'.ell'</span> example1.txt</span></span><br><span class="line">Hello how are you?</span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<p>‘.ell’代表”.”处可以匹配任何单个字符，例如”Cell”, “cell”, “bell”会被匹配。<br>如果如果你想要在”.”处搜索的字母仅仅是大小写H，则可以使用<code>[Hh]ell</code>。  </p>
<hr>
<h4 id="行首-行尾匹配"><a href="#行首-行尾匹配" class="headerlink" title="行首/行尾匹配"></a>行首/行尾匹配</h4><p>这里启用”example2.txt”：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'apple'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>使用”^”从行首开始匹配：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^apple'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>而使用”$”从行尾开始匹配：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'apple$'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>由此可知，使用”^”和”$”也可以全字匹配某一行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^apple$'</span> example2.txt</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>或者使用”^”, “$”配合”.”来返回只有五个字符的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^.....$'</span> example2.txt</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>
<hr>
<h4 id=""><a href="#" class="headerlink" title="?, +, *"></a>?, +, *</h4><p><strong>“?”</strong></p>
<p>“example3.txt”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">coco</span><br><span class="line">cherries</span><br><span class="line">orange</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap?'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<p>没看懂？首先”^”确保行首开始匹配，随后：  </p>
<ul>
<li>“<strong>ap</strong>ple”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了1次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了1次</li>
<li>“<strong>a</strong>ngel”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了0次</li>
</ul>
<p>那么接下来的东西，”+”和”*”，原理上基本上是一样的了。</p>
<hr>
<p><strong>+</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap+'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br></pre></td></tr></table></figure>
<ul>
<li>“<strong>app</strong>le”会被返回，因为在表达式中的p要求出现1次或者多次，这里出现了多次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现1次或者多次，这里出现了1次</li>
<li>“angel”没有被返回，因为在表达式中的p要求出现1次或者多次，这里出现了0次</li>
</ul>
<hr>
<p><strong>*</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap*+*'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<ul>
<li>“<strong>app</strong>le”会被返回，因为在表达式中的p要求出现0次或者多次，这里出现了多次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现0次或者多次，这里出现了1次</li>
<li>“<strong>a</strong>ngel”会被被返回，因为在表达式中的p要求出现0次或者多次，这里出现了0次</li>
</ul>
<hr>
<p>接下来是一些进阶一点的用法了：</p>
<p><strong>整合”.”和”*“</strong></p>
<p>如果我们想要匹配字符”a”，然后后方跟随任意字符，直到”ge”再次出现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'a.*ge'</span> example3.txt</span></span><br><span class="line">orange</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<p>“<em>“跟在”.”之后，所以”任意字符匹配”可以被匹配多次，这就是为什么”or<strong>ange</strong>“和”<em>*ang</em></em>el”能被返回的原因。  </p>
<hr>
<p><strong>使用括号”()”</strong></p>
<p>我们可以使用括号来整合子字符串。例如我们想要寻找字符串”co”出现过一次或多次的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'(co)+'</span> example3.txt</span></span><br><span class="line">coco</span><br></pre></td></tr></table></figure>
<p>为什么要用括号呢，看看如果不用括号会发生什么：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'co*'</span> example3.txt</span></span><br><span class="line">coco</span><br><span class="line">cherries</span><br></pre></td></tr></table></figure>
<p>因为”*”只会应用到它的前一个字符。没加括号的话就会被应用到”o”，而不是整个子字符串”co”。  </p>
<hr>
<h4 id="匹配集合"><a href="#匹配集合" class="headerlink" title="匹配集合"></a>匹配集合</h4><p>可以使用方括号 “[ ]”来定义一个集合，随后进行搜索。你可以按照下面的格式定义集合：  </p>
<ul>
<li><strong>[0123456789]</strong>或者<strong>[0-9]</strong>用来匹配任意单个数字</li>
<li><strong>[A-Z]</strong>用来匹配任何单个大写字母</li>
<li><strong>[a-z]</strong>用来匹配任何单个小写字母</li>
<li><strong>[A-Za-z]</strong>用来匹配任何单个字母，包括大写和小写字母。  </li>
</ul>
<p>例如我们有一个”example4.txt”：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple Juice HKD13</span><br><span class="line">apple pie USD 4</span><br><span class="line">Banana phone HKD</span><br></pre></td></tr></table></figure>
<p>查找包含”apple”或者”Apple”的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'[Aa]pple'</span> example4.txt</span></span><br><span class="line">Apple Juice HKD13</span><br><span class="line">apple pie USD 4</span><br></pre></td></tr></table></figure>
<p>查找包含”HKD”，并在其后跟随一个或者多个数字的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'HKD[0-9]*'</span> example4.txt</span></span><br><span class="line">Apple Juice HKD13</span><br><span class="line">Banana phone HKD</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="匹配序列"><a href="#匹配序列" class="headerlink" title="匹配序列"></a>匹配序列</h4><p>可以使用”{ }”来匹配一个序列 (pattern)。  </p>
<p>上”example5.txt”：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2April2013</span><br><span class="line">30-1-2013</span><br><span class="line">13December2013</span><br></pre></td></tr></table></figure>
<p>如果我们想要查找一个日月年的格式，并且日为2个字符，月至少为3个字符，年为4个字符，你可以整成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^[0-9]{1,2}[a-zA-Z]{3,}[0-9]{4}'</span> example5.txt</span></span><br><span class="line">2April2013</span><br><span class="line">13December2013</span><br></pre></td></tr></table></figure>
<p>这很抽象，所以我们需要简单讲讲：  </p>
<ul>
<li><strong>[0-9]{1,2}</strong>定义一个数字集合，并且需要至少出现一次，最多出现2次</li>
<li><strong>[a-zA-Z]{3,}</strong>定义一个字母（包含大小写）集合，并且需要至少3个字符长</li>
<li><strong>[0-9]{4}</strong>定义一个数字集合，并且必须要是正正好好4个字符长</li>
</ul>
<p>加上行首匹配”^”就ok了。  </p>
<hr>
<h4 id="其他常用匹配写法"><a href="#其他常用匹配写法" class="headerlink" title="其他常用匹配写法"></a>其他常用匹配写法</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表述</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[a-z]*</code></td>
<td style="text-align:left">匹配任意数量字符的小写字母</td>
</tr>
<tr>
<td style="text-align:center"><code>....$</code></td>
<td style="text-align:left">匹配包含四个字符的行</td>
</tr>
<tr>
<td style="text-align:center"><code>abc.*abc</code></td>
<td style="text-align:left">匹配出现两次”abc”的行。两个”abc”之间可以有任意数量的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]{2}-[0-9]{2}-[0-9]{4}</code></td>
<td style="text-align:left">匹配<code>dd-mm-yyyy</code>格式。请注意这不会验证日期是否合法！</td>
</tr>
<tr>
<td style="text-align:center"><code>^.{n,m}$</code></td>
<td style="text-align:left">匹配行长介于n和m个字符之间的行</td>
</tr>
<tr>
<td style="text-align:center"><code>(bye)+</code></td>
<td style="text-align:left">匹配一次或多次出现过”bye”的行，例如”bye”, “byebye”, “byebyebye”，空行不会被匹配。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><br></p>
<p><strong>至此，Module 1全部完结！</strong> </p>
<p><br></p>
<hr>
<h1 id="Module-2-Shell-Script-amp-Version-Control"><a href="#Module-2-Shell-Script-amp-Version-Control" class="headerlink" title="Module 2: Shell Script & Version Control"></a>Module 2: Shell Script &amp; Version Control</h1><p>先来深入一下Shell脚本把。  </p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>Shell 脚本 (Shell Script, .sh) 是一种由 Linux shell 运行的计算机程序。<br>Shell Script是一种解释型语言，而不是编译型语言。因此与 C++ 不同，我们不需要在执行程序之前将 shell 编译为二进制可执行格式。<br>相反，每次执行用 Shell 脚本编写的程序时，shell 都会对其进行解析和解释。  </p>
<p>解释型语言允许我们通过简单地编辑脚本来更快地修改程序。但是，程序通常较慢，因为在执行期间需要进行解析和解释。<br>假设我们有一系列 Shell 命令，我们不想在每次要执行时重新输入这些命令。我们可以将它们保存在一个文件中，并将其称为 shell 脚本。  </p>
<blockquote>
<p><strong>注意注意↑！</strong><br>在 Windows 中编辑脚本文件并导入到 Linux 可能会导致执行失败，因为 Windows 中使用的行尾 (EOL) 不同。<br>  你应该在 Linux 系统内创建和编辑脚本文件（例如，在 SSH 中使用 vi 编辑器，在 X2Go 中使用 gedit）。否则，如果从 Windows 导入脚本文件，则需要确保 Windows 环境中的文本编辑器中的行尾选项设置为 UNIX 格式 (LF) 而不是 Windows 格式 (CRLF)。  </p>
</blockquote>
<p><br></p>
<hr>
<p>我们先来创建一个<code>hello.sh</code>脚本写个典中典Hello world：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi hello.sh</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello world!"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Welcome to ENGG1340"</span></span><br></pre></td></tr></table></figure>
<p><code>echo</code>命令用来向控制台输出一行。行中内容可以是变量值，也可以是字符串。  </p>
<p>保存并退出，随后我们需要使得文件可以被用户运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x hello.sh</span></span><br></pre></td></tr></table></figure>
<p>然后直接运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello.sh</span></span><br><span class="line">Hello world!</span><br><span class="line">Welcome to ENGG1340</span><br></pre></td></tr></table></figure>
<hr>
<p>所有脚本都应以<code>#!</code>开头，这表示系统应使用哪个程序来处理 shell 脚本。在本例中，它是 bash 程序的路径。<br>从Module 1 中我们知道有许多不同的 shell（例如，C shell、Korn shell、Bash shell）。而由于我们使用 Bash shell，因此我们需要提供 bash 程序的路径，以便操作系统知道如何解释 bash shell 命令。<br>在本例中，Bash shell的路径为 /bin/bash。  </p>
<p>你也可以使用<code>which -a</code>命令来找到Bash shell的具体位置： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> -a bash</span></span><br><span class="line">/usr/local/bin/bash</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>参数<code>-a</code>代指返回bash的所有路径。如你所见返回的路径不止一个，这代表Bash的路径可能有多个。在本例中我们使用<code>/bin/bash</code>路径下的那个。  </p>
<hr>
<p>来看看另一个例子。这里我们引入<code>echo</code>命令的新参数<code>-n</code>看看会发生什么不同的情况：  </p>
<p><em>ex1_1.sh</em>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Hello world!"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Welcome to ENGG1340"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bye"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex1_1.sh</span></span><br><span class="line">Hello world!Welcome to ENGG1340</span><br><span class="line">bye</span><br></pre></td></tr></table></figure>
<p><code>-n</code>可以表示”no trailing”使下一行直接继续打印在上一行的末尾。  </p>
<hr>
<p>这次我们来看个带C++的例子：  </p>
<p>“<em>add.cpp</em>“</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="type">int</span> a;</span><br><span class="line">       <span class="type">int</span> b;</span><br><span class="line">       std::cin &gt;&gt; a;</span><br><span class="line">       std::cin &gt;&gt; b;</span><br><span class="line">       std::cout &lt;&lt; a + b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>“<em>input.txt</em>“:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>之前我们使用管线可以封装好整个自动化，不过这里我们试着用Shell脚本： </p>
<p>“<em>ex1_2.sh</em>“:  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile the code</span></span><br><span class="line">g++ add.cpp -o add</span><br><span class="line"><span class="comment"># Run the code and display result</span></span><br><span class="line">./add &lt; input.txt &gt; output.txt</span><br><span class="line"><span class="built_in">cat</span> output.txt</span><br></pre></td></tr></table></figure>
<p>运行：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./ex1_2.sh</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>在Shell脚本中只有一种变量类型，那就是字符串。  </p>
<p>变量名区分大小写，只支持包含大小写字母，数字和下划线 (_)。  </p>
<hr>
<h4 id="定义并访问变量"><a href="#定义并访问变量" class="headerlink" title="定义并访问变量"></a>定义并访问变量</h4><p>我们可以通过这种方式来定义并赋予变量一个值：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet=<span class="string">"dog"</span></span><br></pre></td></tr></table></figure>
<p>等号前后不能有空格。  </p>
<p>如果我们需要取用变量中的内容，则需要使用美元符号：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">pet=<span class="string">"dog"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pet</span></span><br></pre></td></tr></table></figure>
<p>输出为<code>dog</code>。  </p>
<hr>
<h4 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h4><p><code>read</code>命令用来等待用户在控制台向脚本提供输入： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"What is your name?"</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$name</span>"</span></span><br></pre></td></tr></table></figure>
<p>当用户输入完值之后，会被自动存储到变量<code>name</code>中。  </p>
<p>比如我们来看这个程序的具体例子：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_2.sh</span></span><br><span class="line">What is your name?</span><br><span class="line">Kit</span><br><span class="line">Hello, Kit</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>在Shell脚本中区分引用很重要。我们可以用三种方式来确定一个字符串值，分别是<strong>不引用</strong>，<strong>单引号引用</strong>和<strong>双引号引用</strong>。  </p>
<hr>
<p><strong>不引用</strong>  </p>
<p>我们可以在定义字符串的时候不加任何引用，但是这个方法仅在需要定义的字符串是一个整体，没有空格的情况下才可用：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">cat</span></span><br></pre></td></tr></table></figure>
<p>下面这种情况就会报错：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=Apple pie</span><br></pre></td></tr></table></figure>
<p>因为 程序会将Apple当作一个指令来看待，而不是一个字符串。  </p>
<hr>
<p><strong>单引号引用</strong>  </p>
<p>在单引号引用情况下，带空格的字符串可以被成功处理，但是没办法做到变量替换。  </p>
<p>变量替换功能是双引号引用的功能： </p>
<hr>
<p><strong>双引号引用</strong></p>
<p>双引号引用相比单引号引用支持更多功能，其中一个就是变量替换：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:left">变量替换</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:left">转义符</td>
</tr>
<tr>
<td style="text-align:center">``</td>
<td style="text-align:left">包含bash命令</td>
</tr>
</tbody>
</table>
</div>
<p>看不懂？就着下面的例子看看：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">name=<span class="string">"Apple"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Hello, $name'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"\$name = <span class="variable">$name</span>"</span></span><br></pre></td></tr></table></figure>
<p>运行后可以得到： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_3.sh</span></span><br><span class="line">Hello, $name</span><br><span class="line">Hello, Apple</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">name = Apple</span></span><br></pre></td></tr></table></figure>
<p>第一行会被输出为<code>Hello, $name</code>，因为我们使用了单引号引用，<code>name</code>变量不会被替换。<br>第二行会被输出为<code>Hello Apple</code>，因为双引号引用下<code>$name</code>会被替换为变量<code>name</code>。<br>第三行会被输出为<script type="math/tex">name = Apple`，因为我们使用转义符取消了第一个`$name`中`</script>的替换功能，而第二个<code>$name</code>会被保持原状正常替换。  </p>
<p><br></p>
<hr>
<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>前面提到过一嘴，不过我们决定在这里展开相关说明。  </p>
<p>使用反引号(`)，一般是esc键下面的那个键，我们可以在脚本中向变量保存Shell命令的输出，来实现进一步的处理：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"`cat file.txt`"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">b=<span class="string">"`wc -l file.txt | cut -d\" \""</span> -f1`<span class="string">"</span></span><br><span class="line"><span class="string">echo "</span>There are <span class="variable">$b</span> lines <span class="keyword">in</span> file<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>“<em>file.txt</em>“:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Cherry</span><br></pre></td></tr></table></figure>
<p>运行输出为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_4.sh</span></span><br><span class="line">Apple Banana Cherry</span><br><span class="line">There are 3 lines in file</span><br></pre></td></tr></table></figure>
<p>接下来我们解读一下。在变量b中，首先<code>wc</code>命令返回<code>3 file.txt</code>，告诉我们一共有三行。接着我们使用<code>cut</code>命令截去后面多余的部分，返回一个”3”。  </p>
<p>注意在<code>cut</code>命令的参数部分我们使用了转义符，因为原本是<code>cut -d" " -f1</code>，但问题在于外面已经有一对双引号了。解决这个问题只能去转义里面的两个引号。  </p>
<p><br></p>
<hr>
<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>如果我们想要获得一个字符串的长度：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"Apple"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${#a}</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./ex2_5_1.sh</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>其中<code>${\#a}</code>的意思是返回变量a存储的字符串的长度。  </p>
<hr>
<h4 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h4><p>使用<code>${a:pos:len}</code>可以用来返回一个字符串的子字符串。例如：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"Apple Pie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${a:6:3}</span></span><br></pre></td></tr></table></figure>
<p>会返回变量<strong>a</strong>从第<strong>6</strong>个字符位置开始包含并向后数<strong>3</strong>个字符长度的子字符串，也就是：<code>Pie</code>。  </p>
<p>和Python一样第一个字符编号为0。  </p>
<p><br></p>
<hr>
<h4 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h4><p>使用<code>${a/from/to}</code>来指定替换一个字符串。先看例子：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"Apple Pie"</span></span><br><span class="line">from=<span class="string">"Pie"</span></span><br><span class="line">to=<span class="string">"Juice"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${a/from/to}</span></span><br></pre></td></tr></table></figure>
<p>输出为<code>Apple Juice</code>。  </p>
<p>该替换会在字符串内寻找<code>from</code>的第一个匹配，然后将<code>from</code>替换为<code>to</code>的值。  </p>
<p><br></p>
<hr>
<h4 id="按数字计算"><a href="#按数字计算" class="headerlink" title="按数字计算"></a>按数字计算</h4><p>我们存储的变量都是字符串，但是如果我们存入的是数字类型的字符串，并且我们想要进行一些数学运算该咋整？  </p>
<p>虽然听起来很奇怪，但是我们可以使用<code>let</code>命令来进行数学运算。支持加减乘除和整数除法。(+, -, *, /, %)  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"b = <span class="variable">$a</span> = 9"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"c = <span class="variable">$a</span> * <span class="variable">$a</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$C</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"d = <span class="variable">$a</span> % 9"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$d</span></span><br></pre></td></tr></table></figure>
<p>运行为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_5_4.sh</span></span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="获取控制台参数数量"><a href="#获取控制台参数数量" class="headerlink" title="获取控制台参数数量"></a>获取控制台参数数量</h4><p>控制台参数再Shell脚本中会被列为<code>$0</code>, <code>$1</code>, <code>$2</code>一直到<code>$9</code>。<br>作为特殊项，<code>$0</code>会被解析为Shell脚本的名称。<br>如果想要引用第十个或者更多参数，则需要将序号使用括号括起来：<code>${10}</code>, <code>${11}</code>这样，否则命令会被解析为<code>$1</code>和数字的组合。<br><code>$#</code>代表控制台内参数的数量。  </p>
<p>例如我们有一个Shell脚本如下所示：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"There are <span class="variable">$#</span> arguments"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$4</span>"</span></span><br></pre></td></tr></table></figure>
<p>运行脚本后输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_6.sh we are the world</span></span><br><span class="line">There are 4 arguments</span><br><span class="line">./ex2_6.sh</span><br><span class="line">we</span><br><span class="line">are</span><br><span class="line">the</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>在任何脚本语言中，流程控制都是必不可少的一部分。  </p>
<h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h4><p>基本的if else语句语法为：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    *perform some action</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if语句的重点写做fi还有点搞笑。<br>注意了if语句的条件判断，方括号里那个，需要前后带一个空格。注意condition前后离着括号都差一个空格。如果不遵守这个规定会爆语法错误。  </p>
<p>Shell脚本也有else if功能：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"condition 1 met"</span></span><br><span class="line"><span class="keyword">elif</span> [ condition2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"condition 2 met"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"No condition met"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>在上面的语句中，condition的语法条件比较特殊。下面的列表展示了可以当作condition来用的语句：  </p>
<ul>
<li>比较字符串</li>
</ul>
<p>注意<code>$string1</code>和<code>$string</code>都被双引号引用了，所以在<code>$string1</code>和<code>$string2</code>内即使有空格也可以正确比较内容。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">String comparisons</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[ "$string" ]</code></td>
<td style="text-align:left">如果<code>$string</code>的长度不为空，则返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -z "$string" ]</code></td>
<td style="text-align:left">如果<code>$string</code>的长度为空，则返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" == "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>和<code>$string2</code>完全一致，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" != "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>和<code>$string2</code>不一致，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" \&gt; "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>按照字母顺序排序排在<code>$string2</code>后面，则返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" \&lt; "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>按照字母顺序排序排在<code>$string2</code>前面，则返回true</td>
</tr>
</tbody>
</table>
</div>
<p>注意排序那两个符号前面带转义符。</p>
<p><br></p>
<ul>
<li>比较文件或路径</li>
</ul>
<p>可以用来判断文件或者路径的状态。包括但不限于：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件检查</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[ -e $file ]</code></td>
<td style="text-align:left">如果<code>file</code>存在，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -f $file ]</code></td>
<td style="text-align:left">如果<code>file</code>是一个文件，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -d $file ]</code></td>
<td style="text-align:left">如果<code>file</code>是一个路径，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -s $file ]</code></td>
<td style="text-align:left">如果<code>file</code>的大小&gt;0，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -r $file ]</code></td>
<td style="text-align:left">如果<code>file</code>可读，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -w $file ]</code></td>
<td style="text-align:left">如果<code>file</code>可写，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -x $file ]</code></td>
<td style="text-align:left">如果<code>file</code>可执行，返回true</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<ul>
<li>比较数字</li>
</ul>
<p>虽然shell里只有字符串一种变量，但我们也可以按下面的方式来比较数字：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数字比较</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[ $a -eq $b ]</code></td>
<td style="text-align:left">如果a = b，返回true (equal)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -ne $b ]</code></td>
<td style="text-align:left">如果a != b，返回true (not equal)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -lt $b ]</code></td>
<td style="text-align:left">如果a &lt; b，返回true (less than)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -le $b ]</code></td>
<td style="text-align:left">如果a &lt;= b，返回true (less or equal)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -gt $b ]</code></td>
<td style="text-align:left">如果a &gt; b，返回true (greater than)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -ge $b ]</code></td>
<td style="text-align:left">如果a &gt;= b，返回true (greater or equal)</td>
</tr>
</tbody>
</table>
</div>
<p>还是比较好记的</p>
<p><br></p>
<p>例如我们想要写一个小脚本，询问用户想不想要移除所有后缀为<code>.cpp</code>的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Do you want to remove all .cpp files? (Y/N)"</span></span><br><span class="line"><span class="built_in">read</span> ans =</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$ans</span>"</span> == <span class="string">"Y"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">rm</span> -rf *.cpp</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"All .cpp files are removed!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>尤其注意一下if语句带condition的空格问题。留意一下空格都加在哪里了。  </p>
<p>运行为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Do you want to remove all .cpp files? (Y/N)</span><br><span class="line">Y</span><br><span class="line">All .cpp files are removed!</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>学会了？接下来举几个例子：  </p>
<p><strong>Example 1</strong>  </p>
<p>如果g++在编译c++文件时出现了错误，则编译失败，可执行文件将不会生成。所以我们可以使用<code>[ -e file ]</code>来检查文件是否存在。<br>同时，我们也可以考虑一下是不是可以查看一下编译失败的log?  </p>
<p>比如我们可以使用重定向方法来存储错误log：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ hello.cpp -o hello 2&gt; error.txt</span></span><br></pre></td></tr></table></figure>
<p>别忘了<code>2&gt;</code>代表重定向标准错误。  </p>
<p>那么看看这个shell脚本吧：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e hello.cpp ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello.cpp exist"</span></span><br><span class="line">    g++ hello.cpp -o hello 2&gt; error.txt</span><br><span class="line">    <span class="keyword">if</span> [ -e hello ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        ./hello</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Compilation failed!"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Here are the error message"</span></span><br><span class="line">        <span class="built_in">cat</span> error.txt</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello.cpp not found!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>如果<code>hello.cpp</code>包含语法错误，那么下面就是其中一种可能的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello,cpp exist</span><br><span class="line">Compilation failed!</span><br><span class="line">Here are the error message</span><br><span class="line">hello.cpp: In function 'int main()':</span><br><span class="line">hello.cpp:5:5: error: expected ';' before 'return'</span><br><span class="line">     return 0;</span><br><span class="line">     ^~~~~~</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环可以按照指定次数循环。  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">list=<span class="string">"1 2 3 4 5"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$list</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"This is iteration <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>for循环以<code>for i in []</code>开始，需要执行的命令以<code>do</code>和<code>done</code>括起来。  </p>
<p>例如上面的脚本会被运行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is iteration 1</span><br><span class="line">This is iteration 2</span><br><span class="line">This is iteration 3</span><br><span class="line">This is iteration 4</span><br><span class="line">This is iteration 5</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>实际上除了遍历数组，我们也可以遍历一个路径中的文件。<br>比如下面的脚本将会自动将你路径下所有的<code>.cpp</code>文件记录一个备份：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">list=<span class="string">"`ls *.cpp`"</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> <span class="variable">$list</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$fileName</span> <span class="string">"<span class="variable">$fileName</span>.backup"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">a.cpp  backup.sh*  b.cpp  c.cpp</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./backup.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">a.cpp  a.cpp.backup  backup.sh*  b.cpp  b.cpp.backup  c.cpp  c.cpp.backup</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="有用的操作"><a href="#有用的操作" class="headerlink" title="有用的操作"></a>有用的操作</h3><h4 id="在脚本中隐藏命令"><a href="#在脚本中隐藏命令" class="headerlink" title="在脚本中隐藏命令"></a>在脚本中隐藏命令</h4><p>Shell脚本会生成自己的错误和输出信息，有时会引爆你的shell脚本输出。  </p>
<p>为了解决这一点你可以使用之前的重定向方法：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> file123 fileabc 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ -e fileabc ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Copy successful"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>: Oops. Copy failed :("</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>解析一下，<code>1&gt;/dev/null</code>用来将<code>cp</code>命令的标准输出重定向到系统回收站内<code>/dev/null</code>。挺巧妙的。  </p>
<p><code>2&gt;&amp;1</code>则会重定向<code>cp</code>命令的标准错误到同一个位置，只不过我们以<code>&amp;1</code>表示了。  </p>
<p><code>&amp;</code>表示在这里指的是文件描述符，而不是文件名或路径。如果没有<code>&amp;</code>，像<code>2&gt;1</code>这样的命令将无效，因为shell会尝试将<code>1</code>解释为文件名，而不是标准输出文件描述符。  </p>
<p>输出为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex4_1.sh</span></span><br><span class="line">./ex4_1.sh: Oops. Copy failed :(</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="输出到标准错误"><a href="#输出到标准错误" class="headerlink" title="输出到标准错误"></a>输出到标准错误</h4><p>Shell脚本也可以通过<code>echo</code>命令输出到标准错误中：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> file123 fileabc 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ -e fileabc ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Copy successful"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>: Oops. Copy failed :("</span> &gt;&amp;2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>当<code>echo</code>后面跟着<code>&gt;&amp;2</code>时候，则代表我们将该条信息重定向到标准错误层上进行输出了。接下来如果我们执行这个：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex4_2.sh 2&gt; error.txt</span></span><br></pre></td></tr></table></figure>
<p>就可以在”error.txt”中看见我们的错误输出了！  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> error.txt</span></span><br><span class="line">./ex2_6.sh: Oops. Copy failed :(</span><br></pre></td></tr></table></figure>
<p>经过这两步处理后你的shell脚本的输出看起来就像其他shell命令一样了。  </p>
<hr>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>在版本控制这一部分，我们主要学习如何使用Git。  </p>
<p>Git 是一种常见的现代版本控制系统，用于管理和跟踪计算机文件中的更改以及协调多人对这些文件的工作。主要用于软件开发中的源代码管理。<br>Git 是一种分布式版本控制系统 (DVCS)，与大多数替代版本控制系统相比，它具有更高的性能、安全性和灵活性。  </p>
<p>那么什么是版本控制系统？  </p>
<p>版本控制系统 (VCS) 是一类软件工具，支持软件开发团队管理源代码随时间的变化。<br>它在一种特殊的数据库中跟踪每个贡献者对代码的单独更改历史记录。如果出现错误或需要修复错误，开发人员可以返回到源代码的早期版本来解决问题，而不会妨碍其他团队成员的工作流程。<br>如果软件团队不使用 VCS，他们可能会遇到一些问题，例如在项目的两个独立部分之间创建不兼容的代码或对用户可用的更改一无所知。  </p>
<p>在这么多版本控制解决方案中，使用Git的原因是它让开发人员可以在一个地方查看任何项目的变更、决策和进展的整个时间线。<br>借助 Git 这样的 DVCS，可以随时进行协作，同时保持源代码的完整性。使用分支，开发人员可以安全地对生产代码提出更改建议。  </p>
<p>如果你用过Github，你应该对上述这些内容和下面将要讲到的内容比较熟悉。如果不，那么这一节将会很有意思。  </p>
<p><br></p>
<p>Git的使用工作流基本分三步。  </p>
<ol>
<li><code>git init</code>初始化工作目录  </li>
</ol>
<p>首先可以使用Git初始化一个你将要使用的工作目录。Git会尝试在目录内跟踪你对文件的改变。  </p>
<ol>
<li><code>git add</code>增加一次提交  </li>
</ol>
<p>这一步告诉Git，当前目录下所有被更改的文件有哪些。  </p>
<ol>
<li><code>git commit</code>创建一次提交(commit)</li>
</ol>
<p>最后告诉Git让它创建一次提交，类似于创建一个存档点。每一次提交就是某个特定版本。  </p>
<p><br></p>
<hr>
<h3 id="开始使用Git"><a href="#开始使用Git" class="headerlink" title="开始使用Git"></a>开始使用Git</h3><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>要使用Git，我们需要先配置好Git的使用环境。首先我们需要在你的电脑上安装Git。  </p>
<p>检查Git是否在你的电脑上安装，执行<code>git version</code>即可：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git version</span></span><br><span class="line">git version 2.45.2.windows.1</span><br></pre></td></tr></table></figure>
<p>如果没有安装Git，则你可以根据下面的步骤来安装Git。  </p>
<p><br></p>
<p><strong>在Linux上安装</strong>  </p>
<p>在终端执行几行代码就OK了：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get upgrade</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>在MacOS上安装</strong></p>
<p>虽然我不用Mac但是相应的安装方式也是可以提一嘴的。  </p>
<p>首先下载Homebrew来更方便快捷的安装软件：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ruby -e <span class="string">"<span class="subst">$(curl -fsSL</span></span></span></span><br><span class="line">   https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string"><span class="subst">brew doctor</span></span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string"><span class="subst">brew install git</span></span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>在Windows上安装</strong></p>
<p>直接去官网下载安装包即可。  </p>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p><br></p>
<hr>
<h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><p>一个Git仓库包含你工作环境的所有文件，文件夹或者路径等等。配置好Git后Git会自动帮你管理变更。  </p>
<p>一共有两种方式来初始化一个本地仓库。你可以从网上clone一个仓库下来，也可以自己创建一个空白仓库使用。  </p>
<p><br></p>
<p><strong>初始化新仓库</strong></p>
<ol>
<li>打开终端并转到你想要初始化的路径：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> project</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在文件夹内我们使用<code>git init</code>命令创建一个新仓库：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in /home/research/ra/1801/cklai/project/.git/</span><br></pre></td></tr></table></figure>
<p>执行完这行命令后，一个新的<code>.git/</code>子路径会在当前路径下生成。这个指令用来设置好Git用来跟踪你的文件的所有前置工作。  </p>
<ol>
<li>现在我们可以使用Git了。比如说下一步我们创建一个”work.txt”： </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my Git tutorial.</span><br><span class="line">Today we will learn how to get started with Git.</span><br></pre></td></tr></table></figure>
<p><code>git init</code>还有其他的一些可选变体可以使用：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git init</code></td>
<td style="text-align:left">创建新的本地仓库</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --quiet</code><br>or<br><code>git init -q</code></td>
<td style="text-align:left">静默模式，仅输出重要信息，警告和错误。</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --bare</code></td>
<td style="text-align:left">创建一个裸仓库。<br>裸仓库没有工作目录，因此不能在上面进行实际的编辑和修改文件的操作，仅仅是用来存储并共享版本控制的历史记录。</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --template=&lt;template_directory&gt;</code></td>
<td style="text-align:left">给本地仓库指定一个模板</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --separate-git-dir=&lt;git dir&gt;</code></td>
<td style="text-align:left">创建一个包含具体工作目录路径的文本文档</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<p><strong>clone新仓库</strong></p>
<p>或者你也可以从网上拉取一个新仓库下来。  </p>
<ol>
<li>如果你想使用其他人的仓库，你可以直接从代码托管平台上clone一个仓库到你的本地。Github就是全球最大的代码托管平台。  </li>
</ol>
<blockquote>
<p><strong>注意注意↑！</strong><br>如果存在<code>.git</code>路径，那么你的仓库就会被拉取到那里。如果没有，则仓库会被clone到你的当前工作路径。  </p>
</blockquote>
<ol>
<li>输入clone命令即可从网上拉取仓库：  </li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/[YourUsername]/[YourRepository]</span><br><span class="line">Cloning into `Spoon-Knife`...</span><br><span class="line">remote: Counting objects: 10, done.</span><br><span class="line">remote: Compressing objects: 100% (8/8), done.</span><br><span class="line">remove: Total 10 (delta 1), reused 10 (delta 1)</span><br><span class="line">Unpacking objects: 100% (10/10), done.</span><br></pre></td></tr></table></figure>
<p>同样的这里有一些<code>git clone</code>的附加变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git clone --branch &lt;branch_name&gt;</code></td>
<td style="text-align:left">告诉Git你想要拉取的分支是哪一条。有关分支后面再说</td>
</tr>
<tr>
<td style="text-align:center"><code>git clone --bare</code></td>
<td style="text-align:left">将仓库以裸仓库的形式拉取下来</td>
</tr>
<tr>
<td style="text-align:center"><code>git clone --mirror</code></td>
<td style="text-align:left">clone远程存储库的所有扩展引用，并隐式调用 -bare 参数</td>
</tr>
<tr>
<td style="text-align:center"><code>git clone --template=&lt;template_directory&gt; &lt;repo_location&gt;</code></td>
<td style="text-align:left">clone位于<code>&lt;repo location&gt;</code>的仓库，并应用来自<code>&lt;template_directory&gt;</code>的仓库模板</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="查看工作路径"><a href="#查看工作路径" class="headerlink" title="查看工作路径"></a>查看工作路径</h4><p>当你在当前工作路径内工作时，你也可以使用<code>git status</code>命令来查看当前工作目录版本情况的信息：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master </span><br><span class="line"> </span><br><span class="line">No commits yet </span><br><span class="line"> </span><br><span class="line">Untracked files: </span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed) </span><br><span class="line"> </span><br><span class="line">        work.txt </span><br><span class="line"> </span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure>
<p>注意到在Untracked files下存在”work.txt”，这代表这个文本文档被Git可见，但是Git没有开始追踪这个文档的任何更改。解决这个问题我们需要向Git生命暂存更改。  </p>
<p><br></p>
<hr>
<h4 id="暂存更改"><a href="#暂存更改" class="headerlink" title="暂存更改"></a>暂存更改</h4><p>为了让 Git 开始跟踪你在工作目录中所做的更改，你需要先将这些文件添加到暂存区。<br>这可以通过使用命令<code>git add &lt;filename&gt;</code>来完成，其中<code>&lt;filename&gt;</code>是您正在处理的文件的名称，例如我们的”work.txt”文件。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add work.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master </span><br><span class="line"> </span><br><span class="line">No commits yet </span><br><span class="line"> </span><br><span class="line">Changes to be committed: </span><br><span class="line">  (use "git rm --cached &lt;file&gt;..." to unstage) </span><br><span class="line"> </span><br><span class="line">        new file:   work.txt</span><br></pre></td></tr></table></figure>
<p>现在”work.txt”已被加入暂存目录。</p>
<p><br></p>
<p><code>git add</code>的一些额外变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git add .</code></td>
<td style="text-align:left">将当前目录下所有文件添加到暂存区</td>
</tr>
<tr>
<td style="text-align:center"><code>git add -A</code><br>or<br><code>git add --all</code></td>
<td style="text-align:left">查找整个项目中存在的所有新文件或更新文件，并将其添加到暂存区</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="跟踪工作目录中文件变化"><a href="#跟踪工作目录中文件变化" class="headerlink" title="跟踪工作目录中文件变化"></a>跟踪工作目录中文件变化</h4><p>现在我们在”work.txt”新增第三行： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my Git tutorial.</span><br><span class="line">Today we will learn how to get started with Git.</span><br><span class="line">We start with the Basic Git Workflow.</span><br></pre></td></tr></table></figure>
<p>想要查看暂存区和工作目录中同一个文件的区别，我们完全可以使用<code>git diff &lt;filename&gt;</code>命令来查看区别： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff work.txt</span> </span><br><span class="line">diff --git a/work.txt b/work.txt </span><br><span class="line">index 90ac5e6..f0f679f 100644 --- a/work.txt </span><br><span class="line">+++ b/work.txt </span><br><span class="line">@@ -1,2 +1,3 @@ </span><br><span class="line">Welcome to my Git tutorial. </span><br><span class="line">Today we will learn how to get started with Git. </span><br><span class="line">+We start with the Basic Git Workflow.</span><br></pre></td></tr></table></figure>
<p>可以在最后一行看出，Git已经成功登记了文件的更改。如果想要将当前的状态加入暂存，随时可以执行<code>git add work.txt</code>命令。  </p>
<p>下面是一些<code>git diff</code>命令的变体： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git diff --base &lt;filename&gt;</code></td>
<td style="text-align:left">查看与基础文件的冲突</td>
</tr>
<tr>
<td style="text-align:center"><code>git diff &lt;sourcebranch&gt; &lt;targetbranch&gt;</code></td>
<td style="text-align:left">在合并更改之前预览变更</td>
</tr>
</tbody>
</table>
</div>
<p>如果<code>git diff</code>的输出过长，则Git会使用分页器显示内容。在这种情况下我们可以按Q来退出分页器。<br>你也可以在参数中添加<code>--no-pager</code>告诉Git不要使用pager。这个设置对于绝大多数的Git命令都可以使用。  </p>
<p><br></p>
<hr>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>从暂存区存到仓库我们需要使用<code>git commit</code>来提交我们所做的所有更改，建立一个存档。  </p>
<p><code>git commit</code>在使用时需要跟一个参数<code>-m</code>，用来写入你这次更改的内容注释： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">"Added an introduction."</span></span></span><br><span class="line">[master (root-commit) 8327731] Added an introduction. </span><br><span class="line">    Committer: Chan Tai Man &lt;tmchan@academy11.cs.hku.hk&gt; </span><br><span class="line">Your name and email address were configured automatically based </span><br><span class="line">on your username and hostname. Please check that they are accurate. </span><br><span class="line">You can suppress this message by setting them explicitly. Run the </span><br><span class="line">following command and follow the instructions in your editor to edit </span><br><span class="line">your configuration file: </span><br><span class="line"> </span><br><span class="line">    git config --global --edit </span><br><span class="line"> </span><br><span class="line">After doing this, you may fix the identity used for this commit with: </span><br><span class="line"> </span><br><span class="line">    git commit --amend --reset-author </span><br><span class="line"> </span><br><span class="line"> 1 file changed, 3 insertions(+) </span><br><span class="line"> create mode 100644 work.txt</span><br></pre></td></tr></table></figure>
<p>请注意上面有关您的姓名和电子邮件地址配置的消息，实际上你可以按照说明对配置文件进行相应的更改。</p>
<p>始终输入有意义的提交消息，是程序员们的基本操作之一。这对你后期的开发有非常大的帮助，同时对别人也是。  </p>
<p><br></p>
<p>使用<code>git log</code>命令可以查看比较旧版本的项目：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 8327731fa6a9108fb6b54d0b38b9b59c7fbf316c (HEAD -&gt; master) </span><br><span class="line">Author: Chan Tai Man &lt;tmchan@academy11.cs.hku.hk&gt; </span><br><span class="line">Date:   Mon Jan 14 10:38:43 2019 +0800 </span><br><span class="line"> </span><br><span class="line">    Added an introduction.</span><br></pre></td></tr></table></figure>
<p>在每个log中会提供如下四个信息：  </p>
<ul>
<li>40字长的哈希码，我们叫SHA。这是每个commit的唯一识别码 </li>
<li>提交的作者，也就是你自己</li>
<li>提交的时间和日期</li>
<li>提交消息</li>
</ul>
<p><br></p>
<hr>
<h3 id="与他人合作"><a href="#与他人合作" class="headerlink" title="与他人合作"></a>与他人合作</h3><h4 id="使用分支系统"><a href="#使用分支系统" class="headerlink" title="使用分支系统"></a>使用分支系统</h4><p>分支可以看作是指向 Git 存储库中最新提交的指针。<br>当我们初始化存储库时，我们正在处理一个称为<code>master</code>分支的单个分支。我们正在处理的提交称为<code>HEAD</code>，通常是分支的最新提交。  </p>
<p>你可以在某个commit节点创建一个分支。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBed6b622ab401c9305753c7e2623a767f?method=download&amp;shareKey=b90b1091d05ac2a4898119d43ae308e9" alt=""></p>
<p>可以看一下上面这张图。这是一个正在开发的项目的Git图表。每一条线代表一个分支，每一个点代表一个commit。  </p>
<p>可以看到橙色的那条线从粉红色分支的一个commit拉出，经过一系列的更改，最后在上面的一个commit合并到粉红色分支。这两个粉红色commit之间区别在于并入了整个橙色分支的内容。  </p>
<p>要在当前commit拉出一个分支，可以使用<code>git branch BugFix</code>命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch BugFix</span></span><br></pre></td></tr></table></figure>
<p>拉出分支成功后当前工作分支还是在<code>master</code>上。切换到刚拉出来的<code>BugFix</code>分支我们需要：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix</span></span><br><span class="line">Switched to branch 'BugFix'</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>我们也可以使用<code>checkout</code>命令将 HEAD 移至上一个提交。<br>如果这样做，我们也会恢复此提交中文件的状态。例如，我们可以移动到提交 BugFix^，这是分支 BugFix 中的上一个提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix^</span></span><br><span class="line">Note: checking out 'BugFix^'.</span><br><span class="line"></span><br><span class="line">You are in 'detached HEAD' state. You can look around, make experimental </span><br><span class="line">changes and commit them, and you can discard any commits you make in this </span><br><span class="line">state without impacting any branches by performing another checkout. </span><br><span class="line"> </span><br><span class="line">If you want to create a new branch to retain commits you create, you may </span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example: </span><br><span class="line"> </span><br><span class="line">  git checkout -b &lt;new-branch-name&gt; </span><br><span class="line"> </span><br><span class="line">HEAD is now at 8327731 Added an introduction.</span><br></pre></td></tr></table></figure>
<p>想要移动一个特定的分支，那就用<code>git log</code>吧。  </p>
<p>下面是一些用于分支的可用命令：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git branch</code></td>
<td style="text-align:center">列出所有分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch branchname</code></td>
<td style="text-align:center">创建一个分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git checkout branchname</code></td>
<td style="text-align:center">切换到分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git checkout -b branchname</code></td>
<td style="text-align:center">创建并切换到分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -m branchname new_branchname</code></td>
<td style="text-align:center">重命名分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch --merged</code></td>
<td style="text-align:center">显示所有与当前分支合并过的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -d branchname</code></td>
<td style="text-align:center">删除合并完成的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -D branch_to_delete</code></td>
<td style="text-align:center">删除未合并的分支</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>用刚才的那张图做例子，橙色分支最后并入到了粉红色分支上，并入操作我们叫做(merge).  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">"This is some new file in master."</span> &gt; master.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add master.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">"Added master.txt"</span></span></span><br><span class="line">[master 832ceba] Added master.txt </span><br><span class="line"> 1 file changed, 1 insertions(+) </span><br><span class="line"> create mode 100644 master.txt</span><br></pre></td></tr></table></figure>
<p>接下来我们在BugFix分支上也添加一个新文件：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix</span></span><br><span class="line">Switched to branch 'BugFix'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">"This is some new file in BugFix"</span> &gt; bugfix.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add bugfix.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">"Added bugfix.txt"</span></span></span><br><span class="line">[BugFix ed600da] Added bugfix.txt </span><br><span class="line"> 1 file changed, 1 insertions(+) </span><br><span class="line"> create mode 100644 bugfix.txt</span><br></pre></td></tr></table></figure>
<p>我们可以选择向<code>BugFix</code>分支并入<code>master</code>，也可以向<code>master</code>并入<code>BugFix</code>。但是我们可以选择前者，因为这样我们就可以在不干扰<code>master</code>分支的前提下验证bug修复是否有用。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix</span></span><br><span class="line">Already on 'BugFix'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge master -m <span class="string">"Apply changes in master"</span></span></span><br><span class="line">Merge made by the 'recursive' strategy. </span><br><span class="line"> master.txt | 1 + </span><br><span class="line"> 1 file changed, 1 insertion(+) </span><br><span class="line"> create mode 100644 master.txt </span><br></pre></td></tr></table></figure>
<p>如果在<code>master</code>分支下出现了会影响到<code>BugFix</code>的更改，则会出现文件冲突。这时Git就会提示你解决冲突。  </p>
<p>现在假设我们发现修复没啥问题可以直接并入<code>master</code>，则我们可以直接快进并入，叫做”fast foward”。<br>这一步不会创建任何commit。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge BugFix</span></span><br><span class="line">Fast-forward</span><br><span class="line"> bugfix.txt | 1 + </span><br><span class="line"> 1 file changed, 1 insertion(+) </span><br><span class="line"> create mode 100644 bugfix.txt </span><br></pre></td></tr></table></figure>
<p>下面是一些<code>merge</code>命令的变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git merge branchname</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git merge --ff-only branchname</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git merge --no-ff branchname</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git merge --abort</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git cherry-pick 073791e7</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="在远程仓库上工作"><a href="#在远程仓库上工作" class="headerlink" title="在远程仓库上工作"></a>在远程仓库上工作</h4><p>目前为止我们只在本地仓库上作法。 如果你想要加入任何在线的Git项目，你需要去了解如何管理远程仓库。  </p>
<p>使用<code>git remote</code>命令来查看目前所有的远程仓库，<code>git remote -v</code>命令允许你去查看这些远程仓库的URL：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into 'ticgit'...</span><br><span class="line">remote: Enumerating objects: 1857, done. </span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857 </span><br><span class="line">Receiving objects: 100% (1857/1857), 334.04 KiB | 395.00 KiB/s, done. </span><br><span class="line">Resolving deltas: 100% (837/837), done. </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span> </span><br><span class="line">origin </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span> </span><br><span class="line">origin  https://github.com/schacon/ticgit (fetch) </span><br><span class="line">origin  https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>想要添加远程仓库，你可以使用<code>git remote add &lt;shortname&gt; &lt;URL&gt;</code>命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span> </span><br><span class="line">origin </span><br><span class="line">pb</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>或者如果你想查看一个远程仓库的信息，就使用<code>git remote show &lt;remote&gt;</code>：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span> </span><br><span class="line">* remote origin </span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit </span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit </span><br><span class="line">  HEAD branch: master </span><br><span class="line">  Remote branches: </span><br><span class="line">    master tracked </span><br><span class="line">    ticgit tracked </span><br><span class="line">  Local branch configured for 'git pull': </span><br><span class="line">    master merges with remote master </span><br><span class="line">  Local ref configured for 'git push': </span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>
<p>下面有一些有关远程仓库的命令和变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git remote</code></td>
<td style="text-align:center">查看远程仓库配置</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote -v</code></td>
<td style="text-align:center">带着URL查看远程仓库配置</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote add &lt;shortname&gt; &lt;URL&gt;</code></td>
<td style="text-align:center">添加远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote rm &lt;shortname&gt;</code></td>
<td style="text-align:center">删除在本地记录的远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote rename &lt;old-name&gt; &lt;new-name&gt;</code></td>
<td style="text-align:center">重命名在本地记录的远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch --merged</code></td>
<td style="text-align:center">显示所有与当前分支合并过的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -d branchname</code></td>
<td style="text-align:center">删除合并完成的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -D branch_to_delete</code></td>
<td style="text-align:center">删除未合并的分支</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你在本地对远程仓库做出了更改，并且想要远程仓库同步你本地的版本，就可以使用<code>git push</code>将本地的代码推送到远程仓库。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>
<p>此命令仅在您从具有写入权限的服务器克隆且在此期间无人推送时才有效。<br>如果你和其他人同时克隆，并且他们推送上游，然后您推送上游，您的推送将被拒绝。<br>这种情况下必须先获取他们的工作并将其合并到当前版本的工作中，然后才允许推送。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; &lt;branch&gt;</code></td>
<td style="text-align:center">将某个特定分支推送同步到远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; --force</code></td>
<td style="text-align:center">和上面一样，但是本命令会强制将本地推送到远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; -all</code></td>
<td style="text-align:center">将本地所有分支推送同步到远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; --tags</code></td>
<td style="text-align:center">将所有的本地标签推送到远程仓库</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="从远程仓库拉取"><a href="#从远程仓库拉取" class="headerlink" title="从远程仓库拉取"></a>从远程仓库拉取</h4><p>有点像是下载，也可以算是同步。本命令基本上用来以远程仓库为基准，更新本地仓库。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git pull &lt;remote&gt;</code></td>
<td style="text-align:center">将远程仓库的内容同步到本地仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git pull --no-commit &lt;remote&gt;</code></td>
<td style="text-align:center">从远程仓库拉取，但是不在本地创建提交</td>
</tr>
<tr>
<td style="text-align:left"><code>git pull --verbose</code></td>
<td style="text-align:center">从远程仓库拉取时返回verbose内容</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h1 id="Module-3-C-Basics"><a href="#Module-3-C-Basics" class="headerlink" title="Module 3: C++ Basics"></a>Module 3: C++ Basics</h1><p>在这门课中我们要接触一门全新的语言：C++。  </p>
<p>我不想过多介绍有关环境配置和其他的内容，一方面是ENGG1340已经为我们提供了可以直接使用的Linux环境，内置gcc，而在Windows系统上的C++环境配置也不复杂。有需要的自己上网一搜就行。</p>
<p>东西挺多所以我决定每一部分写的少一点，尽可能概括到所有需要掌握的知识点。 </p>
<p><br></p>
<hr>
<h2 id="C-基本语法和程序结构"><a href="#C-基本语法和程序结构" class="headerlink" title="C++基本语法和程序结构"></a>C++基本语法和程序结构</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>我们先从最简单的开始说起吧：  </p>
<p>在程序中插入一段注释，只需要使用双斜杠<code>//</code>就可以达到你的目的：  </p>
<p>例如在下面的程序中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段注释</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello, World!"</span>; <span class="comment">//这行用来输出文本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>注释行在进行编译的时候，会被编译器忽略。大胆地在程序里写下你的注释吧，你也不希望回头看不懂你自己写的程序吧。  </p>
<p><br></p>
<hr>
<h3 id="头文件引用"><a href="#头文件引用" class="headerlink" title="头文件引用"></a>头文件引用</h3><p>在上面的程序中，你会发现第一行是一个由井号开头，看起来和程序没有任何关系的一行。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这一行实际上引用了我们要在程序中使用到的头文件。你可以类比为我们要使用到一个叫做<code>iostream</code>的工具箱。  </p>
<p><code>#include</code>指令在这里用来将预先编写的代码（库）引入到程序中，这些库包含我们可以使用的有用函数和工具。  </p>
<p>至于后面的<code>&lt;iostream&gt;</code>，是一个处理输入和输出的标准 C++ 库。这个库为我们提供了在屏幕上显示内容（输出）和从用户那里获取信息（输入）的工具。<br>具体来说，它为我们提供了 <code>cout</code>命令。  </p>
<p>也就是说如果我们移除程序中的这一行，程序就不知道<code>cout</code>是什么东西了。</p>
<p>怎么提供呢？实际上方法非常暴力：编译器在将要编译文件时，会找到你引用的这些头文件，然后将其粘贴到文件的开头…</p>
<hr>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h3><p><code>main</code>函数是任何C++程序的切入点 (Starting Point)。大概的意思是，编译器在编译该文件时，会默认从main开始往下读。  </p>
<p><code>main</code>函数的结构可以像是是这样：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 我们想要写的任何code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int main()</code>定义了主函数。<code>int</code>的意思代表该函数会返回一个整型值。  </li>
<li><code>{  }</code>这个花括号是主函数的主体 (Body)。 我们在主函数的主题内写到的任何命令，就在主函数要执行的范畴之内。</li>
<li><code>return 0;</code>这一行一般代表我们的程序已经执行完毕。在C++中，在这种情况下返回<code>0</code>是一个约定。</li>
</ul>
<p><br></p>
<hr>
<p>现在你知道了这些内容，我们再回头解答一下一开始写的那个程序干了什么： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{ <span class="comment">// 主函数从这里开始</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Hello, World!"</span>; <span class="comment">// 你写的code</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序在这里成功执行完毕</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>冷知识，如果你把你的主函数写成这样： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 啥也不写</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>程序不会报错，只是主函数刚开始执行就结束了。类似于你定义了一个新房子，但是房子里面什么也没有（  </p>
<p><br></p>
<hr>
<h3 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h3><p>实际上刚才已经接触过一点点了，这里我们系统性讲解一下：  </p>
<p><strong><code>cout</code>（输出）</strong></p>
<p>类似控制台输出。用来将内容输出到控制台的屏幕上：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">"Hello!"</span>;  <span class="comment">// 在屏幕上输出"Hello!"</span></span><br><span class="line">std::cout &lt;&lt; <span class="number">123</span>;       <span class="comment">// 输出数字 123</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; <span class="number">42</span>; <span class="comment">// 输出 "The answer is: 42"</span></span><br></pre></td></tr></table></figure>
<p>我们涉及到了左移<code>&lt;&lt;</code>运算符。把它类比于插入操作就行。</p>
<p>同样的有输出就少不了输入：  </p>
<p><strong><code>cin</code> (输入)</strong></p>
<p>这边就类比于控制台输入了。语句会读取用户在控制台输入的内容：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Please enter your age: "</span>;</span><br><span class="line">std::cin &gt;&gt; age; <span class="comment">// 等待用户输入内容后按下回车</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">"You are "</span> &lt;&lt; age &lt;&lt; <span class="string">" years old."</span>;</span><br></pre></td></tr></table></figure>
<p>上面是一个非常简单的小程序，首先输出文字提示用户输入内容，然后读取用户输入的内容到变量age中，最后输出。  </p>
<p>同样涉及到了右移<code>&gt;&gt;</code>运算符。与左移相反，把这类比于提取操作就ok。  </p>
<hr>
<p><em>有关命名空间</em></p>
<p>Namespace，或者叫命名空间，在上面的程序中使用<code>std::</code>进行表示。<br>现在我们先不过多讨论这一部分，而是先记住在<code>cin</code>和<code>cout</code>之前，带着<code>std::</code>命名空间声明就好。</p>
<p><br></p>
<hr>
<p>下面是一个用到上述所有内容，编写的一个简单的问好小程序：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string name; <span class="comment">// 定义一个叫做"name"的变量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Please enter your name: "</span>;</span><br><span class="line">    std::cin &gt;&gt; name; <span class="comment">// 读取用户输入，存储到name中</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span>; <span class="comment">// 输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在你可以试试编译这个程序并运行。程序会首先输出”Please enter your name: “。输入任何文本后回车，程序会输出一段向你问好的语句。  </p>
<p><code>std::string name</code>定义了一个类型为<code>string</code>的变量。有关变量的内容马上就来。  </p>
<p><br></p>
<hr>
<h3 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h3><p>正如你所想的那样，变量就像是一个容器，可以用来存储信息。而数据类型则是定义了一个容器会存储什么样的信息。  </p>
<p>每一个变量都会有一个名称，这个名称是你作为用户定义的。同时你也必须要声明该变量的数据类型。  </p>
<p>数据类型用来声明该变量存储了了什么类型的数据。下面是一些常见的数据类型： </p>
<ul>
<li><strong><code>int</code> (整数)</strong>：顾名思义，用来存储整数。例如”-1”, “0”, “5”, “100”</li>
<li><strong><code>double</code> (浮点数)</strong>：浮点数基本上可以被理解为带小数点的数字。</li>
<li><strong><code>char</code> (字符)</strong>：用来存储单个字符。字母，数字符号什么的都可以。例如’a’, ‘B’等等。<u>单个字符会被引用在单引号<code>''</code>中，而并非双引号。</u></li>
<li><strong><code>bool</code> (布尔值)</strong>：存储两个状态：True 和 False。</li>
<li><strong><code>string</code> (字符串)</strong>：用来存储字符序列。比如一个单词或一个句子。例如”Hello”或者”C++”。<u>与字符不同点在于，字符串会被引用在双引号中。</u><br>  格外注意，如果我们想要使用字符串，一定要记得引用头文件<code>#include &lt;string&gt;</code>！  </li>
</ul>
<p><br></p>
<hr>
<p>在C++中定义变量挺简单的说是：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">double</span> price;</span><br><span class="line"><span class="type">char</span> initial;</span><br><span class="line"><span class="type">bool</span> isRaining;</span><br><span class="line">std::string name;</span><br></pre></td></tr></table></figure>
<p>先写要定义的数据类型，随后声明你想要的变量名。  </p>
<p>变量名有以下命名规则：  </p>
<ul>
<li>变量名的第一个字符必须是<strong>字母或下划线</strong>。</li>
<li>变量名只能包含三种字符：<strong>大小写字母</strong>，<strong>数字</strong>和<strong>下划线</strong>。  </li>
<li>不能与C++预留名称冲突。差不多是不能与C++声明过的变量重名。  </li>
</ul>
<p>同时注意，变量名<strong>区分大小写</strong>，所以<code>radius</code>和<code>Radius</code>, <code>RADIUS</code>是三个不同的变量。  </p>
<p><br></p>
<hr>
<p>如何为变量赋值？我们可以选择在定义变量的同时为它们声明一个初始值：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="type">double</span> price = <span class="number">19.99</span>;</span><br><span class="line"><span class="type">char</span> initial = <span class="string">'D'</span>;</span><br><span class="line"><span class="type">bool</span> isRaining = <span class="literal">false</span>;</span><br><span class="line">std::string name = <span class="string">"Alice"</span>;</span><br></pre></td></tr></table></figure>
<p>或者也可以直接调用变量名，然后为其赋值：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">30</span>;</span><br><span class="line">price = <span class="number">19.9</span></span><br><span class="line">initial = <span class="string">'D'</span>;</span><br><span class="line">isRaining = <span class="literal">false</span>;</span><br><span class="line">name = <span class="string">"Alice"</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>差不多理解了？下面是一个包含我们介绍过的数据类型的小程序。试试看能不能读懂是什么意思：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> numberOfStudents = <span class="number">25</span>;</span><br><span class="line">    <span class="type">double</span> averageGrade = <span class="number">85.5</span>;</span><br><span class="line">    <span class="type">char</span> gradeLetter = <span class="string">'B'</span>;</span><br><span class="line">    <span class="type">bool</span> isPass = <span class="literal">true</span>;</span><br><span class="line">    std::string courseName = <span class="string">"Introduction to C++"</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Course: "</span> &lt;&lt; courseName &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Number of students: "</span> &lt;&lt; numberOfStudents &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Average grade: "</span> &lt;&lt; averageGrade &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Grade letter: "</span> &lt;&lt; gradeLetter &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Pass status: "</span> &lt;&lt; (isPass ? <span class="string">"Pass"</span> : <span class="string">"Fail"</span>) &lt;&lt; std::endl; <span class="comment">// 逻辑判断</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>std::endl</code>是”end line”的意思。这个命令会让光标移动到下一行。<br><code>?</code>运算符大概能这样理解：<code>(condition ? value_if_true : value_if_false)</code>，用来直接快速运行单个判断。</p>
<p><br></p>
<hr>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>除了定义一个变量，你也可以定义一个常量。<br>有时我们需要一个在程序中永远也不会，同时也不应该会改变的值。这就是常量的作用所在。  </p>
<p>常量类似于一个变量，但是常量的值<strong>一旦定义无法更改</strong>。这是一个固定值。  </p>
<p>你可以使用这样的方式声明一个常量：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DAYS_IN_WEEK = <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> YES_CHAR = <span class="string">'Y'</span>;</span><br><span class="line"><span class="type">const</span> std::string GREETING_MESSAGE = <span class="string">"Welcome!"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const</code>:  这个关键字告诉编译器“这是一个常量，它的值不应该被改变”。</li>
<li>变量名 (例如<code>DAYS_IN_WEEK</code>, <code>PI</code>): 为常量命名，我们通常用大写字母并用下划线分隔单词，以便于识别它们是常量。这是一个约定。</li>
<li>值 (例如后面的<code>7</code>, <code>3.14159</code>): 注意<strong>定义常量时必须同时为它定义一个初始值</strong>。</li>
</ul>
<p><br></p>
<hr>
<blockquote>
<p><em>但是我在Python编程中没有什么常量的概念啊？！</em></p>
</blockquote>
<p>在程序中使用<code>const</code>，有助于我们编写更安全，更有效的代码，同时也增加了代码的可读性。将一个变量声明为<code>const</code>，基本上就告诉编译器，这个变量是不可改的。<br>如果编译器在后期发现有语句尝试更改该值，则会返回错误。这避免了有时意外更改某些值的危险情况。  </p>
<p>至于为什么Python没有开箱即用的常量概念，有一部分的原因为Python设计之初是一个动态类型的解释型语言。变量类型在运行时的时候才会进行检查，并调用解释器逐行执行代码。<br>相比C++，Python更强调程序的自由和灵活性。但不代表我们无法在Python中使用常量，相反我们一般使用“惯例和约定”。<br>在Python中，我们一般也全部使用全部大写的变量名来声明常量，与C++一样。不过区别在于，没有什么会阻止我们更改这个变量的值——这仅仅是一个约定罢了（  </p>
<p><br></p>
<hr>
<p>老规矩我们直接上例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>; <span class="comment">// 将pi声明为常量...</span></span><br><span class="line">  <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Enter the radius of the circle: "</span>;</span><br><span class="line">  std::cin &gt;&gt; radius;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> circumference = <span class="number">2</span> * PI * radius; <span class="comment">// ...然后调用pi</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; circumference &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>还记得我刚才说过的，更改常量的值可能会报错嘛：  </p>
<p>如果你将程序改成这样，在声明<code>PI</code>之后尝试更改<code>PI</code>的值：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">  <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Enter the radius of the circle: "</span>;</span><br><span class="line">  std::cin &gt;&gt; radius;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> circumference = <span class="number">2</span> * PI * radius;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change the value of PI and see what will happen</span></span><br><span class="line">  PI = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"The circumference is: "</span> &lt;&lt; circumference &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>试着运行一下，按理讲程序会报错。<br>这就是使用常量的好处了。能够有效保证某些定义好的量不被意外更改。  </p>
<p><br></p>
<hr>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>C++里有不少运算符。一个一个看吧：  </p>
<h4 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h4><p>数学运算符顾名思义，我觉得是数学运算符：看起来像数学运算符，用起来也是数学运算符。</p>
<ul>
<li><strong><code>+</code>：加法</strong></li>
<li><strong><code>-</code>：减法</strong></li>
<li><strong><code>*</code>：乘法</strong></li>
<li><strong><code>/</code>：除法</strong><ul>
<li><em>注意！</em>：<strong>如果你将两个整数相除，结果则依然会是整数</strong>，小数部分会被截取。举个例子：<br><code>5 / 2</code>的结果是<code>2</code>，而不是<code>2.5</code>。如果我们想要输出小数，可以考虑使用两个浮点数做运算。例如<code>5.0 / 2.0</code>，输出为<code>2.5</code>。  </li>
</ul>
</li>
<li><strong><code>%</code>：取模</strong></li>
</ul>
<p><br></p>
<hr>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符会比较两个传入值，随后输出布尔类型的值，也就是<code>true</code>或者<code>false</code>：  </p>
<ul>
<li><strong><code>==</code>：等于</strong>。用于检验两个值是否相等</li>
<li><strong><code>!=</code>：不等于</strong></li>
<li><strong><code>&lt;</code>：小于</strong></li>
<li><strong><code>&gt;</code>: 大于</strong></li>
<li><strong><code>&lt;=</code>：小于等于</strong></li>
<li><strong><code>&gt;=</code>：大于等于</strong></li>
</ul>
<p><br></p>
<hr>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>这里牵扯到逻辑运算，与，或，非那堆东西：</p>
<ul>
<li><strong><code>&amp;&amp;</code>：与运算</strong>。如果两个传入值都是<code>true</code>，则返回<code>true</code>。</li>
<li><strong><code>||</code>：或运算</strong>。如果两个传入值存在<code>true</code>，则返回<code>true</code>。</li>
<li><strong><code>!</code>：非运算</strong>。输出相反的<code>true</code>和<code>false</code>结果。</li>
</ul>
<p><br></p>
<hr>
<p>搞不懂的话试试运行这个程序吧：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Arithmetic Operators:"</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" + "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; (num1 + num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" - "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; (num1 - num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" * "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; (num1 * num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" / "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; (num1 / num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" % "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; (num1 % num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Comparison Operators:"</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" == "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; (num1 == num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" != "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; (num1 != num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" &lt; "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; (num1 &lt; num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" &gt; "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; (num1 &gt; num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" &lt;= "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; (num1 &lt;= num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; num1 &lt;&lt; <span class="string">" &gt;= "</span> &lt;&lt; num2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; (num1 &gt;= num2) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Logical Operators:"</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">bool</span> isTrue = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">bool</span> isFalse = <span class="literal">false</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"true &amp;&amp; false is "</span> &lt;&lt; (isTrue &amp;&amp; isFalse) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"true || false is "</span> &lt;&lt; (isTrue || isFalse) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"!true is "</span> &lt;&lt; (!isTrue) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h4><p>顺序如下：</p>
<ol>
<li><strong><code>()</code></strong>：与数学一样，我们首先计算括号。</li>
<li><strong><code>!</code></strong>：非运算</li>
<li><strong><code>*, /, %</code></strong>：乘除和取模运算</li>
<li><strong><code>+， -</code></strong>：加减运算</li>
<li><strong><code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code></strong>：比较运算符</li>
<li><strong><code>&amp;&amp;</code></strong>：与运算</li>
<li><strong><code>||</code></strong>：或运算</li>
<li><strong><code>=</code></strong>：赋值符。(<em>顺序为从右往左。赋值语句我们之后再说</em>)</li>
</ol>
<p><br></p>
<hr>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>有时我们想要将一个数据类型转换到另一种数据类型。C++为我们提供了两种转换方式，分别为<strong>隐式转换 (Implicit conversion)</strong>和<strong>显式转换 (Explicit conversion)</strong>。  </p>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>当我们使用隐式转换时，C++则会自动将你的值从一种类型转换到另一种类型。通常我们想要将“较小”的数据类型转换到“较大”的数据类型时，并没有数据损失时，会使用隐式转换：  </p>
<p>比如我们想要将<code>int</code>转换到<code>double</code>：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> integerValue = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> doubleValue = integerValue; <span class="comment">// 在这里应用了隐式转换</span></span><br><span class="line">std::cout &lt;&lt; doubleValue &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>看第二行，C++自动将整数<code>10</code>转换到了double<code>10.0</code>。这个值被赋予给了<code>doubleValue</code>变量。<br>这里使用隐式转换是安全的，因为这里实际上没有牵扯任何数据损失。  </p>
<p><br></p>
<p>再举个例子吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intResult;</span><br><span class="line"><span class="type">double</span> doubleValue1 = <span class="number">5.5</span>;</span><br><span class="line"><span class="type">int</span> intValue2 = <span class="number">3</span>;</span><br><span class="line">intResult = doubleValue1 + intValue2; <span class="comment">// double向int的隐式转换么，我看不太行</span></span><br><span class="line"><span class="type">double</span> doubleResult = doubleValue1 + intValue2; <span class="comment">// 但是我们可以从int隐式转换到double</span></span><br><span class="line">std::cout &lt;&lt; doubleResult &lt;&lt; std::endl; <span class="comment">// 输出为 8.5</span></span><br><span class="line">std::cout &lt;&lt; intResult &lt;&lt; std::endl; <span class="comment">// 会出错，因为你无法将double值赋予到int变量中...</span></span><br></pre></td></tr></table></figure>
<p>在 <code>doubleResult = doubleValue1 + intValue2;</code> 中，intValue2 在加法之前被隐式转换为 double，因此结果为 double。<br>但是，如果不进行显式转换，则不能直接将 double 赋值给 intResult，因为这会丢失小数部分。</p>
<p>再看一下<code>intResult</code>。这一行会在编译时出现问题，因为如果尝试将 double 结果分配给 int 变量而没有进行显式转换，C++ 会将其捕获为编译时错误。</p>
<p>一会我们来探讨什么叫显式转换。</p>
<p><br></p>
<hr>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>当您想要强制转换数据类型，或者当 C++ 不会隐式执行转换时（<em>例如，从“较大”类型转换为“较小”类型，这可能会丢失信息</em>），我们则需要使用显式类型转换，也称为”Type Casting”。  </p>
<p>我们可以选择使用比较经典的，C语言样式的显式转换：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> price = <span class="number">29.99</span>;</span><br><span class="line"><span class="type">int</span> integerPrice = (<span class="type">int</span>)price <span class="comment">// 使用C语言样式显式转换double到int</span></span><br><span class="line">std::cout &lt;&lt; integerPrice &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>或者我们也可以使用比较现代的C++样式进行显式转换。理论来讲这种方式会更加安全，也看起来更干净：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> price = <span class="number">29.99</span>;</span><br><span class="line"><span class="type">int</span> integerPrice = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(price); <span class="comment">// 使用static_cast显式转换double到int</span></span><br><span class="line">std::cout &lt;&lt; integerPrice &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>两种方法都会输出<code>29</code>。因为我们从“较大”的数据类型通过显式转换变成了“较小”的数据类型，所以你可以发现小数部分被整个切掉了。  </p>
<p><br></p>
<p>也可以通过显式转换将<code>char</code>转换到<code>int</code>：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> myChar = <span class="string">'A'</span>;</span><br><span class="line"><span class="type">int</span> asciiValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(myChar);</span><br><span class="line"><span class="type">char</span> backToChar = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(<span class="number">65</span>); <span class="comment">// 'A'的ASCII值是65</span></span><br><span class="line">std::cout&lt;&lt; <span class="string">"ASCII value of "</span> &lt;&lt; myChar &lt;&lt; <span class="string">" is "</span> &lt;&lt; asciiValue &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Character for ASCII 65 is "</span> &lt;&lt; backToChar &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>为你提供示例小程序，看懂了就基本上代表你这块直接毕业了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> integerNumber = <span class="number">15</span>;</span><br><span class="line">  <span class="type">double</span> doubleNumber = <span class="number">7.8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> implicitConversion = integerNumber; <span class="comment">// 隐式转换，int → double</span></span><br><span class="line">  <span class="type">int</span> explicitConversion = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(doubleNumber); <span class="comment">// 显式转换，double → int</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Original integer: "</span> &lt;&lt; integerNumber &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Implicitly converted to double: "</span> &lt;&lt; implicitConversion &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Original double: "</span> &lt;&lt; doubleNumber &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Explicitly converted to int: "</span> &lt;&lt; explicitConversion &lt;&lt; std::endl; <span class="comment">// 注意小数位的数据丢失</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> characterA = <span class="string">'A'</span>;</span><br><span class="line">  <span class="type">int</span> asciiValueOfA = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(characterA); <span class="comment">// char → int</span></span><br><span class="line">  <span class="type">char</span> charFromAscii = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(<span class="number">66</span>);       <span class="comment">// int → char (ASCII码 66 对应 'B')</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Character: "</span> &lt;&lt; characterA &lt;&lt; <span class="string">", ASCII value: "</span> &lt;&lt; asciiValueOfA &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"ASCII value: 66, Character: "</span> &lt;&lt; charFromAscii &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="程序编译与运行"><a href="#程序编译与运行" class="headerlink" title="程序编译与运行"></a>程序编译与运行</h2><p>首先我假设你应该会点Python，因为这是修1340之前的必修课（差不多吧）。即使你没学过Python，那如果你是来自西恩大陆，中学期间的计算机课也给你介绍过一些常见Python用法了。  </p>
<p>C++需要编译器来编译程序，然后处理器才能运行你的C++程序。如果你之前用过Python，你大概对编译器这个概念很陌生。反倒可能听说过解释器这么个东西。  </p>
<p>与Python不同，<strong>C++是一种编译语言</strong>。你的处理器无法直接理解C++代码，但是处理器可以理解机器码，这是一种由 0 和 1 组成的非常低级的语言。<br>编译器充当“翻译官”的角色。它将人类可读的C++代码转换为计算机可以直接执行的机器代码。这样你的处理器就能运行了。</p>
<p>而<strong>Python是一种解释语言</strong>，靠的是解释器。当你运行Python程序时，解释器会逐行读取 Python 代码并直接执行。<br>通常不需要担心将代码编译为机器代码的单独步骤 <em>（尽管 Python 确实会进行一些后台编译以转换为字节码，但这与 C++ 编译有本质上的不同）</em>。  </p>
<p><br></p>
<p>编译程序带来的好处很明显。通常编译程序比解释程序的运行速度快的多，因为编译器只需要编译一次，把你的代码转换成机器码就ok。通常这样生成的机器码经过高度优化，所以处理器可以直接快速执行。这就是为什么C++经常被用来编写对性能要求较高的程序，比如游戏开发，操作系统等。  </p>
<p>另一个好处是编译可以产生一个独立的可执行文件。比如在Windows上的exe文件。我们可以无需编译器，也无需源代码，来直接运行程序。比较利于程序的分发。  </p>
<p><br></p>
<hr>
<h3 id="g-编译器"><a href="#g-编译器" class="headerlink" title="g++编译器"></a>g++编译器</h3><p>简单过一下如何在Linux环境下编译C++源代码：</p>
<ol>
<li><p>定位工作目录和文件，首先你需要找到你要编译的C++源代码。</p>
</li>
<li><p>在命令行中运行：  </p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ my_program.cpp -o my_program</span><br></pre></td></tr></table></figure>
<p>使用<code>g++</code>调用g++编译器，<code>my_program.cpp</code>是你要编译的源文件。<br><code>-o</code>这个flag允许你在下一个参数定义编译输出文件的文件名。在这个例子中名字就是<code>my_program</code>。  </p>
<ol>
<li>最后运行。定位到文件当前的目录后直接输入下面的命令即可运行：  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_program</span><br></pre></td></tr></table></figure>
<p>注意不是<code>my_program.cpp</code>，这是你的源代码，不是编译后的程序。  </p>
<p><br></p>
<hr>
<h3 id="阅读错误信息"><a href="#阅读错误信息" class="headerlink" title="阅读错误信息"></a>阅读错误信息</h3><p>很多小白当运行程序时，或者编译程序时碰到了问题，爆了一堆错误信息，他们一般选择看都不看。  </p>
<p>孩子们这不对，这些文字中会包含非常有用的信息。  </p>
<p>如果你的程序编译失败了，那么就会返回编译错误。语法错误，变量类型错误，引用错误等等都可能会导致编译失败，进而出现错误信息：</p>
<p>比如下面的这个情况是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; std::endl  <span class="comment">// 这里末尾没带分号</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>相似的程序会爆这样的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello.cpp: In function 'int main()':</span><br><span class="line">hello.cpp:5:5: error: expected ';' before 'return'</span><br><span class="line">     return 0</span><br><span class="line">     ^~~~~~</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>
<p><code>expected ';' before return</code>，错误理由已经写在这里了，我们忘了插入分号了。</p>
<p>哦对了在C++中编写程序记得在每行末尾带引号。  </p>
<p><br></p>
<p>或者这种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  std::string message = <span class="string">"Hello"</span>;</span><br><span class="line">  <span class="type">int</span> number = <span class="number">123</span>;</span><br><span class="line">  std::string combined = message + number; <span class="comment">// 数据类型错误！</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; combined &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>相似的程序会爆这样的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type_error.cpp: In function 'int main()':</span><br><span class="line">type_error.cpp:6:14: error: invalid operands of types 'std::string' and 'int' to binary 'operator+'</span><br><span class="line"> std::string message = "Hello" + 123;</span><br><span class="line">                     ^~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>属于当时我们提到的数据类型错误。我们没有进行显示转换，就尝试使用<code>+</code>运算符把<code>std::string</code>类型的变量和<code>int</code>加在一起。这是不能被实现的。  </p>
<p>还有一种引用错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  value = <span class="number">10</span>; <span class="comment">// value 在被使用之前没有被声明</span></span><br><span class="line">  std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>相似的程序会爆这样的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declaration_error.cpp: In function 'int main()':</span><br><span class="line">declaration_error.cpp:5:5: error: 'undeclaredVariable' was not declared in this scope</span><br><span class="line"> undeclaredVariable = 10;</span><br><span class="line"> ^~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>这里的问题是编译器根本找不到<code>undeclaredVariable</code>是什么玩意。用变量之前记得先声明！</p>
<p><br></p>
<hr>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>控制流 (Control Flow)，简而言之就是决定某些指令何时执行，按何种顺序执行的一种概念。<br>目前为止我们写过的程序都是线性的，只会按照从上到下一种方向执行。我们可以引入控制流，让我们的程序更灵活，更强大。  </p>
<p>我打算介绍下面两种主要的控制流类别：</p>
<ul>
<li><strong>分支 (Branching)</strong>：涉及在程序中做出决策。<br>人话讲：“如果此条件为真，则执行这组指令；否则，执行其他操作（或者什么也不做）”。<br>我们将介绍 <code>if</code>、<code>if-else</code> 和 <code>switch</code> 语句。</li>
</ul>
<ul>
<li><strong>循环 (Looping)</strong>：也叫做迭代，涉及多次重复代码块。<br>人话为：“只要此条件为真，就继续执行这组指令”，或者：“执行这组指令一定次数”。<br>这里我们介绍 <code>while</code>和 <code>for</code> 循环。我们还将介绍可以修改循环行为的 <code>break</code> 和 <code>continue</code> 语句。</li>
</ul>
<p>除了这两类，我们还会介绍一些会用在控制流中的其他语句。</p>
<p><br></p>
<hr>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h4><p>最基础的分支语句差不多是<code>if</code>语句了。<code>if</code>语句允许你在某个条件通过的情况下执行特定代码块。  </p>
<p>我们一般使用<code>if</code>语句检查一个条件。如果条件通过，则执行与<code>if</code>语句相关的代码块；如果没有通过则直接跳过。  </p>
<p>下面是一个<code>if</code>语句的例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) {</span><br><span class="line">  <span class="comment">// 如果条件通过，则会执行的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>(condition)</code>处需要写入判断条件。键入的判断语句需要返回<code>true</code>或者<code>false</code>。一般比较常见的判断条件有<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, 或者逻辑判断语句<code>||</code>, <code>&amp;&amp;</code>, <code>!</code>。  </p>
<p><br></p>
<hr>
<h4 id="if-else语句-1"><a href="#if-else语句-1" class="headerlink" title="if...else语句"></a><code>if...else</code>语句</h4><p><code>if...else</code>语句建立在<code>if</code>语句的基础上。<code>if...else</code>相比<code>if</code>新加了一个小步骤：如果条件为真执行一段代码，如果为假执行另一段代码。 </p>
<p>下面是一个<code>if...else</code>语句的例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) {</span><br><span class="line">  <span class="comment">// 如果判断为真，要执行的代码</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 如果条件为假，要执行的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h4><p><code>switch</code>语句稍微复杂一点。如果你想要根据单个变量的值，并从多个选项中选择一个代码块来执行时，那么我们就可以使用<code>switch</code>语句。  </p>
<p>流程大概是，首先<code>switch</code>语句会评估一个表达式，然后将该表达式的值与标签进行比较。如果匹配某个标签，就直接执行某个标签包含的代码。  </p>
<p>直接上例子吧：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) {</span><br><span class="line">  <span class="keyword">case</span> constant1:</span><br><span class="line">    <span class="comment">// 如果 expression == constant1，要执行的代码块</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 注意！我们要使用break来退出switch语句</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> constant2:</span><br><span class="line">    <span class="comment">// 如果 expression == constant2，要执行的代码块</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> constant3:</span><br><span class="line">    <span class="comment">// 如果 expression == constant3，要执行的代码块</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果 expression 与任何一个case都不匹配，则执行default下的代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// *理论来讲这里不加break也没问题，但是我们最好保证编程范式统一</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>switch</code>语句是个相对比较新的概念，所以在这里提供一个小程序把：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> choice;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Menu:"</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"1. Option One"</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"2. Option Two"</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"3. Option Three"</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Enter your choice (1-3): "</span>;</span><br><span class="line">  std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (choice) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"You selected Option One."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"You selected Option Two."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"You selected Option Three."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"Invalid choice. Please enter 1, 2, or 3."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"End of menu program."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>看懂就毕业。  </p>
<p><br></p>
<hr>
<p>还没完。这里解释一下为什么<code>switch</code>语句要在每一个case后面带个<code>break</code>。看看这个例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (number) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"Case 1 executed."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="comment">// break; // 如果我们将case 1的break注释掉...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">      std::cout &lt;&lt; <span class="string">"Case 2 executed."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"Case 3 executed."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">"Default case executed."</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行程序你会看见这样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1 executed.</span><br><span class="line">Case 2 executed.</span><br></pre></td></tr></table></figure>
<p>为什么输出不仅仅是<code>Case 1 executed.</code>？因为当Case1完成执行后，没有跳出<code>switch</code>语句，所以程序会继续向下执行，直到碰到Case2中输出语句下一行的break，这才结束了这次<code>switch</code>。  </p>
<p><br></p>
<hr>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环，或者叫迭代，是编写程序时最基本的控制流结构之一。  </p>
<p>在这里主要介绍C++中两种主要的循环类型，<code>while</code>和<code>for</code>循环。  </p>
<p><br></p>
<hr>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h4><p><code>while</code>循环是两种主要循环类型中较为简单的一种。只要给定条件为真，它就会重复执行一个代码块。  </p>
<p><code>while</code>循环受条件控制，也就是说，只要条件成立，循环就不会停止。</p>
<p>只要指定条件为真，<code>while</code>循环就会重复执行一个代码块。  </p>
<p>如何判断跳出时机呢？在循环的每次迭代之前，<code>while</code>循环都会对条件进行检查。一旦不符合条件，则会直接跳出循环。  </p>
<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) {</span><br><span class="line">  <span class="comment">// 当condition为真的时候，要执行的代码块</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果<code>(condition)</code>一直为真，循环就不会停止。所以注意一下逻辑咯</p>
<p><br></p>
<hr>
<h4 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a><code>for</code>循环</h4><p>与<code>while</code>循环不同，<code>for</code>循环用来编写更可控的循环逻辑。一般当我们知道该循环多少次的时候，或者想要使用可控的方式遍历一串数值的时候，会用到<code>for</code>。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment/decrement) {</span><br><span class="line">  <span class="comment">// 当condition为真的时候执行的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里需要稍微解释一下循环是如何判定的：  </p>
<ul>
<li><p><strong><code>initialization</code></strong>：这一部分旨在循环开始时，也就是第一次循环开始之前执行一次。<br>它通常用户初始化循环计数器变量，也就是一般我们常用的<code>i</code>。<br>我们可以在这里声明并初始化一个变量，也可以直接初始化一个已有的变量。  </p>
</li>
<li><p><strong><code>condition</code></strong>：这里是判断条件。<code>condition</code>是一个布尔表达式，会在每次循环开始之前进行检查，就像while循环那样。如果为假就跳出执行了。  </p>
</li>
<li><p><strong><code>increment/decrement</code></strong>：与Python不同，循环计数器的增减被直接集成到了定义<code>for</code>循环的语句中。<br>这部分常用于更新循环计数器变量的值，例如在一次循环进行完后，增加或减少一次（或多次）计数器的值。  </p>
</li>
</ul>
<p><br></p>
<p>看个例子吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 使用for循环从1数到5</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) { <span class="comment">// initialization: i=1, condition: i&lt;=5, increment: i++</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Count is: "</span> &lt;&lt; i &lt;&lt; std::endl; <span class="comment">// 循环体: 输出循环计数器的值</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Loop finished!"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Count is: 1</span><br><span class="line">Count is: 2</span><br><span class="line">Count is: 3</span><br><span class="line">Count is: 4</span><br><span class="line">Count is: 5</span><br><span class="line">Loop finished!</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a><code>break</code></h4><p>你已经见过这位兄弟了。  </p>
<p>我们主要在<code>switch</code>语句中见过<code>break</code>，但是实际上<code>break</code>在其他的控制流写法中也有应用。比如循环语句。  </p>
<p>在循环中，当<code>break</code>将要被执行，则它所在的循环则会被立即终止，继续执行循环后的代码。  </p>
<p>直接解释有点抽象不如直接上例子。这是<code>while</code>循环的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) {</span><br><span class="line">  <span class="comment">// 写啥都行</span></span><br><span class="line">  <span class="keyword">if</span> (some_condition) {</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 立刻终止循环</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 这里也是写啥都行</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 当break语句执行后，程序会继续执行这里的代码 (while循环外)</span></span><br></pre></td></tr></table></figure>
<p>这是<code>for</code>循环的例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment/decrement) {</span><br><span class="line">  <span class="comment">// 啥都行</span></span><br><span class="line">  <span class="keyword">if</span> (some_condition) {</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 立刻终止循环</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 也是写啥都行</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 当break语句执行后，程序会继续执行这里的代码 (for循环外)</span></span><br></pre></td></tr></table></figure>
<p>想必是不难理解的。  </p>
<p><br></p>
<hr>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a><code>continue</code></h4><p>与<code>break</code>相反，<code>continue</code>的作用不是终止循环，而是在继续循环的基础上，跳过当前的这次循环。<br>对于<code>while</code>和<code>for</code>循环来说，<code>continue</code>会直接重新评估循环的条件，或直接进入递增/递减步骤 (仅限<code>for</code>循环) ，并开始下一次迭代。  </p>
<p><code>while</code>循环：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) {</span><br><span class="line">  <span class="comment">// 可写入任意代码</span></span><br><span class="line">  <span class="keyword">if</span> (some_condition) {</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">// 跳到下一次循环</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果continue发力了，那么这里的代码在当前这次循环不会被执行</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 当while循环结束，或使用break跳出了循环，开始执行这里的代码</span></span><br></pre></td></tr></table></figure>
<p>和<code>for</code>循环的例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment/decrement) {</span><br><span class="line">  <span class="comment">// 可写入任意代码</span></span><br><span class="line">  <span class="keyword">if</span> (some_condition) {</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">// 跳到下一次循环</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果continue发力了，那么这里的代码在当前这次循环不会被执行</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 当for循环结束，或使用break跳出了循环，开始执行这里的代码</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="怎么定义-使用函数？"><a href="#怎么定义-使用函数？" class="headerlink" title="怎么定义/使用函数？"></a>怎么定义/使用函数？</h3><p>我们来唠唠函数吧，每个语言必不可少的一部分。  </p>
<p>在使用函数之前，首先我们要学会如何定义一个函数： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(parameter_list)</span> </span>{</span><br><span class="line">  <span class="comment">// 函数主体</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> return_value</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>非常简单的结构。</p>
<ul>
<li><p><code>return_type</code>告诉编译器函数在完成执行之后，返回什么样类型的值。举例说这可以是<code>int</code>, <code>double</code>, <code>std::string</code>或者其他数据类型。<br>如果你的函数是一个步骤，也就是不会有任何返回值，那么你需要记得在<code>return_type</code>这里使用关键字<strong><code>void</code></strong></p>
</li>
<li><p><code>function_name</code>是你定义的函数的方程名，函数名按理来讲应该讲述了函数用来做什么，比如<code>calculateSum</code>等。没有硬性要求，但这是一个编程范式。<br>说到编程范式，最好保持你的函数命名规则统一。 </p>
</li>
<li><p><code>parameters_list</code>是你在调用函数时可以使用的传入参数。通过使用参数，你可以向函数提供数据，这样就能在每次调用的时候使用不同的值。<br>参数列表实际上是可选的，你的函数也可以不定义任何传入参数，留下一个空括号也没问题，具体看你需求。<br>如果又要定义的参数，则你需要指定每个参数的数据类型和他们的名称，中间用逗号隔开：例如<code>(int num1, int num2, std::string message)</code></p>
</li>
<li><p><code>return return_value</code>坐落在函数主体内。这一句定义了函数的返回值，当函数执行完毕后用来返回值用的。<br><code>return_value</code>必须要遵守你定义的<code>return_type</code>类型。如果<code>return_value</code>的类型能够被隐式转换到<code>return_type</code>类型，也没必要完全一致。<br>如果<code>return_type</code>是<code>void</code>，那么一般我们使用<code>return</code>作为返回语句，而不是带参数的<code>return</code>。<br>如果<code>return_type</code>不是<code>void</code>，那么我们就需要保证在函数内必须<strong>至少有一个<code>return</code>语句能够在函数的每一条可能的执行路径中返回一个正确类型的值</strong>。人话将就是记得写<code>return</code>。  </p>
</li>
</ul>
<p><br></p>
<p>比如我们定义一个能够将两个整数加在一起的函数，同样定义了如何调用函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义addNumbers函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addNumbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>{</span><br><span class="line">  <span class="type">int</span> sum = num1 + num2; <span class="comment">// 在函数内计算加和...</span></span><br><span class="line">  <span class="keyword">return</span> sum;             <span class="comment">// ...然后返回这个值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  result = <span class="built_in">addNumbers</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 使用传入参数 (5和3)调用addNumbers函数，返回值会被录入到result中</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"The sum is: "</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>当你定义了一个函数后，你就可以在程序的其他位置调用你的函数了。你可以调用后直接赋值到变量：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type result_variable = <span class="built_in">function_name</span>(argument_list);</span><br></pre></td></tr></table></figure>
<p>…或者直接在程序中调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">"Result: "</span> &lt;&lt; <span class="built_in">function_name</span>(argument_list) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>甚至用于其他函数的传入值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">another_function</span>(<span class="built_in">function_name</span>(argument_list));</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>C++的函数也可以先声明，在调用，无需先定义函数体。  </p>
<p>在目前的例子中，我们在调用函数之前都为函数设置了一个函数体，但是设想一下你在编写一个大型项目：<br>有时我们可能希望在<code>main()</code>之后或在单独的文件中定义函数。在这种情况下，就需要在调用函数之前提供一个函数原型（也称为函数声明）。  </p>
<p>函数原型会告诉编译器函数的名称、返回类型和参数，这样即使完整的函数定义在后面出现，编译器也知道如何正确处理函数调用。  </p>
<p>函数原型与函数头非常相似，但它以分号结束，而且没有函数体：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addNumbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以将该原型放在<code>main()</code>之前，然后在<code>main()</code>之后或另一个文件中定义完整的函数定义（包括主体）。   </p>
<p><br></p>
<hr>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>我们实际上在刚才已经接触过函数传入参数了，但是实际上这也是个深坑。</p>
<p>首先我们需要学会区分形参与实参，在讨论函数以及如何将数据传递给函数时，经常会用到这些术语。</p>
<p><strong>形式参数 (Formal Parameters)</strong>，简写为形参，是<strong>在函数定义的参数列表中声明的变量</strong>。<br>它们充当函数调用时将传入函数的值的占位符，定义了函数期望接收的输入数据的类型和名称。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addNumbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>比如在这个<code>addNumbers</code>的示例中，<code>num1</code>和<code>num2</code>就是形参。  </p>
<p>而<strong>实际参数 (Actual Arguments, Arguments)</strong>，中文简写可以叫实参，是在<strong>函数调用时传递给函数的实际值</strong>。  </p>
<p>例如在<code>addNumbers(10, 20)</code>的函数调用语句中，<code>10</code>和<code>20</code>就是实际参数。  </p>
<p>实参也可以是表达式，其值经过计算后传递给函数。它们可以是字面形式（如 <code>10</code>、<code>“Alice”</code>），也可以是变量或更复杂的表达式。  </p>
<p><br></p>
<hr>
<p>那么了解这些，我们要深入讨论一些传递值问题了。</p>
<p><strong>逐值传递 (Pass by value)</strong>，是C++ 中的默认参数传递方式。  </p>
<p>对于基本数据类型（如 int、double、char 等），C++ 将逐值传递作为向函数传递参数的默认机制，对于更复杂的类型也是如此。</p>
<p>那么问题来了，什么是逐值传递？  </p>
<p>使用逐值传递时，会<strong>创建实际参数值的副本</strong>并传递给函数的形式参数。<br>然后，函数将使用该副本，而不是调用代码中的原始变量。这样函数内部对形式参数所做的任何更改都不会影响调用代码中的原始实际参数。</p>
<p>逐值传递提供了数据保护，这样函数不会意外修改作为参数传递的原始变量。  </p>
<p><br></p>
<p>那么相反，如果我们想要将传入的数据进行更改怎么搞？  </p>
<p>C++ 提供了其他机制：<strong>引用传递 (Pass by reference)</strong>和<strong>按指针传递 (Pass by pointer)</strong>。<br>这些机制比较先进，我们现在可以简单介绍一下，以加深认识，后期我们会提到这两位大仙。  </p>
<p><br></p>
<p>与其传递副本，引用传递会直接传入原始变量的引用，也就是原始变量的内存地址，而不是它的分身。<br>如果想要指明想要使用引用传递，则需要在你的传入参数按照这样的方式定义实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyByReference</span><span class="params">(<span class="type">int</span>&amp; parameterValue)</span></span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>而指针是一个相对深层次的概念了，不过简单来讲就是一个指路牌，上面写着目标的内存地址。<br>通过按指针传递，你可以选择将指针传入函数。要使用按指针传递，你需要像这样定义形参：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyByPointer</span><span class="params">(<span class="type">int</span>* parameterPtr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>并在调用的时候使用<code>&amp;</code>访问变量的地址：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">modifyByPointer</span>(&amp;originalValue)</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>你应该已经知道返回值可以是C++的基础数据类型，比如<code>int</code>, <code>std::string</code>这种，但是我想展开篇幅讲一讲<code>void</code>。  </p>
<p>在上文我们已经看到<code>void</code>是一种返回类型。<code>void</code>返回类型的函数不返回任何值：执行操作，但不产生返回结果。<br>像之前<code>greetUser</code>这样的函数或向控制台打印输出的函数通常都是<code>void</code>函数，因为它们的主要目的是执行操作（比如显示消息），而不是计算和返回值。  </p>
<p>这样的操作一般不叫作函数，有一个专业的名字叫做流程 (Procedure)。  </p>
<p>当函数的主要目的是执行某些操作或副作用，而不是计算和返回特定值时，就会使用返回类型为<code>void</code>的函数。<br><code>void</code>函数的常见用途包括：</p>
<ul>
<li><strong>向控制台打印输出</strong>： 如<code>std::cout &lt;&lt; ....</code>，用来向用户显示信息、菜单或结果的函数通常是 void 函数。  </li>
<li><strong>修改通过引用或指针传递的数据结构或变量</strong>： 虽然逐值传递不会修改原始数据，但逐引用/指针传递允许函数更改自身作用域之外的数据。<br>这类函数可能是无效的，因为它们的作用是修改本身，而不是返回一个值。</li>
<li><strong>执行设置或初始化任务</strong>： 因为配置某些东西、打开文件或设置初始条件的函数，作用在于执行设置操作，所以它们大概率不需要返回值。</li>
<li><strong>事件处理程序</strong>： 响应用户操作（如点击按钮）或系统事件的函数可能是无效的，因为触发这些函数是为了对事件做出反应，而不是产生计算结果。<br>比如图形用户界面编程，诶就是个挺好的例子。  </li>
</ul>
<p>对于<code>void</code>函数来讲，使用<code>return;</code>实际上是可选的。<br><code>void</code>函数会在函数体结束时自动返回，不过，我们也可以在<code>void</code>函数内部使用<code>return;</code>来按人话要求函数提前退出。例如程序捕获到错误条件，则跳出函数。  </p>
<p><br></p>
<hr>
<h3 id="作用域和生命周期"><a href="#作用域和生命周期" class="headerlink" title="作用域和生命周期"></a>作用域和生命周期</h3><p>这个词听起来有点陌生，不过当你知道<strong>作用域</strong>叫做”<strong>Scope</strong>“，<strong>生命周期</strong>是”<strong>Lifetime</strong>“，可能就能让你恍然大悟了。<br>二位决定了变量在代码不同部分的可访问性和存在性。就函数而言，这些概念对于理解函数内部和外部声明的变量的行为尤为重要。  </p>
<p>那么什么是作用域？变量的作用域是指<strong>程序中可以访问（使用和修改）该变量的区域</strong>。它基本上定义了变量的 “可见性 ”或 “可达性”。  </p>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>首先介绍<strong>局部作用域 (Local Scope)</strong>，也叫做<strong>函数作用域  (Function Scope)</strong>。  </p>
<p>在函数体 (也就是大括号<code>{}</code>内) 声明的变量具有局部作用域，它们是该函数的局部变量。这意味着它们<strong>只能在声明它们的函数中访问</strong>。不能从函数外部（如从 main() 或其他函数）直接访问它们。  </p>
<p>同时<strong>与其他函数或全局作用域中声明的同名变量无关</strong>。即使在不同作用域中有同名变量，它们也会被视为不同的独立变量。  </p>
<p>比如这是一个能解释什么是局部作用域的小例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> localVar = <span class="number">10</span>; <span class="comment">// localVar 在 myFunction 被定义，存在于局部作用域里</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Inside myFunction, localVar = "</span> &lt;&lt; localVar &lt;&lt; std::endl; <span class="comment">// 在函数里访问 localVar 如你可见没啥问题</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="built_in">myFunction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; "In main, localVar = " &lt;&lt; localVar &lt;&lt; std::endl; </span></span><br><span class="line">      <span class="comment">// 'localVar' 没有在主程序的作用域里定义。写下这行会爆一个编译错误                                                          </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>实际上作用域不仅仅局限于函数。任何用大括号<code>{}</code>括起来的代码块，包含<code>if</code>, <code>for</code>, <code>while</code>循环等，都可以定义作用域。<br>在此类代码块中声明的变量是该代码块的局部变量，在代码块之外无法访问：  </p>
<p><br></p>
<hr>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>有局部当然有全局了。<br><strong>全局作用域 (Global Scope)</strong>包括任何函数或代码块之外声明的变量。也就是说，在所有函数和代码块之外声明的变量具有全局作用域。  </p>
<p>一般来讲，这些变量会被在文件级别声明，通常位于 .cpp 文件的顶部，在<code>main()</code>和其他函数之外。  </p>
<p>全局变量可从同一文件中的任何函数访问。如果能够正确使用头文件，那么你也可能从其他文件访问这些变量。  </p>
<p>有关头文件我们后面再说。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">5</span>; <span class="comment">// globalVar 在任何函数外被定义，所以它存在于全局作用域中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>{</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Inside myFunction, globalVar = "</span> &lt;&lt; globalVar &lt;&lt; std::endl; <span class="comment">// 访问globalVar没问题</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"In main, globalVar = "</span> &lt;&lt; globalVar &lt;&lt; std::endl; <span class="comment">// 这里也是</span></span><br><span class="line">  <span class="built_in">myFunction</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>变量的生命周期是指程序执行期间变量在内存中存在的时间段。它是从创建变量 (为其分配内存) 到销毁变量 (释放对应变量的内存)的时间。  </p>
<p>在函数或者块内声明的变量，aka局部变量，具有<u>自动生命周期</u>。<br>这些变量会在程序进入声明他们的函数或块的时候，被分配一个内存。而相应的函数或者块执行完毕后，会自动释放相对应的内存。  </p>
<p>每次调用函数时，C++都会重新创建局部变量，分配内存，并在特定函数调用结束时销毁它们。下次调用同一函数时，会再次创建局部变量，作为新实例。  </p>
<p>稍微有些抽象的一个概念，不过用例子来讲解就不是那么难了：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> localVar = <span class="number">1</span>; <span class="comment">// 当myFunction被调用时，localVar会被创建，分配内存</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">1</span>; <span class="comment">// 一个static类型的变量，这些变量有不同的生命周期</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Inside myFunction, localVar = "</span> &lt;&lt; localVar &lt;&lt; <span class="string">", staticVar = "</span> &lt;&lt; staticVar &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  localVar++;       <span class="comment">// 递增两个变量的值</span></span><br><span class="line">  staticVar++; </span><br><span class="line">} <span class="comment">// 因为myFunction结束了，超出了localVar的生命周期，所以它被销毁了（内存被释放）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="built_in">myFunction</span>(); <span class="comment">// 分三次调用程序</span></span><br><span class="line">  <span class="built_in">myFunction</span>();</span><br><span class="line">  <span class="built_in">myFunction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这个程序的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside myFunction, localVar = 1, staticVar = 1</span><br><span class="line">Inside myFunction, localVar = 1, staticVar = 2</span><br><span class="line">Inside myFunction, localVar = 1, staticVar = 3</span><br></pre></td></tr></table></figure>
<p>可以自己试着跑跑看，不过我想稍微讲一讲<code>static</code>关键字。  </p>
<p><code>static int staticVar = 1;</code>这一行定义了一个<code>static</code>(静态)局部变量。因为我们使用了<code>static</code>关键字，这个变量的生命周期会与其他的有所不同：  </p>
<ul>
<li><p>当程序执行过程中并首次达到它的生命，该变量<strong>只会被初始化一次</strong>。  </p>
</li>
<li><p>当函数退出时，它们<strong>不会被销毁</strong>。相反它们在整个程序执行过程中一直存在于内存中。</p>
</li>
<li><p>在对函数的后续调用中，它们<strong>不会被重新初始化</strong>。它们保留上一次函数调用的值。</p>
</li>
</ul>
<p>在我们的示例中<code>staticVar</code>仅在第一次调用<code>myFunction</code>时初始化为<code>1</code>，而在后续调用中，它不会被重新初始化了。<br>往后它保留前一次调用的值，然后递增。这就是为什么我们会看到<code>staticVar</code>在函数调用（1、2、3）中增加，而<code>localVar</code>在每个函数调用开始时始终为 1。  </p>
<p>我想这大概不是一个很复杂的概念。  </p>
<p><br></p>
<hr>
<p>简而言之，作用域与可见性和可访问性有关。<br>局部变量的作用域是其函数或代码块，全局变量的作用域是全局的。在编程过程中非必要尽可能不创建全局变量。  </p>
<p>而生命周期是指在内存中的存在时间。<br>局部变量有自动生命周期（在函数或块进入时创建，退出时销毁）。全局变量有程序生命周期（在整个程序运行过程中存在）。<br><code>static</code>静态局部变量只需初始化一次，并在函数调用中持续存在。   </p>
<p><br></p>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>我假设你拥有Python的编程经验，至少懂得什么是数组。  </p>
<p>首先说明，<strong>数组 (Array)</strong>是一块连续的内存块，可保存固定数量的相同数据类型的元素。  </p>
<p>在C++中，使用数组之前需要提前定义：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_type array_name[array_size];</span><br></pre></td></tr></table></figure>
<p>要在 C++ 中使用数组，首先需要声明数组。 声明数组时，需要指定</p>
<p><code>data_type</code>说明数组将存储的元素类型，如<code>int</code>、<code>double</code>、<code>char</code>、<code>std::string</code> 等。<br><code>array_name</code>声明数组变量的名称。记得遵循变量命名规则！<br><code>array_size</code>声明数组将容纳的元素个数。使用数组名称后的方括号<code>[]</code>指定。  </p>
<p>看几个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>];</span><br><span class="line"><span class="type">double</span> temperatures[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> letters[<span class="number">26</span>];</span><br><span class="line">std::string names[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记住[]内声明的是数组大小！</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>那太好了，我们该怎么赋值呢？</p>
<p>与其他变量相同，你可以在初始化阶段赋值：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data_type array_name[array_size] = {value1, value2, value3, ..., valueN};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> scores[<span class="number">5</span>] = {<span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>, <span class="number">95</span>, <span class="number">88</span>};</span><br><span class="line"><span class="type">double</span> prices[<span class="number">3</span>] = {<span class="number">19.99</span>, <span class="number">24.50</span>, <span class="number">12.75</span>};</span><br><span class="line"><span class="type">char</span> vowels[<span class="number">5</span>] = {<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>};</span><br><span class="line">std::string weekdays[<span class="number">7</span>] = {<span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>, <span class="string">"Saturday"</span>, <span class="string">"Sunday"</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> smallArray[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line"><span class="type">int</span> evenSmallerArray[<span class="number">3</span>] = {};</span><br></pre></td></tr></table></figure>
<p>也可以在声明后再赋值。</p>
<p><br></p>
<p>你可以通过使用索引（位置）访问数组元素来初始化或修改数组元素。和Python一样，在 C++ 中，数组索引从<code>0</code>开始。</p>
<p>数组的第一个元素位于索引<code>0</code>，第二个元素位于索引<code>1</code>，第三个元素位于索引<code>2</code>，依此类推。对于大小为<code>n</code>的数组，有效索引从<code>0</code>到<code>n-1</code>。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">array_name[index] = value; <span class="comment">// 向索引位置赋值</span></span><br><span class="line">value = array_name[index]; <span class="comment">// 读取索引位置的值</span></span><br><span class="line"><span class="comment">// 注意在非声明阶段，方括号的作用就转变成了索引地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>]; <span class="comment">// 初始化存储int数据类型，长度为5的数组</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">// 赋值流程</span></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">300</span>; </span><br><span class="line">numbers[<span class="number">3</span>] = <span class="number">400</span>;</span><br><span class="line">numbers[<span class="number">4</span>] = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">std::string colors[<span class="number">4</span>];</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"Red"</span>;</span><br><span class="line">colors[<span class="number">1</span>] = <span class="string">"Green"</span>;</span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">"Blue"</span>;</span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"Yellow"</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>有数组能忍住不遍历的都是神人了。在C++你可以通过这样的方式实现如此操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> numbers[<span class="number">5</span>] = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};</span><br><span class="line">  <span class="type">int</span> arraySize = <span class="number">5</span>; <span class="comment">// 在C++中，最好一并存储数组的大小</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Elements of the array are:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arraySize; ++i) { <span class="comment">// 从索引 0 遍历到arraySize，但不包括5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Element at index "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; numbers[i] &lt;&lt; std::endl; <span class="comment">// 访问内容</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>一般数组可以怎么去用呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> NUM_TEMPS = <span class="number">5</span>; <span class="comment">// 使用变量定义数组的大小，是很好的coding习惯</span></span><br><span class="line">  <span class="type">double</span> temperatures[NUM_TEMPS];</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Enter "</span> &lt;&lt; NUM_TEMPS &lt;&lt; <span class="string">" temperature values:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_TEMPS; ++i) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Temperature "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">    std::cin &gt;&gt; temperatures[i]; <span class="comment">// 读取温度，随后存储到第i个索引位置</span></span><br><span class="line">    sum += temperatures[i];       <span class="comment">// 加和</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> averageTemperature = sum / NUM_TEMPS; <span class="comment">// 计算平均</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"\nEntered temperatures are:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_TEMPS; ++i) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Temperature "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; temperatures[i] &lt;&lt; std::endl; <span class="comment">// 输出</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"\nAverage temperature: "</span> &lt;&lt; averageTemperature &lt;&lt; std::endl; <span class="comment">// 输出</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>实际上你也可以声明多维数组：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data_type array_name[number_of_rows][number_of_columns];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>];       <span class="comment">// 声明一个叫做'matrix'的，含有3行4列的2D数组</span></span><br><span class="line"><span class="type">double</span> grid[<span class="number">5</span>][<span class="number">5</span>];      <span class="comment">// 以此类推</span></span><br><span class="line"><span class="type">char</span> chessboard[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">std::string gameBoard[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cube[<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];        <span class="comment">// 或者声明一个三位数组</span></span><br><span class="line"><span class="type">double</span> space[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">// 甚至四维</span></span><br></pre></td></tr></table></figure>
<p>多维数组的赋值方式与一维少许不同：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data_type array_name[number_of_rows][number_of_columns] = {</span><br><span class="line">    {row1_value1, row1_value2, ..., row1_valueN}, <span class="comment">// 第一行</span></span><br><span class="line">    {row2_value1, row2_value2, ..., row2_valueN}, <span class="comment">// 第二行</span></span><br><span class="line">    ...</span><br><span class="line">    {rowM_value1, rowM_value2, ..., rowM_valueN}  <span class="comment">// 第M行</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> partialMatrix[<span class="number">3</span>][<span class="number">3</span>] = {</span><br><span class="line">    {<span class="number">1</span>, <span class="number">2</span>},       <span class="comment">// 第0行设置为：matrix[0][0]=1, matrix[0][1]=2, matrix[0][2]=0 (留空为0)</span></span><br><span class="line">    {<span class="number">3</span>},          <span class="comment">// 第1行设置为： initializes matrix[1][0]=3, matrix[1][1]=0, matrix[1][2]=0</span></span><br><span class="line">    {}           <span class="comment">// 第2行初始化所有值为0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者你可以声明一个空多维数组：</span></span><br><span class="line"><span class="type">int</span> zeroMatrix[<span class="number">2</span>][<span class="number">2</span>] = {}; <span class="comment">// 所有元素都会被默认设置为0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h2><p>杂七杂八不代表不重要，所以竖起耳朵听好了。  </p>
<p><br></p>
<hr>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>Pass-by-reference。按引用传递可能不是很好的翻译方式，但是能搞清楚我指代的是什么就ok。  </p>
<p>众所周知，C++ 默认使用逐值传递。这意味着当您将参数传递给函数时，函数会复制该值，并使用这个值的副本操作。  </p>
<p>函数内部的任何更改都只会影响副本，而不会影响原始变量。  </p>
<p>而引用传递不是传递值的副本，而是传递一个别名或对原始变量本身的引用，你可以把引用看作原始变量的另一个名称或外号。  </p>
<p>它不是一个单独的副本，只是以不同的方式引用存储原始变量的同一内存位置。  </p>
<p>当函数参数被声明为引用时，它就直接与函数调用中传递的实际参数相关联。因此，在函数内部对引用参数执行的任何操作都会直接影响调用代码中的原始变量。  </p>
<p>实际上这些概念在前面都已经解释过了。  </p>
<p><br></p>
<hr>
<p>语法定义之前讲过了我没听清楚怎么办  </p>
<p>那么我告诉你，在 C++ 中，要将函数参数声明为引用，需要<strong>在函数定义的参数列表中的数据类型后使用<code>&amp;</code>符号</strong>。就好比：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(data_type&amp; parameter_name)</span> </span>{ <span class="comment">// 留意'data_type&amp;'中的'&amp;'</span></span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="comment">// ... 此时调用的参数会被直接更改</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这就是声明引用参数的语法了。<code>data_type</code>后面的<code>&amp;</code>符号表示参数名称是一个引用。  </p>
<p>当你调用一个带有引用参数的函数时，函数调用本身的语法与按值传递的语法完全相同；你只需将变量名称作为参数传递，剩下的事情交给<code>&amp;</code>即可。  </p>
<p><br></p>
<p>看个小例子。加入我们想要写一个调换两个数字的小程序：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>{ <span class="comment">// 'a' 和 'b' 按照引用传递进函数</span></span><br><span class="line">  <span class="type">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp; </span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Inside swapValues function: a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 展示函数干的好事</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Before swap: num1 = "</span> &lt;&lt; num1 &lt;&lt; <span class="string">", num2 = "</span> &lt;&lt; num2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">swapValues</span>(num1, num2); <span class="comment">// 调用函数, 并传入参数</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"After swap in main: num1 = "</span> &lt;&lt; num1 &lt;&lt; <span class="string">", num2 = "</span> &lt;&lt; num2 &lt;&lt; std::endl; <span class="comment">// 检查一下函数是否工作正常</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>程序的输出应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before swap: num1 = 10, num2 = 20</span><br><span class="line">Inside swapValues function: a = 20, b = 10</span><br><span class="line">After swap in main: num1 = 20, num2 = 10</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>说得好。那么我们什么时候该使用按引用传递？或者说，我们使用按引用传递有什么好处？  </p>
<ul>
<li><p><strong>直接修改原始参数</strong>：最显而易见的原因是我们可以改变原始变量的值。刚才的<code>swapValues</code>就是一个典型的例子，目的就是修改原始变量。  </p>
</li>
<li><p><strong>避免复制大型对象</strong>：这不是什么编程初期常需要理解的概念，但是你确实需要去理解一下这个有关编程范式的问题：<br>对于大型数据结构，比如数组、矢量、类对象 (一会会提到)，通过值传递可能效率很低，因为它涉及到创建整个大型对象的副本。<br>而使用引用传递效率更高，因为它避免了复制；函数直接使用原始数据。  </p>
<p><em>但对于<code>int</code>、<code>double</code>这种简单的数据类型，性能上的差异通常可以忽略不计，但对于较大的数据，这种差异就很重要了</em></p>
</li>
</ul>
<p><br></p>
<hr>
<h3 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h3><p>是不是之前也提过了…值得我们更细节的说一说这个东西：  </p>
<p>首先你要知道什么是指针。<strong>指针 (Pointer)</strong>是保存另一个变量的内存地址的变量。  </p>
<p>程序中的每个变量都驻留在计算机内存中的特定位置，内存位置由地址表示，地址一般是一个数值。  </p>
<p>指针做的就是存储这个内存地址，看起来像是“指向”另一个变量的内存位置。   </p>
<p><br></p>
<p>定义一个指针很简单：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_type* pointer_name; <span class="comment">// 定义一个指针数据类型变量</span></span><br></pre></td></tr></table></figure>
<p><code>data_type</code>还是老样子，用来指定要使用的数据类型;</p>
<p><code>*</code>星号代表<code>pointer_name</code>是一个指针变量;</p>
<p>然后<code>pointer_name</code>代表变量名。  </p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptrToInt;       <span class="comment">// ptrToInt 是一个能够指向int数据类型的指针</span></span><br><span class="line"><span class="type">double</span>* ptrToDouble; <span class="comment">// ptrToDouble 是一个能够指向double数据类型的指针</span></span><br><span class="line"><span class="type">char</span>* ptrToChar;     <span class="comment">// ptrToChar 同理</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>你有没有想过我们为什么要在按引用传递使用<code>&amp;</code>符号？当<code>&amp;</code>放在变量名前的时候，你会获取到该变量的内存地址：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span>* pointerToNumber;</span><br><span class="line"></span><br><span class="line">pointerToNumber = &amp;number; <span class="comment">// 将number的内存地址赋值给pointerToNumber</span></span><br></pre></td></tr></table></figure>
<p>而<code>*</code>的作用正好相反，用来解析内存地址到它所对应的值。我们将这一步叫做”Dereference”。  </p>
<p>当我们在指针变量名称前加上<code>*</code>时，它会“取消引用”指针，意味着它会提供指针所指向的变量的值：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *pointerToNumber; <span class="comment">// 将pointerToNumber取消引用，拿到内存地址对应的值 (也就是刚才number中的值)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在value会存入number的值，也就是25</span></span><br></pre></td></tr></table></figure>
<p>现在你应该大彻大悟了。接下来我们讲一讲指针传递。</p>
<p><br></p>
<hr>
<p>在指针传递中，我们不传递值或引用，而是将变量的内存地址传递给函数。<br>在声明阶段，我们使用<code>data_type*</code>的形式定义形参：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(data_type* parameter_name)</span> </span>{ <span class="comment">// 注意形参的定义方式 'data_type*'</span></span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="comment">// 记得在函数体内，使用'*parameter_name'来取消引用，访问地址所对应的值。</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>因为形参要求传递进一个内存地址，所以在调用的时候…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">function_name</span>(&amp;variable_name);</span><br></pre></td></tr></table></figure>
<p>…记得使用<code>&amp;</code>，得到变量的内存地址。</p>
<p><br></p>
<p>下面端上小例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementByPointer</span><span class="params">(<span class="type">int</span>* numberPtr)</span> </span>{ <span class="comment">// 'numberPtr' 是一个指向 int 数据类型的指针</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Inside incrementByPointer, value before increment: "</span> &lt;&lt; *numberPtr &lt;&lt; std::endl; <span class="comment">// 首先Dereference</span></span><br><span class="line"></span><br><span class="line">  *numberPtr = *numberPtr + <span class="number">1</span>; <span class="comment">// Dereference，然后更改值</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Inside incrementByPointer, value after increment: "</span> &lt;&lt; *numberPtr &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> myValue = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Before function call, myValue = "</span> &lt;&lt; myValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">incrementByPointer</span>(&amp;myValue); <span class="comment">// 调用函数。注意参数的传入方法！</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"After function call, myValue = "</span> &lt;&lt; myValue &lt;&lt; std::endl; <span class="comment">// 看看函数是否正常工作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>你将会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before function call, myValue = 100</span><br><span class="line">Inside incrementByPointer, value before increment: 100</span><br><span class="line">Inside incrementByPointer, value after increment: 101</span><br><span class="line">After function call, myValue = 101</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>那么什么时候要使用指针传递？是不是感觉指针传递能做的事情，引用传递和按值传递也能解决？  </p>
<p>确实在现在的 C++ 中，当主要目标是修改参数时，引用传递通常比指针传递更受欢迎。在这种情况下，引用传递通常被认为在语法上更安全、更简洁，因为：</p>
<ul>
<li><strong>语法更简单</strong>： 使用逐参传递时，可以直接使用参数名（就像普通变量一样）来修改原始值。而使用逐指针传递时，总是需要使用反引用操作符<code>*</code>来访问和修改被指向的值，这可能稍显不便。</li>
<li><strong>安全性</strong>：<em>赫赫，喜欢我空指针吗</em><br>C++ 中的引用通常总是指向一个有效的对象，所以它们不能像指针那样为“空”或“未初始化”。<br>好埃ver，另一方面，指针可以为空，也就是我们常说的<code>nullPointer</code>，因此在取消引用指针之前，需要小心检查指针是否为空，以避免程序崩溃。  </li>
</ul>
<p>但是实际上指针传递仍然是必不可少的，并常用于多种情况：</p>
<ul>
<li><p><strong>动态内存分配</strong>： 指针是处理动态内存分配的基础 <em>(比如在运行时使用 new 和 delete 来分配和删除内存)</em>。</p>
</li>
<li><p><strong>数据结构和算法</strong>： 在实现涉及内存地址操作的各种数据结构 <em>(例如链表、树等)</em> 和算法时，我们大量使用指针。</p>
</li>
<li><p><strong>与 C 代码和系统库交互</strong>： 许多旧的 C 库和系统级 API 广泛使用指针，而 C++ 经常需要与这些代码交互。</p>
</li>
<li><p><strong>(可选参数指示)</strong>： 在某些coding风格中，通过指针传递（pass-by-pointer）在风格上明确表示函数可能会修改传递给它的参数。<br>参数类型中的<code>*</code>可以作为 “该参数可能会被函数修改 ”的视觉提示。不过，逐参传递和良好的文档也能达到清晰的效果。</p>
</li>
<li><p><strong>空指针作为有效值</strong>： 指针可以设置为<code>nullptr</code>，或旧 C++ 中的<code>NULL</code>，这是一个特殊的值，表示指针当前并不指向任何有效的内存位置。<br>这可以用来表示 “可选”参数，或表示指针可能并不总是指向有效对象。相反，一般来说，引用不能以同样的方式 “为空”。  </p>
</li>
</ul>
<p><br></p>
<hr>
<p>好了这些内容对于Module 3应该足够了。可能会有不少超出课件的内容，不过能知道多一点也是好事。  </p>
<p><br></p>
<hr>
<h1 id="Module-4-Makefile-Programming-Style-Basic-Debugging"><a href="#Module-4-Makefile-Programming-Style-Basic-Debugging" class="headerlink" title="Module 4: Makefile, Programming Style, Basic Debugging"></a>Module 4: Makefile, Programming Style, Basic Debugging</h1><p>实际上我搞错了。原来C++的内容会一直持续到本课程结束，所以我实际上没必要把几乎所有东西都在上一个Module展开的。  </p>
<p>不过展开也没啥大问题，就当个介绍引入吧。  </p>
<p><br></p>
<hr>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="分开编译-Separate-Compilation"><a href="#分开编译-Separate-Compilation" class="headerlink" title="分开编译 (Separate Compilation)"></a>分开编译 (Separate Compilation)</h3><p>你可以在项目中选择单独编译单个文件，不过使用分开编译的好处在于，你可以将程序不同的部分在不同的地方定义好，然后在最后组装到一起。  </p>
<p>在C++中，分开编译就像是把你程序的不同功能，例如不同类型的函数或者类，写在不同的.cpp文件里。</p>
<p>不如我们来看个例子吧：  </p>
<p><br></p>
<hr>
<p>例如我们有一个能够读取两个整数，并输出它们的最大公约数的程序：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcd_single.cpp</span></span><br><span class="line"><span class="comment">// This program finds the GCD of two numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> a, b, c;</span><br><span class="line">  cout &lt;&lt; <span class="string">"Please input two positive numbers: "</span>;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  c = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">  cout &lt;&lt; <span class="string">"GCD is "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// for simplicity, we assume both inputs to be positive</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span>(a != b) {</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) {</span><br><span class="line">      a -= b;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      b -= a;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">前四行是程序的Header。  </span><br><span class="line">`<span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;` 是方程的声明，但不是定义。  </span><br><span class="line"></span><br><span class="line">主程序由`<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{}`包裹，后面的`<span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{}`是方程`gcd`的定义。  </span><br><span class="line"></span><br><span class="line">嗯程序写的挺好，那么我们该如何去运行呢：  </span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ g++ -pedantic-errors -std=c++<span class="number">11</span> gcd_single.cpp -o gcd_single</span><br><span class="line"></span><br><span class="line">$ ./gcd_single</span><br><span class="line">Please input two positive numbers: <span class="number">18</span> <span class="number">24</span></span><br><span class="line">GCD is <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>那么有人就可能在想了，如果按照分开编译的思路去重构该程序，是不是可以将<code>gcd</code>程序分离出来到一个新的.cpp文件中？  </p>
<p>事实证明你可以：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcd.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"gcd.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for simplicity, we assume both inputs to be positive</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span>(a != b) {</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) {</span><br><span class="line">      a -= b;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      b -= a;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>我们将gcd的函数体分离出来，到一个全新的文件<code>gcd.cpp</code>中。  </p>
<p>如果想要允许其他<code>.cpp</code>文件调用<code>gcd.cpp</code>，你需要先像下面一样定义一个<strong>头文件(Header file)</strong>。  </p>
<p>为了让分开编译的代码能够互相使用，我们需要用到头文件。可以把头文件想象成一份“合同”或者“声明”。  </p>
<p>头文件差不多是用来告诉其他文件：“bro，这个<code>.cpp</code>文件里有这些函数或者其他东西，你可以直接调用。”  </p>
<p>比如，如果你的<code>geometry.cpp</code>文件里有一个计算面积的函数<code>calculateArea</code>，你会在<code>geometry.h</code>文件里声明这个函数。然后，任何想用<code>calculateArea</code>的文件只需要包含 <code>geometry.h</code>就可以了  </p>
<p><br></p>
<p>首先头文件内必须要先声明<code>gcd</code>函数的存在，才能告诉其他文件你可以使用<code>gcd</code>函数:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GCD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GCD_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这是课本上提供的写法。我比较倾向于使用下面的方法：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两种写法有什么区别？为何除了函数定义的哪一行，还要多写类似<code>#ifndef</code>或者<code>#pragma once</code>之类的其他内容？  </p>
<p>首先我们先从你的代码如何转变为程序，也就是程序的编译过程说起。  </p>
<p><br></p>
<p>编译说白了有点像是进行一边“翻译”，把人能够读懂的代码翻译成机器能读懂的机器码。  </p>
<ul>
<li>预处理 (Pre-processing):  </li>
</ul>
<p>首先进入预处理。这一步可以被看做是“准备”阶段。预处理器会查看你的代码，寻找以 # 开头的特殊指令（比如 #include）。<br>例如，<code>#include &lt;iostream&gt;</code> 告诉预处理器把<code>iostream</code>库的代码带进来，这样你就可以使用<code>cout</code>和<code>cin</code>了。<br>这个阶段的输出是经过修改的源代码。  </p>
<ul>
<li>编译 (Compilation):  </li>
</ul>
<p>编译是我们主要的翻译阶段。编译器会把预处理过的代码翻译成汇编语言。<br>汇编语言是一种比你的 C++ 代码更低级的语言，更接近机器代码，但仍然可以被人类阅读。  </p>
<ul>
<li>汇编 (Assembly):  </li>
</ul>
<p>接着汇编器会把汇编语言代码转换成机器码。机器码是你的电脑处理器能够直接理解的二进制代码。<br>汇编器的输出是目标文件 (例如，myprogram.o)。  </p>
<ul>
<li>链接 (Linking):  </li>
</ul>
<p>在最后的组装阶段。链接器 (Linker) 会把所有生成的目标文件合并成一个单独的可执行程序。这些文件可能来自不同的源代码文件。<br>它还会把程序用到的库（比如 C++ 标准库）链接进来。</p>
<p><br></p>
<hr>
<p>那么那些额外的语句，实则在刚才的预处理已经介绍过了。我们将这些额外的语句叫做<strong>保护符 (guards)</strong>。保护符的作用是防止我们多次引用同样的内容。  </p>
<p>可以想象一下，你的项目下有好几个文件，都引用了同一个头文件。如果这些文件又被包含进另一个文件里，那么这个头文件就会被包含好多次，这可能会导致错误。<br>包含保护符就是用来避免这种情况的，这玩意确保一个头文件的内容只会被处理一次，不管它被包含了多少次。  </p>
<p>头文件是怎么被使用的？  </p>
<p>实则简单粗暴。在编译阶段，头文件会被直接暴力复制进当前文件的开头。也就是直接ctrl+c/v。如果包含多次的话则可能会出现问题。  </p>
<p><br></p>
<hr>
<p>最后想要使用改写后的程序结构，我们只需要在主程序内引用头文件即可：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcd_main.cpp</span></span><br><span class="line"><span class="comment">// This program finds the GCD of two numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"gcd.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> a, b, c;</span><br><span class="line">  cout &lt;&lt; <span class="string">"Please input two positive numbers: "</span>;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  c = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">  cout &lt;&lt; <span class="string">"GCD is: "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>经过下面的编译步骤：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -pedantic-errors -std=c++11 gcd_main.cpp gcd.cpp -o gcd</span><br></pre></td></tr></table></figure>
<p>你的代码依然可以被正常运行。  </p>
<p><br></p>
<hr>
<p>那么我们为什么要采用分开编译？分开编译究竟好在哪了？  </p>
<ol>
<li><p>能够独立编写编译源文件  </p>
<p> 也可能是最主要的一点吧。我们可以在不同的文件中编写程序的不同部分。例如你就可以把logger写在logger.cpp文件里，而不用把所有东西都塞到主程序中。  </p>
</li>
<li><p>测试目标代码</p>
<p> 使用分开编译，我们就可以将一个单独的<code>.cpp</code>文件编译成目标文件，然后再具体测试这部分特定的代码。<br> 想象一下如果我们要测试一个塞满各种东西的主程序，呃呃</p>
</li>
<li><p>节省重新编译时间</p>
<p> 如果你根据需求只是修改了一个<code>.cpp</code>文件中的一个小部分，那么我们没有必要重新编译整个项目。我们只需要重新编译修改过的文件，然后叫linker来重新链接一下就好了。<br> 加入你在写一个操作系统。如果没有用到分开编译，那么重新写一个小小的地方就要重新编译一整个系统。一下来可能就是好几个小时了。  </p>
</li>
<li><p>允许以目标代码的形式提供类实现，而不公开源代码</p>
<p> 如果你编写了一个库或者一个软件，但是不想做到100%开源。你想让其他人使用你的内容，但是不想让别人访问到你的源代码。这时候你可以使用分开编译，把你的程序以目标代码的形式提供。  </p>
<p> 如果用户想要使用你的软件，自己调用linker把目标代码串起来就好了。  </p>
<p> 例如在g++中你可以使用编译器的<code>-c</code> flag来创建目标文件：  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c myFile.cpp</span><br></pre></td></tr></table></figure>
<p> 这一步会创建一个名为<code>myFile.o</code>的目标文件。  </p>
<p> 一旦我们拥有所有的目标文件，就可以再次使用<code>g++</code>把它们连起来：  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ file1.o file2.o -o myProgram</span><br></pre></td></tr></table></figure>
<p> 这会告诉g++编译器链接<code>file1.o</code>和<code>file2.o</code>，创建一个名为<code>myProgram</code>的可执行程序。  </p>
</li>
</ol>
<p><br></p>
<hr>
<h3 id="Make工具-Make-Tool"><a href="#Make工具-Make-Tool" class="headerlink" title="Make工具 (Make Tool)"></a>Make工具 (Make Tool)</h3><p>在讲解Make工具之前，我想先介绍一下什么叫文件依赖。  </p>
<p>在一个有很多文件的项目里，一些文件可能会依赖于其他文件。例如一个<code>.cpp</code>文件可能会包含一个头文件。如果你修改了这个头文件的内容，那么包含它的<code>.cpp</code>文件可能会需要重新编译。  </p>
<p>而随着项目规模的扩大，文件的数量以及它们之间的关系会变得非常复杂。  </p>
<p>接下来我们就可以用到Make工具了。Make非常强大，会帮助你自动化重新编译和链接程序的过程：Linux 中的make工具在某些源文件更改时智能地重新编译和链接文件。  </p>
<p>使用make工具可以帮助你避免每次修改代码后都需要手动输入所有的<code>g++</code>编译器命令。</p>
<p>Make工具使用一个名字叫做<code>Makefile</code>的文件（没有后缀）来获取文件的依赖信息，这个文件包含了make用来理解你的项目结构以及如何构建它的规则。  </p>
<p><code>Makefile</code>文件不是make生成的，而是你写的。</p>
<p>按照刚才的例子，它看起来像这样：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#This file must be named Makefile</span></span><br><span class="line"><span class="comment">#Comments start with #</span></span><br><span class="line"></span><br><span class="line"><span class="section">gcd.o: gcd.cpp gcd.h</span></span><br><span class="line">      g++ -c gcd.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">gcd_main.o: gcd_main.cpp gcd.h</span></span><br><span class="line">      g++ -c gcd_main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">gcd_main: gcd.o gcd_main.o</span></span><br><span class="line">      g++ gcd.o gcd_main.o -o gcd_main</span><br></pre></td></tr></table></figure>
<p>正如你所见一个<code>Makefile</code>由一系列的规则组成。每个规则指定了如何构建一个特定的目标。包含：  </p>
<ul>
<li><p><strong>目标 (Target)</strong>： 要生成的文件</p>
<p>  这是make将视图创建的文件。例如一个目标文件或者一个可执行文件。</p>
</li>
<li><p><strong>依赖 (Dependencies)</strong>：目标所依赖的文件</p>
<p>  代指如果我们要创建目标文件，我们会需要的其他内容。<br>  如果任何一个依赖文件都比目标文件新，那么目标文件就必须要重新构建。  </p>
</li>
<li><p><strong>命令 (Commands)</strong>：从依赖项生成目标的命令</p>
<p>  每个命令都必须要一个Tab字符开头 <em>(不是空格！)</em>，这些是make来构建目标文件所要执行的实际命令，例如g++…。  </p>
</li>
</ul>
<p>差不多看起来就像是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Target&gt;: &lt;Dependency1&gt; &lt;Dependency2&gt; &lt;...&gt;</span><br><span class="line">      &lt;Commands&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>要使用make工具，我们就可以直接使用<code>make gcd_main</code>命令来生成指定的目标：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make gcd_main</span><br><span class="line">g++ -c gcd.cpp</span><br><span class="line">g++ -c gcd_main.cpp</span><br><span class="line">g++ gcd.o gcd_main.o -o gcd_main</span><br></pre></td></tr></table></figure>
<p>make工具的工作流大概是：首先检查目标的依赖项。  </p>
<p>make 首先查看你指定的目标的依赖项。如果任何一个依赖项本身也有依赖项，make 会继续向下检查（也就是递归），确保所有依赖项都是最新的。  </p>
<p>怎么检查最新的？make 使用时间戳来判断一个文件是否需要重新构建。如果一个依赖文件的修改时间比目标文件新，那么目标文件就会被认为是过时的。  </p>
<p>如果目标不是最新的，那么 make 会执行 <code>Makefile</code> 中与该目标关联的命令。构建一个最新的目标。</p>
<p><br></p>
<hr>
<p>接下来介绍几个新东西。  </p>
<p>Makefile变量 (Makefile Variables)，基本上类似于“快捷方式”，让你的<code>Makefile</code>更易于阅读和维护。  </p>
<p>我们可以在<code>Makefile</code>中定义变量以避免重复键入文件名。也就是说，如果你在<code>Makefile</code>中需要多次使用同一个文件名或编译器选项，你可以把它存储在一个变量中：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TARGET = gcd_main</span><br><span class="line">OBJECTS = gcd.o gcd_main.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line">      g++ <span class="variable">$(OBJECTS)</span> -o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>也就是使用变量替换了。和下面的写法没有区别：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">gcd_main: gcd.o gcd_main.o</span></span><br><span class="line">      g++ gcd.o gcd_main.o -o gcd_main</span><br></pre></td></tr></table></figure>
<p>要使用变量的值，只需要将变量名放在圆括号中，并在前面加上美元符号：<code>$(MY_VARIABLE)</code>。  </p>
<p><br></p>
<hr>
<p>同时make也提供了一些特殊的内置变量，可以在我们的<code>Makefile</code>中使用它们。例如：  </p>
<ul>
<li><p><code>$@</code>代表<strong>目标 (Target)</strong></p>
<p>  这个变量会被替换为目标地名称。  </p>
</li>
<li><p><code>$^</code>代表<strong>依赖项列表 (Dependency list)</strong></p>
<p>  这个变量将会被替代为目标所有依赖项的列表</p>
</li>
<li><p><code>$&lt;</code>代表<strong>依赖项列表中最左边的项</strong></p>
<p>  这个稍微特殊一点：会被替换为依赖项列表中的第一个依赖项的名称。</p>
</li>
</ul>
<p>上改写例子：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">gcd_main.o: gcd_main.cpp gcd.h</span></span><br><span class="line">      g++ -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">gcd_main: gcd.o gcd_main.o</span></span><br><span class="line">      g++ <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>和这个同理：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">gcd_main.o: gcd_main.cpp gcd.h </span></span><br><span class="line">      g++ -c gcd_main.cpp </span><br><span class="line"><span class="section">gcd_main: gcd.o gcd_main.o </span></span><br><span class="line">      g++ gcd.o gcd_main.o -o gcd_main</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><strong>伪目标 (Phony Target)</strong>是一个全新的概念。伪目标是一种定义你总是想让 make 执行的操作的方式，即使当前目录下存在同名的文件。  </p>
<p>通常，make 会检查目标文件是否存在以及是否是最新版本。但是对于伪目标，make 总是会执行相关的命令，而不管是否存在同名的文件。  </p>
<p>举个例子看看吧：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 续刚才的makefile文件接着往下写：  </span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">      rm -f gcd_main gcd.o gcd_main.o gcd.tgz</span><br><span class="line"><span class="section">tar:</span></span><br><span class="line">      tar -czvf gcd.tgz *.cpp *.h</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean tar</span></span><br></pre></td></tr></table></figure>
<p>当我们声明了目标<code>clean</code>，即使我们当前的文件系统下没有叫做<code>clean</code>的文件，<code>rm -f gcd_main gcd.o gcd_main.o gcd.tgz</code>命令仍然会被执行：只需要键入<code>make clean</code>即可。<code>make tar</code>同理。  </p>
<p>但是这个用法有一个小陷阱。假如文件系统下真的有<code>clean</code>文件怎么办？make会发现我们的<code>clean</code>文件是最新的，所以到最后你的命令不会被执行。这就是为什么我们要用到伪目标：  </p>
<p>通过<code>.PHONY</code>声明<code>clean</code>和<code>tar</code>是一个伪目标，即便真的有一个最新的同名文件，你的命令也会被执行。  </p>
<p><br></p>
<hr>
<p>不如来看个最终示例如何：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FLAGS = -pedantic-errors -std=c++11 </span><br><span class="line"> </span><br><span class="line"><span class="section">gcd.o: gcd.cpp gcd.h </span></span><br><span class="line">      g++ <span class="variable">$(FLAGS)</span> -c <span class="variable">$&lt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="section">gcd_main.o: gcd_main.cpp gcd.h </span></span><br><span class="line">      g++ <span class="variable">$(FLAGS)</span> -c <span class="variable">$&lt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="section">gcd_main: gcd.o gcd_main.o </span></span><br><span class="line">      g++ <span class="variable">$(FLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> </span><br><span class="line"> </span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">      rm -f gcd_main gcd.o gcd_main.o gcd.tgz </span><br><span class="line"> </span><br><span class="line"><span class="section">tar: </span></span><br><span class="line">      tar -czvf gcd.tgz *.cpp *.h </span><br><span class="line"> </span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean tar</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">Makefile gcd.cpp gcd.h gcd_main.cpp</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make gcd_main</span><br><span class="line">g++ -pedantic-errors -std=c++11 -c gcd.cpp </span><br><span class="line">g++ -pedantic-errors -std=c++11 -c gcd_main.cpp </span><br><span class="line">g++ -pedantic-errors -std=c++11 gcd.o gcd_main.o -o gcd_main</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">Makefile  gcd_main  gcd.cpp  gcd.h  gcd.o  gcd_main.cpp  gcd_main.o </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make tar </span><br><span class="line">tar -czvf gcd.tgz *.cpp *.h </span><br><span class="line">gcd.cpp </span><br><span class="line">gcd_main.cpp </span><br><span class="line">gcd.h</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">Makefile  gcd_main  gcd.cpp  gcd.h  gcd.o  gcd.tgz  gcd_main.cpp  gcd_main.o </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make clean </span><br><span class="line"><span class="built_in">rm</span> -f gcd_main gcd.o gcd_main.o gcd.tgz </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">Makefile  gcd.cpp  gcd.h  gcd_main.cpp </span><br></pre></td></tr></table></figure>
<p>到这里这一小节完结。  </p>
<p>CMake更强大，能够用来生成<code>Makefile</code>，不过暂且不表。</p>
<p><br></p>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>ENGG1340笔记</p><p><a href="http://naughtychas.github.io/2025/01/25/ENGG1340笔记/">http://naughtychas.github.io/2025/01/25/ENGG1340笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://NaughtyChas.github.io"><p>ntcs</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-01-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-03-18</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2024/12/11/Exam%20Notes%20for%20ENGG1330/" target="_blank" rel="noreferrer">Exam Notes for ENGG 1330</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/" target="_blank" rel="noreferrer">邈想日集</a><br></span><span>  2.<a class="is-size-6" href="/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ENGG1340笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/" target="_blank" rel="noreferrer">浅谈今年CAIE的POE考试</a><br></span><span>  6.<a class="is-size-6" href="/2022/09/05/%E4%BD%A0%E8%AF%B4%E5%BE%97%E5%AF%B9/" target="_blank" rel="noreferrer">收集&quot;你说得对&quot;</a><br></span></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/12/11/Exam%20Notes%20for%20ENGG1330/"><span class="level-item">Exam Notes for ENGG 1330</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://giscus.app/client.js" data-repo="NaughtyChas/NaughtyChas.github.io" data-repo-id="R_kgDOHzXKqQ" data-category="Announcements" data-category-id="DIC_kwDOHzXKqc4CmXAk" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#前言"><span class="mr-2">1</span><span>前言</span></a></li><li><a class="is-flex is-mobile" href="#Module-1-Linux-Environment"><span class="mr-2">2</span><span>Module 1: Linux Environment</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Linux-Shell"><span class="mr-2">2.1</span><span>Linux Shell</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#命令使用说明"><span class="mr-2">2.1.1</span><span>命令使用说明</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#路径和文件管理"><span class="mr-2">2.2</span><span>路径和文件管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#相对路径和绝对路径"><span class="mr-2">2.2.1</span><span>相对路径和绝对路径</span></a></li><li><a class="is-flex is-mobile" href="#主目录"><span class="mr-2">2.2.2</span><span>主目录</span></a></li><li><a class="is-flex is-mobile" href="#重命名路径"><span class="mr-2">2.2.3</span><span>重命名路径</span></a></li><li><a class="is-flex is-mobile" href="#复制文件"><span class="mr-2">2.2.4</span><span>复制文件</span></a></li><li><a class="is-flex is-mobile" href="#命令模式下的命令"><span class="mr-2">2.2.5</span><span>命令模式下的命令</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文件权限"><span class="mr-2">2.3</span><span>文件权限</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#权限指示"><span class="mr-2">2.3.1</span><span>权限指示</span></a></li><li><a class="is-flex is-mobile" href="#举例"><span class="mr-2">2.3.2</span><span>举例</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#其他常用命令"><span class="mr-2">2.4</span><span>其他常用命令</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#文件内搜索-grep"><span class="mr-2">2.4.1</span><span>文件内搜索 (grep)</span></a></li><li><a class="is-flex is-mobile" href="#文件字数-wc"><span class="mr-2">2.4.2</span><span>文件字数 (wc)</span></a></li><li><a class="is-flex is-mobile" href="#排序"><span class="mr-2">2.4.3</span><span>排序</span></a></li><li><a class="is-flex is-mobile" href="#剪切文件"><span class="mr-2">2.4.4</span><span>剪切文件</span></a></li><li><a class="is-flex is-mobile" href="#移除重复行"><span class="mr-2">2.4.5</span><span>移除重复行</span></a></li><li><a class="is-flex is-mobile" href="#拼写检查"><span class="mr-2">2.4.6</span><span>拼写检查</span></a></li><li><a class="is-flex is-mobile" href="#文件差异"><span class="mr-2">2.4.7</span><span>文件差异</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#标准I-O，文件重定向和管道"><span class="mr-2">2.5</span><span>标准I/O，文件重定向和管道</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#管线"><span class="mr-2">2.5.1</span><span>管线</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#搜索"><span class="mr-2">2.6</span><span>搜索</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#搜索文件或路径-find"><span class="mr-2">2.6.1</span><span>搜索文件或路径 (find)</span></a></li><li><a class="is-flex is-mobile" href="#其他常用匹配写法"><span class="mr-2">2.6.2</span><span>其他常用匹配写法</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#Module-2-Shell-Script-amp-Version-Control"><span class="mr-2">3</span><span>Module 2: Shell Script &amp; Version Control</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Shell脚本"><span class="mr-2">3.1</span><span>Shell脚本</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#命令替换"><span class="mr-2">3.1.1</span><span>命令替换</span></a></li><li><a class="is-flex is-mobile" href="#获取控制台参数数量"><span class="mr-2">3.1.2</span><span>获取控制台参数数量</span></a></li><li><a class="is-flex is-mobile" href="#for循环"><span class="mr-2">3.1.3</span><span>for循环</span></a></li><li><a class="is-flex is-mobile" href="#输出到标准错误"><span class="mr-2">3.1.4</span><span>输出到标准错误</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#版本控制"><span class="mr-2">3.2</span><span>版本控制</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#提交更改"><span class="mr-2">3.2.1</span><span>提交更改</span></a></li><li><a class="is-flex is-mobile" href="#从远程仓库拉取"><span class="mr-2">3.2.2</span><span>从远程仓库拉取</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#Module-3-C-Basics"><span class="mr-2">4</span><span>Module 3: C++ Basics</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#C-基本语法和程序结构"><span class="mr-2">4.1</span><span>C++基本语法和程序结构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#注释"><span class="mr-2">4.1.1</span><span>注释</span></a></li><li><a class="is-flex is-mobile" href="#头文件引用"><span class="mr-2">4.1.2</span><span>头文件引用</span></a></li><li><a class="is-flex is-mobile" href="#main函数"><span class="mr-2">4.1.3</span><span>main函数</span></a></li><li><a class="is-flex is-mobile" href="#基本输入输出"><span class="mr-2">4.1.4</span><span>基本输入输出</span></a></li><li><a class="is-flex is-mobile" href="#变量和数据类型"><span class="mr-2">4.1.5</span><span>变量和数据类型</span></a></li><li><a class="is-flex is-mobile" href="#常量"><span class="mr-2">4.1.6</span><span>常量</span></a></li><li><a class="is-flex is-mobile" href="#运算顺序"><span class="mr-2">4.1.7</span><span>运算顺序</span></a></li><li><a class="is-flex is-mobile" href="#显式转换"><span class="mr-2">4.1.8</span><span>显式转换</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#程序编译与运行"><span class="mr-2">4.2</span><span>程序编译与运行</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#g-编译器"><span class="mr-2">4.2.1</span><span>g++编译器</span></a></li><li><a class="is-flex is-mobile" href="#阅读错误信息"><span class="mr-2">4.2.2</span><span>阅读错误信息</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#控制流"><span class="mr-2">4.3</span><span>控制流</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#switch语句"><span class="mr-2">4.3.1</span><span>switch语句</span></a></li><li><a class="is-flex is-mobile" href="#for循环-1"><span class="mr-2">4.3.2</span><span>for循环</span></a></li><li><a class="is-flex is-mobile" href="#continue"><span class="mr-2">4.3.3</span><span>continue</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#函数"><span class="mr-2">4.4</span><span>函数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#怎么定义-使用函数？"><span class="mr-2">4.4.1</span><span>怎么定义/使用函数？</span></a></li><li><a class="is-flex is-mobile" href="#函数声明"><span class="mr-2">4.4.2</span><span>函数声明</span></a></li><li><a class="is-flex is-mobile" href="#函数参数"><span class="mr-2">4.4.3</span><span>函数参数</span></a></li><li><a class="is-flex is-mobile" href="#返回值"><span class="mr-2">4.4.4</span><span>返回值</span></a></li><li><a class="is-flex is-mobile" href="#生命周期"><span class="mr-2">4.4.5</span><span>生命周期</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#数组"><span class="mr-2">4.5</span><span>数组</span></a></li><li><a class="is-flex is-mobile" href="#杂七杂八"><span class="mr-2">4.6</span><span>杂七杂八</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#引用传递"><span class="mr-2">4.6.1</span><span>引用传递</span></a></li><li><a class="is-flex is-mobile" href="#指针传递"><span class="mr-2">4.6.2</span><span>指针传递</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#Module-4-Makefile-Programming-Style-Basic-Debugging"><span class="mr-2">5</span><span>Module 4: Makefile, Programming Style, Basic Debugging</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Makefile"><span class="mr-2">5.1</span><span>Makefile</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#分开编译-Separate-Compilation"><span class="mr-2">5.1.1</span><span>分开编译 (Separate Compilation)</span></a></li><li><a class="is-flex is-mobile" href="#Make工具-Make-Tool"><span class="mr-2">5.1.2</span><span>Make工具 (Make Tool)</span></a></li></ul></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a><p class="size-small"><span>&copy; 2025 ntcs</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noreferrer">Icarus</a> &amp; <a href="https://github.com/LittleYe233/hexo-theme-amazingremake" target="_blank" rel="noreferrer">Amazing-Remake</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022.8.11 17:07:12')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/LittleYe233/hexo-theme-amazingremake"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    enabled: true,
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { // 加载mathjax
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    autoload: {
                        color: [],
                        colorv2: ['color']
                    },
                    packages: {'[+]': ['noerrors']}
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                },
                loader: {
                    load: ['input/asciimath', '[tex]/noerrors']
                }
            };
            $.getScript('//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('undefined','undefined','undefined','undefined',undefined);});
            }
            if('undefined' === 'mathjax'){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>