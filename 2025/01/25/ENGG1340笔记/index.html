<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>ENGG1340笔记 - ntcs&#039; blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ntcs&#039; blog"><meta name="msapplication-TileImage" content="img/icon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ntcs&#039; blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="自学ENGG1340写的笔记"><meta property="og:type" content="article"><meta property="og:title" content="ENGG1340笔记"><meta property="og:url" content="http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="ntcs&#039; blog"><meta property="og:description" content="自学ENGG1340写的笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB3d38757cff77704b4b626c7e77a8299a?method=download&amp;amp;shareKey=7d62b9dd7d9765da3fbbc8ff1020e3f9"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB2e57509e464b685521f221612db841b6?method=download&amp;amp;shareKey=980a26dccb73b17e40f57a8a8bbfb599"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEBfe2c1fb97579cb3ac7600cc5974e5bb8?method=download&amp;amp;shareKey=866755676c9de499cfa8e00e7cad5101"><meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEBed6b622ab401c9305753c7e2623a767f?method=download&amp;amp;shareKey=b90b1091d05ac2a4898119d43ae308e9"><meta property="article:published_time" content="2025-01-25T06:18:50.000Z"><meta property="article:modified_time" content="2025-02-06T16:55:07.070Z"><meta property="article:author" content="ntcs"><meta property="article:tag" content="笔记"><meta property="article:tag" content="计算机"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"},"headline":"ntcs' blog","image":[],"datePublished":"2025-01-25T06:18:50.000Z","dateModified":"2025-02-06T16:55:07.070Z","author":{"@type":"Person","name":"ntcs"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"自学ENGG1340写的笔记"}</script><link rel="canonical" href="http://naughtychas.github.io/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/icon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/&gt; all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="ntcs' blog" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-01-25  <a class="commentCountImg" href="/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">/2025/01/25/ENGG1340笔记/</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="81cf628bb0f4d3d5adbb6fdbb4cc8f4a">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>17.6 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">ENGG1340笔记</h1><div class="content"><blockquote>
<p>自学ENGG1340写的笔记<br><span id="more"></span></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>惊讶的发现这学期ENGG1340是自学课，没有Lecture。讲道理挺舒服的。</p>
<p>ENGG1340期望你拥有Python编程知识作为基础，然后逐渐引入更深层的新内容，包括Linux / Bash Shell，版本控制（Git），C/C++语言等。</p>
<p>叠甲先：笔记可能出错所以轻喷。内容是根据课上发的笔记转写的，所以本文算是个人梳理吧</p>
<hr>
<h1 id="Module-1-Linux-Environment"><a href="#Module-1-Linux-Environment" class="headerlink" title="Module 1: Linux Environment"></a>Module 1: Linux Environment</h1><p>Linux如同Windows一样是操作系统。Linux是开源的，这导致Linux相较于其他操作系统拥有更多长处，例如：可自定义程度较强，安全性也比较高（因为你可以直接读到源代码）。<br>因为Linux是开源的，所以使用Linux也是免费的。在一些相对低价的电子产品上，使用Linux作为操作系统就很划算。</p>
<p>Linux存在不同的发行版，例如Ubuntu, CentOS, Debian等。</p>
<p>在ENGG1340中我们将会使用Ubuntu，虽然现阶段不同发行版不会对课程大纲产生太多影响。</p>
<hr>
<h2 id="Linux-Shell"><a href="#Linux-Shell" class="headerlink" title="Linux Shell"></a>Linux Shell</h2><p>Shell 是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Linux中有不同种类的shell，比如Korn Shell, Bourne Shell, C Shell，以及Bash Shell。<br>不同的Shell之间命令可能有些许区别，例如Korn Shell使用<code>print</code>命令输出一个字符串，而Bash Shell使用<code>echo</code>命令。</p>
<p>在ENGG1340里我们主要使用Bash Shell。</p>
<hr>
<h3 id="Shell-Commands"><a href="#Shell-Commands" class="headerlink" title="Shell Commands"></a>Shell Commands</h3><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>向命令行中输入<code>date</code>，Shell会返回当前系统的时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Sat Jan 25 14:51:19 HKT 2025</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="文件与路径操作"><a href="#文件与路径操作" class="headerlink" title="文件与路径操作"></a>文件与路径操作</h4><p><code>ls</code>命令列举当前目录下的所有文件和路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span> </span><br><span class="line">Documents/  logon.bat*  public_html/  t.txt  Downloads/ </span><br><span class="line">Pictures/  Templates/    </span><br><span class="line">Videos/    </span><br><span class="line">Music/      </span><br><span class="line">Desktop/  engg1340/ </span><br><span class="line">Public/    </span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>命令变体</strong>：</p>
<ul>
<li><code>ls -l</code>  以长字符方式输出，包含额外信息如文件大小，文件拥有者，上次编辑日期等</li>
<li><code>ls -a</code>  输出路径下所有内容，包含隐藏的文件和目录。隐藏的内容会以一点开头<code>.</code>。</li>
<li><code>ls -la</code>  就是<code>ls -l -a</code></li>
</ul>
</blockquote>
<hr>
<p><code>cd</code>命令用来重定向当前目录。例如我们想要访问当前目录下的engg1340路径，直接敲<code>cd engg1340</code>就行：</p>
<blockquote>
<p>命令变体：<br><code>cd ..</code> 前往当前目录的父级路径<br><code>cd ~</code>  前往当前用户的主目录<br><code>cd ~username</code>  前往指定用户的主目录<br><code>cd .</code> 前往当前目录 （虽说没啥效果就是了）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> engg1340</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span> </span><br><span class="line">lab1/  lab2/  lab3/ </span><br></pre></td></tr></table></figure>
<hr>
<p><code>pwd</code>命令将会输出当前的工作目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/home/d003/h978645312</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h4><p>Shell里面有许多命令，能将所有命令记住基本上是不现实的。因此，Shell提供了<code>man</code>命令（Manual的缩写），能够返回命令的详细解释。</p>
<p>例如我想要查看ls命令的详细解释，就可以使用<code>man ls</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LS(1)                                               User Commands                                               LS(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       ls - list directory contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       ls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       List  information  about the FILEs (the current directory by default).  Sort entries alphabetically if none of</span><br><span class="line">       -cftuvSUX nor --sort is specified.</span><br><span class="line"></span><br><span class="line">       Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line"></span><br><span class="line">       -a, --all</span><br><span class="line">              do not ignore entries starting with .</span><br><span class="line"></span><br><span class="line">       -A, --almost-all</span><br><span class="line">              do not list implied . and ..</span><br><span class="line"></span><br><span class="line">       --author</span><br><span class="line">              with -l, print the author of each file</span><br><span class="line"></span><br><span class="line">       -b, --escape</span><br><span class="line">              print C-style escapes for nongraphic characters</span><br><span class="line"></span><br><span class="line">       --block-size=SIZE</span><br><span class="line">              with -l, scale sizes by SIZE when printing them; e.g., '--block-size=M'; see SIZE format below</span><br><span class="line"></span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line"></span><br><span class="line">        -l     use a long listing format</span><br><span class="line"></span><br><span class="line"> Manual page ls(1) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure>
<p>从NAME区域我们可以得知<code>ls</code>的解释为”list directory contents”。<br>从DESCRIPTION区域得知，如果在ls后面加入可选参数<code>-l</code>，代表”use a long listing format”。这会在普通<code>ls</code>的基础上显示更多信息，包括文件大小，文件拥有者，上次编辑日期等等：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 26044</span><br><span class="line">drwxr-xr-x 17 1000 1000     4096 Nov  4 01:17 Python-3.11.0</span><br><span class="line">-rw-r--r--  1 root root 26333656 Oct 24  2022 Python-3.11.0.tgz</span><br><span class="line">drwxr-xr-x  4 root root     4096 Nov  1 13:25 napcat</span><br><span class="line">-rw-------  1 root root   317274 Nov  4 01:38 nohup.out</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="路径和文件管理"><a href="#路径和文件管理" class="headerlink" title="路径和文件管理"></a>路径和文件管理</h2><p>在Linux中根目录用<code>/</code>表示。根目录包含所有的文件和路径。</p>
<p>例如在根目录下有一个”home”路径，”home”下有另一个路径”kit”，那么这个”kit”路径的绝对路径就是：<code>/home/kit</code></p>
<p>有关相对路径和绝对路径的内容一会介绍。</p>
<hr>
<h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>绝对路径总是以<code>/</code>打头。举几个简单的例子：</p>
<ul>
<li><code>/home/file3</code>是在home路径下的文件file3的绝对路径。</li>
<li><code>/home/kit/Desktop/file4</code>是file4的绝对路径。</li>
</ul>
<p>而相对路径和当前的工作目录有联系，相对路径不会以<code>/</code>打头。</p>
<p>例如我们使用上面的file3做例子，如果当前的工作目录为<code>/home</code>，则file3的相对路径为<code>file3</code>。注意看刚才这个file3的路径不以<code>/</code>打头，所以能判断出这是一个相对路径。</p>
<p>file4同理。如果当前工作目录是<code>/home/kit</code>，那么file4的相对路径就是<code>Desktop/file4</code>。</p>
<hr>
<p>如果目录A包含另一个目录B，则A称为B的父目录，B称为A的子目录。例如在刚才的例子中，kit是home的子目录，home是kit的父目录。</p>
<p>一旦shell启动，它当前的工作目录就是主目录。我们总是可以通过命令pwd获得当前的工作目录。</p>
<hr>
<h3 id="主目录"><a href="#主目录" class="headerlink" title="主目录"></a>主目录</h3><p>对于任何用户，都有一个属于该用户的主目录。例如，用户 kit 的主目录位于<code>/home/kit</code></p>
<p><code>~</code>用来表示用户的主目录。你可以使用<code>cd ~</code>命令回到当前用户的主目录，也可以使用<code>cd ~username</code>来前往其他用户的主目录。</p>
<h3 id="路径管理"><a href="#路径管理" class="headerlink" title="路径管理"></a>路径管理</h3><h4 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h4><p><code>mkdir</code>命令可以用来创建路径   <del>新建文件夹</del></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> lab</span></span><br></pre></td></tr></table></figure>
<p>上面的命令会在当前的工作目录下创建一个lab路径。</p>
<p>如果你想在当前工作目录下创建多个路径，可以直接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> lab1 lab2</span></span><br></pre></td></tr></table></figure>
<p>如果想在路径名中包括空格，可以在创建路径时将路径名用引号引起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="string">"lab 1"</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="移除路径"><a href="#移除路径" class="headerlink" title="移除路径"></a>移除路径</h4><p><code>rmdir</code>命令可以用来移除空路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> lab</span></span><br></pre></td></tr></table></figure>
<p>如果想要移除的路径不是空路径，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab1</span></span><br><span class="line">file1.txt  file2.txt</span><br></pre></td></tr></table></figure>
<p>就需要使用<code>rm -rf</code>或者<code>rm -r -f</code>来移除整个路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -r -f lab1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab1</span></span><br><span class="line">ls: cannot access 'lab1': No such file or directory</span><br></pre></td></tr></table></figure>
<p>可以看到路径被成功移除了。</p>
<p><code>-r</code>参数代表系统会按照递归方式向下遍历目标路径下的文件和路径，而<code>-f</code>可以确保删除过程不需要你来进行确认。如果当前路径下文件巨多，不带<code>-f</code>就会很麻烦了。</p>
<hr>
<h4 id="重命名路径"><a href="#重命名路径" class="headerlink" title="重命名路径"></a>重命名路径</h4><p><code>mv</code>命令虽然叫move，但是也可以用来重命名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> lab <span class="string">"lab 1"</span></span></span><br></pre></td></tr></table></figure>
<p>这个命令会把<code>lab</code>路径重命名至<code>lab 1</code>。</p>
<p>如果<code>mv</code>命令下第一个参数和第二个参数的类型一致，例如参数1和参数2都是文件类型，则该命令会将参数1重命名至参数2。</p>
<hr>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p><code>touch</code>命令可以用来创建一个空文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file1.txt</span></span><br></pre></td></tr></table></figure>
<p>可以创建一个名叫”file1.txt”的空文件。</p>
<hr>
<h4 id="展示文件内容"><a href="#展示文件内容" class="headerlink" title="展示文件内容"></a>展示文件内容</h4><p><code>cat</code>，命令可以用来展示文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1.txt</span></span><br><span class="line">Hello, this is the content of file1.txt</span><br><span class="line">Bye Bye!</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p><code>mv</code>命令也可以用来移动文件或者路径位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hello.txt mydir</span></span><br></pre></td></tr></table></figure>
<p>好比说这串命令会将hello.txt移动到<code>mydir</code>路径下。</p>
<p>如果文件拥有同样的前缀，你可以使用星号(<em>)来选中所有符合条件的项。<br>例如：将所有拥有“ <em>*myfile</em></em> ”前缀的文件移动到lab路径下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">myfile1.txt  myfile2.txt lab/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> myfile* lab</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">lab/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lab</span></span><br><span class="line">myfile1.txt  myfile2.txt</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p>除此之外还有其他关于文件操作的命令集合：</p>
<p><code>cp</code> 命令用于复制文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> file1 file2</span></span><br></pre></td></tr></table></figure>
<p>会将”file1”复制至”file2”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r dir1 dir2</span></span><br></pre></td></tr></table></figure>
<p>会将<code>dir1</code>路径包括路径下的所有内容复制到dir2中。</p>
<hr>
<h3 id="使用vi编辑器"><a href="#使用vi编辑器" class="headerlink" title="使用vi编辑器"></a>使用vi编辑器</h3><p>vi编辑器用来创建并编辑文本。就好比Windows上的记事本，或Linux上的gedit，但是他没有图形用户界面，完全在命令行中使用。</p>
<p>vi编辑器中有两个功能：</p>
<ol>
<li>插入模式(Insert mode)：在这个模式中你可以编辑文件内容</li>
<li>命令模式(Command mode)：命令模式用来执行文件操作，比如保存文件等</li>
</ol>
<p>要使用vi编辑器打开一个文件，只需要敲入<code>vi</code>命令即可。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi file2.txt</span></span><br></pre></td></tr></table></figure>
<p>将会打开工作目录下的”file2.txt”文件。如果该文件不存在，编辑器会帮你自动创建一个。</p>
<p>!()[<a target="_blank" rel="noopener" href="https://note.youdao.com/yws/api/personal/file/WEB851884414ef36fe09b4feda45b512323?method=download&amp;shareKey=cbca8ca352f134b3e06ba8e53e65b13c">https://note.youdao.com/yws/api/personal/file/WEB851884414ef36fe09b4feda45b512323?method=download&amp;shareKey=cbca8ca352f134b3e06ba8e53e65b13c</a>]</p>
<p>进入vi编辑器后默认为命令模式。因为我们的路径下没有file2.txt，如你所见编辑器目前显示的是空白文件。</p>
<p><strong>按”I”键切换至插入模式</strong>。当你在插入模式时，你可以在界面的左下角看到<code>-- INSERT --</code>：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB95b622f6c06e6eedb9be9e614f57adfd?method=download&amp;shareKey=2036e5e9da9576ca52eb2934bf7a4909" alt=""></p>
<p>在插入模式中你可以按照我们熟悉的样子编辑文件。如果编辑完成想要保存文件，则需要退回至命令模式。</p>
<p>在插入模式时，<strong>按”esc”以回到命令模式</strong>。当你回到命令模式后，你将不会再左下角看到<code>-- INSERT --</code>字样。这时输入<code>:wq</code>并按下Enter，你会退出vi编辑器，同时你的文件会被保存。</p>
<hr>
<h4 id="命令模式下的命令"><a href="#命令模式下的命令" class="headerlink" title="命令模式下的命令"></a>命令模式下的命令</h4><p>除了“保存并关闭”(<code>:wq</code>)命令外，还有下面这些常见命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">执行的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>:wq</code></td>
<td style="text-align:center">保存并退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:w</code></td>
<td style="text-align:center">保存（但不退出vi编辑器）</td>
</tr>
<tr>
<td style="text-align:center"><code>:w filename</code></td>
<td style="text-align:center">保存到名叫”filename”的新文件下</td>
</tr>
<tr>
<td style="text-align:center"><code>:q</code></td>
<td style="text-align:center">退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:q!</code></td>
<td style="text-align:center">不保存并退出vi编辑器</td>
</tr>
</tbody>
</table>
</div>
<p>想要查阅完整的命令列表的话<a target="_blank" rel="noopener" href="https://www.cs.colostate.edu/helpdocs/vi.html">点我</a></p>
<p>或者你也可以查阅这张Cheatsheet：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3d38757cff77704b4b626c7e77a8299a?method=download&amp;shareKey=7d62b9dd7d9765da3fbbc8ff1020e3f9" alt="Cheatsheet"></p>
<hr>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>Linux系统中的每个文件或目录都被分配了3种类型的所有者。</p>
<ul>
<li><strong>用户（User）</strong>：用户可以作为文件的拥有者</li>
<li><strong>用户组（Group）</strong>：用户组中可以包含多个用户。若用户组拥有一个文件的权限，则组中的每个用户都有该文件的权限。</li>
<li><strong>其他（Other）</strong>：有权访问文件的任何其他用户。它既没有创建文件，也不属于拥有该文件的组。</li>
</ul>
<p>每个用户对于上面的三种所有者定义了三种不同的文件权限：</p>
<ul>
<li><strong>读取（Read）</strong>：拥有文件读取权限的个体可以打开并读取文件中的内容。拥有路径读取权限的个体可以列举出该路径下的内容。</li>
<li><strong>写入（Write）</strong>：拥有文件写入权限的个体可以更改文件中的内容。拥有路径读取权限的个体可以在路径中添加，移除或者重命名内容。</li>
<li><strong>执行（Execute）</strong>：执行权限允许个体来运行程序</li>
</ul>
<hr>
<p>不如举个例子看看：使用之前提到过的<code>ls -l</code>命令来列举出路径下的内容，里面会告诉你文件权限的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 10</span><br><span class="line">-rw------- 1 cklai ra 50 Jul 30 17:07 file1.txt</span><br><span class="line">-rw------- 1 cklai ra 48 Jul 31 15:14 file2.txt</span><br><span class="line">drwx------ 2 cklai ra  2 Jul 30 17:00 lab/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="权限指示"><a href="#权限指示" class="headerlink" title="权限指示"></a>权限指示</h3><p>借用上面的例子，我们来仔细讲讲刚才的输出是啥意思：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total 10</span><br><span class="line">-rw------- 1 cklai ra 50 Jul 30 17:07 file1.txt</span><br></pre></td></tr></table></figure>
<p><code>total 10</code>代表文件在文件系统中占用了多大空间，单位为千字节（kilobytes）。<br>由左至右分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">条目</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-rw-------</code></td>
<td style="text-align:center">代表<strong>文件权限</strong>。具体的释义马上就解释（</td>
</tr>
<tr>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center">代表<strong>文件拥有的硬链接数量</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>cklai</code></td>
<td style="text-align:center">代表<strong>文件拥有者</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>ra</code></td>
<td style="text-align:center">文件拥有者存在的用户组</td>
</tr>
<tr>
<td style="text-align:center"><code>50</code></td>
<td style="text-align:center"><strong>文件大小</strong>，单位为字节（byte）</td>
</tr>
<tr>
<td style="text-align:center"><code>Jul 23 17:07</code></td>
<td style="text-align:center"><strong>上次修改时间</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>file1.txt</code></td>
<td style="text-align:center"><strong>文件名</strong></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>现在我们来讲讲权限指示该怎么解读。<br>权限指示（Permission indicator）是一个十字符长的字符串，通常分为四部分：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e57509e464b685521f221612db841b6?method=download&amp;shareKey=980a26dccb73b17e40f57a8a8bbfb599" alt=""></p>
<p>这玩意可以分成四部分解读，<strong>Type</strong>, <strong>User permissions</strong>, <strong>Group permission</strong>和<strong>Other permission</strong>。</p>
<hr>
<p><strong>Type</strong>:</p>
<p>代指权限指示的第一个字符。</p>
<ul>
<li>如果第一个字符是<strong>短横线 “-“</strong>，则代表它是一个<strong>正常文件</strong>。</li>
<li>如果第一个字符是<strong>字母d “d”</strong>，则代表这是一个路径。</li>
</ul>
<p>还有其他的类型不过这里涵盖不到。可以自己上网查询。</p>
<hr>
<p><strong>User permissions</strong></p>
<p>第2-4个字符表示用户的权限。三个位置会显示”r”, “w”或者”x”。</p>
<p>比如这里显示了”rw-“，就代表：</p>
<ul>
<li>可以读取文件 (read, r)</li>
<li>可以写入文件 (write, w)</li>
<li>但是<em>不能</em>执行文件。如果文件可以被执行，第三个位置会显示”x”</li>
</ul>
<hr>
<p><strong>Group permission</strong></p>
<p>5-7个字符表示了用户组的权限。同样用rwx表示权限。</p>
<hr>
<p><strong>Other permission</strong></p>
<p>最后三位表示了文件对其他所有人的权限。</p>
<p>如果显示”—-“，则表示其他人都不可以读取(r)，写入(w)，并且也不能执行(x)</p>
<hr>
<h3 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h3><p>你可以使用<code>chmod</code>命令来更改你拥有的文件或者路径的权限：</p>
<p><code>chmod</code>命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> [<span class="built_in">who</span>][operator][permissions] filename</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>who</code></li>
</ul>
<p>在参数<code>who</code>内，可以键入四个不同的字母来指定要更改的对象群体：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>u</strong></td>
<td style="text-align:center">指定<strong>用户</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>g</strong></td>
<td style="text-align:center">指定<strong>用户组</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>o</strong></td>
<td style="text-align:center">指定<strong>其他</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>a</strong></td>
<td style="text-align:center">指定<strong>所有群体</strong>的权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<ul>
<li><code>operator</code></li>
</ul>
<p>在参数<code>operator</code>内，共有三个运算符，用来代指具体的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>+</strong></td>
<td style="text-align:center"><strong>增加</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>-</strong></td>
<td style="text-align:center"><strong>移除</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>=</strong></td>
<td style="text-align:center"><strong>设定</strong>权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<ul>
<li><code>permission</code></li>
</ul>
<p>在参数<code>permission</code>内，就是我们熟悉的r, w和x了。这些参数用指定要用来增加或者减少的权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>r</strong></td>
<td style="text-align:center"><strong>读取</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>w</strong></td>
<td style="text-align:center"><strong>写入</strong>权限</td>
</tr>
<tr>
<td style="text-align:center"><strong>x</strong></td>
<td style="text-align:center"><strong>运行</strong>权限</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><strong>Example 1：更改权限</strong></p>
<p>在Linux中，可以首先使用<code>touch</code>创建一个新文件。<code>touch</code>命令创建的文件对用户的默认权限为可读可写(rw-)。<br>想要更改权限，就可以使用<code>chmod</code>来指定文件的权限。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 26</span><br><span class="line">-rw------- 1 cklai ra   0 Aug  1 11:48 file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o+w file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">total 26</span><br><span class="line">-rw-----w- 1 cklai ra   0 Aug  1 11:48 file</span><br></pre></td></tr></table></figure>
<p>其中，<code>chmod o+w file</code>意思是对于其他用户(o)授予(+)写入(w)权限。</p>
<hr>
<p><strong>Example 2： 更改多个权限</strong></p>
<p>可以在<code>permission</code>参数内键入多个值来一次性设置多个权限。就刚才的例子往下继续：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">-rw-----w- 1 cklai ra   0 Aug  1 11:48 file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o+rx file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line">-rw----rwx 1 cklai ra   0 Aug  1 11:48 file*</span><br></pre></td></tr></table></figure>
<p><code>chmod o+rx file</code>的释义为：对其他用户(o)授予(+)读取(r)和运行(x)权限。</p>
<p>可以看到更新完权限后，文件名后面出现了一个星号”*”，这代表文件现在是可执行的。</p>
<hr>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p>这里会介绍很多新的命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>grep 'abc' file</code></td>
<td style="text-align:left">返回在文件中包含”abc”的行。可以使用更高级的描述来实现更复杂的搜索。</td>
</tr>
<tr>
<td style="text-align:center"><code>cut -d, -f2 file</code></td>
<td style="text-align:left">返回特定的数据列。<br>它根据标志-d指定的定界符分隔每行，并返回标志-f指定的列（字段编号从1开始）。</td>
</tr>
<tr>
<td style="text-align:center"><code>diff file1 file2</code></td>
<td style="text-align:left">显示两个文件的区别。</td>
</tr>
<tr>
<td style="text-align:center"><code>wc file</code></td>
<td style="text-align:left">返回文件中的行数，字数和字符数。</td>
</tr>
<tr>
<td style="text-align:center"><code>sort file</code></td>
<td style="text-align:left">按照字母顺序将文件中的每行进行排序</td>
</tr>
<tr>
<td style="text-align:center"><code>uniq file</code></td>
<td style="text-align:left">用于删除相邻的重复行，最后只会留下一个重复行。</td>
</tr>
<tr>
<td style="text-align:center"><code>spell file</code></td>
<td style="text-align:left">检查文件中所有的拼写错误。</td>
</tr>
<tr>
<td style="text-align:center"><code>su</code></td>
<td style="text-align:left">将用户模式更改为超级用户模式。</td>
</tr>
<tr>
<td style="text-align:center"><code>yum install prog</code><br>或者<br><code>apt-get install prog</code></td>
<td style="text-align:left">这个命令会链接特定服务器来下载并安装程序。<br>一般来讲你需要先运行<code>su</code>才能使用这些命令来安装程序。</td>
</tr>
<tr>
<td style="text-align:center"><code>man cmd</code></td>
<td style="text-align:left">显示命令<code>cmd</code>的手册页。找到使用命令的其他选项对您非常有用。</td>
</tr>
</tbody>
</table>
</div>
<p>接下来我们会细致介绍这些命令的用法</p>
<hr>
<h3 id="文件内搜索-grep"><a href="#文件内搜索-grep" class="headerlink" title="文件内搜索 (grep)"></a>文件内搜索 (grep)</h3><p><code>grep</code>命令适用于搜索文件内的行。</p>
<p>例如这里有一个”<em>example1.txt</em>“文件包含如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 Apple 3.5</span><br><span class="line">4 Chicken 50</span><br><span class="line">1 Coke 5.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">3 Chocolate 15</span><br><span class="line">2 Milk 8</span><br></pre></td></tr></table></figure>
<p>运行下面的命令将会返回文件内所有包含”ke”的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'ke'</span> example1.txt</span></span><br><span class="line">4 Chicken 50</span><br><span class="line">1 Coke 5.5</span><br></pre></td></tr></table></figure>
<p>搜索是很大的一块内容。这里仅用来介绍。后面我们会在搜索章节一起将文件内文件外搜索一并讲清楚的。  </p>
<p><br></p>
<hr>
<h3 id="文件字数-wc"><a href="#文件字数-wc" class="headerlink" title="文件字数 (wc)"></a>文件字数 (wc)</h3><p>同样使用”example1.txt”作为例子：</p>
<p>运行该命令则会返回如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> example1.txt</span></span><br><span class="line"> 6 18 71 example1.txt</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>第一个数字代表<strong>行数</strong>，也就是文件共有六行</li>
<li>第二个数字代表<strong>词数</strong>，表明文件中有18个词</li>
<li>第三个数字代表<strong>文件大小</strong>，代指文件大小为71字节</li>
</ul>
<p>搭配参数<code>-l</code>使用可以仅仅返回行数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -l example1.txt</span></span><br><span class="line">6 example1.txt</span><br></pre></td></tr></table></figure>
<p>搭配参数<code>-w</code>使用可以仅仅返回词数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -w example1.txt</span></span><br><span class="line">18 example1.txt</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用<code>sort</code>命令来对文件内容排序。如果没有指定任何输入参数，则默认排序方式按照<strong>字母表顺序排列</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> example1.txt</span></span><br><span class="line">1 Coke 5.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br><span class="line">5 Apple 3.5</span><br></pre></td></tr></table></figure>
<p>你可以使用不同的传入参数来指定排序方法。例如：</p>
<ul>
<li>使用<code>-n</code>则按照数字顺序排序：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -n example1.txt</span></span><br><span class="line">1 Coke 5.5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br><span class="line">5 Apple 3.5</span><br><span class="line">10 Jelly 5</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-r</code>则按照倒序顺序排序:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -n -r example1.txt</span></span><br><span class="line">10 Jelly 5</span><br><span class="line">5 Apple 3.5</span><br><span class="line">4 Chicken 50</span><br><span class="line">3 Chocolate 15</span><br><span class="line">2 Milk 8</span><br><span class="line">1 Coke 5.5</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-k</code>则按照字段排序。需要注意排序字段ID从1开始，而不是0。</li>
</ul>
<p>例如，将文件按照第三个字段进行排序。在”example1.txt”中，每行最后的那组数字就是第三字段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -k3 -n example1.txt</span></span><br><span class="line">5 Apple 3.5</span><br><span class="line">10 Jelly 5</span><br><span class="line">1 Coke 5.5</span><br><span class="line">2 Milk 8</span><br><span class="line">3 Chocolate 15</span><br><span class="line">4 Chicken 50</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>-t</code>用来告诉排序程序，我们使用分隔符并非空格而是逗号。</li>
</ul>
<p>例如我们有一个”example1.txt”的变体，”example1_comma.txt”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example1_comma.txt</span></span><br><span class="line">5,Apple,3.5</span><br><span class="line">4,Chicken,50</span><br><span class="line">1,Coke,5.5</span><br><span class="line">10,Jelly,5</span><br><span class="line">3,Chocolate,15</span><br><span class="line">2,Milk,8</span><br></pre></td></tr></table></figure>
<p>需要在使用<code>sort</code>时加入参数<code>-t</code>来指定分隔符为逗号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -t, -k3 -n example1_comma.txt</span></span><br><span class="line">5,Apple,3.5 </span><br><span class="line">10,Jelly,5 </span><br><span class="line">1,Coke,5.5 </span><br><span class="line">2,Milk,8 </span><br><span class="line">3,Chocolate,15 </span><br><span class="line">4,Chicken,50</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="剪切文件"><a href="#剪切文件" class="headerlink" title="剪切文件"></a>剪切文件</h3><p>这里指的不是我们熟悉的剪切文件到其他目录，而是直接在文件内剪掉一部分内容。</p>
<p><code>cut</code>命令将会修剪文件并返回特定的内容。要使用这个命令，我们需要向<code>cut</code>命令指定分隔符。</p>
<p>指定分隔符的参数为<code>-d</code>，代表delimiter，注意不要和之前的<code>sort</code>命令搞混了！该参数不是可选的，即便分隔符为空格，你也需要指定参数<code>-d</code>。</p>
<p>使用参数<code>-f</code>来告诉程序你想要返回的字段，说白了就是列。和<code>sort</code>一样，字段ID从1开始而不是0。</p>
<p>例如，返回”example1.txt”文件内的第一字段和第三字段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d <span class="string">' '</span> -f 1,3 example1.txt</span></span><br><span class="line">5 3.5 </span><br><span class="line">4 50 </span><br><span class="line">1 5.5 </span><br><span class="line">10 5 </span><br><span class="line">3 15 </span><br><span class="line">2 8</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="移除重复行"><a href="#移除重复行" class="headerlink" title="移除重复行"></a>移除重复行</h3><p><code>uniq</code>命令删除相邻的重复行，只保留一个重复行。  </p>
<p>注意咯，它只删除相邻的重复项。</p>
<p>“example2.txt”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Apple </span><br><span class="line">Apple pie </span><br><span class="line">Apple pie </span><br><span class="line">Apple </span><br><span class="line">Apple </span><br><span class="line">Apple pie</span><br></pre></td></tr></table></figure>
<p>想要移除在”example2.txt”中多余的相邻重复行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uniq</span> example2.txt</span> </span><br><span class="line">Apple </span><br><span class="line">Apple pie </span><br><span class="line">Apple </span><br><span class="line">Apple pie</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h3><p><code>spell</code>命令返回文件中所有可能出现拼写错误的词：</p>
<p>“example3.txt”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">It's a beautiffful day!</span><br><span class="line">I am so happpy todday.</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spell example3.txt</span></span><br><span class="line">beautiffful </span><br><span class="line">happpy </span><br><span class="line">todday</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>如果你自己的Linux机子运行这个命令报错，那么你的系统很有可能没有安装需要的软件包。按照下面的步骤修复这个问题吧：</p>
<ol>
<li>切换到Superuser账号：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br></pre></td></tr></table></figure>
<p>还记得我们之前说过安装软件包之前需要切换到su账号吗</p>
<ol>
<li>安装<code>aspell</code>包：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install aspell</span></span><br></pre></td></tr></table></figure>
<ol>
<li>退回到你当前的账户：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件差异"><a href="#文件差异" class="headerlink" title="文件差异"></a>文件差异</h3><p><code>diff</code>命令用来显示两个文件的区别。</p>
<p>“fileA.txt”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>
<p>“fileB.txt”:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eee</span><br><span class="line">aaa</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure></p>
<p>下面的命令则会返回将”fileA.txt”转化为”fileB.txt”的步骤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff fileA.txt fileB.txt</span></span><br><span class="line">0a1 </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eee</span> </span><br><span class="line">2,3c3 </span><br><span class="line">&lt; bbb </span><br><span class="line">&lt; ccc</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ddd</span> </span><br></pre></td></tr></table></figure>
<p>这里我们需要一点解释了。</p>
<p><strong>0a1</strong>：  </p>
<p>在<em>fileA</em>的第<strong>0</strong>行之后添加(<strong>a</strong>, add)一行，添加的内容由下一行<strong>&gt; eee</strong>表示</p>
<p><strong>2, 3c3</strong>：  </p>
<p>将<em>fileA</em>中的第<strong>2, 3</strong>行变成(<strong>c</strong>, change)<em>fileB</em>的第三行。<br>完成这一步需要先删除掉两行，由<strong>&lt;</strong>表示：</p>
<p><strong>&lt; bbb</strong><br><strong>&lt; ccc</strong><br>代表删除掉这两行。</p>
<p>分割线隔开后出现了<strong>&gt;</strong>。这代表我们需要在删除后再次添加一行：</p>
<p><strong>&gt; ddd</strong></p>
<p>代表再添加文本”ddd”</p>
<p>这样就能把”fileA.txt”变成”fileB.txt”了。</p>
<hr>
<p>再举另一个例子把：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">diff fileB.txt fileA.txt</span> </span><br><span class="line">1d0 </span><br><span class="line">&lt; eee </span><br><span class="line">3c2,3 </span><br><span class="line">&lt; ddd </span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">bbb</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ccc</span> </span><br></pre></td></tr></table></figure>
<p>刚才是由A变B，现在是由B变A了。</p>
<p><strong>1d0</strong>：  </p>
<p>在<em>fileB</em>中删除(<strong>d</strong>, delete)第一行，随后的内容就会在第<strong>0</strong>行被对齐。</p>
<p><strong>&lt; eee</strong>表示我们删除了”eee”</p>
<p><strong>3c2,3</strong>：  </p>
<p>和刚才刚好反过来，将<em>fileB</em>中的第<strong>3</strong>行变为<em>fileA</em>的<strong>2,3</strong>行。先删去”ddd”，然后加入”bbb”和”ccc”</p>
<hr>
<h2 id="标准I-O，文件重定向和管道"><a href="#标准I-O，文件重定向和管道" class="headerlink" title="标准I/O，文件重定向和管道"></a>标准I/O，文件重定向和管道</h2><h3 id="标准IO和文件重定向"><a href="#标准IO和文件重定向" class="headerlink" title="标准IO和文件重定向"></a>标准IO和文件重定向</h3><h4 id="标准输入，输出和标准错误"><a href="#标准输入，输出和标准错误" class="headerlink" title="标准输入，输出和标准错误"></a>标准输入，输出和标准错误</h4><p>在Shell中使用命令时，Shell将每个进程与一些打开的文件关联起来，并使用称为<strong>文件描述符</strong> (File descriptors)的数字引用这些打开的文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件描述符</th>
<th style="text-align:left">文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">标准输入(stdin) - 输入文件</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">标准输出(stdout) - 输出文件</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">标准错误(stderr) - 输出错误的文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="重定向运算符"><a href="#重定向运算符" class="headerlink" title="重定向运算符"></a>重定向运算符</h4><p>一般来讲当我们执行命令时，输出会在屏幕上通过Shell打印出来。我们可以使用<strong>重定向运算符</strong> (Redirection operator) “<strong>&gt;</strong>“ 来重定向输出到一个文件内。  </p>
<p>例如，下面的命令将会保存路径中的文件到”file.txt”中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l 1&gt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>或者也可以用这样的短格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>如果使用了上述命令，则输出将不会显示在屏幕上，而是会被记录到文件”files.txt”中。当用来排查数据，debug或者就是简单保存信息时，这招很有用。</p>
<blockquote>
<p>如果多次执行上述命令，系统可能会显示”<strong>cannot overwrite existing file</strong>“。<br>为了解决这个问题，可以先手动删除已有的文件，或者使用<strong>&gt;|</strong>强制写入文件。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt;| files.txt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<hr>
<p>下面是一些常见的重定向运算符和他们的释义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>command 1&gt; file</code><br>或者<br><code>command &gt; file</code></td>
<td style="text-align:left">将标准输出<strong>发送到</strong> <em>file</em>中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 1&gt;&gt; file</code><br>或者<br><code>command &gt;&gt; file</code></td>
<td style="text-align:left">将标准输出<strong>追加到</strong> <em>file</em>中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 2&gt; file</code></td>
<td style="text-align:left">将标准错误<strong>发送到*</strong>file*中</td>
</tr>
<tr>
<td style="text-align:center"><code>command 2&gt;&gt; file</code></td>
<td style="text-align:left">将标准错误<strong>追加到*</strong>file*中</td>
</tr>
<tr>
<td style="text-align:center"><code>command &lt; fileA &gt; fileB 2&gt;fileC</code></td>
<td style="text-align:left">首先命令会从<em>fileA</em>中读取，执行后将输出发送到<em>fileB</em>，将标准错误发送到<em>fileC</em></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong>&gt;</strong>和<strong>&gt;&gt;</strong>的区别在于，”&gt;”将会在每次执行时覆盖文件内容，而”&gt;&gt;”则会在文件后面追加内容。</p>
<hr>
<p>如果我们这里有一个C++程序，我们也可以使用这样的运算符来进行操作。例如下面的程序”add.cpp”会由两个输入，将两个输入加起来之后获得一个输出：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="type">int</span> a;</span><br><span class="line">       <span class="type">int</span> b;</span><br><span class="line">       std::cin &gt;&gt; a;</span><br><span class="line">       std::cin &gt;&gt; b;</span><br><span class="line">       std::cout &lt;&lt; a+b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编译文件为一个叫做”add”的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ add.cpp -o add</span></span><br></pre></td></tr></table></figure>
<p>这时你可以将自己的输入写到文件内，如”input.txt”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>然后使用”&lt;”传入参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./add &lt; input.txt</span></span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>或者你可以更进一步，将输入和输出都独立出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./add &lt; input.txt &gt; output.txt</span></span><br></pre></td></tr></table></figure>
<p>为何不能使用 <code>input.txt &gt; ./add &gt; output.txt</code>这种写法？因为Shell会尝试执行input.txt。  </p>
<p><br></p>
<hr>
<h4 id="管线"><a href="#管线" class="headerlink" title="管线"></a>管线</h4><p>有时候我们需要将一个程序的输出换做另一个程序的输入，我们可以创建并且利用管线来优雅地解决这个问题。  </p>
<p>“|”是管线的符号。这个符号用来重定向一个程序的输出到另一个程序的输入，没有中间商赚差价。所谓中间商就是刚才用到的输入输出文本文件。  </p>
<p>举个例子，如下是两行命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt; files.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">"Jan 26"</span> &lt; files.txt</span></span><br></pre></td></tr></table></figure>
<p>简而言之就是使用<code>ls</code>命令列出所有内容到”files.txt”中，然后从”files.txt”中搜索所有含有”Jan 26”的行。  </p>
<p>太复杂了。  </p>
<p>整个操作可以换做下面的一行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep <span class="string">"Jan 26"</span></span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>|</code>，可以将<code>|</code>之前的命令输出直接当作<code>|</code>后面的命令传入。在这个例子中具体是将<code>ls -l</code>的输出当作<code>grep</code>命令的传入来用了。  </p>
<hr>
<p>举几个例子吧。  </p>
<p><strong>Example 1</strong>:</p>
<p>假设我们现在有一个”data.txt”文件，我们需要按照价格将其排序，然后仅仅将商品的名称和价格保存到”result.txt”文件夹中，要求只能使用一行命令。  </p>
<p>来看看标准题解：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> -k3 -n data.txt | <span class="built_in">cut</span> -d<span class="string">' '</span> -f2,3 &gt; result.txt</span></span><br></pre></td></tr></table></figure>
<p>首先我们使用<code>sort</code>命令，对”data.txt”的<strong>第三个字段(-k3)</strong>按照<strong>数字顺序(n)</strong>进行排序。<br>然后你看见了<code>|</code>。这代表这一步的输出即将被传入到下一个命令，也就是<code>cut</code>。<br>在<code>cut</code>中我们以<strong>空格作为分隔符(-d’ ‘)</strong>，并<strong>保留第二第三字段(-f2,3)</strong>，最后存入到”result.txt”中。  </p>
<p>还是很简单的。下面是这个过程的视觉表述方式：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfe2c1fb97579cb3ac7600cc5974e5bb8?method=download&amp;shareKey=866755676c9de499cfa8e00e7cad5101" alt=""></p>
<hr>
<p><strong>Example 2</strong>:</p>
<p>目标是在当前路径下对用户，用户组和其他人有运行权限的文件和路径。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 190</span><br><span class="line">-rwx--x--x    1   kit  gopher   0   Sep  12 10:30  add.o</span><br></pre></td></tr></table></figure>
<p>对于所有目标都有执行权限的话，则权限指示的第4, 7, 10位应该是x。但是我们应该如何检索呢？看看下面这行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^...x..x..x'</span> [传入]</span></span><br></pre></td></tr></table></figure>
<p>使用<code>-E</code>参数可以告诉Shell我们需要做样式匹配搜索了。对于<code>'^...x..x..x'</code>来讲：  </p>
<ul>
<li>“^”表示从行首开始匹配。</li>
<li>“.”表示可以匹配任意字符。</li>
</ul>
<p>加在一起的话，<code>'^...x..x..x'</code>的意思大概就是，从行首开始匹配，返回在第4, 7, 10个位置有字母”x”的行。  </p>
<p>那么一行就能解决了：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | grep -E <span class="string">'^...x..x..x'</span></span></span><br></pre></td></tr></table></figure>
<p>结构上和上一个例子一样所以这里不解释了。  </p>
<p><br></p>
<hr>
<p><strong>Example 3</strong></p>
<p>加入你想移除文件里的某几列，然后将其输入到程序里。举个例子，”mark.txt”，包含学生信息的单行数据：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> mark.txt</span></span><br><span class="line">2011111111 John M 98.5 100 62.5 88 75.5</span><br></pre></td></tr></table></figure>
<p>对应格式是：[UID, 名称，性别，分数1，分数2，分数3，分数4，分数5]</p>
<p>然后我们同样有一个C++程序用来处理信息，用于计算平均分：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mark.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> main {</span><br><span class="line">       <span class="type">double</span> a1, a2, a3, a4, a5;</span><br><span class="line">       std::cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a3 &gt;&gt; a4 &gt;&gt; a5;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">"The overall mark the student get is: "</span>;</span><br><span class="line">       std::cout &lt;&lt; (a1 + a2 + a3 + a4 + a5) / <span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>程序的问题是输入仅有五项成绩，但是我们的”mark.txt”文件内包含UID在内的其他多余信息。  </p>
<p>那这就很坏了。  </p>
<p>一种方法是我们可以使用管线来先处理”mark.txt”，然后传入程序。我们可以使用<code>cut</code>命令处理一下：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d<span class="string">' '</span> -f-8 mark.txt</span></span><br><span class="line">98.5 100 62.5 88 75.5</span><br></pre></td></tr></table></figure>
<p>然后编译程序运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ mark.cpp -o mark</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cut</span> -d<span class="string">' '</span> -f4-8 mark.txt | ./mark &gt; result.txt</span></span><br></pre></td></tr></table></figure>
<p>这样程序的输出就会被记录到”result.txt”中：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> result.txt</span></span><br><span class="line">The overall marks the student get is: 84.9</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="搜索文件或路径-find"><a href="#搜索文件或路径-find" class="headerlink" title="搜索文件或路径 (find)"></a>搜索文件或路径 (find)</h3><p>各位应该在Windows或MacOS中使用过搜索功能。你也可以在Linux中实现对文件或路径的搜索操作：  </p>
<p>使用<code>find</code>命令可以用来搜索文件或路径。<code>find</code>命令的格式为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [path] [-name] [-type]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[path]</code>告诉系统你想从哪里开始搜索操作。  </li>
<li><code>[name]</code>是你想要搜索的文件或路径的名字。  </li>
<li><code>[type]</code>是可选参数，参数包含：  <ul>
<li><code>-type f</code>代表仅搜索文件 (<em>files</em>)</li>
<li><code>-type d</code>命令之搜索路径 (<em>directory</em>)</li>
</ul>
</li>
</ul>
<hr>
<p>举个例子，假如在当前位置有下面这几个文件和路径：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">hello/  hello.cpp  hello.txt</span><br></pre></td></tr></table></figure>
<p>那么在当前目录下搜索”hello.txt”的方法即为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello.txt"</span> -<span class="built_in">type</span> f</span></span><br><span class="line">./hello.txt</span><br></pre></td></tr></table></figure>
<p>上面的命令<br>在上面的命令中，<code>.</code>代表<strong>当前目录</strong>。指定当前目录后<code>find</code>会在这个目录为基础向下寻找文件。  </p>
<p><br></p>
<p>或者我们也可以在当前位置下搜索”hello”打头的文件：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello.*"</span> -<span class="built_in">type</span> f</span></span><br><span class="line">./hello.cpp</span><br><span class="line">./hello.txt</span><br></pre></td></tr></table></figure>
<p>…或者是搜索路径：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">"hello"</span> -<span class="built_in">type</span> d</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件内搜索-grep-1"><a href="#文件内搜索-grep-1" class="headerlink" title="文件内搜索 (grep)"></a>文件内搜索 (grep)</h3><p><code>grep</code> (Global Regular Expression Print)命令之前已经介绍过了。这里介绍更多细节：  </p>
<p>之前用的是不带<code>-E</code>的使用方式，只是用来返回文件内的匹配行：  </p>
<p>“example1.txt”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello how are you?</span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'hell'</span> example1.txt</span></span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<p><code>grep</code>命令<strong>区分大小写！</strong>这就是为什么返回的是包含”shell”的第二行，而不是包含”Hello”的第一行。  </p>
<hr>
<p><code>grep</code>可以加入可选参数<code>-E</code>，代表按样式匹配。格式为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E [regular experssion] [filename]</span><br></pre></td></tr></table></figure>
<p>在<code>regular expression</code>中，你可以按照下面的符号来进行自定义匹配：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:left">匹配任何<strong>单个字符</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:left">仅从<strong>行首</strong>开始匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:left">仅从<strong>行尾</strong>开始匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:left">一个字符后面跟一个”?”，则该字符可被匹配<strong>0次或1次</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:left">一个字符后面跟一个”+”，则该字符可被匹配<strong>1次或多次</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">一个字符后面跟一个”<em>“，则该字符可被匹配<em>*0次或多次</em></em></td>
</tr>
<tr>
<td style="text-align:center"><code>[]</code></td>
<td style="text-align:left">被”[]”括起来的字符会被<strong>全字匹配</strong><br>括起来的字符可以是单个字符，也可以是多个字符<br>你可以用”-“符号来自定义区间<br>例如，与其使用[12345]，可以使用[1-5]代替</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:left"><strong>转义符</strong><br>使用转义符来取消特殊字符的特殊效用<br>例如我们想要寻找”.”而不发挥它“匹配单个字符的属性”，就写成<code>\.</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n}</code></td>
<td style="text-align:left">匹配”n”次出现的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n,}</code></td>
<td style="text-align:left">匹配<em>至少</em>“n”次出现的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>pattern {n,m}</code></td>
<td style="text-align:left">匹配出现”n”和”m”次数之间的<code>pattern</code></td>
</tr>
<tr>
<td style="text-align:center"><code>(ab){3}</code></td>
<td style="text-align:left">出现三次”ab”排列<br>例如(ab){3}会被匹配做”ababab”，不是”abbb”</td>
</tr>
</tbody>
</table>
</div>
<p>接下来我们使用刚才”example1.txt”，挑重点解释。  </p>
<hr>
<h4 id="任意单字符匹配"><a href="#任意单字符匹配" class="headerlink" title="任意单字符匹配"></a>任意单字符匹配</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'.ell'</span> example1.txt</span></span><br><span class="line">Hello how are you?</span><br><span class="line">I am using the bash shell like a pro!</span><br></pre></td></tr></table></figure>
<p>‘.ell’代表”.”处可以匹配任何单个字符，例如”Cell”, “cell”, “bell”会被匹配。<br>如果如果你想要在”.”处搜索的字母仅仅是大小写H，则可以使用<code>[Hh]ell</code>。  </p>
<hr>
<h4 id="行首-行尾匹配"><a href="#行首-行尾匹配" class="headerlink" title="行首/行尾匹配"></a>行首/行尾匹配</h4><p>这里启用”example2.txt”：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">'apple'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>使用”^”从行首开始匹配：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^apple'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">apple pie</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>而使用”$”从行尾开始匹配：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'apple$'</span> example2.txt</span></span><br><span class="line">apple</span><br><span class="line">pineapple</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>由此可知，使用”^”和”$”也可以全字匹配某一行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^apple$'</span> example2.txt</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>或者使用”^”, “$”配合”.”来返回只有五个字符的行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^.....$'</span> example2.txt</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>
<hr>
<h4 id=""><a href="#" class="headerlink" title="?, +, *"></a>?, +, *</h4><p><strong>“?”</strong></p>
<p>“example3.txt”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">coco</span><br><span class="line">cherries</span><br><span class="line">orange</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap?'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<p>没看懂？首先”^”确保行首开始匹配，随后：  </p>
<ul>
<li>“<strong>ap</strong>ple”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了1次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了1次</li>
<li>“<strong>a</strong>ngel”会被返回，因为在表达式中的p要求出现0次或者1次，这里出现了0次</li>
</ul>
<p>那么接下来的东西，”+”和”*”，原理上基本上是一样的了。</p>
<hr>
<p><strong>+</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap+'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br></pre></td></tr></table></figure>
<ul>
<li>“<strong>app</strong>le”会被返回，因为在表达式中的p要求出现1次或者多次，这里出现了多次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现1次或者多次，这里出现了1次</li>
<li>“angel”没有被返回，因为在表达式中的p要求出现1次或者多次，这里出现了0次</li>
</ul>
<hr>
<p><strong>*</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^ap*+*'</span> example3.txt</span></span><br><span class="line">apple</span><br><span class="line">ape</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<ul>
<li>“<strong>app</strong>le”会被返回，因为在表达式中的p要求出现0次或者多次，这里出现了多次</li>
<li>“<strong>ap</strong>e”会被返回，因为在表达式中的p要求出现0次或者多次，这里出现了1次</li>
<li>“<strong>a</strong>ngel”会被被返回，因为在表达式中的p要求出现0次或者多次，这里出现了0次</li>
</ul>
<hr>
<p>接下来是一些进阶一点的用法了：</p>
<p><strong>整合”.”和”*“</strong></p>
<p>如果我们想要匹配字符”a”，然后后方跟随任意字符，直到”ge”再次出现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'a.*ge'</span> example3.txt</span></span><br><span class="line">orange</span><br><span class="line">angel</span><br></pre></td></tr></table></figure>
<p>“<em>“跟在”.”之后，所以”任意字符匹配”可以被匹配多次，这就是为什么”or<strong>ange</strong>“和”<em>*ang</em></em>el”能被返回的原因。  </p>
<hr>
<p><strong>使用括号”()”</strong></p>
<p>我们可以使用括号来整合子字符串。例如我们想要寻找字符串”co”出现过一次或多次的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'(co)+'</span> example3.txt</span></span><br><span class="line">coco</span><br></pre></td></tr></table></figure>
<p>为什么要用括号呢，看看如果不用括号会发生什么：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'co*'</span> example3.txt</span></span><br><span class="line">coco</span><br><span class="line">cherries</span><br></pre></td></tr></table></figure>
<p>因为”*”只会应用到它的前一个字符。没加括号的话就会被应用到”o”，而不是整个子字符串”co”。  </p>
<hr>
<h4 id="匹配集合"><a href="#匹配集合" class="headerlink" title="匹配集合"></a>匹配集合</h4><p>可以使用方括号 “[ ]”来定义一个集合，随后进行搜索。你可以按照下面的格式定义集合：  </p>
<ul>
<li><strong>[0123456789]</strong>或者<strong>[0-9]</strong>用来匹配任意单个数字</li>
<li><strong>[A-Z]</strong>用来匹配任何单个大写字母</li>
<li><strong>[a-z]</strong>用来匹配任何单个小写字母</li>
<li><strong>[A-Za-z]</strong>用来匹配任何单个字母，包括大写和小写字母。  </li>
</ul>
<p>例如我们有一个”example4.txt”：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple Juice HKD13</span><br><span class="line">apple pie USD 4</span><br><span class="line">Banana phone HKD</span><br></pre></td></tr></table></figure>
<p>查找包含”apple”或者”Apple”的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'[Aa]pple'</span> example4.txt</span></span><br><span class="line">Apple Juice HKD13</span><br><span class="line">apple pie USD 4</span><br></pre></td></tr></table></figure>
<p>查找包含”HKD”，并在其后跟随一个或者多个数字的行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'HKD[0-9]*'</span> example4.txt</span></span><br><span class="line">Apple Juice HKD13</span><br><span class="line">Banana phone HKD</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="匹配序列"><a href="#匹配序列" class="headerlink" title="匹配序列"></a>匹配序列</h4><p>可以使用”{ }”来匹配一个序列 (pattern)。  </p>
<p>上”example5.txt”：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2April2013</span><br><span class="line">30-1-2013</span><br><span class="line">13December2013</span><br></pre></td></tr></table></figure>
<p>如果我们想要查找一个日月年的格式，并且日为2个字符，月至少为3个字符，年为4个字符，你可以整成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">'^[0-9]{1,2}[a-zA-Z]{3,}[0-9]{4}'</span> example5.txt</span></span><br><span class="line">2April2013</span><br><span class="line">13December2013</span><br></pre></td></tr></table></figure>
<p>这很抽象，所以我们需要简单讲讲：  </p>
<ul>
<li><strong>[0-9]{1,2}</strong>定义一个数字集合，并且需要至少出现一次，最多出现2次</li>
<li><strong>[a-zA-Z]{3,}</strong>定义一个字母（包含大小写）集合，并且需要至少3个字符长</li>
<li><strong>[0-9]{4}</strong>定义一个数字集合，并且必须要是正正好好4个字符长</li>
</ul>
<p>加上行首匹配”^”就ok了。  </p>
<hr>
<h4 id="其他常用匹配写法"><a href="#其他常用匹配写法" class="headerlink" title="其他常用匹配写法"></a>其他常用匹配写法</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表述</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[a-z]*</code></td>
<td style="text-align:left">匹配任意数量字符的小写字母</td>
</tr>
<tr>
<td style="text-align:center"><code>....$</code></td>
<td style="text-align:left">匹配包含四个字符的行</td>
</tr>
<tr>
<td style="text-align:center"><code>abc.*abc</code></td>
<td style="text-align:left">匹配出现两次”abc”的行。两个”abc”之间可以有任意数量的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]{2}-[0-9]{2}-[0-9]{4}</code></td>
<td style="text-align:left">匹配<code>dd-mm-yyyy</code>格式。请注意这不会验证日期是否合法！</td>
</tr>
<tr>
<td style="text-align:center"><code>^.{n,m}$</code></td>
<td style="text-align:left">匹配行长介于n和m个字符之间的行</td>
</tr>
<tr>
<td style="text-align:center"><code>(bye)+</code></td>
<td style="text-align:left">匹配一次或多次出现过”bye”的行，例如”bye”, “byebye”, “byebyebye”，空行不会被匹配。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><br></p>
<p><strong>至此，Module 1全部完结！</strong> </p>
<p><br></p>
<hr>
<h1 id="Module-2-Shell-Script-amp-Version-Control"><a href="#Module-2-Shell-Script-amp-Version-Control" class="headerlink" title="Module 2: Shell Script & Version Control"></a>Module 2: Shell Script &amp; Version Control</h1><p>先来深入一下Shell脚本把。  </p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>Shell 脚本 (Shell Script, .sh) 是一种由 Linux shell 运行的计算机程序。<br>Shell Script是一种解释型语言，而不是编译型语言。因此与 C++ 不同，我们不需要在执行程序之前将 shell 编译为二进制可执行格式。<br>相反，每次执行用 Shell 脚本编写的程序时，shell 都会对其进行解析和解释。  </p>
<p>解释型语言允许我们通过简单地编辑脚本来更快地修改程序。但是，程序通常较慢，因为在执行期间需要进行解析和解释。<br>假设我们有一系列 Shell 命令，我们不想在每次要执行时重新输入这些命令。我们可以将它们保存在一个文件中，并将其称为 shell 脚本。  </p>
<blockquote>
<p><strong>注意注意↑！</strong><br>在 Windows 中编辑脚本文件并导入到 Linux 可能会导致执行失败，因为 Windows 中使用的行尾 (EOL) 不同。<br>  你应该在 Linux 系统内创建和编辑脚本文件（例如，在 SSH 中使用 vi 编辑器，在 X2Go 中使用 gedit）。否则，如果从 Windows 导入脚本文件，则需要确保 Windows 环境中的文本编辑器中的行尾选项设置为 UNIX 格式 (LF) 而不是 Windows 格式 (CRLF)。  </p>
</blockquote>
<p><br></p>
<hr>
<p>我们先来创建一个<code>hello.sh</code>脚本写个典中典Hello world：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi hello.sh</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello world!"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Welcome to ENGG1340"</span></span><br></pre></td></tr></table></figure>
<p><code>echo</code>命令用来向控制台输出一行。行中内容可以是变量值，也可以是字符串。  </p>
<p>保存并退出，随后我们需要使得文件可以被用户运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x hello.sh</span></span><br></pre></td></tr></table></figure>
<p>然后直接运行：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello.sh</span></span><br><span class="line">Hello world!</span><br><span class="line">Welcome to ENGG1340</span><br></pre></td></tr></table></figure>
<hr>
<p>所有脚本都应以<code>#!</code>开头，这表示系统应使用哪个程序来处理 shell 脚本。在本例中，它是 bash 程序的路径。<br>从Module 1 中我们知道有许多不同的 shell（例如，C shell、Korn shell、Bash shell）。而由于我们使用 Bash shell，因此我们需要提供 bash 程序的路径，以便操作系统知道如何解释 bash shell 命令。<br>在本例中，Bash shell的路径为 /bin/bash。  </p>
<p>你也可以使用<code>which -a</code>命令来找到Bash shell的具体位置： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> -a bash</span></span><br><span class="line">/usr/local/bin/bash</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>参数<code>-a</code>代指返回bash的所有路径。如你所见返回的路径不止一个，这代表Bash的路径可能有多个。在本例中我们使用<code>/bin/bash</code>路径下的那个。  </p>
<hr>
<p>来看看另一个例子。这里我们引入<code>echo</code>命令的新参数<code>-n</code>看看会发生什么不同的情况：  </p>
<p><em>ex1_1.sh</em>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Hello world!"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Welcome to ENGG1340"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bye"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex1_1.sh</span></span><br><span class="line">Hello world!Welcome to ENGG1340</span><br><span class="line">bye</span><br></pre></td></tr></table></figure>
<p><code>-n</code>可以表示”no trailing”使下一行直接继续打印在上一行的末尾。  </p>
<hr>
<p>这次我们来看个带C++的例子：  </p>
<p>“<em>add.cpp</em>“</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="type">int</span> a;</span><br><span class="line">       <span class="type">int</span> b;</span><br><span class="line">       std::cin &gt;&gt; a;</span><br><span class="line">       std::cin &gt;&gt; b;</span><br><span class="line">       std::cout &lt;&lt; a + b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>“<em>input.txt</em>“:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>
<p>之前我们使用管线可以封装好整个自动化，不过这里我们试着用Shell脚本： </p>
<p>“<em>ex1_2.sh</em>“:  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile the code</span></span><br><span class="line">g++ add.cpp -o add</span><br><span class="line"><span class="comment"># Run the code and display result</span></span><br><span class="line">./add &lt; input.txt &gt; output.txt</span><br><span class="line"><span class="built_in">cat</span> output.txt</span><br></pre></td></tr></table></figure>
<p>运行：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./ex1_2.sh</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>在Shell脚本中只有一种变量类型，那就是字符串。  </p>
<p>变量名区分大小写，只支持包含大小写字母，数字和下划线 (_)。  </p>
<hr>
<h4 id="定义并访问变量"><a href="#定义并访问变量" class="headerlink" title="定义并访问变量"></a>定义并访问变量</h4><p>我们可以通过这种方式来定义并赋予变量一个值：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pet=<span class="string">"dog"</span></span><br></pre></td></tr></table></figure>
<p>等号前后不能有空格。  </p>
<p>如果我们需要取用变量中的内容，则需要使用美元符号：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">pet=<span class="string">"dog"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pet</span></span><br></pre></td></tr></table></figure>
<p>输出为<code>dog</code>。  </p>
<hr>
<h4 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h4><p><code>read</code>命令用来等待用户在控制台向脚本提供输入： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"What is your name?"</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$name</span>"</span></span><br></pre></td></tr></table></figure>
<p>当用户输入完值之后，会被自动存储到变量<code>name</code>中。  </p>
<p>比如我们来看这个程序的具体例子：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_2.sh</span></span><br><span class="line">What is your name?</span><br><span class="line">Kit</span><br><span class="line">Hello, Kit</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>在Shell脚本中区分引用很重要。我们可以用三种方式来确定一个字符串值，分别是<strong>不引用</strong>，<strong>单引号引用</strong>和<strong>双引号引用</strong>。  </p>
<hr>
<p><strong>不引用</strong>  </p>
<p>我们可以在定义字符串的时候不加任何引用，但是这个方法仅在需要定义的字符串是一个整体，没有空格的情况下才可用：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">cat</span></span><br></pre></td></tr></table></figure>
<p>下面这种情况就会报错：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=Apple pie</span><br></pre></td></tr></table></figure>
<p>因为 程序会将Apple当作一个指令来看待，而不是一个字符串。  </p>
<hr>
<p><strong>单引号引用</strong>  </p>
<p>在单引号引用情况下，带空格的字符串可以被成功处理，但是没办法做到变量替换。  </p>
<p>变量替换功能是双引号引用的功能： </p>
<hr>
<p><strong>双引号引用</strong></p>
<p>双引号引用相比单引号引用支持更多功能，其中一个就是变量替换：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:left">变量替换</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:left">转义符</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code>``</td>
<td style="text-align:left">包含bash命令</td>
</tr>
</tbody>
</table>
</div>
<p>看不懂？就着下面的例子看看：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">name=<span class="string">"Apple"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Hello, $name'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"\$name = <span class="variable">$name</span>"</span></span><br></pre></td></tr></table></figure>
<p>运行后可以得到： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_3.sh</span></span><br><span class="line">Hello, $name</span><br><span class="line">Hello, Apple</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">name = Apple</span></span><br></pre></td></tr></table></figure>
<p>第一行会被输出为<code>Hello, $name</code>，因为我们使用了单引号引用，<code>name</code>变量不会被替换。<br>第二行会被输出为<code>Hello Apple</code>，因为双引号引用下<code>$name</code>会被替换为变量<code>name</code>。<br>第三行会被输出为<script type="math/tex">name = Apple`，因为我们使用转义符取消了第一个`$name`中`</script>的替换功能，而第二个<code>$name</code>会被保持原状正常替换。  </p>
<p><br></p>
<hr>
<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>前面提到过一嘴，不过我们决定在这里展开相关说明。  </p>
<p>使用反引号(`)，一般是esc键下面的那个键，我们可以在脚本中向变量保存Shell命令的输出，来实现进一步的处理：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"`cat file.txt`"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">b=<span class="string">"`wc -l file.txt | cut -d\" \""</span> -f1`<span class="string">"</span></span><br><span class="line"><span class="string">echo "</span>There are <span class="variable">$b</span> lines <span class="keyword">in</span> file<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>“<em>file.txt</em>“:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Cherry</span><br></pre></td></tr></table></figure>
<p>运行输出为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_4.sh</span></span><br><span class="line">Apple Banana Cherry</span><br><span class="line">There are 3 lines in file</span><br></pre></td></tr></table></figure>
<p>接下来我们解读一下。在变量b中，首先<code>wc</code>命令返回<code>3 file.txt</code>，告诉我们一共有三行。接着我们使用<code>cut</code>命令截去后面多余的部分，返回一个”3”。  </p>
<p>注意在<code>cut</code>命令的参数部分我们使用了转义符，因为原本是<code>cut -d" " -f1</code>，但问题在于外面已经有一对双引号了。解决这个问题只能去转义里面的两个引号。  </p>
<p><br></p>
<hr>
<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>如果我们想要获得一个字符串的长度：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"Apple"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${#a}</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./ex2_5_1.sh</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>其中<code>${\#a}</code>的意思是返回变量a存储的字符串的长度。  </p>
<hr>
<h4 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h4><p>使用<code>${a:pos:len}</code>可以用来返回一个字符串的子字符串。例如：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"Apple Pie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${a:6:3}</span></span><br></pre></td></tr></table></figure>
<p>会返回变量<strong>a</strong>从第<strong>6</strong>个字符位置开始包含并向后数<strong>3</strong>个字符长度的子字符串，也就是：<code>Pie</code>。  </p>
<p>和Python一样第一个字符编号为0。  </p>
<p><br></p>
<hr>
<h4 id="替换字符串内容"><a href="#替换字符串内容" class="headerlink" title="替换字符串内容"></a>替换字符串内容</h4><p>使用<code>${a/from/to}</code>来指定替换一个字符串。先看例子：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"Apple Pie"</span></span><br><span class="line">from=<span class="string">"Pie"</span></span><br><span class="line">to=<span class="string">"Juice"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${a/from/to}</span></span><br></pre></td></tr></table></figure>
<p>输出为<code>Apple Juice</code>。  </p>
<p>该替换会在字符串内寻找<code>from</code>的第一个匹配，然后将<code>from</code>替换为<code>to</code>的值。  </p>
<p><br></p>
<hr>
<h4 id="按数字计算"><a href="#按数字计算" class="headerlink" title="按数字计算"></a>按数字计算</h4><p>我们存储的变量都是字符串，但是如果我们存入的是数字类型的字符串，并且我们想要进行一些数学运算该咋整？  </p>
<p>虽然听起来很奇怪，但是我们可以使用<code>let</code>命令来进行数学运算。支持加减乘除和整数除法。(+, -, *, /, %)  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"b = <span class="variable">$a</span> = 9"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"c = <span class="variable">$a</span> * <span class="variable">$a</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$C</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="string">"d = <span class="variable">$a</span> % 9"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$d</span></span><br></pre></td></tr></table></figure>
<p>运行为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_5_4.sh</span></span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="获取控制台参数数量"><a href="#获取控制台参数数量" class="headerlink" title="获取控制台参数数量"></a>获取控制台参数数量</h4><p>控制台参数再Shell脚本中会被列为<code>$0</code>, <code>$1</code>, <code>$2</code>一直到<code>$9</code>。<br>作为特殊项，<code>$0</code>会被解析为Shell脚本的名称。<br>如果想要引用第十个或者更多参数，则需要将序号使用括号括起来：<code>${10}</code>, <code>${11}</code>这样，否则命令会被解析为<code>$1</code>和数字的组合。<br><code>$#</code>代表控制台内参数的数量。  </p>
<p>例如我们有一个Shell脚本如下所示：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"There are <span class="variable">$#</span> arguments"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$4</span>"</span></span><br></pre></td></tr></table></figure>
<p>运行脚本后输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2_6.sh we are the world</span></span><br><span class="line">There are 4 arguments</span><br><span class="line">./ex2_6.sh</span><br><span class="line">we</span><br><span class="line">are</span><br><span class="line">the</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>在任何脚本语言中，流程控制都是必不可少的一部分。  </p>
<h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h4><p>基本的if else语句语法为：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    *perform some action</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if语句的重点写做fi还有点搞笑。<br>注意了if语句的条件判断，方括号里那个，需要前后带一个空格。注意condition前后离着括号都差一个空格。如果不遵守这个规定会爆语法错误。  </p>
<p>Shell脚本也有else if功能：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"condition 1 met"</span></span><br><span class="line"><span class="keyword">elif</span> [ condition2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"condition 2 met"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"No condition met"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>在上面的语句中，condition的语法条件比较特殊。下面的列表展示了可以当作condition来用的语句：  </p>
<ul>
<li>比较字符串</li>
</ul>
<p>注意<code>$string1</code>和<code>$string</code>都被双引号引用了，所以在<code>$string1</code>和<code>$string2</code>内即使有空格也可以正确比较内容。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">String comparisons</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[ "$string" ]</code></td>
<td style="text-align:left">如果<code>$string</code>的长度不为空，则返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -z "$string" ]</code></td>
<td style="text-align:left">如果<code>$string</code>的长度为空，则返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" == "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>和<code>$string2</code>完全一致，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" != "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>和<code>$string2</code>不一致，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" \&gt; "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>按照字母顺序排序排在<code>$string2</code>后面，则返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ "$string1" \&lt; "$string2" ]</code></td>
<td style="text-align:left">如果<code>$string1</code>按照字母顺序排序排在<code>$string2</code>前面，则返回true</td>
</tr>
</tbody>
</table>
</div>
<p>注意排序那两个符号前面带转义符。</p>
<p><br></p>
<ul>
<li>比较文件或路径</li>
</ul>
<p>可以用来判断文件或者路径的状态。包括但不限于：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件检查</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[ -e $file ]</code></td>
<td style="text-align:left">如果<code>file</code>存在，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -f $file ]</code></td>
<td style="text-align:left">如果<code>file</code>是一个文件，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -d $file ]</code></td>
<td style="text-align:left">如果<code>file</code>是一个路径，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -s $file ]</code></td>
<td style="text-align:left">如果<code>file</code>的大小&gt;0，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -r $file ]</code></td>
<td style="text-align:left">如果<code>file</code>可读，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -w $file ]</code></td>
<td style="text-align:left">如果<code>file</code>可写，返回true</td>
</tr>
<tr>
<td style="text-align:center"><code>[ -x $file ]</code></td>
<td style="text-align:left">如果<code>file</code>可执行，返回true</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<ul>
<li>比较数字</li>
</ul>
<p>虽然shell里只有字符串一种变量，但我们也可以按下面的方式来比较数字：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数字比较</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[ $a -eq $b ]</code></td>
<td style="text-align:left">如果a = b，返回true (equal)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -ne $b ]</code></td>
<td style="text-align:left">如果a != b，返回true (not equal)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -lt $b ]</code></td>
<td style="text-align:left">如果a &lt; b，返回true (less than)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -le $b ]</code></td>
<td style="text-align:left">如果a &lt;= b，返回true (less or equal)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -gt $b ]</code></td>
<td style="text-align:left">如果a &gt; b，返回true (greater than)</td>
</tr>
<tr>
<td style="text-align:center"><code>[ $a -ge $b ]</code></td>
<td style="text-align:left">如果a &gt;= b，返回true (greater or equal)</td>
</tr>
</tbody>
</table>
</div>
<p>还是比较好记的</p>
<p><br></p>
<p>例如我们想要写一个小脚本，询问用户想不想要移除所有后缀为<code>.cpp</code>的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Do you want to remove all .cpp files? (Y/N)"</span></span><br><span class="line"><span class="built_in">read</span> ans =</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$ans</span>"</span> == <span class="string">"Y"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">rm</span> -rf *.cpp</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"All .cpp files are removed!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>尤其注意一下if语句带condition的空格问题。留意一下空格都加在哪里了。  </p>
<p>运行为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Do you want to remove all .cpp files? (Y/N)</span><br><span class="line">Y</span><br><span class="line">All .cpp files are removed!</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>学会了？接下来举几个例子：  </p>
<p><strong>Example 1</strong>  </p>
<p>如果g++在编译c++文件时出现了错误，则编译失败，可执行文件将不会生成。所以我们可以使用<code>[ -e file ]</code>来检查文件是否存在。<br>同时，我们也可以考虑一下是不是可以查看一下编译失败的log?  </p>
<p>比如我们可以使用重定向方法来存储错误log：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ hello.cpp -o hello 2&gt; error.txt</span></span><br></pre></td></tr></table></figure>
<p>别忘了<code>2&gt;</code>代表重定向标准错误。  </p>
<p>那么看看这个shell脚本吧：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e hello.cpp ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello.cpp exist"</span></span><br><span class="line">    g++ hello.cpp -o hello 2&gt; error.txt</span><br><span class="line">    <span class="keyword">if</span> [ -e hello ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        ./hello</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Compilation failed!"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Here are the error message"</span></span><br><span class="line">        <span class="built_in">cat</span> error.txt</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello.cpp not found!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>如果<code>hello.cpp</code>包含语法错误，那么下面就是其中一种可能的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello,cpp exist</span><br><span class="line">Compilation failed!</span><br><span class="line">Here are the error message</span><br><span class="line">hello.cpp: In function 'int main()':</span><br><span class="line">hello.cpp:5:5: error: expected ';' before 'return'</span><br><span class="line">     return 0;</span><br><span class="line">     ^~~~~~</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环可以按照指定次数循环。  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">list=<span class="string">"1 2 3 4 5"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$list</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"This is iteration <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>for循环以<code>for i in []</code>开始，需要执行的命令以<code>do</code>和<code>done</code>括起来。  </p>
<p>例如上面的脚本会被运行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is iteration 1</span><br><span class="line">This is iteration 2</span><br><span class="line">This is iteration 3</span><br><span class="line">This is iteration 4</span><br><span class="line">This is iteration 5</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>实际上除了遍历数组，我们也可以遍历一个路径中的文件。<br>比如下面的脚本将会自动将你路径下所有的<code>.cpp</code>文件记录一个备份：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">list=<span class="string">"`ls *.cpp`"</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> <span class="variable">$list</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$fileName</span> <span class="string">"<span class="variable">$fileName</span>.backup"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">a.cpp  backup.sh*  b.cpp  c.cpp</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./backup.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">a.cpp  a.cpp.backup  backup.sh*  b.cpp  b.cpp.backup  c.cpp  c.cpp.backup</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="有用的操作"><a href="#有用的操作" class="headerlink" title="有用的操作"></a>有用的操作</h3><h4 id="在脚本中隐藏命令"><a href="#在脚本中隐藏命令" class="headerlink" title="在脚本中隐藏命令"></a>在脚本中隐藏命令</h4><p>Shell脚本会生成自己的错误和输出信息，有时会引爆你的shell脚本输出。  </p>
<p>为了解决这一点你可以使用之前的重定向方法：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> file123 fileabc 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ -e fileabc ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Copy successful"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>: Oops. Copy failed :("</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>解析一下，<code>1&gt;/dev/null</code>用来将<code>cp</code>命令的标准输出重定向到系统回收站内<code>/dev/null</code>。挺巧妙的。  </p>
<p><code>2&gt;&amp;1</code>则会重定向<code>cp</code>命令的标准错误到同一个位置，只不过我们以<code>&amp;1</code>表示了。  </p>
<p><code>&amp;</code>表示在这里指的是文件描述符，而不是文件名或路径。如果没有<code>&amp;</code>，像<code>2&gt;1</code>这样的命令将无效，因为shell会尝试将<code>1</code>解释为文件名，而不是标准输出文件描述符。  </p>
<p>输出为：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex4_1.sh</span></span><br><span class="line">./ex4_1.sh: Oops. Copy failed :(</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h4 id="输出到标准错误"><a href="#输出到标准错误" class="headerlink" title="输出到标准错误"></a>输出到标准错误</h4><p>Shell脚本也可以通过<code>echo</code>命令输出到标准错误中：  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> file123 fileabc 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ -e fileabc ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Copy successful"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>: Oops. Copy failed :("</span> &gt;&amp;2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>当<code>echo</code>后面跟着<code>&gt;&amp;2</code>时候，则代表我们将该条信息重定向到标准错误层上进行输出了。接下来如果我们执行这个：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex4_2.sh 2&gt; error.txt</span></span><br></pre></td></tr></table></figure>
<p>就可以在”error.txt”中看见我们的错误输出了！  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> error.txt</span></span><br><span class="line">./ex2_6.sh: Oops. Copy failed :(</span><br></pre></td></tr></table></figure>
<p>经过这两步处理后你的shell脚本的输出看起来就像其他shell命令一样了。  </p>
<hr>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>在版本控制这一部分，我们主要学习如何使用Git。  </p>
<p>Git 是一种常见的现代版本控制系统，用于管理和跟踪计算机文件中的更改以及协调多人对这些文件的工作。主要用于软件开发中的源代码管理。<br>Git 是一种分布式版本控制系统 (DVCS)，与大多数替代版本控制系统相比，它具有更高的性能、安全性和灵活性。  </p>
<p>那么什么是版本控制系统？  </p>
<p>版本控制系统 (VCS) 是一类软件工具，支持软件开发团队管理源代码随时间的变化。<br>它在一种特殊的数据库中跟踪每个贡献者对代码的单独更改历史记录。如果出现错误或需要修复错误，开发人员可以返回到源代码的早期版本来解决问题，而不会妨碍其他团队成员的工作流程。<br>如果软件团队不使用 VCS，他们可能会遇到一些问题，例如在项目的两个独立部分之间创建不兼容的代码或对用户可用的更改一无所知。  </p>
<p>在这么多版本控制解决方案中，使用Git的原因是它让开发人员可以在一个地方查看任何项目的变更、决策和进展的整个时间线。<br>借助 Git 这样的 DVCS，可以随时进行协作，同时保持源代码的完整性。使用分支，开发人员可以安全地对生产代码提出更改建议。  </p>
<p>如果你用过Github，你应该对上述这些内容和下面将要讲到的内容比较熟悉。如果不，那么这一节将会很有意思。  </p>
<p><br></p>
<p>Git的使用工作流基本分三步。  </p>
<ol>
<li><code>git init</code>初始化工作目录  </li>
</ol>
<p>首先可以使用Git初始化一个你将要使用的工作目录。Git会尝试在目录内跟踪你对文件的改变。  </p>
<ol>
<li><code>git add</code>增加一次提交  </li>
</ol>
<p>这一步告诉Git，当前目录下所有被更改的文件有哪些。  </p>
<ol>
<li><code>git commit</code>创建一次提交(commit)</li>
</ol>
<p>最后告诉Git让它创建一次提交，类似于创建一个存档点。每一次提交就是某个特定版本。  </p>
<p><br></p>
<hr>
<h3 id="开始使用Git"><a href="#开始使用Git" class="headerlink" title="开始使用Git"></a>开始使用Git</h3><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>要使用Git，我们需要先配置好Git的使用环境。首先我们需要在你的电脑上安装Git。  </p>
<p>检查Git是否在你的电脑上安装，执行<code>git version</code>即可：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git version</span></span><br><span class="line">git version 2.45.2.windows.1</span><br></pre></td></tr></table></figure>
<p>如果没有安装Git，则你可以根据下面的步骤来安装Git。  </p>
<p><br></p>
<p><strong>在Linux上安装</strong>  </p>
<p>在终端执行几行代码就OK了：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get upgrade</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>在MacOS上安装</strong></p>
<p>虽然我不用Mac但是相应的安装方式也是可以提一嘴的。  </p>
<p>首先下载Homebrew来更方便快捷的安装软件：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ruby -e <span class="string">"<span class="subst">$(curl -fsSL</span></span></span></span><br><span class="line">   https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string"><span class="subst">brew doctor</span></span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string"><span class="subst">brew install git</span></span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>在Windows上安装</strong></p>
<p>直接去官网下载安装包即可。  </p>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p><br></p>
<hr>
<h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><p>一个Git仓库包含你工作环境的所有文件，文件夹或者路径等等。配置好Git后Git会自动帮你管理变更。  </p>
<p>一共有两种方式来初始化一个本地仓库。你可以从网上clone一个仓库下来，也可以自己创建一个空白仓库使用。  </p>
<p><br></p>
<p><strong>初始化新仓库</strong></p>
<ol>
<li>打开终端并转到你想要初始化的路径：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> project</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在文件夹内我们使用<code>git init</code>命令创建一个新仓库：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in /home/research/ra/1801/cklai/project/.git/</span><br></pre></td></tr></table></figure>
<p>执行完这行命令后，一个新的<code>.git/</code>子路径会在当前路径下生成。这个指令用来设置好Git用来跟踪你的文件的所有前置工作。  </p>
<ol>
<li>现在我们可以使用Git了。比如说下一步我们创建一个”work.txt”： </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my Git tutorial.</span><br><span class="line">Today we will learn how to get started with Git.</span><br></pre></td></tr></table></figure>
<p><code>git init</code>还有其他的一些可选变体可以使用：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git init</code></td>
<td style="text-align:left">创建新的本地仓库</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --quiet</code><br>or<br><code>git init -q</code></td>
<td style="text-align:left">静默模式，仅输出重要信息，警告和错误。</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --bare</code></td>
<td style="text-align:left">创建一个裸仓库。<br>裸仓库没有工作目录，因此不能在上面进行实际的编辑和修改文件的操作，仅仅是用来存储并共享版本控制的历史记录。</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --template=&lt;template_directory&gt;</code></td>
<td style="text-align:left">给本地仓库指定一个模板</td>
</tr>
<tr>
<td style="text-align:center"><code>git init --separate-git-dir=&lt;git dir&gt;</code></td>
<td style="text-align:left">创建一个包含具体工作目录路径的文本文档</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<p><strong>clone新仓库</strong></p>
<p>或者你也可以从网上拉取一个新仓库下来。  </p>
<ol>
<li>如果你想使用其他人的仓库，你可以直接从代码托管平台上clone一个仓库到你的本地。Github就是全球最大的代码托管平台。  </li>
</ol>
<blockquote>
<p><strong>注意注意↑！</strong><br>如果存在<code>.git</code>路径，那么你的仓库就会被拉取到那里。如果没有，则仓库会被clone到你的当前工作路径。  </p>
</blockquote>
<ol>
<li>输入clone命令即可从网上拉取仓库：  </li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/[YourUsername]/[YourRepository]</span><br><span class="line">Cloning into `Spoon-Knife`...</span><br><span class="line">remote: Counting objects: 10, done.</span><br><span class="line">remote: Compressing objects: 100% (8/8), done.</span><br><span class="line">remove: Total 10 (delta 1), reused 10 (delta 1)</span><br><span class="line">Unpacking objects: 100% (10/10), done.</span><br></pre></td></tr></table></figure>
<p>同样的这里有一些<code>git clone</code>的附加变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git clone --branch &lt;branch_name&gt;</code></td>
<td style="text-align:left">告诉Git你想要拉取的分支是哪一条。有关分支后面再说</td>
</tr>
<tr>
<td style="text-align:center"><code>git clone --bare</code></td>
<td style="text-align:left">将仓库以裸仓库的形式拉取下来</td>
</tr>
<tr>
<td style="text-align:center"><code>git clone --mirror</code></td>
<td style="text-align:left">clone远程存储库的所有扩展引用，并隐式调用 -bare 参数</td>
</tr>
<tr>
<td style="text-align:center"><code>git clone --template=&lt;template_directory&gt; &lt;repo_location&gt;</code></td>
<td style="text-align:left">clone位于<code>&lt;repo location&gt;</code>的仓库，并应用来自<code>&lt;template_directory&gt;</code>的仓库模板</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="查看工作路径"><a href="#查看工作路径" class="headerlink" title="查看工作路径"></a>查看工作路径</h4><p>当你在当前工作路径内工作时，你也可以使用<code>git status</code>命令来查看当前工作目录版本情况的信息：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master </span><br><span class="line"> </span><br><span class="line">No commits yet </span><br><span class="line"> </span><br><span class="line">Untracked files: </span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed) </span><br><span class="line"> </span><br><span class="line">        work.txt </span><br><span class="line"> </span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure>
<p>注意到在Untracked files下存在”work.txt”，这代表这个文本文档被Git可见，但是Git没有开始追踪这个文档的任何更改。解决这个问题我们需要向Git生命暂存更改。  </p>
<p><br></p>
<hr>
<h4 id="暂存更改"><a href="#暂存更改" class="headerlink" title="暂存更改"></a>暂存更改</h4><p>为了让 Git 开始跟踪你在工作目录中所做的更改，你需要先将这些文件添加到暂存区。<br>这可以通过使用命令<code>git add &lt;filename&gt;</code>来完成，其中<code>&lt;filename&gt;</code>是您正在处理的文件的名称，例如我们的”work.txt”文件。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add work.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master </span><br><span class="line"> </span><br><span class="line">No commits yet </span><br><span class="line"> </span><br><span class="line">Changes to be committed: </span><br><span class="line">  (use "git rm --cached &lt;file&gt;..." to unstage) </span><br><span class="line"> </span><br><span class="line">        new file:   work.txt</span><br></pre></td></tr></table></figure>
<p>现在”work.txt”已被加入暂存目录。</p>
<p><br></p>
<p><code>git add</code>的一些额外变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git add .</code></td>
<td style="text-align:left">将当前目录下所有文件添加到暂存区</td>
</tr>
<tr>
<td style="text-align:center"><code>git add -A</code><br>or<br><code>git add --all</code></td>
<td style="text-align:left">查找整个项目中存在的所有新文件或更新文件，并将其添加到暂存区</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="跟踪工作目录中文件变化"><a href="#跟踪工作目录中文件变化" class="headerlink" title="跟踪工作目录中文件变化"></a>跟踪工作目录中文件变化</h4><p>现在我们在”work.txt”新增第三行： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my Git tutorial.</span><br><span class="line">Today we will learn how to get started with Git.</span><br><span class="line">We start with the Basic Git Workflow.</span><br></pre></td></tr></table></figure>
<p>想要查看暂存区和工作目录中同一个文件的区别，我们完全可以使用<code>git diff &lt;filename&gt;</code>命令来查看区别： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff work.txt</span> </span><br><span class="line">diff --git a/work.txt b/work.txt </span><br><span class="line">index 90ac5e6..f0f679f 100644 --- a/work.txt </span><br><span class="line">+++ b/work.txt </span><br><span class="line">@@ -1,2 +1,3 @@ </span><br><span class="line">Welcome to my Git tutorial. </span><br><span class="line">Today we will learn how to get started with Git. </span><br><span class="line">+We start with the Basic Git Workflow.</span><br></pre></td></tr></table></figure>
<p>可以在最后一行看出，Git已经成功登记了文件的更改。如果想要将当前的状态加入暂存，随时可以执行<code>git add work.txt</code>命令。  </p>
<p>下面是一些<code>git diff</code>命令的变体： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>git diff --base &lt;filename&gt;</code></td>
<td style="text-align:left">查看与基础文件的冲突</td>
</tr>
<tr>
<td style="text-align:center"><code>git diff &lt;sourcebranch&gt; &lt;targetbranch&gt;</code></td>
<td style="text-align:left">在合并更改之前预览变更</td>
</tr>
</tbody>
</table>
</div>
<p>如果<code>git diff</code>的输出过长，则Git会使用分页器显示内容。在这种情况下我们可以按Q来退出分页器。<br>你也可以在参数中添加<code>--no-pager</code>告诉Git不要使用pager。这个设置对于绝大多数的Git命令都可以使用。  </p>
<p><br></p>
<hr>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>从暂存区存到仓库我们需要使用<code>git commit</code>来提交我们所做的所有更改，建立一个存档。  </p>
<p><code>git commit</code>在使用时需要跟一个参数<code>-m</code>，用来写入你这次更改的内容注释： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">"Added an introduction."</span></span></span><br><span class="line">[master (root-commit) 8327731] Added an introduction. </span><br><span class="line">    Committer: Chan Tai Man &lt;tmchan@academy11.cs.hku.hk&gt; </span><br><span class="line">Your name and email address were configured automatically based </span><br><span class="line">on your username and hostname. Please check that they are accurate. </span><br><span class="line">You can suppress this message by setting them explicitly. Run the </span><br><span class="line">following command and follow the instructions in your editor to edit </span><br><span class="line">your configuration file: </span><br><span class="line"> </span><br><span class="line">    git config --global --edit </span><br><span class="line"> </span><br><span class="line">After doing this, you may fix the identity used for this commit with: </span><br><span class="line"> </span><br><span class="line">    git commit --amend --reset-author </span><br><span class="line"> </span><br><span class="line"> 1 file changed, 3 insertions(+) </span><br><span class="line"> create mode 100644 work.txt</span><br></pre></td></tr></table></figure>
<p>请注意上面有关您的姓名和电子邮件地址配置的消息，实际上你可以按照说明对配置文件进行相应的更改。</p>
<p>始终输入有意义的提交消息，是程序员们的基本操作之一。这对你后期的开发有非常大的帮助，同时对别人也是。  </p>
<p><br></p>
<p>使用<code>git log</code>命令可以查看比较旧版本的项目：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 8327731fa6a9108fb6b54d0b38b9b59c7fbf316c (HEAD -&gt; master) </span><br><span class="line">Author: Chan Tai Man &lt;tmchan@academy11.cs.hku.hk&gt; </span><br><span class="line">Date:   Mon Jan 14 10:38:43 2019 +0800 </span><br><span class="line"> </span><br><span class="line">    Added an introduction.</span><br></pre></td></tr></table></figure>
<p>在每个log中会提供如下四个信息：  </p>
<ul>
<li>40字长的哈希码，我们叫SHA。这是每个commit的唯一识别码 </li>
<li>提交的作者，也就是你自己</li>
<li>提交的时间和日期</li>
<li>提交消息</li>
</ul>
<p><br></p>
<hr>
<h3 id="与他人合作"><a href="#与他人合作" class="headerlink" title="与他人合作"></a>与他人合作</h3><h4 id="使用分支系统"><a href="#使用分支系统" class="headerlink" title="使用分支系统"></a>使用分支系统</h4><p>分支可以看作是指向 Git 存储库中最新提交的指针。<br>当我们初始化存储库时，我们正在处理一个称为<code>master</code>分支的单个分支。我们正在处理的提交称为<code>HEAD</code>，通常是分支的最新提交。  </p>
<p>你可以在某个commit节点创建一个分支。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBed6b622ab401c9305753c7e2623a767f?method=download&amp;shareKey=b90b1091d05ac2a4898119d43ae308e9" alt=""></p>
<p>可以看一下上面这张图。这是一个正在开发的项目的Git图表。每一条线代表一个分支，每一个点代表一个commit。  </p>
<p>可以看到橙色的那条线从粉红色分支的一个commit拉出，经过一系列的更改，最后在上面的一个commit合并到粉红色分支。这两个粉红色commit之间区别在于并入了整个橙色分支的内容。  </p>
<p>要在当前commit拉出一个分支，可以使用<code>git branch BugFix</code>命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch BugFix</span></span><br></pre></td></tr></table></figure>
<p>拉出分支成功后当前工作分支还是在<code>master</code>上。切换到刚拉出来的<code>BugFix</code>分支我们需要：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix</span></span><br><span class="line">Switched to branch 'BugFix'</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>我们也可以使用<code>checkout</code>命令将 HEAD 移至上一个提交。<br>如果这样做，我们也会恢复此提交中文件的状态。例如，我们可以移动到提交 BugFix^，这是分支 BugFix 中的上一个提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix^</span></span><br><span class="line">Note: checking out 'BugFix^'.</span><br><span class="line"></span><br><span class="line">You are in 'detached HEAD' state. You can look around, make experimental </span><br><span class="line">changes and commit them, and you can discard any commits you make in this </span><br><span class="line">state without impacting any branches by performing another checkout. </span><br><span class="line"> </span><br><span class="line">If you want to create a new branch to retain commits you create, you may </span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example: </span><br><span class="line"> </span><br><span class="line">  git checkout -b &lt;new-branch-name&gt; </span><br><span class="line"> </span><br><span class="line">HEAD is now at 8327731 Added an introduction.</span><br></pre></td></tr></table></figure>
<p>想要移动一个特定的分支，那就用<code>git log</code>吧。  </p>
<p>下面是一些用于分支的可用命令：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git branch</code></td>
<td style="text-align:center">列出所有分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch branchname</code></td>
<td style="text-align:center">创建一个分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git checkout branchname</code></td>
<td style="text-align:center">切换到分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git checkout -b branchname</code></td>
<td style="text-align:center">创建并切换到分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -m branchname new_branchname</code></td>
<td style="text-align:center">重命名分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch --merged</code></td>
<td style="text-align:center">显示所有与当前分支合并过的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -d branchname</code></td>
<td style="text-align:center">删除合并完成的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -D branch_to_delete</code></td>
<td style="text-align:center">删除未合并的分支</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>用刚才的那张图做例子，橙色分支最后并入到了粉红色分支上，并入操作我们叫做(merge).  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">"This is some new file in master."</span> &gt; master.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add master.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">"Added master.txt"</span></span></span><br><span class="line">[master 832ceba] Added master.txt </span><br><span class="line"> 1 file changed, 1 insertions(+) </span><br><span class="line"> create mode 100644 master.txt</span><br></pre></td></tr></table></figure>
<p>接下来我们在BugFix分支上也添加一个新文件：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix</span></span><br><span class="line">Switched to branch 'BugFix'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">"This is some new file in BugFix"</span> &gt; bugfix.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add bugfix.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">"Added bugfix.txt"</span></span></span><br><span class="line">[BugFix ed600da] Added bugfix.txt </span><br><span class="line"> 1 file changed, 1 insertions(+) </span><br><span class="line"> create mode 100644 bugfix.txt</span><br></pre></td></tr></table></figure>
<p>我们可以选择向<code>BugFix</code>分支并入<code>master</code>，也可以向<code>master</code>并入<code>BugFix</code>。但是我们可以选择前者，因为这样我们就可以在不干扰<code>master</code>分支的前提下验证bug修复是否有用。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout BugFix</span></span><br><span class="line">Already on 'BugFix'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge master -m <span class="string">"Apply changes in master"</span></span></span><br><span class="line">Merge made by the 'recursive' strategy. </span><br><span class="line"> master.txt | 1 + </span><br><span class="line"> 1 file changed, 1 insertion(+) </span><br><span class="line"> create mode 100644 master.txt </span><br></pre></td></tr></table></figure>
<p>如果在<code>master</code>分支下出现了会影响到<code>BugFix</code>的更改，则会出现文件冲突。这时Git就会提示你解决冲突。  </p>
<p>现在假设我们发现修复没啥问题可以直接并入<code>master</code>，则我们可以直接快进并入，叫做”fast foward”。<br>这一步不会创建任何commit。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge BugFix</span></span><br><span class="line">Fast-forward</span><br><span class="line"> bugfix.txt | 1 + </span><br><span class="line"> 1 file changed, 1 insertion(+) </span><br><span class="line"> create mode 100644 bugfix.txt </span><br></pre></td></tr></table></figure>
<p>下面是一些<code>merge</code>命令的变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git merge branchname</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git merge --ff-only branchname</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git merge --no-ff branchname</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git merge --abort</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"><code>git cherry-pick 073791e7</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="在远程仓库上工作"><a href="#在远程仓库上工作" class="headerlink" title="在远程仓库上工作"></a>在远程仓库上工作</h4><p>目前为止我们只在本地仓库上作法。 如果你想要加入任何在线的Git项目，你需要去了解如何管理远程仓库。  </p>
<p>使用<code>git remote</code>命令来查看目前所有的远程仓库，<code>git remote -v</code>命令允许你去查看这些远程仓库的URL：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into 'ticgit'...</span><br><span class="line">remote: Enumerating objects: 1857, done. </span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857 </span><br><span class="line">Receiving objects: 100% (1857/1857), 334.04 KiB | 395.00 KiB/s, done. </span><br><span class="line">Resolving deltas: 100% (837/837), done. </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span> </span><br><span class="line">origin </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span> </span><br><span class="line">origin  https://github.com/schacon/ticgit (fetch) </span><br><span class="line">origin  https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>想要添加远程仓库，你可以使用<code>git remote add &lt;shortname&gt; &lt;URL&gt;</code>命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span> </span><br><span class="line">origin </span><br><span class="line">pb</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>或者如果你想查看一个远程仓库的信息，就使用<code>git remote show &lt;remote&gt;</code>：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span> </span><br><span class="line">* remote origin </span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit </span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit </span><br><span class="line">  HEAD branch: master </span><br><span class="line">  Remote branches: </span><br><span class="line">    master tracked </span><br><span class="line">    ticgit tracked </span><br><span class="line">  Local branch configured for 'git pull': </span><br><span class="line">    master merges with remote master </span><br><span class="line">  Local ref configured for 'git push': </span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>
<p>下面有一些有关远程仓库的命令和变体：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git remote</code></td>
<td style="text-align:center">查看远程仓库配置</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote -v</code></td>
<td style="text-align:center">带着URL查看远程仓库配置</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote add &lt;shortname&gt; &lt;URL&gt;</code></td>
<td style="text-align:center">添加远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote rm &lt;shortname&gt;</code></td>
<td style="text-align:center">删除在本地记录的远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git remote rename &lt;old-name&gt; &lt;new-name&gt;</code></td>
<td style="text-align:center">重命名在本地记录的远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch --merged</code></td>
<td style="text-align:center">显示所有与当前分支合并过的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -d branchname</code></td>
<td style="text-align:center">删除合并完成的分支</td>
</tr>
<tr>
<td style="text-align:left"><code>git branch -D branch_to_delete</code></td>
<td style="text-align:center">删除未合并的分支</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你在本地对远程仓库做出了更改，并且想要远程仓库同步你本地的版本，就可以使用<code>git push</code>将本地的代码推送到远程仓库。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>
<p>此命令仅在您从具有写入权限的服务器克隆且在此期间无人推送时才有效。<br>如果你和其他人同时克隆，并且他们推送上游，然后您推送上游，您的推送将被拒绝。<br>这种情况下必须先获取他们的工作并将其合并到当前版本的工作中，然后才允许推送。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; &lt;branch&gt;</code></td>
<td style="text-align:center">将某个特定分支推送同步到远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; --force</code></td>
<td style="text-align:center">和上面一样，但是本命令会强制将本地推送到远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; -all</code></td>
<td style="text-align:center">将本地所有分支推送同步到远程仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git push &lt;remote&gt; --tags</code></td>
<td style="text-align:center">将所有的本地标签推送到远程仓库</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h4 id="从远程仓库拉取"><a href="#从远程仓库拉取" class="headerlink" title="从远程仓库拉取"></a>从远程仓库拉取</h4><p>有点像是下载，也可以算是同步。本命令基本上用来以远程仓库为基准，更新本地仓库。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>git pull &lt;remote&gt;</code></td>
<td style="text-align:center">将远程仓库的内容同步到本地仓库</td>
</tr>
<tr>
<td style="text-align:left"><code>git pull --no-commit &lt;remote&gt;</code></td>
<td style="text-align:center">从远程仓库拉取，但是不在本地创建提交</td>
</tr>
<tr>
<td style="text-align:left"><code>git pull --verbose</code></td>
<td style="text-align:center">从远程仓库拉取时返回verbose内容</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>ENGG1340笔记</p><p><a href="http://naughtychas.github.io/2025/01/25/ENGG1340笔记/">http://naughtychas.github.io/2025/01/25/ENGG1340笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://NaughtyChas.github.io"><p>ntcs</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-01-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-02-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2024/12/11/Exam%20Notes%20for%20ENGG1330/" target="_blank" rel="noreferrer">Exam Notes for ENGG 1330</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/" target="_blank" rel="noreferrer">邈想日集</a><br></span><span>  2.<a class="is-size-6" href="/2025/01/25/ENGG1340%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ENGG1340笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/" target="_blank" rel="noreferrer">浅谈今年CAIE的POE考试</a><br></span><span>  6.<a class="is-size-6" href="/2022/09/05/%E4%BD%A0%E8%AF%B4%E5%BE%97%E5%AF%B9/" target="_blank" rel="noreferrer">收集&quot;你说得对&quot;</a><br></span></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/12/11/Exam%20Notes%20for%20ENGG1330/"><span class="level-item">Exam Notes for ENGG 1330</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://giscus.app/client.js" data-repo="NaughtyChas/NaughtyChas.github.io" data-repo-id="R_kgDOHzXKqQ" data-category="Announcements" data-category-id="DIC_kwDOHzXKqc4CmXAk" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#前言"><span class="mr-2">1</span><span>前言</span></a></li><li><a class="is-flex is-mobile" href="#Module-1-Linux-Environment"><span class="mr-2">2</span><span>Module 1: Linux Environment</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Linux-Shell"><span class="mr-2">2.1</span><span>Linux Shell</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#命令使用说明"><span class="mr-2">2.1.1</span><span>命令使用说明</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#路径和文件管理"><span class="mr-2">2.2</span><span>路径和文件管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#相对路径和绝对路径"><span class="mr-2">2.2.1</span><span>相对路径和绝对路径</span></a></li><li><a class="is-flex is-mobile" href="#主目录"><span class="mr-2">2.2.2</span><span>主目录</span></a></li><li><a class="is-flex is-mobile" href="#重命名路径"><span class="mr-2">2.2.3</span><span>重命名路径</span></a></li><li><a class="is-flex is-mobile" href="#复制文件"><span class="mr-2">2.2.4</span><span>复制文件</span></a></li><li><a class="is-flex is-mobile" href="#命令模式下的命令"><span class="mr-2">2.2.5</span><span>命令模式下的命令</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文件权限"><span class="mr-2">2.3</span><span>文件权限</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#权限指示"><span class="mr-2">2.3.1</span><span>权限指示</span></a></li><li><a class="is-flex is-mobile" href="#举例"><span class="mr-2">2.3.2</span><span>举例</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#其他常用命令"><span class="mr-2">2.4</span><span>其他常用命令</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#文件内搜索-grep"><span class="mr-2">2.4.1</span><span>文件内搜索 (grep)</span></a></li><li><a class="is-flex is-mobile" href="#文件字数-wc"><span class="mr-2">2.4.2</span><span>文件字数 (wc)</span></a></li><li><a class="is-flex is-mobile" href="#排序"><span class="mr-2">2.4.3</span><span>排序</span></a></li><li><a class="is-flex is-mobile" href="#剪切文件"><span class="mr-2">2.4.4</span><span>剪切文件</span></a></li><li><a class="is-flex is-mobile" href="#移除重复行"><span class="mr-2">2.4.5</span><span>移除重复行</span></a></li><li><a class="is-flex is-mobile" href="#拼写检查"><span class="mr-2">2.4.6</span><span>拼写检查</span></a></li><li><a class="is-flex is-mobile" href="#文件差异"><span class="mr-2">2.4.7</span><span>文件差异</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#标准I-O，文件重定向和管道"><span class="mr-2">2.5</span><span>标准I/O，文件重定向和管道</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#管线"><span class="mr-2">2.5.1</span><span>管线</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#搜索"><span class="mr-2">2.6</span><span>搜索</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#搜索文件或路径-find"><span class="mr-2">2.6.1</span><span>搜索文件或路径 (find)</span></a></li><li><a class="is-flex is-mobile" href="#其他常用匹配写法"><span class="mr-2">2.6.2</span><span>其他常用匹配写法</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#Module-2-Shell-Script-amp-Version-Control"><span class="mr-2">3</span><span>Module 2: Shell Script &amp; Version Control</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Shell脚本"><span class="mr-2">3.1</span><span>Shell脚本</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#命令替换"><span class="mr-2">3.1.1</span><span>命令替换</span></a></li><li><a class="is-flex is-mobile" href="#获取控制台参数数量"><span class="mr-2">3.1.2</span><span>获取控制台参数数量</span></a></li><li><a class="is-flex is-mobile" href="#for循环"><span class="mr-2">3.1.3</span><span>for循环</span></a></li><li><a class="is-flex is-mobile" href="#输出到标准错误"><span class="mr-2">3.1.4</span><span>输出到标准错误</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#版本控制"><span class="mr-2">3.2</span><span>版本控制</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#提交更改"><span class="mr-2">3.2.1</span><span>提交更改</span></a></li><li><a class="is-flex is-mobile" href="#从远程仓库拉取"><span class="mr-2">3.2.2</span><span>从远程仓库拉取</span></a></li></ul></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a><p class="size-small"><span>&copy; 2025 ntcs</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noreferrer">Icarus</a> &amp; <a href="https://github.com/LittleYe233/hexo-theme-amazingremake" target="_blank" rel="noreferrer">Amazing-Remake</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022.8.11 17:07:12')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/LittleYe233/hexo-theme-amazingremake"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    enabled: true,
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { // 加载mathjax
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    autoload: {
                        color: [],
                        colorv2: ['color']
                    },
                    packages: {'[+]': ['noerrors']}
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                },
                loader: {
                    load: ['input/asciimath', '[tex]/noerrors']
                }
            };
            $.getScript('//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('undefined','undefined','undefined','undefined',undefined);});
            }
            if('undefined' === 'mathjax'){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>