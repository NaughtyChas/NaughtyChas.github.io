<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>A2CS笔记 - ntcs&#039; blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ntcs&#039; blog"><meta name="msapplication-TileImage" content="img/icon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ntcs&#039; blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="CS课堂笔记 (A2)"><meta property="og:type" content="article"><meta property="og:title" content="A2CS笔记"><meta property="og:url" content="http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="ntcs&#039; blog"><meta property="og:description" content="CS课堂笔记 (A2)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><meta property="article:published_time" content="2023-07-01T09:18:28.000Z"><meta property="article:modified_time" content="2023-10-04T04:14:42.634Z"><meta property="article:author" content="MXK"><meta property="article:tag" content="笔记"><meta property="article:tag" content="CIE"><meta property="article:tag" content="计算机"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"},"headline":"ntcs' blog","image":["http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"],"datePublished":"2023-07-01T09:18:28.000Z","dateModified":"2023-10-04T04:14:42.634Z","author":{"@type":"Person","name":"MXK"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"CS课堂笔记 (A2)"}</script><link rel="canonical" href="http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/icon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ntcs' blog" type="application/atom+xml">
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/thumbnails/CS.jpg" alt="A2CS笔记"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-07-01  <a class="commentCountImg" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">f4fef354d440d79d973c2bf25f8e464b</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f4fef354d440d79d973c2bf25f8e464b">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>4 小时  <i class="fas fa-pencil-alt"> </i>37.5 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">A2CS笔记</h1><div class="content"><blockquote>
<p>CS课堂笔记 (A2)<br><span id="more"></span></p>
</blockquote>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h1><p>学了一段时间的计算机，觉得继续写这些笔记还是蛮有用的，于是乎就打算继续下去。<br>这次是A2阶段的计算机笔记。<br>和AS部分一样，写下本文的目的是帮助自己更好地学习CS这门科目，因此，希望路过的大佬轻喷。  </p>
<hr>
<p>本笔记内容基于《Computer Science for Cambridge International AS &amp; A Level》，剑桥大学出版社出版，教材为第二版，A-Level课程编号为<code>9618</code>。  </p>
<hr>
<h1 id="PART-THREE-进阶理论"><a href="#PART-THREE-进阶理论" class="headerlink" title="PART THREE: 进阶理论"></a><strong>PART THREE: 进阶理论</strong></h1><h1 id="第十六章：数据的表示"><a href="#第十六章：数据的表示" class="headerlink" title="第十六章：数据的表示"></a><strong>第十六章：数据的表示</strong></h1><p>崭新的故事从第十六章继续开始了。  </p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>早在第13章我们介绍过变量的数据类型的概念。具体是：当一个程序在使用变量之前，必须要显示别该变量的数据类型。  </p>
<p>当时介绍了一些最常用的数据类型，但是在本章我们将会接触一些更深入的数据类型。  </p>
<p><br></p>
<h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a><strong>内置数据类型</strong></h3><p><strong>内置数据类型 (Built-in data types)</strong>，顾名思义，就是已经默认集成在编译器中的数据类型，是<strong>被编程语言预先定义的数据类型</strong>。一般来说，这些数据类型被认为成执行数据操作最快的类型。  </p>
<p>比如说在Python里面，内置数据类型就有这些：str, int, float等。  </p>
<p>这些数据类型具体的操作，值分配的操作全部由编程语言定义。  </p>
<p><br></p>
<hr>
<h3 id="用户定义的数据类型"><a href="#用户定义的数据类型" class="headerlink" title="用户定义的数据类型"></a><strong>用户定义的数据类型</strong></h3><p>和内置数据类型相对立的，就是可以由用户定义的数据类型。</p>
<p>一般来说，“用户”通常是使用操作系统提供“用户界面”的人：“用户”是向正在运行的程序提供输入并从其接收输出的人。然而在编写程序时，程序员就成为了编程语言所指的“用户”。名词 <strong>用户定义的数据类型(User-defined data types)</strong> 中的“用户”就是指程序员们。  </p>
<p>这种数据类型是由用户在程序中根据需要所定义的，以便根据幼存储相同或者不同类型的数据类型。  </p>
<p>尽管用户定义的数据类型不是内置数据类型，但是只有在编程语言提供对该类型构造的支持情况下，才可以使用某种特定的用户定义数据类型。  </p>
<article class="message is-info"><div class="message-body">

<b>User-defined data type: where the programmer includes the definition in the program.</b>

</div></article> 


<p><br></p>
<hr>
<h3 id="非复合数据类型"><a href="#非复合数据类型" class="headerlink" title="非复合数据类型"></a><strong>非复合数据类型</strong></h3><p><strong>非复合数据类型 (Non-composite data types)</strong> 是不引用其他数据类型的数据类型。也就是说，这些数据类型的定义没有用到其他的数据类型。  </p>
<p>某些用户定义的数据类型也有可能是非符合的数据类型。  </p>
<article class="message is-info"><div class="message-body">

<b>Non-composite data type: a data type defined without reference to another data type.</b>

</div></article> 



<p><br></p>
<hr>
<h3 id="枚举数据类型"><a href="#枚举数据类型" class="headerlink" title="枚举数据类型"></a><strong>枚举数据类型</strong></h3><p><strong>枚举数据类型 (Enumerated data type)</strong>是用户定义的数据类型，它是根据有序值列表定义的。 </p>
<p>同时，它是一种非复合数据类型。</p>
<p>简单举一个例子就很好理解了：这里使用Python来定义一个数据类型<code>Color</code>:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    RED = <span class="number">1</span></span><br><span class="line">    GREEN = <span class="number">2</span></span><br><span class="line">    BLUE = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Color.RED)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行了<code>print(Color.RED)</code>之后，会输出<code>1</code>。因为<code>RED</code>定义的值正好为<code>1</code>。  </p>
<p>我们通过上面的代码定义了一个名叫<code>Color</code>的枚举数据类型，其中包含三个值：<code>RED</code>,<code>GREEN</code>和<code>BLUE</code>。  </p>
<p>需要注意的是，枚举数据类型中定义的值是有序的，这意味着枚举数据类型具有隐含的值顺序。</p>
<article class="message is-info"><div class="message-body">

<b>Enumerated data type: a non-composite user-defined data type for which the definition identifies all possible values.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="复合用户定义数据类型"><a href="#复合用户定义数据类型" class="headerlink" title="复合用户定义数据类型"></a><strong>复合用户定义数据类型</strong></h3><p>开始变复杂了。  </p>
<p><strong>复合用户定义数据类型 (Composite user-defined data types)</strong>具有引用至少一种其他类型的定义。  </p>
<p>复合用户定义数据类型有两个非常重要的实例：  </p>
<ol>
<li><p>在第十三章介绍过的<strong>记录数据类型 (Record data type)</strong>是描述值和变量的数据类型。这是程序员定义的数据类型，允许程序员定义新的记录类型。这允许程序员们使用精确匹配特定程序的数据要求的组件来创建并记录数据类型。Python不支持这样的数据类型。  </p>
</li>
<li><p><strong>类 (Class)</strong>是面向对象编程中用于对象的数据类型。换句话说，类是创建对象(或者特定数据结构)，提供窗台初始值，以及行为实现的蓝图。  </p>
</li>
</ol>
<p>下面的代码就是在Python中的一个类：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"Hello, my name is <span class="subst">{self.name}</span> and I am <span class="subst">{self.age}</span> years old."</span>)</span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">"John"</span>, <span class="number">25</span>)</span><br><span class="line">person.say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们定义了一个名叫<code>Person</code>的类，其中包含两个子变量：<code>name</code>和<code>age</code>，和一个子函数<code>say_hello()</code>。  </p>
<p><br></p>
<hr>
<h3 id="指针数据类型"><a href="#指针数据类型" class="headerlink" title="指针数据类型"></a><strong>指针数据类型</strong></h3><p>在计算机编程中，<strong>指针 (Pointer)</strong>是一个存储另一个变量的内存地址的变量。<strong>指针数据类型 (Pointer data type)</strong>是用于声明指针变量的数据类型。  </p>
<p>在AS部分学的链表(Linked list)<strong>不是</strong>一个指针数据类型。因为链表是一种包含指向其他节点的指针的数据结构。不是指针数据类型的原因是它存储的不是内存地址的变量。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>学学伪代码：  </p>
<p>当需要使用指针的时候，就可以使用这个符号声明：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TYPE</span><br><span class="line">TIntegerPointer ← ^Integer</span><br></pre></td></tr></table></figure>
<p>定义了<code>TIntegerPointer</code>的数据类型是整形的指针。  </p>
<p>我们也可以这么写：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE MyIntegerPointer : TIntegerPointer</span><br></pre></td></tr></table></figure>
<p>这是一个不需要使用插入符 (^) 的方法。  </p>
<p><br></p>
<p><br></p>
<p>接下来我们来定义一些数据：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE Number1, Number2 : INTEGER</span><br><span class="line">Number1 ← 100</span><br><span class="line"></span><br><span class="line">MyIntegerPointer ← @Number1</span><br></pre></td></tr></table></figure>
<p>最后一行代码向指针变量赋了值。变量<code>MyIntegerPointer</code>现在存储着<code>Number1</code>的地址。   </p>
<p>然后我们可以使用下面的这种方法为<code>Number2</code>赋予一个<code>200</code>的值：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number2 ← MyIntegerPointer^ * 2</span><br></pre></td></tr></table></figure>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Pointer variable: one for which the value is the address in memory of a different variable.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="集合数据类型"><a href="#集合数据类型" class="headerlink" title="集合数据类型"></a><strong>集合数据类型</strong></h3><p>计算机科学中也存在集合的定义：<strong>集合是一种抽象数据类型，可以存储某些值，没有任何特定的顺序，并且没有重复的值。</strong>  </p>
<p><strong>集合数据类型 (Set data type)</strong>与大多数其他集合类型不同，通常不是从集合中检索特定元素，而是测试集合中的成员资格值，可以说是将一整个整体来进行处理(?)</p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Set: a collection of data items that lacks any structure;contains no duplicates and has a number of defined operations that can be performed on it.</b>

</div></article> 

<p><br></p>
<p>常用的操作有这些：  </p>
<ul>
<li>检查集合中是否存在某个值</li>
<li>添加新的数据值</li>
<li>删除现有的数据值</li>
<li>将一个集合添加到另一个集合当中</li>
</ul>
<p><br></p>
<hr>
<p>Python的其中一个亮点就和集合数据类型有关。在Python中，处理集合数据类型十分方便。  </p>
<p>下面是在Python中操作集合数据类型的一些实例：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个集合</span></span><br><span class="line">my_set = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向集合中添加一个值</span></span><br><span class="line">my_set.add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合中剔除一个值</span></span><br><span class="line">my_set.remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查值是否在集合内</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> <span class="keyword">in</span> my_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2 is in the set"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- 华丽的分割线 ------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个集合</span></span><br><span class="line">set1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">set2 = {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的并集</span></span><br><span class="line">union_set = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(union_set) <span class="comment"># 输出为: {1, 2, 3, 4, 5}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的交集</span></span><br><span class="line">intersection_set = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(intersection_set) <span class="comment"># 输出为: {3}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的差</span></span><br><span class="line">difference_set = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(difference_set) <span class="comment"># 输出为: {1, 2}</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h2><p>在日常计算机使用中，会遇到各种各样的文件类型，例如图形文件、文字处理文件、电子表格文件等。<br>无论文件类型如何，内容都使用特定的二进制代码存储，从而保证文件的正常使用。  </p>
<p>这里就出现了新东西：<strong>二进制文件 (Binary file)</strong>和<strong>记录 (Record)</strong>  </p>
<p>二进制文件是包含二进制格式信息的文件，二进制格式是 0 和 1 的序列。二进制文件用于以计算机可以读取但人类不易理解的格式存储数据。二进制文件的示例包括可执行文件、图像文件和音频文件。</p>
<p>记录是一种包含一个或多个字段的数据结构，每个字段包含一条数据。记录用于以易于访问和操作的方式存储和组织数据。在计算机科学中，记录通常用于表示数据库和其他数据存储系统中的数据。</p>
<article class="message is-info"><div class="message-body">

<b>Binary file: a file designed for storing data to be used by a computer program.</b>

<br>

<b>Record: a collection of fields containing data values.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="串行文件"><a href="#串行文件" class="headerlink" title="串行文件"></a><strong>串行文件</strong></h3><p><strong>串行文件 (Serial file)</strong>是一种包含信息的文件类型，<strong>信息按其发生的顺序记录在文件中。</strong>  </p>
<p>它还可以用来记录文件信息。在这种情况下，文件信息将按照它们在串行文件中保存的顺序列出。所以说：信息或文件基本上是按时间顺序记录的。  </p>
<p><br></p>
<hr>
<h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a><strong>顺序文件</strong></h3><p><strong>顺序文件 (Sequential files)</strong>是根据某些键值排序的文件。顺序文件主要用于文件命中率较高的应用场景中。 <em>#文件命中率衡量计算机系统或程序性能的重要参数,它可以反应计算机在访问存储器时的效率。</em>  </p>
<p>顺序文件的一个示例是包含有关公司员工信息的文件。<br>该文件可以根据员工的姓氏进行排序，以便将具有相同姓氏的所有员工分组在一起。这将使根据姓氏搜索员工变得更加容易。</p>
<p><br></p>
<hr>
<h3 id="直接访问文件"><a href="#直接访问文件" class="headerlink" title="直接访问文件"></a><strong>直接访问文件</strong></h3><p><strong>直接访问文件 (Direct-access file)</strong> 有时候也被称之为<strong>随机访问文件 (Random-access files)</strong>。和内存一样，随机性表明我们可以访问文件中的任何记录，或者在任何位置写入内容，而无需按照顺序依行读取文件。在使用这种文件时，我们可以直接访问文件的某个区块。  </p>
<p><br></p>
<p>另一种方法是在将记录输入直接访问文件时使用散列算法。</p>
<p>如果每条记录中有一个数字关键字段，则可以使用一种简单的哈希算法。<br>该算法选择一个合适的数字并将该数字除以关键字段中的值。 然后，该除法的余数标识文件中用于存储该记录的地址。<br>如果合适的数字是与文件的预期大小相似的质数，则效果最佳。</p>
<p>我们举一个简单的计算例子：我们使用关键字段中的 4 位值来说明文件中的地址，其中 1000 用于除数。 以下代表三种计算，其中余数代表地址：  </p>
<p>0045 / 1000 余数为45<br>2005 / 1000 余数为5<br>3000 / 1000 余数为5</p>
<p>从这些计算中可以看出两个事实。<br>第一个事实是，计算出的地址没有任何顺序，具体取决于关键字段中的值。<br>第二个事实是，不同的关键字段值可以产生相同的余数，因此在文件中产生相同的地址。</p>
<p>正因为相同的地址可能产生，所以当同一个地址被使用的时候，可能会发生冲突。<br>哈希算法的职责是尽可能平均地分配地址，从而最大限度地减少冲突的可能性。  </p>
<p>但是哈希算法也不是万能的，无论再怎么平均分配，冲突必定出现。所以说如果冲突出现，我们有以下这些解决方案：  </p>
<ul>
<li>使用顺序搜索来查找计算出的地址后是否有空闲地址。</li>
<li>在文件末尾保留一些溢出地址。</li>
<li>创建一个可以从每个地址访问的链接列表。</li>
</ul>
<p><br></p>
<hr>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a><strong>文件访问</strong></h3><p>一旦我们选择了文件组织，并将文件中注入了数据，我们就需要考虑下如何使用这些文件，如何访问这些数据。  </p>
<p>对于<strong>串行文件</strong>来说，正常的方法是逐条读取文件。但是说如果需要再其中的一个字段中搜索特定的一个值，唯一的办法就是从头开始读取记录，直到我们找到了我们的目标。  </p>
<p>如果我们需要在<strong>顺序文件</strong>寻找特定值的话，可能也需要像串行文件一样进行搜索。但是，如果我们已知包含所需数据的关键字段，那么直接读取关键字段就可以了。  </p>
<p><strong>直接访问文件</strong>的话，首先需要将关键字段的值提供给哈希算法进行计算。</p>
<p><br></p>
<hr>
<h3 id="文件类型的选择"><a href="#文件类型的选择" class="headerlink" title="文件类型的选择"></a><strong>文件类型的选择</strong></h3><p><strong>串行文件</strong>特别适合批处理或者备份磁带上的数据，因为串行文件中的数据是与时间相关的。  </p>
<p>如果我们需要快速访问一个大文件中的单个记录，就需要使用<strong>直接访问文件</strong>。比如说需要登录一个具有许多用户的系统，在这种情况下，用户登录时用于检查密码的文件就应该是直接访问的。  </p>
<p><strong>顺序文件</strong>特别适用与从文件的一次搜索中获得多个记录的应用程序。一个例子是家谱：我们可以对所有特定家族名称的所有记录进行搜索。  </p>
<p><br></p>
<hr>
<h2 id="实数"><a href="#实数" class="headerlink" title="实数"></a><strong>实数</strong></h2><p>在计算机中，实数是带有小数部分的数。  </p>
<p>当我们在一个二进制系统中写下一个实数的值，并需要存储下来的话，我们有多个选择：我们可以选择简单的表示法，也可以使用指数表示法(科学计数法)。  </p>
<p>比如说，数字’25.3’可以写成：  </p>
<p>       <code>.253 * 10^2</code> 或 <code>2.53 * 10^1</code> 或 <code>25.3 * 10^0</code> 或 <code>253 * 10^-1</code></p>
<p>就对于’25.3’来说，直接表达是最好的存储方案。<br>但如果数字非常大或非常小，就需要尽可能地使用科学计数法。  </p>
<p><br></p>
<hr>
<h3 id="浮点-amp-定点表示法"><a href="#浮点-amp-定点表示法" class="headerlink" title="浮点&定点表示法"></a><strong>浮点&amp;定点表示法</strong></h3><p>在计算机系统中，我们只能是有二进制码来存储实数。其中的一种方法就是使用<strong>定点表示法 (Fixed-point representation)</strong>。  </p>
<p>在定点表示法中，首先需要确定总位数。其中总位数中的一部分位来表示整数部分，其余的位表示小数部分。  </p>
<p>另一种方法就是使用<strong>浮点表示法 (Floating-point representation)</strong>。所有使用浮数都可以改写成下面这种形式：  </p>
<p>         <code>±M × R^E</code></p>
<p>其中，有效的位数由<code>±M</code>表示，我们叫做<strong>尾数 (Mantissa)</strong>。<code>E</code>表示指数。浮点数中的 “指数 “并不代表原数的整数部分。相反，它表示在确定浮点表示数的值时，基数（在计算机系统中通常为 2）所升高的整数幂。  </p>
<p>一般来说基数<code>R</code>不会存储进这个浮点数内，因为<code>R</code>有一个隐含值“2”。具体原因是我们在使用二进制表示数字时逢2进一。    </p>
<article class="message is-info"><div class="message-body">

<b>Floating-point representation: a representation of real numbers that stores a value for the mantissa and a value for the exponent.</b>

</div></article> 

<p><br></p>
<p><em>p.s. mantissa是尾数的意思。</em></p>
<p><br></p>
<hr>
<p>我们来举例子了解一下两种表示法之间的区别：  </p>
<p>对于定点表示法来说，在一个字节内，我们可以使用最高的有效位作为符号位，然后再使用接下来的五位表示整数部分。这就会为小数部分的表示留下两个位。  </p>
<p>下表给出了一些比较重要的非零值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:center">二进制码</th>
<th style="text-align:center">(对应的)十进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">最大的正值</td>
<td style="text-align:center"><code>011111 11</code></td>
<td style="text-align:center">31.75</td>
</tr>
<tr>
<td style="text-align:left">最小的正值</td>
<td style="text-align:center"><code>000000 01</code></td>
<td style="text-align:center">0.25</td>
</tr>
<tr>
<td style="text-align:left">绝对值最小的负值</td>
<td style="text-align:center"><code>100000 01</code></td>
<td style="text-align:center">-0.25</td>
</tr>
<tr>
<td style="text-align:left">绝对值最大的负值</td>
<td style="text-align:center"><code>111111 11</code></td>
<td style="text-align:center">-31.75</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>浮点表示法的话，我们可以使用4个位来表示尾数，然后再使用另外的4位表示指数。每一个位都使用2的补码来表示。<br>其中，指数存储为有符号的整数，尾数存储为定点实数。  </p>
<p>那么我们应该如何确定哪一位是二进制点。</p>
<p>下面的表格给出了使用4位来表示尾数的两个选项：<br>在每种情况下，我们都选择了等价的二进制点，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>011 1</code></td>
<td style="text-align:center"><code>3.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>011 0</code></td>
<td style="text-align:center"><code>3.0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>010 1</code></td>
<td style="text-align:center"><code>2.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>101 0</code></td>
<td style="text-align:center"><code>-3.0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>100 1</code></td>
<td style="text-align:center"><code>-3.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>100 0</code></td>
<td style="text-align:center"><code>-4.0</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0 111</code></td>
<td style="text-align:center"><code>0.875</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0 110</code></td>
<td style="text-align:center"><code>0.75</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0 101</code></td>
<td style="text-align:center"><code>0.625</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 010</code></td>
<td style="text-align:center"><code>-0.75</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 001</code></td>
<td style="text-align:center"><code>-0.875</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 000</code></td>
<td style="text-align:center"><code>-1.0</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0111</code></td>
<td style="text-align:center"><code>7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0110</code></td>
<td style="text-align:center"><code>6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0101</code></td>
<td style="text-align:center"><code>5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1010</code></td>
<td style="text-align:center"><code>-6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1001</code></td>
<td style="text-align:center"><code>-7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1000</code></td>
<td style="text-align:center"><code>-8</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>浮点表示法的特殊值如下表所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:center">二进制码</th>
<th style="text-align:center">(对应的)十进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">最大的正值</td>
<td style="text-align:center"><code>0 111 0111</code></td>
<td style="text-align:center">0.875 × 2^7 = <strong>112</strong></td>
</tr>
<tr>
<td style="text-align:left">最小的正值</td>
<td style="text-align:center"><code>0 001 1000</code></td>
<td style="text-align:center">0.125 × 2^(-8) = <strong>1/2048</strong></td>
</tr>
<tr>
<td style="text-align:left">绝对值最小的负值</td>
<td style="text-align:center"><code>1 111 1000</code></td>
<td style="text-align:center">-0.125 × 2^(-8) = <strong>-1/2048</strong></td>
</tr>
<tr>
<td style="text-align:left">绝对值最大的负值</td>
<td style="text-align:center"><code>1 000 0111</code></td>
<td style="text-align:center">-1 × 2^7 = <strong>-128</strong></td>
</tr>
</tbody>
</table>
</div>
<p><em>p.s. 上课时候有人提出了一个问题：Exponent部分的第一位为什么不是1从而达到最大值？老师的解释是“因为Exponent部分也同样存在符号位，所以最大的正值只能将后三位填充为一。”</em></p>
<p><br></p>
<hr>
<h3 id="精度与标准化"><a href="#精度与标准化" class="headerlink" title="精度与标准化"></a><strong>精度与标准化</strong></h3><p>当使用浮点表示法表示数据时，需要从两个方面着重考虑。  </p>
<p>首先需要决定使用的总位数，然后还要决定分割线的位置 <em>(表示尾数的位数和表示指数的位数之间的分割线)</em>  </p>
<p>然而在我们使用的时候只需要选择使用的总位数就可以了。具体的位数分割就会交给浮点处理器来决定。  </p>
<p>当然这也不代表你没法决定尾数和指数位数的数量了：一般来说，增加尾数位数可以提供更高的精度，但是同样会减少指数位数。如此一来就会减少可以表示的值的范围。  </p>
<p>所以说为了获取最大精度，我们就必须要标准化浮点数。因为<strong>越多的尾数位数代表着更高的精准度</strong>，所以在考虑提升精度时，要尽可能对表示尾数的位数使用多的位数。  </p>
<p><strong>将浮点表示法中的数字标准化意味着选择一个指数，以防止在尾数中出现前导零。</strong>。举个例子：<code>0 1000.11</code>并没有标准化：小数点前面一共有5位。如果想要标准化这一串数据，就要将其变成<code>0.100011</code>。小数点向左移动了四位，因此在此情景中指数为4。</p>
<p><br></p>
<p>我们可以使用八位浮点表示一个数值。因为要表示正数，十进制表示以2进位。<br>比如说：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制表示</th>
<th style="text-align:center">浮点二进制表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0.125 × 2^4</code></td>
<td style="text-align:center"><code>0 001 0100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0.25 × 2^3</code></td>
<td style="text-align:center"><code>0 010 0011</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0.5 × 2^2</code></td>
<td style="text-align:center"><code>0 100 0010</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>表示负数也没有问题。这里用-4作为十进制表示的底数：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制表示</th>
<th style="text-align:center">浮点二进制表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-0.25 × 2^4</code></td>
<td style="text-align:center"><code>1 110 0100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-0.5 × 2^3</code></td>
<td style="text-align:center"><code>1 100 0011</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-1.0 × 2^2</code></td>
<td style="text-align:center"><code>1 000 0010</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="表示法的转换"><a href="#表示法的转换" class="headerlink" title="表示法的转换"></a><strong>表示法的转换</strong></h3><p>在AS部分的第一章，我们讨论了多种将数字转换为不同形式的方法。</p>
<p>先来看定点二进制表示法。举个例子：4.75转换为定点二进制表示法  </p>
<p>打眼一看挺简单的：4可以转换为<code>100</code>，.75转化为二进制的<code>.11</code>，所以4.75的定点二进制表示法大概是<code>100.11</code>。但是别忘了正数的首位需要以0开头。这样的话就只添加一个符号位就可以解决问题了。这样，4.75就可以以定点二进制表示法写成<code>0100.11</code>。  </p>
<p>那么负数怎么办呢？比如说-4.75，就可以先从4.75的表示开始，然后再将它转换成对应的二进制补码：  </p>
<p>     <code>0100.11</code> 转换为： <code>1011.00</code>（一次补码）<br>     <code>1011.01</code>就是-4.75的二次补码。</p>
<p>有关于二次补码的内容，可以去AS部分的第一张扒翻一下。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>转换成浮点就有一些复杂了。在转换之前，我们应该注意：大多数小数部分无法精确地转换为浮点数值。因为二进制小数部分的因数有1/2， 1/4， 1/8， 1/16等等。所以说除非被转换的值正好是这些因数的和，否则无法进行精确的转换。<br>比如说，从0.1到0.9之间的的值中，只有0.5可以被精确的转换。</p>
<p><br></p>
<p>转换正值的方法如下：  </p>
<ol>
<li>使用我们在AS第一章中描述的方法转换整数部分。</li>
<li>添加在开头添加符号位</li>
<li>使用下面的方法转换小数位  </li>
<li>将整数和小数部分组合起来，并将它们输入到分配用于表示尾数的最高有效位中。</li>
<li>用零填充尾数的剩余位和指数的位。</li>
<li>通过改变指数值来调整二进制小数点的位置，以实现归一化的表示。</li>
</ol>
<p><br></p>
<p>第三步提到的方法如下：  </p>
<p>我们试着转化一下8.75：  </p>
<ol>
<li>整数位8转换成<code>1000</code>，然后添加符号位。这样就变成了<code>0 1000</code></li>
<li>小数部分“.75”可以在二进制中表示为<code>.11</code></li>
</ol>
<blockquote>
<p><strong>将小数转换为二进制时，可以将小数部分乘以2，然后观察得到的整数部分和小数部分。</strong>然后再乘以2直到得到的小数部分等于0。稍后需要将每次乘法结果的整数部分写成等价的二进制数。0.75十进制到二进制的答案是0.11。<br><br>小数部分“0.75”的转换步骤大概是：<br><br>1. <code>0.75 * 2 = 1.5</code>，1.5的整数位包含1，因此位数部分的第一位需要写<code>1</code>。<br>2. 去掉刚才的乘积的整数部分，<code>0.5 * 2 = 1.0</code>。1.0的整数部分包含1，因此尾数部分的第一位需要写<code>1</code>。正因为整数位的1减去后，小数位不包含任何信息，所以转换到此结束。<br><br>所以<code>0.75</code>转化过后就是<code>.11</code>。</p>
</blockquote>
<ol>
<li>该组合给出 <code>0 1000.11</code>，其指数值为零。  </li>
<li>移动二进制小数点后，我们得到 <code>0.100011</code>，小数点相比原来向左移动了四位，因此在此情景中指数为4其指数值为十进制的4。  </li>
<li>下一阶段取决于为尾数和指数定义的位数； 如果为尾数分配10位，为指数分配4位，则最终表示为尾数为 <code>0100011000</code>，指数为 <code>0100</code>。</li>
</ol>
<p><br></p>
<hr>
<h3 id="使用浮点数的问题"><a href="#使用浮点数的问题" class="headerlink" title="使用浮点数的问题"></a><strong>使用浮点数的问题</strong></h3><p>如上所述，将十进制实数值转换为二进制表示形式几乎可以保证一定程度的近似。 用于存储尾数的位数也有限制。</p>
<p>浮点数用于<strong>涉及重复计算的扩展数学过程</strong>。 例如，在使用大气数学模型的天气预报中，或在经济预测中。 在这样的编程中，在记录每次计算的结果时存在轻微的近似。<br>如果计算重复足够多次，这些所谓的舍入误差可能会变得很大。 防止错误成为严重问题的唯一方法是通过使用更多的尾数位来提高浮点表示的精度。<br>因此，编程语言提供了以“双精度”或“四精度”工作的选项。</p>
<p>另外，浮点数还可能引发溢出错误条件，因为浮点数能够存储的数字范围有限。</p>
<p><br></p>
<hr>
<h1 id="第十七章：通讯及互联网技术"><a href="#第十七章：通讯及互联网技术" class="headerlink" title="第十七章：通讯及互联网技术"></a><strong>第十七章：通讯及互联网技术</strong></h1><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a><strong>传输方式</strong></h2><p>对于通过互联网进行的通信，有两种可能的方法：<strong>电路交换 (Circuit switching)</strong>或<strong>分组交换 (Packet switching)</strong>。  </p>
<p><br></p>
<hr>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a><strong>电路交换</strong></h3><p>电路交换在传统电话系统中运用的比较广泛。  </p>
<p>电路交换是实现电信网络的一种方法。在这种方法中，两个网络节点通过网络建立专用的通信信道（通过电路），然后才能进行通信。<br>电路的特征决定了信道的带宽，并且这个专用通讯链路会在使用期间一直保持连接。<br>电路交换法师一种面向连接的网络，通过在发送方和接收方之间建立专用路径，提供了有保证的数据传输速率。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB0d939d18b99654b52231aaedd9491e5e?method=download&amp;shareKey=7ca23d690c92033f34eb8055e9f8c426" alt=""></p>
<p><br></p>
<p>通过电路交换传输数据的大致流程如下：  </p>
<ol>
<li>发送方提供预期的接收方的身份信息  </li>
<li>由系统来检查接收方是否准备好接收数据  </li>
<li>如果接收方可以接收数据，那么就会在网络上建立一些连接  </li>
<li>数据随后被传输</li>
<li>移除所有的建立的连接</li>
</ol>
<p>在这种情况下，我们暂时没有必要对电路交换网络中的每个节点进行定义。<br>节点之间的链路师共享传输介质中的专用信道，可以保证传输的畅通无阻、<br>当连接结束后，随着链路的断开，连接也就明确结束了。<br>不过，对于租用线路数据连接而言，可能会建立永久性的连线。  </p>
<p><br></p>
<hr>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><strong>分组交换</strong></h2><p><strong>分组交换 (Packet-switching)</strong>允许我们再不建立电路的情况下进行数据传输。  </p>
<p>数据不能以连续的流的形式发送，相反，数据被打包成一个一个数据包内然后被发送出去。  </p>
<p>数据包由包含传送指令的标头和数据主题构成。这个方法有点像邮政服务发送信件一样，但是要更加复杂。比如说在电路交换那一章的图片仍然可以描述数据包交换，只不过所使用的链路在发送方传输数据包的时候还没有被定义。  </p>
<p>此外，与电路交换传输所需的功能相比，节点将具有更多扩展的功能。我们将会在下面的一个章节中探讨路由器如何充当节点并且支持数据包的发送与接受。  </p>
<p><br></p>
<p>当我们使用分组交换法的时候，网络可以通过两种方式提供服务：<strong>无连接服务 (Connectionless service)</strong> 或者是 <strong>面向连接的服务 (Connection-oriented service)</strong>。  </p>
<p>对于无连接服务来说，我们在发送数据包的时候不知道接收者是否准备好接受数据包，而且我们无法确认数据包是否会传输成功。  </p>
<p>在面向连接的服务中，我们发送第一个数据包的目的是为了确认对方是否能够正常的接受数据包。如果收到了确认的话，那么发送方就会发送更多的数据包。如果没有收到确认，那么发送方就会再次尝试发送第一个数据包来确认状态。  </p>
<p><br></p>
<hr>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a><strong>传输协议</strong></h2><p>网络协议的基本定义很简单：它是一组规则。但问题是这些规则与什么东西有关呢？  </p>
<p>在回答这个问题之前，我们应该明白：我们通常所说的“协议”是指的包含许多单独协议的协议栈，因为网络的复杂性需要我们去制定许多单独的协议。<br>另一个复杂因素是：一个协议可能有许多不同的版本。<br>而且通常有一类协议可以用来补充另一类协议的作用。    </p>
<article class="message is-info"><div class="message-body">

<b>Protocol: a set of rules for data transmission which are agreed by sender and receiver.</b>

</div></article> 

<p><br></p>
<p>任何通过网络传输的通信，都必须在发送方和接收方之间商定一套构成协议的传输规则。<br>在最简单的层面上，协议可以规定成正电压代表比特值为1。协议也可以规定发送方不得超过的传输速度。<br>许多规则与信息的格式或信息的组成部分有关。比如说，定义数据包中前40哥字节的格式。  </p>
<p><br></p>
<hr>
<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a><strong>协议栈</strong></h2><p>对于协议套件而言，协议可以被是认作为协议栈中的层。这一概念设计了多个方面：  </p>
<ul>
<li><p>每一层只能接受上一层或者下一层的输入。  </p>
</li>
<li><p>相邻的层之间有一个明确的界限，这是层与层之间唯一允许的互动。  </p>
</li>
<li><p>一个层由下层的行动提供服务。  </p>
</li>
<li><p>除了最底层之外，各层的功能都是由安装的软件创建的。  </p>
</li>
<li><p>层可以包括子层。  </p>
</li>
<li><p>任何用户交互都将使用与堆栈中最高层相关的协议。  </p>
</li>
<li><p>对于硬件的任何直接访问都仅限于堆栈的最底层。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="TCP-IP-协议套件"><a href="#TCP-IP-协议套件" class="headerlink" title="TCP/IP 协议套件"></a><strong>TCP/IP 协议套件</strong></h2><p>TCP/IP是为支持互联网使用二创建的协议套件。<br>TCP/IP可以根据下图所示的模型来进行解释：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfdae828f6e782a26d5c50baafadfe83a?method=download&amp;shareKey=b16b227c06708c287e7ee21d0263a4cb" alt="">  </p>
<p>不难看出，TCP/IP协议只占用了这个模型的前三层。</p>
<p>图中显示了两个终端系统 （<em>最左边和最右边的两列</em>），并且也显示了这两个系统中相应层之间的逻辑连接。<br>一个应用程序可以在一个终端系统上运行，并与另一个终端系统上运行的应用程序建立直接连接。<br>发送端系统上的应用层协议向同一系统上的传输层协议发送信息，然后传输层协议启动一个进程，将相同的信息传送到接收端系统。<br>在接收端系统上，最后阶段是传输层协议将信息传送给应用层协议。  </p>
<p><br></p>
<p>TCP/IP协议套件由许多子协议组成，包括以下协议：  </p>
<ul>
<li>应用层协议： HTTP SMTP DNS FTP POP3 IMAP</li>
<li>传输层： TCP UDP SCTP IP</li>
<li>网络层： IP IGMP ICMP ARP</li>
</ul>
<p>选择这些协议是为了说明TCP/IP协议套件包含了应用范围非常广泛的协议，而且这些协议仍然在不断地发展。  </p>
<p><br></p>
<hr>
<h3 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP (传输控制协议)"></a><strong>TCP (传输控制协议)</strong></h3><p><strong>传输控制协议 (Transmission Control Protocol, TCP)</strong>是指TCP协议套件中定义的一个协议。它起源于最初的网络实施，是互联网协议（IP）的补充。因此，整个协议套件通常被称为 TCP/IP。  </p>
<p>TCP 是面向连接的。客户端和服务器之间必须先建立连接，然后才能发送数据。<br>在建立连接之前，服务器必须监听（被动开放）客户端的连接请求。<br>三方握手（主动打开）、重传和错误检测增加了可靠性，但延长了延迟。  </p>
<p>（所以如果不需要可靠数据流服务的应用程序可以使用<strong>用户数据报协议 (User Datagram Protocol, UDP)</strong>。它提供的无连接数据报服务优先考虑的是最低延迟，而不是可靠性。）  </p>
<p>TCP 可避免网络拥塞，不过，TCP 也存在漏洞，包括拒绝服务、连接劫持、TCP 否决和重置攻击。  </p>
<p><br></p>
<p>如果在终端系统上运行的应用程序要向不同终端的系统上面发送信息，那么这个应用程序会被收到上面说过的应用层协议所控制。<br>该协议会将用户的数据传送给传输层，然后由传输层运行的TCP协议负责讲信息安全的发送给接收方。  </p>
<p>TCP协议会创建足够的数据包来容纳所有的数据，而且每一个数据包都会由报头和用户数据组成。  </p>
<p><br></p>
<p>除了确保数据的安全传输外，TCP协议还需要确保任何相应都会被引导回应用层级，因此，报文头中的一项内容就是<strong>端口号 (Port number)</strong>。端口号用于标识应用层的协议，比如说，HTTP的端口号就是80。  </p>
<p>数据包还必须包括接收端系统应用层协议的端口号，虽然说TCP不关心接收端的系统地址。  </p>
<p>在一个序列里的数据包会包含一个序列号，目的是为了在数据传输的重点能够正确的按照顺序重新组装数据。  </p>
<p><br></p>
<p>TCP 协议是面向连接的。一旦网络层向传输层返回确认，表明连接已经建立，TCP 就会发送其他数据包并接收包含确认的响应数据包。而且还可以识别并重新发送丢失的数据包。  </p>
<p><br></p>
<hr>
<h3 id="IP-互联网协议"><a href="#IP-互联网协议" class="headerlink" title="IP (互联网协议)"></a><strong>IP (互联网协议)</strong></h3><p><strong>互联网协议 (Internet Protocol)</strong>是一种协议或者一组规则，用于数据包的路由和寻址，使其能够穿越网络到达它要去的目的地。<br>穿越互联网的数据被分为一个个较小的块，我们之前提到过，叫做数据包。每个数据包的报头都附有IP信息，这些信息有助于</p>
<p>在网络层中，IP的是能够确保终端连接互联网的一个重要因素。<br>IP协议从传输层接受数据包，然后添加一个报头。报头包含发送方和接收方的IP地址。要找到接收方的IP地址，很可能需要使用DNS服务来找到与用户数据中提供的URL相对应的地址。  </p>
<p><br></p>
<p>IP数据包通常被叫做“<strong>数据报 (Datagram)</strong>”。它被发送到数据链路层，然后被发送到不同的协议套件中。  </p>
<p>数据链路层会把数据报组装成一个“帧”，然后再进行发送。有关这个“帧”的内容下一章我们会进一步解释。  </p>
<p><br></p>
<p>IP具有无连接服务的功能，一旦发送了数据包，IP无法知道他是不是真正的到达了目的地。如果IP收到了一个包含对先前发送的数据包的确认数据包，那么它只会把该数据包传递给TCP，自己不会了解其中的内容。  </p>
<p><br></p>
<hr>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a><strong>路由器</strong></h3><p>上面的图片显示，数据链路层发送的“帧”在传送之前会到达一个路由器（或者是多个路由器）。在这一阶段，帧的数据报内容会被反馈给IP。现在路由器软件的功能是在传输过程中选择下一个目标主机。  </p>
<p>用白话来说，当数据从一台设备发送到另一台设备时，会被分解成叫做“帧”的微小单元，然后通过网络发送。这些帧首先会被路由器接受，因为路由器是引导网络数据流的设备。<br>路由器检查包含数据报内的帧内容，并使用路由表来确认数据的下一个目的地。<br>路由表是每个路由器特有的，包含数据通过网络的最佳路径等其他信息。一旦路由器确认了下一个目的地，它就会更新数据报中的地址，然后将其传回数据链路层，由数据链路层继续发送。这一过程在每一个路由器上都会重复运行。  </p>
<p><br></p>
<p>作为网络中的一个节点，交换机和路由器的主要区别是在于：当一个帧到达交换机的时候，交换机不做任何的路由操作，而是直接发送数据。交换机在数据链路层运行，但是无法进入网络层。  </p>
<p><br></p>
<hr>
<h2 id="以太网-Ethernet-协议栈"><a href="#以太网-Ethernet-协议栈" class="headerlink" title="以太网(Ethernet)协议栈"></a><strong>以太网(Ethernet)协议栈</strong></h2><p>在AS部分的第二章，我们就已经了解过以太网了。以太网是一套专门为局域网设计的协议，因此它可以在不予互联网或者任何网络连接的本地局域网中运行。<br>但是现在的局域网几乎不可避免地需要与互联网产生链接，所以说局域网的协议套件现在已经添加了对于互联网协议套件的支持。  </p>
<p><br></p>
<p>如果我们仔细查看一个终端系统的协议栈(<em>还是上面的那个图</em>)， 你就会发现TCP/IP协议套件占据了五层协议栈的最上面的三层，因此我们可以说，TCP/IP协议套件得到了下面两层的支持。<br>TCP/IP与这两个较低层的功能无关，它的设计目的是能够得到任何可用协议的支持。  </p>
<p>值得注意的是，有些数据来源只对终端系统使用了4层栈。这种情况下，可能是数据决定只调用完全由软件处理的层，也可能是将TCP/IP的所有支持合并到了同一层中。  </p>
<p><br></p>
<hr>
<p>以太网是最有可能用来提供两个较低层所需功能的协议。从逻辑上来说，以太网套件包括了数据链路层和物理层两个子层，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c778329b108c9457c86bd268d99339b?method=download&amp;shareKey=6006174e1cb318f6cff4dd5c7fc5f809" alt=""></p>
<p>下面的这几点说明了以太网在支持TCP/IP的时候的功能： </p>
<ul>
<li><p><strong>逻辑链路控制(Logic Link Control, LcC)</strong>协议负责与网络层的交互。它管理数据传输并确保数据传输的完整性。不过由于以太网是一种无连接协议，所以它不负责检查传输是否成功发送。  </p>
</li>
<li><p><strong>介质访问控制(Medium Access Control, mac)</strong>协议负责组装被称之为“帧”的以太网数据包。其中的两个组成部分是发送器地址和接收器地址。此外，MAC协议还负责启动帧传输，并处理因碰撞(可能因为使用了CSMA/CD)导致的传输失败之后的恢复工作。  </p>
</li>
<li><p><strong>物理编码子层（Physical Coding Sublayer, PCS）</strong>,协议负责对准备传输的数据进行编码，或对于收到的数据进行解码。  </p>
</li>
<li><p><strong>物理介质附件(Physical Medium Attachment, PMA)</strong>协议负责信号的收发。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a><strong>MAC地址</strong></h3><p>在以太网中，一个以太网帧使用的地址是物理地址或者MAC地址。<br>MAC地址值分配给网络接口控制器（NIC）的唯一标识符，用作网段内通信的网络地址。这部分的内容同样在AS部分的第二章提到过。简单来说，MAC地址标识一个唯一的网卡。<br>在大多数IEEE 802网络技术（包括以太网，Wi-Fi和蓝牙）中，这种用法都十分常见。  </p>
<p>迄今为止，定义MAC地址使用的48位可以保证每一个设备都分配到他们自己的MAC地址。不过，除了使用48位方案，现在还有一种64位的替代方案。这种方案已经偶尔使用，但是在将来48位地址不够用的时候就真正派上用场了。  </p>
<p>48位地址通常使用十六进制标识，比如说：  </p>
<p>        <code>4A:30:12:24:1A:10</code>  </p>
<p><br></p>
<hr>
<h2 id="与TCP-IP有关的应用层协议"><a href="#与TCP-IP有关的应用层协议" class="headerlink" title="与TCP/IP有关的应用层协议"></a><strong>与TCP/IP有关的应用层协议</strong></h2><h3 id="HTTP-HyperText-Transfer-Protocol"><a href="#HTTP-HyperText-Transfer-Protocol" class="headerlink" title="HTTP (HyperText Transfer Protocol)"></a><strong>HTTP (HyperText Transfer Protocol)</strong></h3><p><strong>超文本传输协议(HyperText Transfer Protocol, HTTP)</strong>，是最重要的应用层协议，因为这是万维网的基础。<br>每次用户使用网络浏览器访问网站的时候都会用到HTTP，但它的功能对用户是隐藏的。换句话说，当你访问一个网站的时候，你的浏览器会向网站的服务器发送一个HTTP请求，而服务器则使用HTTP回应用户网站的内容。这个过程发生在幕后，用户是看不到的。  </p>
<p>HTTP协议定义了报文的格式。请求信息的第一行是“<strong>请求行 (Request Line)</strong>”，请求行之后还可以加上<strong>标题行 (Header Line)</strong>。所有这些信息都是用ASCII编码。请求行的格式如下：  </p>
<p>        <code>&lt;Method&gt; &lt;URL&gt; &lt;Version&gt;CRLF</code>  </p>
<p>其中后面的CR和LF是ASCII的回车和换行符。  </p>
<p>请求行通常使用GET作为获取方法。不过除了GET方法，还存在其他的获取内容方法。这使得HTTP成为一种适用范围更广的协议，而不仅仅用于网页访问。<br>在使用HTTP的时候，我们必须指定HTTP的版本，因为HTTP发展到现在已经存在了好多版本。  </p>
<p><br></p>
<hr>
<h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a><strong>电子邮件协议</strong></h3><p>发送和接受电子邮件的传统方法如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2850a0d087d768b07083c5289fe9cd21?method=download&amp;shareKey=acbc8c637f4a495999dfecfde993215b" alt=""></p>
<p>这其中设计三个单独的客户端到服务器的交互。客户端的电子邮件发件人必须和邮件服务器建立连接，然后该服务器必须变成“客户端”向真正客户端的电子邮件接收者所使用的邮件服务器进行传输。  </p>
<p><br></p>
<p>目前存在以下三种主流的电子邮件协议：  </p>
<p><strong>简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)</strong>，是一种“Push”协议，即用于从一个服务器向另一个服务器发送电子邮件。而<strong>邮局协议版本3 (POP3)</strong>是一种“Pull”协议，即用于从服务器检索电子邮件并下载到客户端计算机。  </p>
<p>还有一种协议叫做<strong>互联网消息访问协议 (Internet Message Access Protocol, IMAP)</strong>，这是POP3的最新替代方案。POP3是将电子邮件下载到客户端计算机上，但是IMAP允许将电子邮件保存在服务器上，同时客户端也可以访问存储的电子邮件。<br>这意味着如果使用IMAP协议，你可以在任何设备上访问你的邮件。而使用POP3，我们只能从下载邮件的客户端系统访问你的邮件。  </p>
<p>一般来说，POP3在抵御网络攻击方面可能会更加安全，因为电子邮件都存在客户端计算机的本地。不过使用IMAP存储电子邮件的服务器可能会定期备份，但是本地客户端大概率不会。  </p>
<p><br></p>
<hr>
<h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP (文件传输协议)"></a><strong>FTP (文件传输协议)</strong></h3><p><strong>文件传输协议 (File Transfer Protocol, FTP)</strong>是一种标准通信协议，用于在计算机网络中将计算机文件从服务器传输到客户端。  </p>
<p>FTP 基于客户机-服务器模型架构，在客户机和服务器之间使用独立的控制和数据连接。FTP 用户可以通过明文登录协议（通常以用户名和密码的形式）进行身份验证，但如果服务器配置允许，也可以匿名连接。  </p>
<p>为了保护用户名和密码并对内容进行加密的安全传输，FTP 通常使用 SSL/TLS (FTPS) 或用 SSH 文件传输协议 (SFTP) 代替。  </p>
<p><br></p>
<hr>
<h2 id="P2P文件共享"><a href="#P2P文件共享" class="headerlink" title="P2P文件共享"></a><strong>P2P文件共享</strong></h2><p><strong>点对点文件共享 (Peer-to-peer file sharing, P2P file sharing)</strong>产生的网络流是互联网使用的主要特征之一。  </p>
<p>P2P 是一种没有结构和控制机制的架构。点对点既是客户端也是服务器，每个点对点只是一个终端系统。当对等体充当服务器时，它被称为 “种子”。</p>
<p><br></p>
<p>在P2P中，BitTorrent协议是最常用的协议，因为它可以快速的共享文件。 BitTorrent 是一种用于点对点文件共享（P2P）的通信协议，它使用户能够以分散的方式在互联网上分发数据和电子文件。要发送或接收文件，用户需要在联网电脑上使用 BitTorrent 客户端。  </p>
<p>BitTorrent 客户端是实现 BitTorrent 协议的计算机程序。BitTorrent 客户端适用于各种计算平台和操作系统，包括 Rainberry 公司发布的官方客户端。流行的客户端包括 μTorrent、迅雷、Transmission、qBittorrent、Vuze、Deluge、BitComet 和 Tixati等等。</p>
<p>BitTorrent 跟踪器提供可用于传输的文件列表，并允许客户端查找可传输文件的对等用户（称为 “种子”）。程序员布拉姆-科恩于 2001 年 4 月设计了该协议，并于 2001 年 7 月 2 日发布了第一个可用版本。BitTorrent 协议可用于减少分发大文件对服务器和网络的影响。BitTorrent 协议允许用户加入一个主机 “群”，同时相互上传和下载文件，而不是从单个源服务器下载文件。  </p>
<p><br></p>
<p>如果我们决定在终端系统使用BitTorrent，我们需要解决下面这三个基本问题：  </p>
<ol>
<li>如何确保计算机能够在网络上找到拥有目标资源的计算机？  </li>
</ol>
<blockquote>
<p>首先每个内容的供应者都提供一个内容描述，叫做torrent。这是一个包含跟踪器 （<em>引导计算机找到内容的服务器</em>）名称和内容块列表的文件。torrent文件比内容至少要小上三个过更多的数量级，因此这样的种子文件更易于我们传播。<br>跟踪器是一个服务器，它的任务是维护正在下载和上传内容的所有其他的终端的列表。  </p>
</blockquote>
<ol>
<li>在这样的对等网络上，如何为所有人提供高速的下载？  </li>
</ol>
<blockquote>
<p>对等网络在下载和上传的过程是同时发生的，但是对等网络必须同时交换数据块列表，来确保优先下载稀有的数据块。只要下载一次稀有的片段，那么这个数据块的稀有程度就会降低。  </p>
</blockquote>
<ol>
<li>每个终端如何鼓励其他的终端提供内容，而不是仅仅使用协议下载文件造福自己？  </li>
</ol>
<blockquote>
<p>在经济中有一个名词叫做”Free-rider”。在这里我们需要对付的就是这类的终端。解决的方法如下：<br>首先一个终端先随机尝试连接其他的终端，然后仅仅向那些提供常规下载的节点传输数据。如果发现有一个节点不下载或者下载速度贼慢，那么这个节点最后就会被“隔离”或者“阻塞”。  </p>
</blockquote>
<p><br></p>
<hr>
<h1 id="第十八章：硬件与虚拟机"><a href="#第十八章：硬件与虚拟机" class="headerlink" title="第十八章：硬件与虚拟机"></a><strong>第十八章：硬件与虚拟机</strong></h1><h2 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a><strong>控制单元</strong></h2><p><strong>控制单元 (Control unit, CU)</strong>是计算机中CPU的一个组件，用于指导处理器的运行。它通常使用二进制解码器将编码指令转换为定时和控制信号，从而直到内存，算术逻辑单元(ALU)和IO设备等其他单元的运行。  </p>
<p>控制单元管理大部分计算机的资源，并直到中央处理器与其他设备之间的数据流。在现在计算机设计中，控制单元通常是中央处理器的内部组成部分，其整体作用和运行方式自推出以来一直没有发生改变。  </p>
<p><br></p>
<hr>
<p>在执行程序时，中央处理器会接收一连串机器码指令。中央处理器内的控制单元有责任确保正确处理每一条机器指令。有两种方法可以设计控制单元，使其发挥功能：  </p>
<ul>
<li><p><strong>将控制单元构建为逻辑电路</strong>：这也称为<strong>硬连线控制单元 (Hardwired control unit)</strong>。硬连线控制单元通过逻辑电路将从中央处理器内存接收到的指令转化为控制信号。来自计算机主机内存的指令被发送到指令寄存器，指令寄存器负责识别其“操作码”。随后操作码被传递给指令解码器，指令解码器使用操作码来解释要生成的控制信号。然后，逻辑电路根据任何外部输入和条件代码创建了信号。&lt;/br&gt; &lt;/br&gt;整个过程由系统时钟同步，系统时钟产生有规律的脉冲，在低电平和高电平之间持续切换，形成了0和1。这种控制单元之所以是“硬连线”，是因为他们的逻辑电路是由硬件以逻辑门电路的物理排列。&lt;/br&gt; &lt;/br&gt;硬接线控制单元的一些缺点是成本相对较高，难以用于复杂的操作，而且无法在不进行物理改动的情况下对它进行修改。此外，每个电路只能处理一种形式的指令。不过，硬接线控制单元速度更快，因为每一种指令都由自己指定的电路来完成计算。  </p>
</li>
<li><p><strong>使用微编程构建微程序控制单元</strong>：这样的方法叫做<strong>微程序控制单元 (Microprogrammed control unit)</strong>。微编程控制单元采用编程的方法实现。在微程序控制中，微操作是通过执行由微指令组成的程序来实现的。<br> <br> 控制存储器地址寄存器用来指定微指令的地址。控制存储器被用为ROM，其永久存储了左右的控制信息我们一般称为<strong>固件 (Firmware)</strong>。控制寄存器保存从存储器获取的微指令。微指令包含一个控制字，为数据处理器指定一个或者多个微操作。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="CISC和RISC处理器"><a href="#CISC和RISC处理器" class="headerlink" title="CISC和RISC处理器"></a><strong>CISC和RISC处理器</strong></h2><p>处理器的架构是指其物理结构。不过，处理器也有所谓的 “指令集架构”。</p>
<p>指令集架构涉及到： </p>
<ul>
<li>指令集</li>
<li>指令格式</li>
<li>寻址模式</li>
<li>指令可以访问的寄存器</li>
</ul>
<p>其中，指令集的选择是区分指令集架构的主要因素。  </p>
<p><br></p>
<hr>
<p>在计算机发展的早期，选择计算机指令集架构的一个重要因素是，该架构是否能够使高级语言编译器的编写变得更加容易。我们现在将这一种架构叫做<strong>复杂指令集计算机 (Complex Instruction Set Computer, CISC)</strong>。</p>
<p>直到20世纪70年代末期，人们开始对这一理念产生质疑。有人认为，使用<strong>精简指令集计算机 (Reduces Instruction Set Computer, RISC)</strong>会是一种更好的方法。  </p>
<p><br></p>
<p>下面介绍一下这两位：  </p>
<p>CISC和RISC是两种不同类型的计算机体系结构。二者的主要区别在于<strong>中央处理器可执行的指令数</strong>和<strong>执行这些指令所需要的周期数</strong>。  </p>
<p>CISC试图尽量减少每个程序的指令数，但是代价是这会增加每个指令的周期数。这就意味着CISC处理器一般<u>拥有大量的复杂指令</u>，但是可以在一条指令中执行多种操作。这些指令通常更长，功能更强大，可以用更少的单条指令来完成复杂的任务。  </p>
<p>现在转过头来看看另一边的RISC。RISC是一种以每个程序的指令数量为代价来减少每条指令周期的方法。这就意味着RISC处理器的<strong>简单指令数量较少</strong>，<strong>只能执行单一的操作</strong>。这样，RISC处理器的指令集就设计的比CISC更简单，更小了。这些指令通常更短更简单，需要更多的单独指令才能完成复杂的任务。  </p>
<p>这两种方法各有利弊。CISC处理器通常<strong>更容易编程</strong>，因为它们有更强大的指令。但由于每条指令的周期数多，所以运行速度可能会慢一些。RISC处理器由于减少了每条指令的周期数，因此运行的速度普遍较快，但是因为需要更多的单独指令来执行复杂的任务，因此这可能会使得编程的难度直线上升。  </p>
<article class="message is-info"><div class="message-body">

<b>Complex Instruction Set Computer (CISC): a single instruction can be more complex and involve more loading of data from memory.</b>

<br>

<b>Reduced Instruction Set Computer (RISC): s single instruction is simpler, requiring minimal loading of data from memory.</b>

</div></article> 



<p><br></p>
<hr>
<p>下表列出了RISC区别于CISC的一些特征：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">RISC</th>
<th style="text-align:left">CISC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">更少的指令数</td>
<td style="text-align:left">更多的指令数</td>
</tr>
<tr>
<td style="text-align:left">更简单的指令</td>
<td style="text-align:left">更复杂的指令</td>
</tr>
<tr>
<td style="text-align:left">指令格式相对简单</td>
<td style="text-align:left">指令格式复杂</td>
</tr>
<tr>
<td style="text-align:left">尽可能使用单周期指令</td>
<td style="text-align:left">多周期指令</td>
</tr>
<tr>
<td style="text-align:left">定长指令</td>
<td style="text-align:left">可变长度指令</td>
</tr>
<tr>
<td style="text-align:left">只对内存地址执行加载和存储指令</td>
<td style="text-align:left">向内存地址存储多种指令</td>
</tr>
<tr>
<td style="text-align:left">更少的寻址模式</td>
<td style="text-align:left">更多的寻址模式</td>
</tr>
<tr>
<td style="text-align:left">多个寄存器组</td>
<td style="text-align:left">更少的寄存器</td>
</tr>
<tr>
<td style="text-align:left">多为<strong>硬连线控制单元</strong></td>
<td style="text-align:left">多为<strong>微程序控制单元</strong></td>
</tr>
<tr>
<td style="text-align:left">更利于流水线作业</td>
<td style="text-align:left">不太利于流水线作业</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，RISC处理器大多使用硬连线控制单元，而CISC处理器大多使用微编程控制单元。</p>
<p>指令数量的减少并不是使用RISC的主要驱动力，降低指令的复杂性才是RISC的主要特征。  </p>
<p>典型的CISC架构包含很多的专用指令，专用指令的设计符合高级编程语言的要求。专用指令需要多次访问内存。与直接访问寄存器相比，访问内存的速度可谓是相当慢。  </p>
<p>RISC处理器的指令非常简单，因此数据可以存储在寄存器中，并在寄存器中进行操作。除了初始化和资源存储请求之外，无需对存储器进行任何的访问。   </p>
<p>RISC指令的简单性使得硬连线控制单元的使用更加容易。而许多CISC指令的复杂性使得硬连线控制单元的构建更加复杂，因此我们使用微程序控制单元。  </p>
<p><br></p>
<hr>
<h3 id="流水线作业-Pipelining"><a href="#流水线作业-Pipelining" class="headerlink" title="流水线作业 (Pipelining)"></a><strong>流水线作业 (Pipelining)</strong></h3><p>创建 RISC 处理器的主要驱动力之一，就是为高效流水线提供机会。  </p>
<p><strong>流水线 (Pipelining)</strong>是一种专门应用于指令执行的并行方式。其他并行形式将在下一节中讨论。  </p>
<p><em>好像翻译成“流水线”不是很恰当，但是懂我意思就行</em></p>
<article class="message is-info"><div class="message-body">

<b>Pipelining: instruction-level parallelism.</b>

</div></article> 

<p><br></p>
<hr>
<p>流水线作业的基本原理是第五章中介绍的F-E Cycle可以分为若干阶段。其中的一个形式是“五阶段模型”。要实现流水线操作，处理器的结构必须含有5个独立的单元，这样每个单元就可以单独处理五个阶段中的其中一个阶段。这同样解释了为什么RISC处理器需要许多的寄存器组，因为存在多个处理单元，而每个单元必须需要寄存器来访问将要使用的数据。</p>
<p>五阶段模型如下表所述：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">时钟周期 →</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Instruction Fetch<br>(指令读取，IF)</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">3.1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">5.1</td>
<td style="text-align:center">(6.1)</td>
<td style="text-align:center">(7.1)</td>
</tr>
<tr>
<td style="text-align:left">Instruction Decode<br>(指令解码，ID)</td>
<td style="text-align:center"></td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">2.2</td>
<td style="text-align:center">3.2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">5.2</td>
<td style="text-align:center">(6.2)</td>
</tr>
<tr>
<td style="text-align:left">Operand Fetch<br>(操作数抓取，OF)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.3</td>
<td style="text-align:center">2.3</td>
<td style="text-align:center">3.3</td>
<td style="text-align:center">4.3</td>
<td style="text-align:center">5.3</td>
</tr>
<tr>
<td style="text-align:left">Instruction Execute<br>(指令执行，IE)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.4</td>
<td style="text-align:center">2.4</td>
<td style="text-align:center">3.4</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Result Write Back<br>(结果回写，WB)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.5</td>
<td style="text-align:center">2.5</td>
<td style="text-align:center">3.5</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>在上面的表格中，每一行代表流水线中的一个阶段： 指令读取 (IF)、指令解码 (ID)、操作数读取 (OF)、指令执行 (IE) 和结果回写 (WB)，同时每列代表一个时钟周期。单元中的数字代表指令编号和该指令的阶段。例如，”1.1 “表示指令 1 处于 第一步 “IF” 阶段，”2.5 “表示指令 2 处于第五步 “WB” 阶段。  </p>
<p>解读一下表格：最初只有第一条指令的第一阶段进入了流水线。在第六个时钟周期，当第一个指令已经离开流水线时 <em>（因为不存在第六个流水线阶段）</em>，指令2的最后一步仍在处理，而且指令6才刚刚进入流水线作业 <em>（因为没有第六个流水线阶段，所以第六个指令的流程并没有画在表上。但如果第六个指令需要处理的话，会在第六个时钟周期进入流水线）</em>。</p>
<p>流水线一旦开始运行，就要处理五个阶段的五条单独指令。特别是在每个时钟周期，都需要完成一条指令的处理工作。如果没有流水线并行作业，那么处理时间将延长五倍。</p>
<p><br></p>
<p>在流水线系统中，多条指令在流水线的不同阶段同时处理。当中断发生时，流水线中就会有几条指令尚未执行完毕。<br>有两种解决中断问题的解决方案：  </p>
<ul>
<li><p>第一种：<strong>清除最近进入的四条指令的流水线内容，只留下最早进入的指令。</strong>然后，正常的中断处理程序就可以应用于剩余的指令。</p>
</li>
<li><p>第二种：<strong>在处理器中构建具有独立程序计数器寄存器的独立单元。</strong>这样就可以在处理中断时为流水线中的所有指令存储当前数据。</p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="基本计算机架构"><a href="#基本计算机架构" class="headerlink" title="基本计算机架构"></a><strong>基本计算机架构</strong></h2><p>描述不同计算机体系结构的一种有效的方法是：考虑指令流的数量和数据流的数量。因此这区分出了四种类型的架构：  </p>
<p><br></p>
<hr>
<h3 id="单指令流单数据流-SISD"><a href="#单指令流单数据流-SISD" class="headerlink" title="单指令流单数据流 (SISD)"></a><strong>单指令流单数据流 (SISD)</strong></h3><p><strong>单指令流单数据流 (Single Instruction Stream Single Data Stream, SISD)</strong>是早期计算机中的典型架构，同样也是早期的微处理器所采用的排列方式。具体来说，SISD代表了包含一个控制单元，一个处理器单元和一个存储器单元的单台计算机的组织结构。所有的指令按照顺序执行，系统内部可能有并行能力，也可能没有。  </p>
<p>虽说是这样，但是课本上写的是SISD纯粹是顺序性的产物，没有一点点并行性。我们就按照这条来记吧。</p>
<p><br></p>
<p>下图展示了如何使用SISD来操作数组中的单个元素：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB30316d3629bca49a5815cbb453ffaab7?method=download&amp;shareKey=3ed3432f2423c78b6885dccd0b2e3c68" alt="">  </p>
<p>图中给出了一个原始的数组。如果机器需要将这个数组内的元素乘以2，那么SISD就会按照顺序一个一个地处理数组内部的数据，从右到左。换言之，SISD对于数组内每一个元素都执行了相同的“乘以2”的操作。  </p>
<article class="message is-info"><div class="message-body">

<b>SISD: Stands for Single Instruction Stream Single Data stream; a single processor accessing one memory.</b>

</div></article> 


<p><br></p>
<hr>
<h3 id="单指令流多数据流-SIMD"><a href="#单指令流多数据流-SIMD" class="headerlink" title="单指令流多数据流 (SIMD)"></a><strong>单指令流多数据流 (SIMD)</strong></h3><p><strong>单指令流多数据流 (Single Instruction Stream Multiple Data Stream, SIMD)</strong>所描述的计算机具有多个处理元件，可以<u>同时对多个数据点执行相同的操作</u>。这类计算机利用数据级的并行性，但是不利用它们的并发性。 </p>
<p>SIMD是一种并行处理方式，也就是多个处理元件同时对多个数据点执行相同操作。这意味着计算机就可以使用相同的指令同时处理多个数据点，而不是一步只能处理一个数据点。这可以大大提升某些类型计算的速度。也就是说，虽然说存在并行计算，但是每个单元在任何给定的时刻都执行完全相同的指令。  </p>
<p><br></p>
<hr>
<p>下图是一个SIMD的图示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7144d89b55622ba1765c5b94a0c5e21e?method=download&amp;shareKey=1d05101205bb890f3f1a34bb47dd9fde" alt=""></p>
<p>由图可见，所有在数组中的元素都在同一个指令周期完成了处理，而不像SISD一样每一个元素都需要单独处理。  </p>
<p><br></p>
<p>SIMD 的结构通常用图表表示，就像下图一样：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6215f557d53c58f88328a11754ac405e?method=download&amp;shareKey=2f07fdbe2d15d4e0cc24e974bdcd90c8" alt=""></p>
<p>在本图中，结构图显示数据流进入了四个单独的组件，这些组件都提供了相同的指令。这些组件被称之为<strong>处理单元(Processing Unit, PU)</strong>，有时这些组件也被称为<strong>处理原件(Processing Element, PE)</strong>。无论使用什么名称，这些组件都全部是ALU，也就是算术逻辑单元。有多个名称的原因是因为实现SIMD有多种方法：  </p>
<p>第一种实现方法是使用阵列或者向量处理器(Matrix &amp; Vector processors)。他们有一组并行的寄存器，每一个数据流都会被安排一个寄存器。我们可以使用一4位或者128位的大型寄存器，来同时存储多个数值。在这种实现方式中，并行性仅仅内置在一个处理器中，允许这个处理器同时处理多个数据流。</p>
<p>另一种方法是使用多核处理器。现在大多数的电脑都搭载了多核处理器。比如说使用4核处理器，就代表四个处理器并行工作。在这种情况下，每一个处理器都可能有自己专用的告诉缓存来提供可靠的数据流。</p>
<article class="message is-info"><div class="message-body">

<b>SIMD: Stands for Single Instruction Stream Multiple Data Stream; processing of parallel data input requiring one control unit instructing multiple processing units.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="多指令流单数据流-MISD"><a href="#多指令流单数据流-MISD" class="headerlink" title="多指令流单数据流 (MISD)"></a><strong>多指令流单数据流 (MISD)</strong></h3><p><strong>多指令流单数据流 (Multiple Instruction Stream Single Data Stream, MISD)</strong>是一种并行计算架构，其中<u>许多功能单元对同样的数据执行不同的操作。</u>  </p>
<p>与SIMD相比，MISD的应用就少得多，因为MISD通常更适合常用的数据并行技术。具体来说，他们可以更好的扩展和使用计算资源。话虽这么讲，MISD也是有应用的，比如说用于航天飞机的飞行控制计算机。大家也知道航天方面的数据计算是不容有失的，-在这种情况下，使用 MISD 架构可将多条指令应用于同一数据流，从而提供冗余并提高系统的可靠性。</p>
<article class="message is-info"><div class="message-body">

<b>MISD: Stands for Multiple Instruction Stream Single Data Stream; does not exist in a single architecture.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="多指令流多数据流-MIMD"><a href="#多指令流多数据流-MIMD" class="headerlink" title="多指令流多数据流 (MIMD)"></a><strong>多指令流多数据流 (MIMD)</strong></h3><p><strong>多指令流多数据流 (Multiple Instruction Stream Multiple Data Stream, MIMD)</strong>是一种并行计算架构。在这种架构中，有许多个处理器异步独立运行。<u>在任何时候，不同的处理器都可能对不同的数据执行不同的指令。</u>  </p>
<p>MIMD架构被应用于多个领域，如计算机辅助设计，仿真，建模或者是通信交换机。MIMD机器可以分为共享内存和分布式内存两类，他们的类别是基于MIMD处理器访问内存的方式决定的。共享机器模型可以是总线型、扩展型或者分层型。</p>
<article class="message is-info"><div class="message-body">

<b>MIMD: Stands for Multiple Instruction Stream Multiple Data Stream; multiple processors asynchronously processing parallel data input.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="大规模并行计算机系统"><a href="#大规模并行计算机系统" class="headerlink" title="大规模并行计算机系统"></a><strong>大规模并行计算机系统</strong></h3><p><strong>大规模并行计算机系统 (Massively parallel computer systems)</strong>是指使用大量计算机处理器（或者是独立的计算机）同时并行执行一组协调计算的计算架构。这可以通过各种各样的方法实现，比如说网格计算 (Grid computing)，就是透过使用大量的异构计算机的未使用资源，将其作为嵌入在分布式电信基础设施中的一个虚拟的计算机集群，为解决大规模的计算问题提供模型的方案。大名鼎鼎的SETI@home项目就是使用了这项技术，通过筹集大量计算机用户的剩余资源来分布式计算问题。这些小的计算机结合起来的算力同样强大，丝毫不亚于超级计算机。  </p>
<p>大规模并行计算机系统与超级计算机的区别在于，负责驱动多个处理器的不是总线结构，而是支持多个计算机单元的网络基础设施。不同计算机上面运行的程序可以通过网络传递信息进行通信。 </p>
<p><br></p>
<hr>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><strong>虚拟机</strong></h2><p>虚拟机听起来像是个硬件，但其实不是。最常见的虚拟机类型是<strong>系统虚拟机 (System virtual machine)</strong>，它的作用是模拟真实计算机系统硬件的软件。  </p>
<article class="message is-info"><div class="message-body">

<b>System virtual machine: the emulation of computer system hardware using software.</b>

</div></article> 

<p><br></p>
<p>一般来说，应用程序需要在操作系统支持的情况下才能在硬件上直接运行。虚拟机的原理是进程直接与操作系统提供的软件界面进行交互，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBad58e3603d7ce6727ad0207a279a5d47?method=download&amp;shareKey=ae8057b16074d482045345abe63369db" alt="">  </p>
<p>从上图我们需要注意这几点：  </p>
<ol>
<li><p>应用程序是在客户操作系统的协助下安装的。客座操作系统将通过与虚拟机交互来支持运行中的应用程序，就好像客座操作系统通常运行的硬件一样。  </p>
</li>
<li><p>虚拟机实施软件可被视为一种实用程序，运行时受特定主机操作系统的支持，而主机操作系统又是主机硬件所特有的。  </p>
</li>
<li><p>在主机操作系统的控制下，主机硬件上可以同时直接运行应用程序。  </p>
</li>
</ol>
<p><br></p>
<p>虚拟机方法的主要优点是可以在一个计算机系统上提供多个不同的操作系统。如果一个组织拥有遗留系统，希望继续使用旧软件，但又不想保留旧硬件，这一点就特别有价值。  </p>
<p>另外，拥有大型主机并提供服务器整合设施的公司也可以多次提供相同的操作系统。不同的公司可以获得自己的虚拟机，作为服务器运行。  </p>
<p>使用虚拟机的一个缺点是需要花费大量时间和精力来实施。另一个缺点是虚拟机的性能无法达到普通系统的性能水平。  </p>
<p><br></p>
<p>之前在第八章讨论的 Java 虚拟机是进程虚拟机的一个例子，它基于不同的基本概念。进程虚拟机提供了一个与平台无关的编程环境，允许程序在任何平台上以相同的方式执行。这是一种仅支持运行 Java 程序的特定软件。</p>
<p><br></p>
<hr>
<h1 id="第十九章：逻辑门与布尔代数"><a href="#第十九章：逻辑门与布尔代数" class="headerlink" title="第十九章：逻辑门与布尔代数"></a><strong>第十九章：逻辑门与布尔代数</strong></h1><h2 id="逻辑电路"><a href="#逻辑电路" class="headerlink" title="逻辑电路"></a><strong>逻辑电路</strong></h2><p>早在第四章，我们就已经接触过了逻辑电路中使用的逻辑门符号，并讨论了逻辑电路，真值表和逻辑表达式之间的关系。本章会介绍一些额外的内容，比如一些用于构建计算机硬件功能组建的特定电路。  </p>
<h3 id="半加法器-The-half-adder"><a href="#半加法器-The-half-adder" class="headerlink" title="半加法器 (The half adder)"></a><strong>半加法器 (The half adder)</strong></h3><p>在计算机中，二进制加法运算随处可见。两个比特的结果相加结果要么为1，要么为0。在一些特殊情况下，如1和1相加，会导致当前位结果为0，同时它的下一位会被加一，也就是进位。  </p>
<p>执行二进制加法最简单的电路是<strong>半加法器 (Half adder)</strong>。如下图所示，半加法器会接受两个值的输入，然后输出“和位(S)”和一个“进位(C)”。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB50fb2efc7af272739fbc1a90ed75d8fb?method=download&amp;shareKey=c676b82aaa0cdaed3a57929e73110e3b" alt=""></p>
<p>这个电路的真值表看起来就是这样的：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input</th>
<th style="text-align:center">Input</th>
<th style="text-align:center">Output</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center"><strong>C</strong></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>通过检查这个真值表，我们大概可以推测出半加法器的成分如何。<br>可以看到，只有在两个输入位都为1的时候，进位C才会出现1的结果。因此，C输出的真值表就可能是基于AND逻辑门实现的。<br>和位S输出的真值表与之前聊过的XOR运算符的真值表一致，所以我们也可以推测半加法器里面还存在一个XOR逻辑门。<br>因此，产生半加法器功能的电路可以包含一个AND门和一个XOR门，其中这两个逻辑门都会接受A和B两个输入。</p>
<p>当然，上面列出的只是完成这个功能的其中一种情况，还有更多逻辑门的搭配方式可以实现这样的功能。冷知识：NAND逻辑门和NOR门是两个通用门，这意味着任何的逻辑电路都可以使用这两种逻辑门进行构建。再加上NAND和NOR门易于制造的特点，导致电路制造商们很喜欢使用它们俩。下面这个图片就是仅仅使用NAND门和NOR门构建出来的一个半加法器：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB534f2fe40966c4cfe4f07994cae4f61c?method=download&amp;shareKey=8ab4d250399ae72eeb307bba668d92d5" alt=""></p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Half adder circuit: a circuit which performs binary addition of two individual bits.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="全加法器-The-full-adder"><a href="#全加法器-The-full-adder" class="headerlink" title="全加法器 (The full adder)"></a><strong>全加法器 (The full adder)</strong></h3><p>一般来说，如果我们需要计算两个二进制数字相加，则我们必须要从两个数字的最小位开始计算，一直计算到最大位。在计算的每一个阶段，前一个加法的结果的进位数字都必须并入到当前的计算中。<br>如果每次使用半加法器，就必须需要使用单独的电路来处理进位问题，因为半加法器仅仅接受两个输入。  </p>
<p><strong>全加法器 (Full adder)</strong>是一种执行加法运算的一种电路。这种加法器接受三个输入：两个需要相加的数字和上一位产生的进位，并产生三个输出，分别是三个输入的和以及下一位的进位。  </p>
<p>当我们需要对不止一位进行二进制加法运算时，我们最好使用全加法器，因为全加法器考虑了前一位假发的金文，所以它能够处理所有的进位问题。例如我们设计对多位二进制数（如4位，8位，16位二进制数等）进行算术运算的电路，我们就需要使用全加法器。</p>
<p>全加法器的真值表如下：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Input</th>
<th>Input</th>
<th>Output</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>Cin</td>
<td>S</td>
<td>Cout</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>全加法器的一种可能的构造如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf506c3d9a0c9e9dcad6f14905ad95347?method=download&amp;shareKey=cf712be00f7aa9f64cd2ea3b41c00895" alt=""></p>
<p><br></p>
<p>我们之前说过，所有的电路理论上都可以使用NAND和NOR逻辑门来构建。所以全加法器的另一种构造如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7f4a38b0b4d46b3034ead532ffb7a7a5?method=download&amp;shareKey=212c866467e455e7c6f529fe74bea972" alt=""></p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Full adder circuit: a circuit which performs binary addition of two individual bits and an input carry bit.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="时序电路"><a href="#时序电路" class="headerlink" title="时序电路"></a><strong>时序电路</strong></h2><p>到目前为止，本书中介绍过的所有电路全部都是 组合电路 (Combinational circuit)。对于这样的电路来说，输出的值只由输入的值决定。<br>接下来我们会介绍时序电路，它的输出取决于输入和前一个输出项。  </p>
<p><strong>时序电路 (Sequential logic circuit)</strong>是一种数字电路，它存储上一个输出信息并使用它来计算下一个输出。我们刚说过，时序电路于组合电路不同之处就在于，时序电路既依赖当前输入值，同样也依赖存储在某一个存储元件中的上一个输出状态。  </p>
<article class="message is-info"><div class="message-body">

<b>Combinational circuit: a circuit in which the output is dependent only on the input values.</b>

<br>

<b>Sequential circuit: a circuit in which the output depends n the input values and the previous output.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="SR-触发器-SR-Flip-flop"><a href="#SR-触发器-SR-Flip-flop" class="headerlink" title="SR 触发器 (SR Flip-flop)"></a><strong>SR 触发器 (SR Flip-flop)</strong></h3><p>下面我们要介绍的SR触发器，是时序电路的一个简单例子。  </p>
<p><strong>SR触发器 (SR Flip-flop)</strong>，又称之为SR锁存器，是数字电子产品中经常会用到的一种基本触发器。SR触发器是一种双稳定器件，这意味着SR触发器有两个稳定状态，而这两种稳定状态可以被无限期保存。正因为这种独特的记忆特性，卫门叫它“锁存器”。它可以由两个NAND门和一个NOR门组成，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf6c36ffa6f6e12b7716959b642e9bd4f?method=download&amp;shareKey=a83e7e149cc8b4acf2c767a8f0011cdc" alt=""></p>
<p>SR触发器有两个输入端，分别是 <strong>“置位” (S)</strong>和 <strong>“复位” (R)</strong>。以及两个输出端，分别是<strong>Q</strong>和<strong>Q’</strong>。<br>SR触发器的工作原理如下：  </p>
<ul>
<li><strong>设置 (set) 状态</strong>： 当设置(S)为1，(R)为0时，这时输出(Q)就会变为1。这表示锁存器进入了设置状态。  </li>
<li><strong>复位 (reset) 状态</strong>： 当设置(R)为1，(S)为0时，这时输出(Q)就会变为0。这表示锁存器进入了复位状态。  </li>
<li><strong>保持 (hold) 状态</strong>： 当输入端的(S)和(R)均为0时，无论上一个状态是设置状态还是复位状态，触发器会保持原来的状态。也就是说，输出还是会与上次相同。 <br> 比如说，如果SR触发器的上一个状态处于“set”状态，也就是Q的输出为1，并且输入S和R都是0，那么触发器会继续输出Q为1。  </li>
</ul>
<p>SR触发器的真值表如下所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input Signals</th>
<th style="text-align:center">Input Signals</th>
<th style="text-align:center">Initial State</th>
<th style="text-align:center">Initial State</th>
<th style="text-align:center">Final State</th>
<th style="text-align:center">Final State</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">R</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">Q’</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">Q’</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>从真值表中我们可以发现，表中不包含当R = 1或者S = 1的行，因为如果当S与R同时等于1，会导致输出“非法”。因为当遵循布尔代数原则时，Q和Q’不会同时输出0。Q与Q’本身应该就是彼此互补的，即当一个值为1时，另一个值应该为0。所以，输出是违反这个逻辑，是“非法”的。  </p>
<p>在实际运用中，我们要避免使S和R都同时为1，因为它会导致数字电路中不可预测的行为。因此为了保证电路的可靠运行，我们需要尽可能避开这种用法。</p>
<p><br></p>
<hr>
<h3 id="JK-触发器-JK-Flip-flop"><a href="#JK-触发器-JK-Flip-flop" class="headerlink" title="JK 触发器 (JK Flip-flop)"></a><strong>JK 触发器 (JK Flip-flop)</strong></h3><p>我们在数字电路中最讨厌的就是像刚才SR触发器中，任何可能导致电路发生“不可预测”的无效输出或者错误处理。<br>实际上，除了在电路中存在S与R都为1导致的无效输出之外，如果信号无法同时到达触发器，也会导致输出的不可预测性。为了解决这个问题，电路可以包含一个时钟脉冲输入，以提供同步输入的更好机会。<strong>JK触发器 (JK Flip-flip)</strong>，也叫JK锁存器，就是这样的一个例子。  </p>
<p>JK触发器是一种连续双状态单比特存储设备，是以它的发明者杰克·基尔命名的。<br>这个不重要，重要的是JK触发器有一个时钟输入引脚(Clock, CLK)，两个数据输入引脚(J和K)和两个输出引脚(Q和Q’)。如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa259e5b4f4f0cd30f9d02342b97c1b82?method=download&amp;shareKey=c369533d4b892af9c697199f4227abc4" alt=""></p>
<p>JK触发器可以画成左边的简略形式，它的展开形式如右图所示。  </p>
<p><br></p>
<p>在时钟周期的情况下，JK触发器可以在时钟的前缘触发，或者是后缘触发。将时钟周期想象成一个方波。前缘就是电平从0变成1的电平上升时刻，而后缘就是电平从1变成0的电平下降时刻。</p>
<p>要理解电路是如何运作的，我们需要先理解一个大前提。除非所有的输入都为1，否则与非门的输出为1。如果电路处于未设置状态，那么Q = 0， Q’ = 1。这种状态是稳定并且自洽的，就正如下面的参数所示：  </p>
<ol>
<li>时钟和J都输入为0</li>
<li>因此左上角的NAND门输出为1</li>
<li>右上角的NAND门会接受两个为1的值的输入。</li>
<li>Q = 0</li>
</ol>
<p>如果J的输入变成了1，时钟的输入也变成了1，那么就会发生下面这些事情：  </p>
<ol>
<li>左上角的NAND门就会接受两个为1的值的输入</li>
<li>所以它的输出为0</li>
<li>这就会导致右上角的NAND门以1的值输出Q</li>
<li>这样一来，右下角的NAND门就会接受两个为1的值的输入。 </li>
<li>所以Q’的输出为0</li>
</ol>
<p><br></p>
<hr>
<p>JK触发器的真值表如下： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>J</strong></th>
<th><strong>K</strong></th>
<th><strong>Clock</strong></th>
<th><strong>Q</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>↑</td>
<td>Q unchanged</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>↑</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>↑</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>↑</td>
<td>Q toggles</td>
</tr>
</tbody>
</table>
</div>
<p>由此可见，当J和K的输入均为1的时候，Q与Q’的值会发生变换。</p>
<p>J可以被称作为“集合输入”。当J被设置为1，并K被设置为0的时候，它会导致输出Q也被设置为1。<br>K可以被叫做“清除输入”。当K被设置为1，J被设置为0的时候，会导致Q被清除（设置为0）。  </p>
<p>JK与SR触发器不一样的是，每两个输入任意发生组合都会产生一个有效的输出，输入J和K的每一个组合都对Q和Q’产生明确定义的影响，而不像SR触发器一样，包含一个无效输出。这个特性导致JK触发器更加可靠，更有预测性，因为没有导致任何不确定因素或者未定义输出的情况出现。</p>
<p><br></p>
<hr>
<h2 id="布尔代数基础"><a href="#布尔代数基础" class="headerlink" title="布尔代数基础"></a><strong>布尔代数基础</strong></h2><p>本书的第四章讲过了如何使用逻辑命题来使用布尔运算符来组合成逻辑表达式。而布尔代数为编写简洁的逻辑表达式提供了方法，并提供了一种简化表达式的“公式”。  </p>
<p>当使用一种代数形式的时候，理解它的含义是十分重要的。举个简单的例子，1+1可以被解释成很多不同的情况： </p>
<p>1 + 1 = 2<br>1 + 1 = 10<br>1 + 1 = 0<br>1 + 1 = 1</p>
<p>一式表示的是十进制算术，二式表示二进制算术，三式表示位算术，而四式可以表示布尔代数。这是因为在布尔代数中，1表示为<code>TRUE</code>，0表示为<code>FALSE</code>，而<code>+</code>可以表示或。因此，第四个计算式可以以下面这种形式表示出来：  </p>
<p>                         <code>TRUE OR TRUE is TRUE</code></p>
<p>布尔代数的表示有它的专有符号。比如说<code>AND</code>可以表示为∧，<code>OR</code>可以表示为∨。或者，<code>A AND B</code>可以写成<code>A.B</code>或者<code>AB</code>。在本章中，我们会使用这种类似“点乘”的<code>AND</code>表示方法。<code>NOT</code>的具体方式是在字母上面加一个横线。比如说<code>NOT A</code>可以表示为<code>Ā</code>。  </p>
<p><br></p>
<hr>
<p>在建立了基本的表示法之后，我们就需要考虑我们的计算规则了。<br>下表中的内容可以被叫做“法则”或者“定义式”：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Identity / Law</th>
<th style="text-align:center">AND form</th>
<th style="text-align:center">OR form</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Identity</td>
<td style="text-align:center"><code>1.A = A</code></td>
<td style="text-align:center"><code>0 + A = A</code></td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center"><code>0.A = 0</code></td>
<td style="text-align:center"><code>1 + A = 1</code></td>
</tr>
<tr>
<td style="text-align:center">Idempotent</td>
<td style="text-align:center"><code>A.A = A</code></td>
<td style="text-align:center"><code>A + A = A</code></td>
</tr>
<tr>
<td style="text-align:center">Inverse</td>
<td style="text-align:center"><code>A.Ā = 0</code></td>
<td style="text-align:center"><code>A + Ā = 1</code></td>
</tr>
<tr>
<td style="text-align:center">Commutative</td>
<td style="text-align:center"><code>A.B = B.A</code></td>
<td style="text-align:center"><code>A + B = B + A</code></td>
</tr>
<tr>
<td style="text-align:center">Associative</td>
<td style="text-align:center"><code>(A.B).C = A.(B.C)</code></td>
<td style="text-align:center"><code>(A + B) + C = A + (B + C)</code></td>
</tr>
<tr>
<td style="text-align:center">Distributive</td>
<td style="text-align:center"><code>A + B.C = (A + B).(A + C)</code></td>
<td style="text-align:center"><code>A.(B + C) = A.B + A.C</code></td>
</tr>
<tr>
<td style="text-align:center">Absorption</td>
<td style="text-align:center"><code>A.(A + B) = A</code></td>
<td style="text-align:center"><code>A + A.B = A</code></td>
</tr>
<tr>
<td style="text-align:center">De Morgan’s</td>
<td style="text-align:center"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="13.617ex" height="2.523ex" role="img" focusable="false" viewBox="0 -1033 6018.7 1115"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(1194.7,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="1953.7" height="237" x="0" y="148" viewBox="488.4 148 1953.7 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(5.861,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(2231.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(3287.2,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="750" height="237" x="0" y="148" viewBox="187.5 148 750 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.25,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(4259.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mover" transform="translate(5259.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(0,615)"><svg width="759" height="237" x="0" y="148" viewBox="189.8 148 759 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.277,1)"></path></svg></g></g></g></g></svg></mjx-container></td>
<td style="text-align:center"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="13.617ex" height="2.523ex" role="img" focusable="false" viewBox="0 -1033 6018.7 1115"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="2731.4" height="237" x="0" y="148" viewBox="682.9 148 2731.4 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(8.194,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(3009.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(4065,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="750" height="237" x="0" y="148" viewBox="187.5 148 750 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.25,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(4815,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mover" transform="translate(5259.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(0,615)"><svg width="759" height="237" x="0" y="148" viewBox="189.8 148 759 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.277,1)"></path></svg></g></g></g></g></svg></mjx-container></td>
</tr>
<tr>
<td style="text-align:center">Double Complement</td>
<td style="text-align:center"><code>̿A = A</code></td>
<td style="text-align:center"><code>̿A = A</code></td>
</tr>
</tbody>
</table>
</div>
<p><em>打表格太费劲了，下次直接截图算了</em>  </p>
<p><em>下文中出现的<code>Ā</code>或者<code>A'</code>都代表<code>NOT A</code></em></p>
<p>上面的表格展示了在布尔代数中的一系列恒等式。就拿德摩根定律举例子：德摩根定律允许我们交换<code>FALSE</code>和<code>TRUE</code>，或者交换<code>AND</code>和<code>OR</code>来将形式变换掉。  </p>
<p>比如说这里有一个表达式：<code>0.A = 0</code>，读作”FALSE AND A is FALSE”。根据德摩根定律，我们可以将<code>AND</code>换成<code>OR</code>,并将所有元素取反。这样就能得到另一个相等的形式：<code>1 + A = 1</code>。总结一下，德摩根定律的变化法则是：  </p>
<ol>
<li><strong>变换时交换<code>TRUE</code>和<code>FALSE</code>（0和1）</strong>  </li>
<li><strong>变换时交换<code>AND</code>和<code>OR</code>（<code>.</code>和<code>+</code>）</strong>  </li>
</ol>
<p><br></p>
<hr>
<p><span class="tag is-warning">Example</span></p>
<p>来做个例题。  </p>
<p>考虑一下这个表达式：<code>A + Ā.B</code>。我们如何化简它？  </p>
<p>有意思的是，要化简这个式子，我们首先需要将式子先变得更复杂。<br>表中提到了有这样一个公式：<code>A + A.B = A</code>。可以通过这一点把原式中的A换掉，就变成了这样：  </p>
<p>                <code>A + A.B + Ā.B</code>  </p>
<p>下一步我们暂时忽略<code>A</code>，然后对<code>A.B + Ā.B</code>使用交换律。步骤如下：  </p>
<p>                <code>A.B + Ā.B = B.A + B.Ā = B.(A + Ā)</code>  </p>
<p>                <code>B.(A + Ā) = B.1</code>    </p>
<p>这一步应用了公式<code>A + Ā = 1</code>。  </p>
<p>将结果带回原式，即可得到化简最终答案：<code>A + B.1</code>。  </p>
<p><br></p>
<hr>
<h2 id="布尔代数运用"><a href="#布尔代数运用" class="headerlink" title="布尔代数运用"></a><strong>布尔代数运用</strong></h2><h3 id="从真值表中创建布尔表达式"><a href="#从真值表中创建布尔表达式" class="headerlink" title="从真值表中创建布尔表达式"></a><strong>从真值表中创建布尔表达式</strong></h3><p>为特定问题创建布尔表达式，有时可以以真值表作为切入点。  </p>
<p>直接上例子把：  </p>
<p><br></p>
<hr>
<p><span class="tag is-warning">Example</span></p>
<p>我们来举一个两个输出的AND门的例子。真值表如下所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>我们即将使用的”Sum of product”的方法是为真值表中的每一行创建一个最小项，输出为1。然后再对这些最小和求和，得到最终的布尔表达式。  </p>
<p><strong>最小项 (Minterm)</strong>是输出为1的特定组合。<br>在这个真值表里，只有一个最小项，那就是当<code>A = 1</code>或者<code>B = 1</code>时。我们将这个最小项记为<code>A.B</code>。<br>因为这个真值表只有一个最小项，所以说这个真值表的最终布尔表达式就是<code>A.B</code>。  </p>
<p><br></p>
<p>但是如果不只有一个最小项怎么办？或者，表中不只有一个输出项怎么办？  </p>
<p>下面是一个半加法器的真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input</th>
<th style="text-align:center">Input</th>
<th style="text-align:center">Output</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center"><strong>Sum</strong></td>
<td style="text-align:center"><strong>Carry</strong></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>首先，我们对”Sum”这一列输出创建最小项：  </p>
<ul>
<li>第二行 (<code>A = 0</code>, <code>B = 1</code>)，最小项是<code>Ā.B</code> (NOT A AND B)</li>
<li>第三行 (<code>A = 1</code>, <code>B = 0</code>)，最小项是<code>A.B'</code> (A AND NOT B)</li>
</ul>
<p>我们使用<code>OR</code>将所有的最小项连接在一起，这样的话就形成了Sum的布尔表达式：   </p>
<p>                <code>Sum = A'.B + A.B'</code>  </p>
<p>同理可得，<code>Carry = A.B</code>  </p>
<p>化简只能够将两列输出分别对应一个布尔表达式，所以最终的答案是：  </p>
<p><code>Sum = A'.B + A.B'</code><br><code>Carry = A.B</code> </p>
<p><br></p>
<hr>
<h3 id="逻辑电路的布尔代数式"><a href="#逻辑电路的布尔代数式" class="headerlink" title="逻辑电路的布尔代数式"></a><strong>逻辑电路的布尔代数式</strong></h3><p><span class="tag is-warning">Example</span></p>
<p>有时候我们需要通过一个逻辑电路来写出布尔代数式。那这个半加法器电路举例子：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB64571bca6b2aebf3bf9e4ad5d2645fcc?method=download&amp;shareKey=418cfa3d73daa608b02e026411a220d2" alt=""></p>
<p>我们跟着A和B两个输入项，来到了第一个NAND门。根据NAND的真值表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>NAND真值表的前三行都为1，所以我们需要为此构建三个最小项。结合起来如下：  </p>
<p><code>W = A'.B' + A'.B + A.B'</code></p>
<p>下一步，W的输出会去到三个NAND门里进行运算。我们这里以X门举例子。如果要画出X的真值表不是很容易，因此我们会考虑NAND门的本质计算方法，那就是先进行一个AND运算，然后将结果取反，也就是跟一个NOT运算。而AND的结果正式两个值的乘积。  </p>
<p>我们先来进行AND运算：  </p>
<p>                <code>A.(A'.B' + A'.B + A.B')</code>  </p>
<p>接着应用布尔分配式，也就是<code>A.(B + C) = A.B + A.C</code>：  </p>
<p>                <code>A.A'.B' + A.A'.B + A.A.B'</code></p>
<p><code>A.A'</code>的结果是0。在AND运算中，只要输入有0，那么输出必然为0。所以我们可以简化成：  </p>
<p>                <code>A.A.B'</code></p>
<p>因为<code>A.A = A</code>，所以最后化简出来的式子就是：  </p>
<p>                <code>A.B'</code></p>
<p>然而事情到这里还没有结束。因为我们只完成了NAND运算里的AND部分，接下来我们会执行NOT运算，也就是将上面的表达式求逆。根据德摩根定律 (元素取反，AND和OR交换)，我们可以得到原式的逆式：  </p>
<p>                <code>A' + B</code>  </p>
<p>到这一步就可以出X的结果了。同样的流程也可以适用于Y的结果：  </p>
<p>                <code>X = A' + B</code>  , <code>Y = A + B'</code>  </p>
<p>这两位合起来，就是S的输出。同样，我们需要先执行AND运算，再通过德摩根定律执行NOT运算：   </p>
<p>                <code>(A + B').(A' + B)</code> (AND执行后)</p>
<p>                <code>S = A'.B + A.B'</code> (NOT执行后)</p>
<p>C的结论，也可以通过这样的流程算出来了。  </p>
<p><br></p>
<hr>
<h2 id="卡诺图-Karnaugh-map"><a href="#卡诺图-Karnaugh-map" class="headerlink" title="卡诺图 (Karnaugh map)"></a><strong>卡诺图 (Karnaugh map)</strong></h2><p><strong>卡诺图 (Karnaugh map, K-map)</strong>是一种从真值表创建布尔代数表达式的方法。<br>K-map可以使这个过程比使用乘积之和来创建最小项要简单得多。如果应用正确，那么卡诺图就可以生成布尔代数表达式的最简单形式。</p>
<p>下表是一个OR逻辑门的真值表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>我们如果使用Sum of products方式来写出的布尔逻辑式如下:  </p>
<p><code>X = A'.B + A.B' + A.B</code></p>
<p>但是我们如果使用卡诺图，就会比较简单了。下面的卡诺图表示了OR逻辑门：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB63ba74660c841de4a57b6ca299f2a079?method=download&amp;shareKey=1ce8f665aec4c02e372293aa7bb7780a" alt=""></p>
<p>在解读卡诺图时，我们需要遵循这些规则：  </p>
<ul>
<li>只考虑内容为1的单元格</li>
<li>在可能的情况下，尽可能将包含1的单元格以<strong>最大矩形</strong>囊括起来。<strong>而且矩形的面积必须是2，4，8等等</strong>。</li>
<li>每一个矩形可以重叠，但也只是在必要的情况下重叠。尽量做到不重叠矩形。  </li>
<li>如果有单个1无法加入到任何矩形中，那么我们就把它自己视为一个组。</li>
</ul>
<p>这些规则决定了图中的蓝色框框。<br>竖着看：B保持不变，但是A发生了变化，所以B被保留。<br>横着看：A保持不变，所以A被保留。<br><strong>最终的布尔表达式就是这些保留值的和。</strong>，如下所示：  </p>
<p><code>X = A + B</code></p>
<p><br></p>
<hr>
<h1 id="第二十章：系统软件"><a href="#第二十章：系统软件" class="headerlink" title="第二十章：系统软件"></a><strong>第二十章：系统软件</strong></h1><h2 id="操作系统的目的"><a href="#操作系统的目的" class="headerlink" title="操作系统的目的"></a><strong>操作系统的目的</strong></h2><p>我们在第八章就提到了<strong>操作系统 (Operating System, OS)</strong>。本章会详细讨论一些有关于操作系统的更多细节。  </p>
<p>我们可以先从系统使用方面的细节开始：  </p>
<ol>
<li><p>计算机系统需要一个程序，这个程序会在计算机启动时开始运行。我们将其称之为<strong>基本输入/输出系统(Basic input/output system, BIOS)</strong>。BIOS存储在ROM中。它作为一个引导程序，目标是在计算机开始运行时，将操作系统从硬盘引导至内存中，从而使其运行。  </p>
</li>
<li><p><strong>多程序设计 (Multi-programming)</strong>是一个操作系统提供的功能，允许多个程序同时加载到内存中。问题在于在一个特定时间内，只有一个程序能够使用CPU，所以其他程序需要保持准备状态，并在合适的实际轮流使用CPU。这样做是为了最大化利用CPU，因为若当前的程序的输入或输出任务完成后，CPU就可以立即切换到下一个程序。  </p>
</li>
<li><p><strong>分时 (Time-sharing)</strong>是另一个计算机系统中的概念，此概念赋予了多用户同时使用同一个计算机系统的机会。“分时”的概念是指每个用户可以获得使用CPU的一小段时间。具体来说，分时操作系统使用CPU调度和多程序设计，一次为一个用户提供共享计算机的一小部分。每个用户在内存中至少有一个独立的程序。当程序被加载到内存中并执行后，会在短时间内完成IO的处理或者其他处理。用户获得CPU关注的这一小部分时间叫做“时间片 (Time slice)”，“时间段 (Time slot)”或者“量子 (Quantum)”。一般来说它的时间长度约为10-100毫秒。</p>
</li>
<li><p>操作系统的目的可以由两个视角来进行解释，分别是<strong>内部视角 (Internal viewpoint)</strong>和<strong>外部视角 (External viewpoint)</strong>。内部视角主要<u>关注操作系统如何组织其活动以最大化利用资源</u>。这包括管理硬件资源，如CPU、内存和各种存储设备，以及软件资源，如运行进程、系统性能和安全性。操作系统需要保证这些资源被有效的利用，才能提供给用户最棒的性能。 <br> 外部视角主要关注操作系统为用户提供的设施和服务。这些服务包括UI，对运行应用程序的支持，文件管理，网络连接，用户身份验证等等的特性。从这个角度来看，操作系统的目标是为用户提供方便有效的功能和体验。  </p>
</li>
</ol>
<p><br></p>
<hr>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a><strong>操作系统结构</strong></h3><p>操作系统的结构为资源管理和用户提供设施和功能提供了平台。它管理硬件资源，如CPU、内存和存储设备，以及软件资源，如运行进程、系统性能和安全性。它还为用户提供服务，如用户友好的界面、对运行应用程序的支持、文件管理、网络连接和安全特性。  </p>
<p>操作系统的逻辑结构提供了两种<strong>运行模式 (Mode of operation)</strong>，分别是<strong>用户模式 (User mode)</strong>和<strong>内核模式 (Kernel mode)</strong>。具体解释如下：  </p>
<ul>
<li>用户模式：应用程序和部分操作系统的其中一种运行模式。在用户模式下，程序不能直接访问硬件或内存，必须使用系统调用来访问这些资源。  </li>
<li>内核模式：也称为主管模式、系统模式或特权模式。在这种模式下，操作系统可以不受限制地访问所有硬件资源和内存。在内核模式下运行的代码可以直接与系统硬件交互，并且可以执行任何CPU指令。  </li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<p>提供这两种运行模式的操作系统部分是分开的。实际上，操作系统的内核是一直运行的，但操作系统的其余部分会以用户模式持续运行。<br>一种可能的实现方式是使用分层结构，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB46af197e0a665f59df40a434625dc585?method=download&amp;shareKey=4cdc6645cf7b30b5420fab0514c7e926" alt=""></p>
<p>在这种结构中，用户通过用户界面(UI)来操作应用程序，而应用程序通过<em>Utilities</em>来对内核进行调用。为了维护系统的正常运作，每一个较高的层都需要较低的层来提供完整的服务。  </p>
<p><br></p>
<p>虽然但是，上面的这一种结构在实际实践的过程中可能会碰到一些问题。所以说一般的方法是使用一个更加灵活的模块化结构。<br>该结构会在内核需要的时候调用不同的模块来处理工作。这种结构与<strong>微内核结构 (Micro-kernel structure)</strong>联系在一起。<br>简单的解释一下微内核结构：这种结构旨在使内核尽可能小而轻，因为它只提供必要的服务，比如进程调度和进程通信。而大多数非必要的服务，比如说设备驱动程序，会交给用户空间处理。这种设计可以使得操作系统比传统的单片内核更加模块化和灵活。  </p>
<p>具体的结构如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4711318e34bd0f53a9998d0db19e41b0?method=download&amp;shareKey=436d1c8eab09f174959fe0d2ce76c6a9" alt=""></p>
<p><br></p>
<hr>
<h2 id="输入-输出系统-I-O"><a href="#输入-输出系统-I-O" class="headerlink" title="输入/输出系统 (I/O)"></a><strong>输入/输出系统 (I/O)</strong></h2><p>实际上，I/O系统不只是涉及到计算机与用户之间发生的输入和输出，同时也负责了程序运行时对存储设备的输入和输出。<br>下图展示出了I/O系统的结构：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe364bf0aea1ca3b80daa72c698a17b1d?method=download&amp;shareKey=ed789a39365bd63cd1a3e4f0d39c59f9" alt=""></p>
<p>上图中的总线结构说明，I/O设备和内存之间可以有一个数据传输选项，那就是设备驱动。如果对于大量数据来说，操作系统也可以确保在内存和I/O设备之间直接传输数据。  </p>
<p>为了理解I/O的管理问题，我们需要考虑一下时间表。<br>不难理解，一秒钟对于计算机系统来说是一个很长的时间，因为CPU大多运行在GHz频率，所以说一秒钟内会存在超过一万亿个时钟周期。<br>下表给出了I/O的典型速度：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Device</th>
<th style="text-align:left">Data rate</th>
<th style="text-align:left">Time for transfer of 1 byte</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Keyboard</td>
<td style="text-align:left">10 Bps</td>
<td style="text-align:left">0.1s</td>
</tr>
<tr>
<td style="text-align:left">Screen</td>
<td style="text-align:left">50 MBps</td>
<td style="text-align:left">2 * 10^(-8) s</td>
</tr>
<tr>
<td style="text-align:left">Disk</td>
<td style="text-align:left">5 MBps</td>
<td style="text-align:left">2 * 10^(-7) s</td>
</tr>
</tbody>
</table>
</div>
<p>不难看出，这些设备的运行速度和CPU的运行速度简直不是一个数量级。所以说CPU就需要特意注意，在I/O设备交流数据时候，CPU不能进入空闲状态。<br>具体的管理方法会在下一节讨论：  </p>
<p><br></p>
<hr>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a><strong>进程调度</strong></h2><p>在系统运行过程中，为了提供最佳性能，我们需要考虑进程调度的问题。  </p>
<p><strong>CPU调度 (CPU Scheduling)</strong>是操作系统中的一个进程，它允许一个进程在另一个进程因为I/O资源不可用或者暂停（处于等待状态）的时候使用CPU，从而发挥出CPU的最佳性能。<br>CPU调度的目标是让系统更加高效和快速。每当CPU空闲时，操作系统必须在就绪的进程队列中选择一个进程来执行。  </p>
<p><br></p>
<p>对于可以在操作系统上运行的程序来说，他们一开始是存储在磁盘上的。然而，用户可以将这些程序作为“<strong>作业 (job)</strong>”来提交给系统。<br>在操作系统的上下文中，“作业”是系统需要执行的工作单元。这可以是一个程序或一组相关的程序，以及关于它们如何运行的附加信息。<br>一份“作业”中可能包含：  </p>
<ul>
<li>实际需要执行的程序（代码）</li>
<li>程序的输入</li>
<li>有关程序所需的资源信息（如内存或者硬盘空间和地址）</li>
<li>有关如何处理输出的说明（比如说输出应该保存到哪里）</li>
</ul>
<p>一旦作业被提交给系统，操作系统就有责任管理作业的执行。这包括将程序加载到内存中，调度程序的CPU时间，管理程序对其他系统资源的使用，以及处理程序的输出。</p>
<p>在实际的情况中，如果对于多CPU系统来说，调度就会有些更加麻烦了。不过这不是我们目前需要考虑的问题。  </p>
<p><br></p>
<hr>
<p>操作系统中，长期调度器或者高级调度程序可控制选择将存储在磁盘上的程序移入主内存。<br>如果内存过于拥挤，中期调度程序需要负责将某些程序从内存中取回磁盘。<br>当程序已经被记录至在内存中时，一个短期或低级调度程序会控制程序何时可以访问 CPU</p>
<p><strong>长期调度器 (Long-term Scheduler)</strong>又称为准入调度器，负责控制新进程是否可以进入系统。它来决定哪些程序可以从作业池（包括所有进程的磁盘存储）中放入就绪队列，并加载到内存中。它可以确保选择某些合适的进程，以优化CPU的工作效率。  </p>
<p><strong>中期调度器 (Medium-term Scheduler)</strong>可以将进程暂时从主内存中移除，并在主内存空间比较紧张的时候将进程重新放回至磁盘中，使此进程变为“挂起”状态。我们将这个操作叫做<strong>换出 (Swapping out)</strong>或者<strong>滚出 (Rolling out)</strong>。中期调度器也可以评估当前主内存的情况，然后决定时候将挂起的进程重新加入至主内存中继续处理。  </p>
<p><strong>短期调度器 (Short-term Scheduler)</strong>也被称之为CPU调度器，它决定哪些已经就绪，并且存在在内存中的进程可以被CPU执行。短期调度器所做出的决定的频率要比其他两个调度器的频率要高得多，因为为了发挥最大性能，进程之间不允许出现任何中断。  </p>
<p>以上三种调度器在操作系统中一起工作，可以有效地管理进程，从而确保每个进程都获得成功执行所需的必要资源和CPU时间。</p>
<article class="message is-info"><div class="message-body">

<b>High-level scheduler: makes decisions about which program stored on disk should be moved into memory</b>

<br>

<b>Low-level scheduler: makes decisions about which process stored in memory should have access to the CPU</b>

</div></article> 


<p><br></p>
<p>所以说在运行程序时，涉及到的硬件之间的交流大概是这样子的：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB610a4dc613998d58c627e8e4f898e1e9?method=download&amp;shareKey=c5b0a214a907c69b16add3526f02c906" alt=""></p>
<p><br></p>
<hr>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h3><p>在第八章中，我们提到过：进程可以定义成“正在运行中的程序”。这个定义可以进一步加入程序第一次进入内存时的状态，来改进进程的定义。具体来说，当一个进程第一次进入到内存后，它的状态就可以叫做“新”。在这一阶段，我们可以在内存中创建一个叫做<strong>进程控制块 (Process control block, PCB)</strong>的东西，以便我们在进程执行的同时读取有关它的数据。<br>PCB是一个数据结构，操作系统可以用它来管理进程的信息。这些信息包括如下细节：  </p>
<ul>
<li><strong>进程的状态</strong>： 进程的当前状态（比如说是新，就绪，运行，挂起还是停止）</li>
<li><strong>进程ID (PID)</strong>： 这是进程的唯一标识码</li>
<li><strong>程序计数器 (Program counter)</strong>： 老朋友了。表示该进程要执行的下一条指令的地址。</li>
<li><strong>CPU寄存器</strong>： 该进程目前正在使用的CPU寄存器</li>
<li><strong>CPU调度信息</strong>： 调度进程所需的信息。可能包含优先级信息以及调度队列的指针</li>
<li><strong>I/O信息</strong>： 分配给进程的I/O设备，或者打开文件的列表等等</li>
</ul>
<p>除了列出的条目，PCB中还存在更多的细节。这里就不展开说了。  </p>
<p>一旦进程进入内存，并且设置好了PCB，进程的状态就可以随着它开始执行和与系统交互而改变。例如，当进程使用CPU的时候，进程的状态就可能从“就绪”变成“运行”。如果进程在等待用户的输入，那么它的状态就可能从“运行”变成“等待”。等等。</p>
<p>哦对了，一个进程可以拆分成不同的部分来执行，这些独立的部分叫做“<strong>线程 (Threads)</strong>”。</p>
<article class="message is-info"><div class="message-body">

<b>Process: a program in memory that has an associated control block</b>

<br>

<b>Process control block (PCB): a complex data structure containing all data relevant to the running of a process </b>

<br>

<b>Thread: part of a program which is handled as an individual process when being executed</b>

</div></article> 



<p><br></p>
<p>进程处理的流程如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB095855ea3e9913fa7d4f1105b18fc94e?method=download&amp;shareKey=bdfecf61b430451e5608fbdeff7b04b7" alt=""></p>
<p><br></p>
<hr>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a><strong>中断</strong></h3><p>有些时候，中断是因为过早终止正在运行的进程而引起的。除此之外，中断的发生也有其他两种可能性：  </p>
<ol>
<li><p>进程由交替使用CPU和I/O的处理时段共同组成。然而I/O需要的时间太长，而且CPU不可能一直闲置等待 I/O 完成。因此当处于运行状态的进程发出需要进行 I/O 操作的系统调用，并不得不转入等待状态时，就会使用中断机制。</p>
</li>
<li><p>调度程序决定停止进程的原因有多种，稍后将在 “调度算法”标题下讨论。</p>
</li>
</ol>
<p>不管发生中断的原因是什么，操作系统的内核都必须需要调用一个中断处理例程来尝试处理问题。首先，我们必须要将程序运行过程中，存储在寄存器中的当前值记录在进程控制块，也就是刚才说过的PCB中。这允许系统可以重新拾起这个进程，然后重新开始处理终端的进程。  </p>
<p><br></p>
<hr>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a><strong>调度算法</strong></h3><p>尽管长期调度器在选择将哪个程序加载到内存时需要做出决定，但这里我们只关注短期调度器或低级调度器的选项。  </p>
<p>首先，调度算法可以是<strong>抢占式 (Preemptive)</strong>的或<strong>非抢占式 (Non-preemptive)</strong>的。抢占式算法可以停止进程，否则进程将继续不受干扰地运行。如果一个算法是抢占式的，那么它可能需要涉及进程优先级的考虑工作。所谓 “抢占式”，是指当进程的分配时间（或时间片）过期时，调度器可以强行将其从 CPU 中移除。这与非抢占式调度相反，在非抢占式调度中，进程一直运行到结束或被 I/O 阻塞为止。</p>
<p>这时候我们可以使用<strong>轮询算法 (Round-robin algorithm)</strong>来处理问题。这是一种抢占式算法，是操作系统中最简单的进程调度算法之一。在轮转调度中，每个进程都被分配了一个固定的时间片。如果这个进程所分配的时间片用完了，那么这个进程会被直接停止掉。  </p>
<p>当然，进程如果以某些奇怪的方式停止掉以后，在某些情况下我们还会希望他们继续回来执行。因此，轮询算法还可以用来实现<strong>FIFO队列 (FIFO queue)</strong>，也就是“先进先出队列”来实现。进程被添加到队列的末尾，并按照到达的顺序分配 CPU。一旦某个进程轮到使用 CPU（即其时间片已过期），它就会被移到队列的后面。</p>
<p>基于优先级的调度算法则更为复杂。其中一个原因是，每次有新进程进入就绪队列或运行中的进程停止时，都需要重新评估进程的优先级。另一个原因是，无论使用什么方案来判断优先级，都需要进行一定的计算。可能的标准有：  </p>
<ul>
<li>进程执行的所需估计时间</li>
<li>进程执行剩余的时间</li>
<li>在就绪队列中已经花费的时间长度</li>
<li>进程是I/O绑定还是CPU绑定</li>
</ul>
<p>显然，在上面列出的条目里，估计执行时间并非易事。<br>有些程序需要大量的输入输出，例如为员工打印工资条。此类进程的CPU使用很少，因此为其分配高优先级是有意义的，这样就可以进行少量的CPU使用。然后，在打印发生时，就可以将本流程切换到等待状态了。</p>
<p><br></p>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h2><p>“内存管理”一词包含如下方面：</p>
<ul>
<li>内存管理为操作系统内核提供受保护的内存空间</li>
<li>将程序加载到内存中需要做准备工作，而内存管理可以为程序本身、相关的过程和程序所需的数据定义内存地址</li>
<li>当运行在多程序设计的计算机上时，内存管理就相对来说比较复杂了。与存储在硬盘上的文件一样，进程在主内存中的存储也会产生碎片。这时，中期调度器可能需要将进程移出主内存，以缓解问题。</li>
<li>内存管理必须决定应该将多大一部分内存分配给共享内存的各个进程。</li>
</ul>
<p><br></p>
<hr>
<h3 id="分区与段"><a href="#分区与段" class="headerlink" title="分区与段"></a><strong>分区与段</strong></h3><p>当不同的进程同时加载到内存中时，早期的内存管理方法是对内存进行<strong>分区 (Partition)</strong>，它的目的是尽可能将整个进程加载到一个分区中。但是如果进程的大小小于分区大小，就会浪费内存。<br>后续出现的其中一个改进方法是“<strong>动态分区 (Dynamic partitioning)</strong>”，其中允许调整分区大小以匹配进程大小。然而每个分区一个进程的规则仍然存在。</p>
<p>具体来说，分区是一种将计算机内存划分为多个分区的方法，每个分区可容纳一个进程。其目的是将一个进程的全部内容加载到一个分区中。不过，如果进程的大小小于分区的大小，这种方法可能会造成浪费，导致分区内的内存闲置。</p>
<p>动态分区是对最初方法的改进。在动态分区中，我们允许调整分区的大小以匹配进程的大小。这有助于确保每个进程只使用其所需的内存，从而减少内存浪费。不过，每个分区只能容纳一个进程的规则仍然存在，这意味着每个分区一次只能容纳一个进程。  </p>
<p><br></p>
<p>上述思想拓展出了另一个解决方案，那就是<strong>分段 (Segmentation)</strong>。分段是操作系统中的一种内存管理技术，它将计算机的主内存划分为大小可变的部分，称为<strong>段 (Segments)</strong>。其中的每个段可分配给一个进程。每个段的详细信息都存储在一个称为<strong>段表 (Segment table)</strong>的表格中。</p>
<p>分段被描述为动态分区思想的延伸，因为如果一个进程太大，那么它就无法容纳在一个分区中。所以将其划分为更小的段会是一个潜在的解决方案。然后，每个分段都可以加载到内存中的动态分区中。这种方法可以更高效地处理大型进程，因为每个分段都可以根据需要独立加载或卸载。 这也有助于减少外部碎片，因为分段可以更整齐地嵌入可用内存空间。</p>
<p><br></p>
<hr>
<h3 id="分页与虚拟内存"><a href="#分页与虚拟内存" class="headerlink" title="分页与虚拟内存"></a><strong>分页与虚拟内存</strong></h3><p>在现代计算机系统中，我们一般使用<strong>分页 (Paging)</strong>的方法来管理内存。<br>分页是一种不需要连续分配物理内存的方案，它允许计算机的物理内存以不连续的方式记录。在分页中，进程会被划分为长度相等的部分，我们将这些部分称之为“<strong>页 (Page)</strong>”。  </p>
<p>在操作系统内存管理中，内存可以被划分为固定长度的块，我们将其称为“<strong>帧 (Frames)</strong>”。<br>二级存储器(如硬盘)也可以划分为固定大小的块，通常称为“<strong>扇区 (Sectors)</strong>”或“<strong>集群 (Clusters)</strong>”，但在这里也可以称为“帧”。这些块可以保存从主内存换出的页。  </p>
<p>操作系统会跟踪哪些帧是空闲的，哪些帧是正在使用的。当程序需要将一页加载到内存中时，操作系统会找到一个空闲帧，并将该页加载到其中。如果没有空闲帧，操作系统可能需要换出当前内存中的一页，为新页腾出空间。这种技术允许操作系统有效地利用内存和辅助存储，并支持虚拟内存等特性，其中程序可以比物理内存的总量更大。</p>
<p>将所有的页同时加载到内存中实际上是可行的（如果你的计算机内存够大）。<br>但即使这是可能的，通常情况下我们也不需要使用程序的所有部分。因此将某些页放回二级存储是必要的。  </p>
<article class="message is-info"><div class="message-body">

<b>Segmentation: where a large process is divided into segments for loading into memory but the segments are not constrained to be the same size</b>

<br>

<b>Paging: where a large process is divided into pages which have to be the same size</b>

</div></article> 

<p><br></p>
<hr>
<p>这就引出了一个新的概念。  </p>
<p>分页使用的一种特殊情况是，如果程序非常大，其所需的地址空间可能会大于内存大小。<br>这时候，我们就会需要用到分页技术支持的<strong>虚拟内存管理 (Virtual memory management)</strong>来解决这种情况了。  </p>
<p>分页在执行过程中会要求CPU将地址传输到<strong>内存管理单元 (Memory management unit, MMU)</strong>，内存管理单元负责为每一个“页”分配地址。这个地址必须由两个部分组成，分别是“页码”加上该页起始处的“偏移量”。  </p>
<p>内存管理单元负责将CPU中的逻辑地址转换为内存中的物理地址。它使用一种称为<strong>页表 (Page table)</strong>的数据结构来实现这一点，页表跟踪每个页在物理内存中的位置。地址的页码部分用作页表的索引。该索引处的页表项包含物理内存中该页的基址。然后将偏移量添加到该基址，以获得所需的确切物理内存位置。</p>
<p><br></p>
<hr>
<p>有些抽象，所以我们来简单展示一个非常简化的页表：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb1fe4ad9a625703c2201225483bf201d?method=download&amp;shareKey=8b6556ecb3677f52577831150b8e3f84" alt=""></p>
<p>图片的左侧展示了一个有48条指令的程序，不难看出，这些指令占用了3个页。反过来说，这3页占用了48条内存地址。  </p>
<p>该系统的逻辑地址采用8个位存储。因为一个字节(8位)可以表示256个不同的值(从0到255)，而我们只使用16页，所以我们只需要前4位来表示页码(因为<code>2^4 = 16</code>)。剩下的4位用来表示页面内的偏移量。所以说在本系统中，逻辑地址被分为了两个部分，而他们的表示方式为：  </p>
<ul>
<li>四个最高位存储页码。</li>
<li>四个最低有效位将偏移量存储在页面中。  </li>
</ul>
<p>这使得系统可以通过其页码和偏移量快速有效地定位内存中的任何指令。  </p>
<p><br></p>
<p>而图表的右半部分展示了各个页的物理内存地址。在继续之前，我们需要先强调，<strong>页帧 (Page frame)</strong>和帧之间没啥区别。  </p>
<p>好的，我们继续。  </p>
<p>需要注意的是，所使用的页帧不必在物理内存中相邻。这意味着程序的不同部分可以加载到不同的内存区域，而不必彼此相邻。这是分页和虚拟内存的优点之一，因为它允许更有效地使用内存。从图中我们可以得到，程序的前两个页已经被加载到内存中的页帧中。  </p>
<p>图表中间的部分说明了此流程中页表的内容。在分页系统中，内存中的每个进程都有一个单独的页表。页表中每个页都有条目，而页码会作为索引。<br>表中的每个条目都包含一个表示该页当前是否在内存中的存在标志，我们叫它”<strong>Presence flag</strong>“，如图中第二列所示。<br>在这里显示的版本中，第三个条目显示了页帧号。或者，这可以记录页面框架中第一个项目的物理地址。它可以记录页面框架中第一个项目的物理地址。  </p>
<p><br></p>
<p>在使用分页的时候，在最开始的开始，包含一个进程的一组页会存储在磁盘上。在进程切换到“就绪”状态时，其中的一个页或者多个页就会被加载到内存中。当进程被指派为“运行”状态时，进程就可以开始执行了。  </p>
<p>然而，有些时候，进程可能会请求访问地址不在内存中的页，我们管这种情况叫做“<strong>缺页异常条件 (Page fault)</strong>”，或者更简单的说法——页面错误。<br>当出现页面错误时，操作系统需要将所需的页面从辅助存储(如硬盘)带到内存中。但是，如果没有可用的空闲内存，操作系统将需要选择一个当前加载的页面来替换。这就是<strong>页面替换算法 (Page replacement algorithm)</strong>发挥作用的地方。  </p>
<p>有好几种页面替换算法，比如说：  </p>
<ul>
<li><p><strong>先进先出 (First-in First-out, FIFO)</strong>:这个简单的算法替换内存中最老的页面(即，首先加载的页面)。虽然易于实现，但如果仍然频繁访问旧页面，则此方法可能导致更高的页面错误率。  </p>
</li>
<li><p><strong>LRU (Least Recently Used)</strong>:这个方法会替换最长时间未被访问的页面。它基于这样一种观察，即最近被大量使用的页面很可能在将来再次被大量使用。虽然这种方法通常执行得很好，但它需要跟踪每个页面最后访问的时间，所以这种方法带来的计算量就会变得更大一些。  </p>
</li>
</ul>
<p><br></p>
<p>虚拟内存可能会带来一些问题。可能出现的最严重的问题之一是<strong>磁盘抖动 (Disk thrashing)</strong>。当进程不断地需要在内存内和内存外交换页面时，就会发生这种情况。简单来说，虚拟存储管理中的抖动现象是指系统频繁地进行磁盘交换，导致系统的性能下降的现象。  </p>
<p>比如说当系统内存不足时，操作系统会将一部分数据交换到磁盘中以释放内存。但是，当系统再次需要这些数据时，又需要将其从磁盘中加载回来，这就会产生磁盘交换。当系统的内存利用率接近饱和状态时，这种抖动现象会变得更加明显。因为系统需要频繁的交换数据，导致磁盘的负载变高，同时也降低了系统的响应速度和性能。为了避免这种情况的发生，我们可以增加系统内存，或者优化虚拟内存的存储策略来缓解问题。</p>
<article class="message is-info"><div class="message-body">

<b>Disk thrashing: when paging is being used and a repetitive state has been reached where loading one page causes a need for another page to be loaded almost immediately but the loading of this new page causes the same immediate need</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="提供给用户的操作系统设施"><a href="#提供给用户的操作系统设施" class="headerlink" title="提供给用户的操作系统设施"></a><strong>提供给用户的操作系统设施</strong></h2><p>操作系统需要让用户来使用，所以它需要提供<strong>用户界面 (User interface, UI)</strong>。用户界面可以以命令行、图形显示或语音识别系统等方式来体现，但是请记住，用户界面的功能始终是允许用户与正在运行的程序进行交互。  </p>
<p>当程序涉及到设备的使用时，操作系统提供<strong>设备驱动程序 (Device driver program)</strong>。  </p>
<p>操作系统还必须提供一个<strong>文件系统 (File system)</strong>来存储数据和程序。在实际使用的时候，用户必须选择用户名并组织文件在文件夹中的结构，但是用户用不着管理磁盘上的物理数据是怎样存储的——因为这些是文件系统的活儿。  </p>
<p>如果用户是程序员，则操作系统支持提供<strong>编程环境 (Programming environment)</strong>。这样，程序员就可以在操作系统的帮助下，即便在不熟悉处理器功能的情况下也能创建和运行程序。  </p>
<p>当一个程序被运行时，我们可以将其认为是一个<strong>用户类型 (Type of user)</strong>，程序就像人类用户可能通过单击或键入来告诉计算机要做什么一样，程序使用一种称为<strong>系统调用 (System call)</strong>的东西向操作系统发出请求，这些类似于程序的点击或输入方式。例如，如果程序需要从文件中读取数据，它不会去查找文件本身。相反，它使用系统调用来要求操作系统执行此操作。然后操作系统接管，找到文件，并将数据提供给程序。<br>这样就引申出来了一个新的概念，叫做<strong>程序编程接口 (Application programming interface, API)</strong>。API就像操作系统为程序提供的选项菜单。菜单上的每个选项(每个API调用)都做一件特定的事情，比如在屏幕上创建一个图标。为了完成它的工作，API调用可能会使用一个或多个系统调用。  </p>
<p><br></p>
<hr>
<h2 id="转译软件"><a href="#转译软件" class="headerlink" title="转译软件"></a><strong>转译软件</strong></h2><p>同样是在第八章，我们概述了编译器和解释器的使用与特性。现在我们来深入介绍一下解释器的工作原理，并同时介绍解释器的工作原理。<br>编译器和解释器的编写工作是一项专业性极强的工作，通常情况下都由专家完成，而每个人的编写方式都各不相同。因此，本小节会探讨一些比较常见的思路。  </p>
<p>编译器可以被分解成一个“前端”和“后端”。前端程序对代码进行分析，它检查代码的语法和语义，确保它遵循编程语言的规则并具有逻辑意义。如果没有错误，它会生成<strong>中间代码 (Intermediate code)</strong>。中间代码是一种完全捕获源代码含义(语义)的表示形式。  </p>
<p>而编译器的“后端”将这些中间代码作为输入。然后，它从这个中间表示合成或创建目标代码。目标代码是计算机能够执行的最终机器码。</p>
<p>这样的一个分析-综合模型如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf24bfb42acabc62fca77dde3bd4bec2e?method=download&amp;shareKey=d093f91182e7f059ae2d0bd2ce3188aa" alt=""></p>
<p><br></p>
<p>先说好，我们假设上面的结构处理的源代码没有任何错误。接下来我们解释一下每一个步骤：  </p>
<p>首先，源代码是逐行读取的，而且是重复逐行读取的。对于每一行来说，编译器都会生成它们对应的中间代码。上图还展示了解释器程序如何在前端进行分析过程。在这种情况下，一旦发现某一行源代码没有错误，并将其转换为中间代码，就会执行该行源代码。  </p>
<p><br></p>
<hr>
<h3 id="前端分析阶段"><a href="#前端分析阶段" class="headerlink" title="前端分析阶段"></a><strong>前端分析阶段</strong></h3><p>如下图所示，我们可以将前端的处理阶段分成这样的四个部分：  </p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>生成中间代码</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd56b4dd092332686b3ab5445260b5bc7?method=download&amp;shareKey=6fc3b6e0d1356832c10556ca79b3112b" alt=""></p>
<p><br></p>
<p>编译器或解释器的输入数据是程序的源代码，我们叫它<strong>字符序列 (Sequence of characters)</strong>，而<strong>词素 (Lexeme)</strong>是这个序列中一个有意义的单个字符或字符集合。 例如，词素可以是程序员定义的标识符（如变量名），也可以是编程语言预定义的关键字、运算符或符号。</p>
<p><strong>第一步：词法分析</strong>：就是将源代码分解为这些单个词法的过程。<br>一种方法是首先删除源代码中的所有空白（空格、制表符、换行符）和注释。然后，检查源代码的每一行并识别每个词素。简单来说，词法分析就像是将一个句子分解成一个个单词，并了解每个单词在句子中的作用。  </p>
<p>以伪代码的形式表述：<code>Var Count : integer;</code>，会被解释成一个存在五个词素的指令，分别是<code>Var Count : integer ;</code>。<br>同样，<code>PercentMark[Count] := Score * 10</code>会被解释成一个存在八个词素的指令，分别是<code>PercentMark [ Count ] := Score * 10</code>。</p>
<p>词法分析器现在必须对每个词素进行分类，以便将代码行标记化。例如，在第一个例子中，<code>var</code>和<code>integer</code>必须被识别为关键字，<code>;</code>被识别为标识符，<code>:</code>以及<code>;</code>必须被视为不同的词素。  </p>
<p>对于每个识别到的标识符，我们都必须在<strong>符号表 (Symbol table)</strong>中创建一个条目。符号表中包含了每个标识符的属性，比如说数据类型，在何处被声明以及在何处被赋值。<br>符号表是编译器的一个重要的数据结构，虽然上面的的图显示了它只会在语法分析程序中使用，但是到了后期的编译阶段，我们同样也会继续使用它。<br>值得强调的是，因为大多数的编译器是多遍的，所以说符号表里面的内容是可以频繁的更新的。  </p>
<article class="message is-info"><div class="message-body">

<b>Symbol table: a data structure in which each record contains the name and attributes of an identifier</b>

</div></article> 


<p>也不是所有的内容都可以转换为标识符，所以我们需要另一个表来记录非标识符词法的内容。<br>总之，无论采用何种方案，词法分析的输出都是源代码的分词版本。文献中提到了用于表示标记的各种格式。  </p>
<p><br></p>
<p><strong>第二部：语法解析</strong>：也称之为解析，涉及对程序结构的分析。分析的结果会被记录为语法或者是解析树。<br>下面的图片展示了这个语句”<code>y := 2 * x + 4</code>“的解析树：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6b978d0fb2694bec7ddd774abcc1002f?method=download&amp;shareKey=1b501575072ae80fbfdf497e7eedd173" alt=""></p>
<p>如果树被成功的解析了，那么程序会在+4之前先去将x乘以2。  </p>
<p><br></p>
<p><strong>第三步：语义分析</strong>：语义分析是为了确定代码的全部含义。 为记录这些信息，我们构建了一棵带注释的抽象语法树。 对于语法树中的标识符，会建立一套相关的属性，包括数据类型等。 这些属性也记录在符号表中。  </p>
<p>前端分析的最后阶段经常创建的中间代码的格式是三地址码。例如，下面的赋值语句有5个标识符，对应5个地址:</p>
<p><code>y := a + (b * c - d) / e</code></p>
<p>这一个赋值语句可以转换为以下4个语句，每个语句最多需要3个地址:  </p>
<p><code>temp := b * c</code><br><code>temp := temp - d</code><br><code>temp := temp / e</code><br><code>y := a + temp</code></p>
<p><br></p>
<hr>
<h3 id="语言的语法表示"><a href="#语言的语法表示" class="headerlink" title="语言的语法表示"></a><strong>语言的语法表示</strong></h3><p>每种编程语言都有自己定义的语法。为了使语言可以正常使用，这个语法必须被程序员和编译器作者理解。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7b03490853d0d2cbcbdc90b52d54a871?method=download&amp;shareKey=a8b731d4fbb0228ee6936de7dfb9896a" alt=""></p>
<p>表示语法的一种方法是使用<strong>语法图 (Syntax diagram)</strong>，上图就是一个实例语法图。<br>比如，上面的语法图规定了这样一条语法规则：标识符必须以字母开头，而后面可以是无字符或者多个字母或数字的集合。  </p>
<p><br></p>
<p>另一种方法是使用<strong>巴科斯范式 (Backus-Naur Form)</strong>来表示。下面是一些使用巴科斯范式的例子：  </p>
<p><code>&lt;Identifier&gt;::=&lt;Letter&gt;|&lt;Identifier&gt;&lt;Letter&gt;|&lt;Identifier&gt;&lt;Digit&gt;</code><br><code>&lt;Digit&gt;::=0|1|2|3|4|5|6|7|8|9</code><br><code>&lt;Letter&gt;::=&lt;UpperCaseLetter&gt;|&lt;LowerCaseLetter&gt;</code><br><code>&lt;UpperCaseLetter&gt;::=A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z</code><br><code>&lt;LowerCaseLetter&gt;::=a|b|c|d|e|f|g|h|i|j|K|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z</code></p>
<p>在巴科斯范式中，<code>|</code>为了分离单独的每一个选项，<code>::=</code>可以被描述成“被定义为”。<br>在上面的例子中，<code>&lt;Identifier&gt;</code>是使用递归的方式定义的。但如果我们要定义的内容无法抽象到这个级别，那么我们也可以使用列举的方式定义内容。  </p>
<p><br></p>
<hr>
<h3 id="后端合成阶段"><a href="#后端合成阶段" class="headerlink" title="后端合成阶段"></a><strong>后端合成阶段</strong></h3><p>如果前端分析已经确定源代码存在语法错误，那么后端过程的唯一目标就是通过列表的形式来呈现这些错误。<br>每个发生的错误，都会有两个属性：错误的解释和在程序源代码中的位置。这些信息可以帮助到程序员，让他们更方便的调试软件。  </p>
<p>但是如果在没有错误的情况下，主要的后端阶段是从中间代码生成机器代码，同时可能涉及代码优化。<br>优化的目的是创建一个高效的程序。有一种优化方式专注于优化原始源代码中固有的、已经传播到中间代码中的特性。<br>举个简单的例子，以下连续的赋值语句:  </p>
<p><code>x := (a + b) * (a - b)</code><br><code>y := (a + 2 * b) * (a - b)</code></p>
<p>它的优化方式就可以是这样：  </p>
<p><code>temp := (a - b)</code><br><code>x := (a + b) * temp</code><br><code>y := x + temp * b</code></p>
<p><br></p>
<hr>
<h3 id="表达式的求值"><a href="#表达式的求值" class="headerlink" title="表达式的求值"></a><strong>表达式的求值</strong></h3><p>赋值语句通常是一个为标识符定义新值的代数表达式。<br>计算表达式时，首先要将代码中的中缀表示法转换为<strong>反向波兰表示法(Reverse Polish Notation, RPN)</strong>。<br>在 RPN 中，运算符（如 +、-、*、/）写在操作数的后面。例如，表达式 <code>5 + 3</code> 在 RPN 中会写成 <code>5 3 +</code>。这可以简化表达式的求值过程，因为一旦将表达式转换成 RPN，就可以从左到右地求值，而无需跟踪优先级规则或括号。  </p>
<p>举一些例子:  </p>
<p>Absolutely! Here are some examples of Reverse Polish Notation (RPN):</p>
<ol>
<li><p>中缀表示法: <code>2 + 3</code><br>RPN: <code>2 3 +</code></p>
</li>
<li><p>中缀表示法: <code>4 * 5</code><br>RPN: <code>4 5 *</code></p>
</li>
<li><p>中缀表示法: <code>(1 + 2) * 3</code><br>RPN: <code>1 2 + 3 *</code></p>
</li>
<li><p>中缀表示法: <code>2 + 3 * 4</code><br>RPN: <code>2 3 4 * +</code></p>
</li>
<li><p>中缀表示法: <code>(7 - 2) / (5 + 3)</code><br>RPN: <code>7 2 - 5 3 + /</code></p>
</li>
</ol>
<p><br></p>
<hr>
<h3 id="计算RPN表达式"><a href="#计算RPN表达式" class="headerlink" title="计算RPN表达式"></a><strong>计算RPN表达式</strong></h3><p>我们可以使用栈来计算RPN表达式。<br>让我们下面这个RPN表达式的执行，其中x的值为3,y的值为4:</p>
<p><code>x 2 * y 3 * + 6 /</code>  </p>
<p>这里遵循的规则是依次将值添加到栈中。<br>如果RPN表达式中的下一项是操作符，则进程中断。这将导致前两个元素从栈中弹出。<br>随后需要使用运算符从这两个值创建一个新值，并将新值添加到栈中，然后该过程继续进行。<br>下图给出了栈的连续内容，指出了何时使用了操作符。当弹出两个值时，栈的中间状态不会显示。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB662084ed9ed021ff6fdb92d969139a44?method=download&amp;shareKey=2cbcbaa31654831501c5c03da8282b42" alt=""></p>
<p>如果使用的是第6章讨论的具有有限指令集的简单处理器，那么RPN的使用就没有什么价值。<br>因为现代处理器的指令集中会有处理堆栈操作的指令，因此编译器可以将表达式转换为RPN，因为它知道将表达式转换为机器码可以利用这些内容并允许在程序执行中进行堆栈处理。 </p>
<p><br></p>
<hr>
<h1 id="第二十一章：数据安全"><a href="#第二十一章：数据安全" class="headerlink" title="第二十一章：数据安全"></a><strong>第二十一章：数据安全</strong></h1><h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a><strong>加密原理</strong></h2><p>在计算机系统中，加密可以用来作为存储数据的常规方法。不过，本章讨论的加密的重点是在数据通过网络的传输时而使用。  </p>
<p>本章会主要探讨下面这三个问题：  </p>
<ul>
<li>加密算法是不是足够稳健，以至于加密数据不会对未经授权的第三方应用（或者任何个体）解密？  </li>
<li>如何确认加密数据时用的密钥，是保密的呢？  </li>
<li>通信的接收者如何知道是谁发送了加密通信？  </li>
</ul>
<p><br></p>
<p>加密的流程如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb68b5fb3de1daa54df1157f381a26d05?method=download&amp;shareKey=c1aab18fd4fb3279e4b3fa0eec64dcb8" alt=""></p>
<p>首先，数据以<strong>明文 (Plaintext)</strong>的形式进入加密环节。首先，明文会使用<strong>密钥 (Key)</strong>进行<strong>加密 (Encryption)</strong>步骤。<br>明文经过加密后，就会变成<strong>密文 (Ciphertext)</strong>，随后密文就会被发送到它传输的目的地。<br>当另一台计算机收到了密文的时候，它也可以使用密钥来对密文进行<strong>解密 (Decryption)</strong>来还原原本的明文。</p>
<article class="message is-info"><div class="message-body">

<b>Plaintext: data before encryption</b>

<br>

<b>Ciphertext: the result of applying an encryption algorithm to data</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a><strong>安全问题</strong></h3><p>在进行加密传输的时候，下面这些安全问题确实是值得一提的：  </p>
<ul>
<li><strong>保密性 (Confidentiality)</strong>：确保只有接收方能解密密文，而其他未经授权的终端无法解密密文</li>
<li><strong>真实性 (Authenticity)</strong>：接收方能够确定到底是谁发送了密文</li>
<li><strong>完整性 (Integrity)</strong>：密文在传输过程中无法发生修改</li>
<li><strong>不可否认性 (Non-repudiation)</strong>：发送方和接收方都不能否认参与了数据的传输</li>
<li><strong>可用性 (Availability)</strong>：不应该发生任何事情来阻止接收方接收传输</li>
</ul>
<p>而在本章的讨论中，我们只考虑前三点：保密性，真实性和完整性。<br>由于讯息在传送过程中可能会被截取，而内容可能会被未获授权的人士阅读，因此我们需要考虑保密性问题。<br>同时对完整性的关注反映了这样一个事实:传输可能被故意干扰，但也可能在传输过程中意外损坏数据。  </p>
<p><br></p>
<hr>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a><strong>加密方法</strong></h3><p>对于加密算法来说，首先它不能被保密，这意味着加密算法必须在公共领域公开。而且，加密密钥必须是保密的。<br>加密一般来说有两种常用的策略，一种是<strong>对称密钥加密 (Symmetric key encryption)</strong>，另一种是<strong>非对称密钥加密 (Asymmetric key encryption)</strong>，也称为<strong>公钥加密 (Public key encryption)</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Symmetric key encryption: one private key is held by both sender and receiver and is used for both encryption and decryption</b>

<br>

<b>Asymmetric key encryption: there is a public key and a private key one of which is used for encryption and the other for decryption</b>

</div></article> 

<p><br></p>
<p>在对称密钥加密中，我们自始至终只会用到一个密钥，而这个密钥只有消息的发送端和接收端知道。“只会用到一个密钥”的意思是：发送方会使用这个密钥加密信息，而接收端同时也会使用这个密钥来解密信息。  </p>
<p>而对称密钥加密就不是这种方式了，因为加密和解密的密钥不同，所以密钥的传递就会变成一个大问题。<br>发送方需要密钥来加密，但如何将密钥安全地传递给接收方以允许解密呢？<br>在非对称密钥加密中，使用两个不同的密钥，一个用于加密，另一个用于解密。两个密钥中只有一个是保密的。所以说如果我们要使用非对称密钥加密，那么发送端手中会有两个密钥，其中一个是公钥，而且这个公钥可以被发送给任何想要参与通信的人，而另一个密钥是永远不会发送给任何人的秘密私钥。如果某人(发送方)想要向密钥持有者(接收方)发送安全消息，他们使用接收方的公钥对消息进行加密。此过程将原始消息(明文)转换为不可读的格式(密文)。一旦接收方获得密文，他们可以使用他们的私钥将其解密回原始消息。因为只有接收方可以访问他们的私钥，所以他们是唯一可以解密和读取消息的人。公钥可以被多人共享。这意味着任何数量的人都可以向接收者发送安全消息，并且只有接收者能够解密和读取这些消息。  </p>
<p>需要注意以下两点：  </p>
<ul>
<li>如果两个人需要双向通信，那么通信的双方都需要一个私钥，并且必须将匹配的公钥发送给另一个人。  </li>
<li>要确保传输被截获和消息被提取时的机密性，必须满足两个要求：加密算法必须复杂，而且用于定义密钥的位数必须很大 （防止暴力穷举）。  </li>
</ul>
<p><br></p>
<hr>
<h2 id="数字签名与电子证书"><a href="#数字签名与电子证书" class="headerlink" title="数字签名与电子证书"></a><strong>数字签名与电子证书</strong></h2><p>上面提到的非对称加密，是一种使用两个不同密钥的加密类型，包括用于加密的公钥和用于解密的私钥，反之亦然。每一个个体都可以用他们的私钥加密消息。然后可以将此加密消息发送给拥有相应公钥的收件人。同时，接收方可以使用公钥将接收到的密文解密回原始消息。但因为公钥的公开性，这就导致了非对称加密不保证数据的完全保密，因为任何人都可能获得公开密钥，从而可以解密信息。  </p>
<p>不过，这种方法可用来验证发件人是谁。 由于只有发件人才拥有私人密钥，而公钥只对特定的私人密钥起作用，如果收件人发现解密成功，就意味着该信息一定是用相应的私人密钥加密的。 因此，它验证了信息确实是由私钥持有者发送的。 这就是所谓的数字签名。  </p>
<p><strong>数字签名(Digital Signature)</strong>是一种特定类型的电子签名，它要求签名者使用基于证书的数字ID来 <u> 验证其身份 </u>。数字证书通常由独立的证书颁发机构(CA)颁发，CA在颁发证书之前验证签名者的身份。  </p>
<p>现在来看，电子签名是使用非对称加密算法的公钥和私钥实现的：发送方使用他们的私钥加密消息。这就像用只有寄件人才有的私人印章来封一封信一样。而接收方拥有相应的公钥，可以对消息进行解密。这就像用合适的工具打开密封的信。如果解密成功，它验证消息确实是由私钥的持有者发送的，因为只有特定的私钥可以被用来加密消息，并且可以被相应的公钥解密。这就像一个数字签名，提供发送者身份的证明。</p>
<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc471bd9c4caf08fffabf10f50ecca5ac?method=download&amp;shareKey=7d9e77033f410ea9c98bcdc564545db0" alt=""></p>
<p>但是使用这种数字签名的缺点在于：它与整个消息的加密相关联。这可能导致计算数字签名会需要强大的算力支持，因为牵扯到所有数据来计算数字签名需要密集计算。  </p>
<p>所以另一种选择是使用加密哈希函数。这是一个特殊的函数，它接受一个输入(或’消息’)并返回一个固定大小的字节字符串。对于每个唯一的输入，输出都是唯一的——即使输入中的一个小变化也会产生如此巨大的哈希值输出变化，以至于新的哈希值看起来与旧的哈希值不相关。<br>随后，发送方将哈希函数应用于他们的消息，从而创建一个“<strong>摘要 (Digest)</strong>”。此摘要是表示消息内容的唯一数字。发送方然后使用他们的私钥加密该摘要。加密后的摘要作为数字签名。上图展示了通过摘要生成电子签名的流程。  </p>
<p>在信息发送阶段，原始消息(明文)和加密摘要(数字签名)然后一起发送，通常将摘要作为单独的文件附加到消息中。由于摘要比整个消息小得多，因此加密和传输它比加密整个消息要快得多。在一些网站下载内容时，它们可能会同时提供文件的SHA-256摘要。通过比对自己下载的文件的SHA-256与官网的进行比较，可以知道用户下载的文件是否在下载过程中发生了损坏。   </p>
<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB564dcb1844aefc51deeeb7d53142b7f0?method=download&amp;shareKey=6e09e4b98e7690464025f65ab03a5a30" alt=""></p>
<p>上图描述了信息在接收端发生的处理过程。  </p>
<p>刚才谈到SHA-256的时候说过，接收方使用与发送方使用相同的公共单向哈希函数从接收到的消息中创建摘要。这将产生一个唯一的数字，表示接收到的消息的内容。随后，接收方使用发送方的公钥解密随消息一起发送的原始摘要的加密版本。接收方将从收到的消息中计算出的摘要与解密后的原始摘要进行比较。如果它们匹配，则验证消息在传输过程中没有被篡改，并确认发送方的真实性(因为只有发送方的私钥才能以一种可以由相应的公钥解密的方式加密原始摘要)。  </p>
<p><br></p>
<p>然而，真实性只向接收者确认消息是由向他们发送公钥的人发送的，但是它没有考虑这样一个事实，即某人可能会创建公钥并假装是其他人。为了克服这一限制，需要一种更严格的方式来确保身份验证。这就是<strong>证书颁发机构 (Certification Authority, CA)</strong>的用武之地。<br>CA是一个受信任的第三方，它验证实体(如人、计算机或组织)的身份，并通过数字证书将它们绑定到公钥。 </p>
<p>而CA是一个更大的系统的一部分，被称为<strong>公钥基础设施 (Public Key Infrastructure, PKI)</strong>，它管理密钥和证书，并在不受信任的网络(如互联网)上实现安全通信。PKI确保每个公钥对于其持有者是唯一的，并提供查找、撤销和更新证书的方法。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc2b105e9ae510369c308295ffa89a248?method=download&amp;shareKey=649eae63c45dafd48372c03945b5907c" alt="">  </p>
<p>根据上图，我们可以来探讨一下从CA获取安全证书的过程：  </p>
<ol>
<li><strong>联系CA</strong>：想要接收安全消息的个体会联系本地CA来获取一对公私钥  </li>
<li><strong>身份确认</strong>：CA需要确认个体的身份，这可能涉及多种身份验证方法</li>
<li><strong>提供公钥</strong>：当身份确认通过后，个体需要将他们的公钥提供给CA</li>
<li><strong>创建数字证书</strong>：提交后，CA会创建一个数字证书，并将该个体的公钥写入该文档。此证书作为一种形式的身份证的公钥</li>
<li><strong>添加数字签名</strong>：随后CA会使用自己的私钥加密数字证书，并对其添加数字签名</li>
<li><strong>接收数字证书</strong>：然后CA将数字证书发送给该个体</li>
<li><strong>发布数字证书</strong>：该个体就可以将数字证书发布在网站或其他可访问的位置。现在，任何想要发送加密消息给该个体的人都可以在数字证书中找到他们的认证公钥</li>
</ol>
<p>这个过程可以确保当有人使用该个体的公钥向他们发送加密消息时，他们可以确信该密钥确实属于该个体，并且没有被篡改。  </p>
<p><br></p>
<hr>
<h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a><strong>对称密钥加密</strong></h2><p>多年来，数据加密标准(DES)一直是对称密钥加密的正常选择。当DES的弱点成为一个问题时，Triple DES取代了它。<br>2001年，高级加密标准(AES)作为一种优越的方法被引入。出于教育目的，我们在本章之探讨相对较简单的<strong>简化数据加密标准 (Simplified DES, S-DES)</strong>，以便更好地理解在加密中执行的各种操作。  </p>
<p>S-DES实际上是一种分组密码，这意味着它以比特为单位对数据进行加密。在S-DES中，它操作以8位构成的“块”。<br>这个过程从一个10位的密钥开始。S-DES的第一步是从原来的10位密钥创建两个8位密钥。这是通过一系列的置换(位的重新排序)和移位来实现的。<br>简单简述一下步骤：  </p>
<ol>
<li><strong>置换 (Permutation)</strong>：10位的密钥首先根据预定义的置换规则进行置换(重排)</li>
<li><strong>拆分 (Splitting)</strong>：置换后的内容被拆分为两部分</li>
<li><strong>移位 (Shifts)</strong>：每一半都要经历一系列的左移</li>
<li><strong>二次置换 (Second permutation)</strong>：移位后，将两部分合并，再进行一次置换来生成第一个8位的密钥</li>
<li><strong>更多的移位</strong>：如题，更多的移位</li>
<li><strong>最终置换 (Final permutation)</strong>：在经过这些移位步骤后，将这两部分再次组合，并进行另一次置换以生成第二个8位密钥  </li>
</ol>
<p>举一个置换过程例子吧：  </p>
<p>我们有一个10为的密钥：<code>0101010101</code>，而且定义好的置换规则为<code>35274101986</code><br>将这种排列规则应用于密钥意味着按照规则指定的位置重新排列键中的位：<br>在这种置换规则的情况下，表示：置换后的密钥的第一个位置是原始密钥的第3位，第二个位置是原始密钥的第5位，以此类推。<br>之后的置换过程就是这样继续循环下去了。  </p>
</div><div class="article-licensing box"><div class="licensing-title"><p>A2CS笔记</p><p><a href="http://naughtychas.github.io/2023/07/01/A2CS笔记/">http://naughtychas.github.io/2023/07/01/A2CS笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://NaughtyChas.github.io"><p>MXK</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-07-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-10-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/" target="_blank" rel="noreferrer">邈想日集</a><br></span><span>  2.<a class="is-size-6" href="/2022/08/24/Latex%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">LaTeX自学笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span><span>  5.<a class="is-size-6" href="/2023/06/10/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noreferrer">有关深度学习</a><br></span><span>  6.<a class="is-size-6" href="/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/" target="_blank" rel="noreferrer">浅谈今年CAIE的POE考试</a><br></span></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/06/10/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-item">有关深度学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'f4fef354d440d79d973c2bf25f8e464b',
            repo: 'Blog-Comment',
            owner: 'NaughtyChas',
            clientID: 'b602cb01d4c2668b35ae',
            clientSecret: '0a26ed5993551a9754281410ba3aa5f772dfbdf2',
            admin: ["NaughtyChas"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            proxy: 'https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1</span><span>写在前面</span></a></li><li><a class="is-flex is-mobile" href="#PART-THREE-进阶理论"><span class="mr-2">2</span><span>PART THREE: 进阶理论</span></a></li><li><a class="is-flex is-mobile" href="#第十六章：数据的表示"><span class="mr-2">3</span><span>第十六章：数据的表示</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数据类型"><span class="mr-2">3.1</span><span>数据类型</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#内置数据类型"><span class="mr-2">3.1.1</span><span>内置数据类型</span></a></li><li><a class="is-flex is-mobile" href="#用户定义的数据类型"><span class="mr-2">3.1.2</span><span>用户定义的数据类型</span></a></li><li><a class="is-flex is-mobile" href="#非复合数据类型"><span class="mr-2">3.1.3</span><span>非复合数据类型</span></a></li><li><a class="is-flex is-mobile" href="#枚举数据类型"><span class="mr-2">3.1.4</span><span>枚举数据类型</span></a></li><li><a class="is-flex is-mobile" href="#复合用户定义数据类型"><span class="mr-2">3.1.5</span><span>复合用户定义数据类型</span></a></li><li><a class="is-flex is-mobile" href="#指针数据类型"><span class="mr-2">3.1.6</span><span>指针数据类型</span></a></li><li><a class="is-flex is-mobile" href="#集合数据类型"><span class="mr-2">3.1.7</span><span>集合数据类型</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文件管理"><span class="mr-2">3.2</span><span>文件管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#串行文件"><span class="mr-2">3.2.1</span><span>串行文件</span></a></li><li><a class="is-flex is-mobile" href="#顺序文件"><span class="mr-2">3.2.2</span><span>顺序文件</span></a></li><li><a class="is-flex is-mobile" href="#直接访问文件"><span class="mr-2">3.2.3</span><span>直接访问文件</span></a></li><li><a class="is-flex is-mobile" href="#文件访问"><span class="mr-2">3.2.4</span><span>文件访问</span></a></li><li><a class="is-flex is-mobile" href="#文件类型的选择"><span class="mr-2">3.2.5</span><span>文件类型的选择</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#实数"><span class="mr-2">3.3</span><span>实数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#浮点-amp-定点表示法"><span class="mr-2">3.3.1</span><span>浮点&amp;定点表示法</span></a></li><li><a class="is-flex is-mobile" href="#精度与标准化"><span class="mr-2">3.3.2</span><span>精度与标准化</span></a></li><li><a class="is-flex is-mobile" href="#表示法的转换"><span class="mr-2">3.3.3</span><span>表示法的转换</span></a></li><li><a class="is-flex is-mobile" href="#使用浮点数的问题"><span class="mr-2">3.3.4</span><span>使用浮点数的问题</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第十七章：通讯及互联网技术"><span class="mr-2">4</span><span>第十七章：通讯及互联网技术</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#传输方式"><span class="mr-2">4.1</span><span>传输方式</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#电路交换"><span class="mr-2">4.1.1</span><span>电路交换</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#分组交换"><span class="mr-2">4.2</span><span>分组交换</span></a></li><li><a class="is-flex is-mobile" href="#传输协议"><span class="mr-2">4.3</span><span>传输协议</span></a></li><li><a class="is-flex is-mobile" href="#协议栈"><span class="mr-2">4.4</span><span>协议栈</span></a></li><li><a class="is-flex is-mobile" href="#TCP-IP-协议套件"><span class="mr-2">4.5</span><span>TCP/IP 协议套件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#TCP-传输控制协议"><span class="mr-2">4.5.1</span><span>TCP (传输控制协议)</span></a></li><li><a class="is-flex is-mobile" href="#IP-互联网协议"><span class="mr-2">4.5.2</span><span>IP (互联网协议)</span></a></li><li><a class="is-flex is-mobile" href="#路由器"><span class="mr-2">4.5.3</span><span>路由器</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#以太网-Ethernet-协议栈"><span class="mr-2">4.6</span><span>以太网(Ethernet)协议栈</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#MAC地址"><span class="mr-2">4.6.1</span><span>MAC地址</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#与TCP-IP有关的应用层协议"><span class="mr-2">4.7</span><span>与TCP/IP有关的应用层协议</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#HTTP-HyperText-Transfer-Protocol"><span class="mr-2">4.7.1</span><span>HTTP (HyperText Transfer Protocol)</span></a></li><li><a class="is-flex is-mobile" href="#电子邮件协议"><span class="mr-2">4.7.2</span><span>电子邮件协议</span></a></li><li><a class="is-flex is-mobile" href="#FTP-文件传输协议"><span class="mr-2">4.7.3</span><span>FTP (文件传输协议)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#P2P文件共享"><span class="mr-2">4.8</span><span>P2P文件共享</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十八章：硬件与虚拟机"><span class="mr-2">5</span><span>第十八章：硬件与虚拟机</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#控制单元"><span class="mr-2">5.1</span><span>控制单元</span></a></li><li><a class="is-flex is-mobile" href="#CISC和RISC处理器"><span class="mr-2">5.2</span><span>CISC和RISC处理器</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#流水线作业-Pipelining"><span class="mr-2">5.2.1</span><span>流水线作业 (Pipelining)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#基本计算机架构"><span class="mr-2">5.3</span><span>基本计算机架构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#单指令流单数据流-SISD"><span class="mr-2">5.3.1</span><span>单指令流单数据流 (SISD)</span></a></li><li><a class="is-flex is-mobile" href="#单指令流多数据流-SIMD"><span class="mr-2">5.3.2</span><span>单指令流多数据流 (SIMD)</span></a></li><li><a class="is-flex is-mobile" href="#多指令流单数据流-MISD"><span class="mr-2">5.3.3</span><span>多指令流单数据流 (MISD)</span></a></li><li><a class="is-flex is-mobile" href="#多指令流多数据流-MIMD"><span class="mr-2">5.3.4</span><span>多指令流多数据流 (MIMD)</span></a></li><li><a class="is-flex is-mobile" href="#大规模并行计算机系统"><span class="mr-2">5.3.5</span><span>大规模并行计算机系统</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#虚拟机"><span class="mr-2">5.4</span><span>虚拟机</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十九章：逻辑门与布尔代数"><span class="mr-2">6</span><span>第十九章：逻辑门与布尔代数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#逻辑电路"><span class="mr-2">6.1</span><span>逻辑电路</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#半加法器-The-half-adder"><span class="mr-2">6.1.1</span><span>半加法器 (The half adder)</span></a></li><li><a class="is-flex is-mobile" href="#全加法器-The-full-adder"><span class="mr-2">6.1.2</span><span>全加法器 (The full adder)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#时序电路"><span class="mr-2">6.2</span><span>时序电路</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#SR-触发器-SR-Flip-flop"><span class="mr-2">6.2.1</span><span>SR 触发器 (SR Flip-flop)</span></a></li><li><a class="is-flex is-mobile" href="#JK-触发器-JK-Flip-flop"><span class="mr-2">6.2.2</span><span>JK 触发器 (JK Flip-flop)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#布尔代数基础"><span class="mr-2">6.3</span><span>布尔代数基础</span></a></li><li><a class="is-flex is-mobile" href="#布尔代数运用"><span class="mr-2">6.4</span><span>布尔代数运用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#从真值表中创建布尔表达式"><span class="mr-2">6.4.1</span><span>从真值表中创建布尔表达式</span></a></li><li><a class="is-flex is-mobile" href="#逻辑电路的布尔代数式"><span class="mr-2">6.4.2</span><span>逻辑电路的布尔代数式</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#卡诺图-Karnaugh-map"><span class="mr-2">6.5</span><span>卡诺图 (Karnaugh map)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第二十章：系统软件"><span class="mr-2">7</span><span>第二十章：系统软件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#操作系统的目的"><span class="mr-2">7.1</span><span>操作系统的目的</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#操作系统结构"><span class="mr-2">7.1.1</span><span>操作系统结构</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#输入-输出系统-I-O"><span class="mr-2">7.2</span><span>输入/输出系统 (I/O)</span></a></li><li><a class="is-flex is-mobile" href="#进程调度"><span class="mr-2">7.3</span><span>进程调度</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#进程状态"><span class="mr-2">7.3.1</span><span>进程状态</span></a></li><li><a class="is-flex is-mobile" href="#中断"><span class="mr-2">7.3.2</span><span>中断</span></a></li><li><a class="is-flex is-mobile" href="#调度算法"><span class="mr-2">7.3.3</span><span>调度算法</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#内存管理"><span class="mr-2">7.4</span><span>内存管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#分区与段"><span class="mr-2">7.4.1</span><span>分区与段</span></a></li><li><a class="is-flex is-mobile" href="#分页与虚拟内存"><span class="mr-2">7.4.2</span><span>分页与虚拟内存</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#提供给用户的操作系统设施"><span class="mr-2">7.5</span><span>提供给用户的操作系统设施</span></a></li><li><a class="is-flex is-mobile" href="#转译软件"><span class="mr-2">7.6</span><span>转译软件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#前端分析阶段"><span class="mr-2">7.6.1</span><span>前端分析阶段</span></a></li><li><a class="is-flex is-mobile" href="#语言的语法表示"><span class="mr-2">7.6.2</span><span>语言的语法表示</span></a></li><li><a class="is-flex is-mobile" href="#后端合成阶段"><span class="mr-2">7.6.3</span><span>后端合成阶段</span></a></li><li><a class="is-flex is-mobile" href="#表达式的求值"><span class="mr-2">7.6.4</span><span>表达式的求值</span></a></li><li><a class="is-flex is-mobile" href="#计算RPN表达式"><span class="mr-2">7.6.5</span><span>计算RPN表达式</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第二十一章：数据安全"><span class="mr-2">8</span><span>第二十一章：数据安全</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#加密原理"><span class="mr-2">8.1</span><span>加密原理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#安全问题"><span class="mr-2">8.1.1</span><span>安全问题</span></a></li><li><a class="is-flex is-mobile" href="#加密方法"><span class="mr-2">8.1.2</span><span>加密方法</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#数字签名与电子证书"><span class="mr-2">8.2</span><span>数字签名与电子证书</span></a></li><li><a class="is-flex is-mobile" href="#对称密钥加密"><span class="mr-2">8.3</span><span>对称密钥加密</span></a></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a><p class="size-small"><span>&copy; 2023 MXK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noreferrer">Icarus</a> &amp; <a href="https://github.com/LittleYe233/hexo-theme-amazingremake" target="_blank" rel="noreferrer">Amazing-Remake</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022.8.11 17:07:12')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/LittleYe233/hexo-theme-amazingremake"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    enabled: true,
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { // 加载mathjax
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    autoload: {
                        color: [],
                        colorv2: ['color']
                    },
                    packages: {'[+]': ['noerrors']}
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                },
                loader: {
                    load: ['input/asciimath', '[tex]/noerrors']
                }
            };
            $.getScript('//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);});
            }
            if('undefined' === 'mathjax'){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>