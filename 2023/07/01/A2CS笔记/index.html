<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>A2CS笔记 - ntcs&#039; blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ntcs&#039; blog"><meta name="msapplication-TileImage" content="img/icon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ntcs&#039; blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="CS课堂笔记 (A2)"><meta property="og:type" content="article"><meta property="og:title" content="A2CS笔记"><meta property="og:url" content="http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="ntcs&#039; blog"><meta property="og:description" content="CS课堂笔记 (A2)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><meta property="article:published_time" content="2023-07-01T09:18:28.000Z"><meta property="article:modified_time" content="2023-10-11T02:11:48.747Z"><meta property="article:author" content="MXK"><meta property="article:tag" content="笔记"><meta property="article:tag" content="CIE"><meta property="article:tag" content="计算机"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"},"headline":"ntcs' blog","image":["http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"],"datePublished":"2023-07-01T09:18:28.000Z","dateModified":"2023-10-11T02:11:48.747Z","author":{"@type":"Person","name":"MXK"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"CS课堂笔记 (A2)"}</script><link rel="canonical" href="http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/icon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="ntcs' blog" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/thumbnails/CS.jpg" alt="A2CS笔记"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-07-01  <a class="commentCountImg" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">f4fef354d440d79d973c2bf25f8e464b</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f4fef354d440d79d973c2bf25f8e464b">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>7 小时  <i class="fas fa-pencil-alt"> </i>58.8 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">A2CS笔记</h1><div class="content"><blockquote>
<p>CS课堂笔记 (A2)<br><span id="more"></span></p>
</blockquote>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h1><p>学了一段时间的计算机，觉得继续写这些笔记还是蛮有用的，于是乎就打算继续下去。<br>这次是A2阶段的计算机笔记。<br>和AS部分一样，写下本文的目的是帮助自己更好地学习CS这门科目，因此，希望路过的大佬轻喷。  </p>
<hr>
<p>本笔记内容基于《Computer Science for Cambridge International AS &amp; A Level》，剑桥大学出版社出版，教材为第二版，A-Level课程编号为<code>9618</code>。  </p>
<hr>
<h1 id="PART-THREE-进阶理论"><a href="#PART-THREE-进阶理论" class="headerlink" title="PART THREE: 进阶理论"></a><strong>PART THREE: 进阶理论</strong></h1><h1 id="第十六章：数据的表示"><a href="#第十六章：数据的表示" class="headerlink" title="第十六章：数据的表示"></a><strong>第十六章：数据的表示</strong></h1><p>崭新的故事从第十六章继续开始了。  </p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>早在第13章我们介绍过变量的数据类型的概念。具体是：当一个程序在使用变量之前，必须要显示别该变量的数据类型。  </p>
<p>当时介绍了一些最常用的数据类型，但是在本章我们将会接触一些更深入的数据类型。  </p>
<p><br></p>
<h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a><strong>内置数据类型</strong></h3><p><strong>内置数据类型 (Built-in data types)</strong>，顾名思义，就是已经默认集成在编译器中的数据类型，是<strong>被编程语言预先定义的数据类型</strong>。一般来说，这些数据类型被认为成执行数据操作最快的类型。  </p>
<p>比如说在Python里面，内置数据类型就有这些：str, int, float等。  </p>
<p>这些数据类型具体的操作，值分配的操作全部由编程语言定义。  </p>
<p><br></p>
<hr>
<h3 id="用户定义的数据类型"><a href="#用户定义的数据类型" class="headerlink" title="用户定义的数据类型"></a><strong>用户定义的数据类型</strong></h3><p>和内置数据类型相对立的，就是可以由用户定义的数据类型。</p>
<p>一般来说，“用户”通常是使用操作系统提供“用户界面”的人：“用户”是向正在运行的程序提供输入并从其接收输出的人。然而在编写程序时，程序员就成为了编程语言所指的“用户”。名词 <strong>用户定义的数据类型(User-defined data types)</strong> 中的“用户”就是指程序员们。  </p>
<p>这种数据类型是由用户在程序中根据需要所定义的，以便根据幼存储相同或者不同类型的数据类型。  </p>
<p>尽管用户定义的数据类型不是内置数据类型，但是只有在编程语言提供对该类型构造的支持情况下，才可以使用某种特定的用户定义数据类型。  </p>
<article class="message is-info"><div class="message-body">

<b>User-defined data type: where the programmer includes the definition in the program.</b>

</div></article> 


<p><br></p>
<hr>
<h3 id="非复合数据类型"><a href="#非复合数据类型" class="headerlink" title="非复合数据类型"></a><strong>非复合数据类型</strong></h3><p><strong>非复合数据类型 (Non-composite data types)</strong> 是不引用其他数据类型的数据类型。也就是说，这些数据类型的定义没有用到其他的数据类型。  </p>
<p>某些用户定义的数据类型也有可能是非符合的数据类型。  </p>
<article class="message is-info"><div class="message-body">

<b>Non-composite data type: a data type defined without reference to another data type.</b>

</div></article> 



<p><br></p>
<hr>
<h3 id="枚举数据类型"><a href="#枚举数据类型" class="headerlink" title="枚举数据类型"></a><strong>枚举数据类型</strong></h3><p><strong>枚举数据类型 (Enumerated data type)</strong>是用户定义的数据类型，它是根据有序值列表定义的。 </p>
<p>同时，它是一种非复合数据类型。</p>
<p>简单举一个例子就很好理解了：这里使用Python来定义一个数据类型<code>Color</code>:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    RED = <span class="number">1</span></span><br><span class="line">    GREEN = <span class="number">2</span></span><br><span class="line">    BLUE = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Color.RED)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行了<code>print(Color.RED)</code>之后，会输出<code>1</code>。因为<code>RED</code>定义的值正好为<code>1</code>。  </p>
<p>我们通过上面的代码定义了一个名叫<code>Color</code>的枚举数据类型，其中包含三个值：<code>RED</code>,<code>GREEN</code>和<code>BLUE</code>。  </p>
<p>需要注意的是，枚举数据类型中定义的值是有序的，这意味着枚举数据类型具有隐含的值顺序。</p>
<article class="message is-info"><div class="message-body">

<b>Enumerated data type: a non-composite user-defined data type for which the definition identifies all possible values.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="复合用户定义数据类型"><a href="#复合用户定义数据类型" class="headerlink" title="复合用户定义数据类型"></a><strong>复合用户定义数据类型</strong></h3><p>开始变复杂了。  </p>
<p><strong>复合用户定义数据类型 (Composite user-defined data types)</strong>具有引用至少一种其他类型的定义。  </p>
<p>复合用户定义数据类型有两个非常重要的实例：  </p>
<ol>
<li><p>在第十三章介绍过的<strong>记录数据类型 (Record data type)</strong>是描述值和变量的数据类型。这是程序员定义的数据类型，允许程序员定义新的记录类型。这允许程序员们使用精确匹配特定程序的数据要求的组件来创建并记录数据类型。Python不支持这样的数据类型。  </p>
</li>
<li><p><strong>类 (Class)</strong>是面向对象编程中用于对象的数据类型。换句话说，类是创建对象(或者特定数据结构)，提供窗台初始值，以及行为实现的蓝图。  </p>
</li>
</ol>
<p>下面的代码就是在Python中的一个类：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"Hello, my name is <span class="subst">{self.name}</span> and I am <span class="subst">{self.age}</span> years old."</span>)</span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">"John"</span>, <span class="number">25</span>)</span><br><span class="line">person.say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们定义了一个名叫<code>Person</code>的类，其中包含两个子变量：<code>name</code>和<code>age</code>，和一个子函数<code>say_hello()</code>。  </p>
<p><br></p>
<hr>
<h3 id="指针数据类型"><a href="#指针数据类型" class="headerlink" title="指针数据类型"></a><strong>指针数据类型</strong></h3><p>在计算机编程中，<strong>指针 (Pointer)</strong>是一个存储另一个变量的内存地址的变量。<strong>指针数据类型 (Pointer data type)</strong>是用于声明指针变量的数据类型。  </p>
<p>在AS部分学的链表(Linked list)<strong>不是</strong>一个指针数据类型。因为链表是一种包含指向其他节点的指针的数据结构。不是指针数据类型的原因是它存储的不是内存地址的变量。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>学学伪代码：  </p>
<p>当需要使用指针的时候，就可以使用这个符号声明：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TYPE</span><br><span class="line">TIntegerPointer ← ^Integer</span><br></pre></td></tr></table></figure>
<p>定义了<code>TIntegerPointer</code>的数据类型是整形的指针。  </p>
<p>我们也可以这么写：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE MyIntegerPointer : TIntegerPointer</span><br></pre></td></tr></table></figure>
<p>这是一个不需要使用插入符 (^) 的方法。  </p>
<p><br></p>
<p><br></p>
<p>接下来我们来定义一些数据：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE Number1, Number2 : INTEGER</span><br><span class="line">Number1 ← 100</span><br><span class="line"></span><br><span class="line">MyIntegerPointer ← @Number1</span><br></pre></td></tr></table></figure>
<p>最后一行代码向指针变量赋了值。变量<code>MyIntegerPointer</code>现在存储着<code>Number1</code>的地址。   </p>
<p>然后我们可以使用下面的这种方法为<code>Number2</code>赋予一个<code>200</code>的值：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number2 ← MyIntegerPointer^ * 2</span><br></pre></td></tr></table></figure>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Pointer variable: one for which the value is the address in memory of a different variable.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="集合数据类型"><a href="#集合数据类型" class="headerlink" title="集合数据类型"></a><strong>集合数据类型</strong></h3><p>计算机科学中也存在集合的定义：<strong>集合是一种抽象数据类型，可以存储某些值，没有任何特定的顺序，并且没有重复的值。</strong>  </p>
<p><strong>集合数据类型 (Set data type)</strong>与大多数其他集合类型不同，通常不是从集合中检索特定元素，而是测试集合中的成员资格值，可以说是将一整个整体来进行处理(?)</p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Set: a collection of data items that lacks any structure;contains no duplicates and has a number of defined operations that can be performed on it.</b>

</div></article> 

<p><br></p>
<p>常用的操作有这些：  </p>
<ul>
<li>检查集合中是否存在某个值</li>
<li>添加新的数据值</li>
<li>删除现有的数据值</li>
<li>将一个集合添加到另一个集合当中</li>
</ul>
<p><br></p>
<hr>
<p>Python的其中一个亮点就和集合数据类型有关。在Python中，处理集合数据类型十分方便。  </p>
<p>下面是在Python中操作集合数据类型的一些实例：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个集合</span></span><br><span class="line">my_set = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向集合中添加一个值</span></span><br><span class="line">my_set.add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合中剔除一个值</span></span><br><span class="line">my_set.remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查值是否在集合内</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> <span class="keyword">in</span> my_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2 is in the set"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- 华丽的分割线 ------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个集合</span></span><br><span class="line">set1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">set2 = {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的并集</span></span><br><span class="line">union_set = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(union_set) <span class="comment"># 输出为: {1, 2, 3, 4, 5}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的交集</span></span><br><span class="line">intersection_set = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(intersection_set) <span class="comment"># 输出为: {3}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的差</span></span><br><span class="line">difference_set = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(difference_set) <span class="comment"># 输出为: {1, 2}</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h2><p>在日常计算机使用中，会遇到各种各样的文件类型，例如图形文件、文字处理文件、电子表格文件等。<br>无论文件类型如何，内容都使用特定的二进制代码存储，从而保证文件的正常使用。  </p>
<p>这里就出现了新东西：<strong>二进制文件 (Binary file)</strong>和<strong>记录 (Record)</strong>  </p>
<p>二进制文件是包含二进制格式信息的文件，二进制格式是 0 和 1 的序列。二进制文件用于以计算机可以读取但人类不易理解的格式存储数据。二进制文件的示例包括可执行文件、图像文件和音频文件。</p>
<p>记录是一种包含一个或多个字段的数据结构，每个字段包含一条数据。记录用于以易于访问和操作的方式存储和组织数据。在计算机科学中，记录通常用于表示数据库和其他数据存储系统中的数据。</p>
<article class="message is-info"><div class="message-body">

<b>Binary file: a file designed for storing data to be used by a computer program.</b>

<br>

<b>Record: a collection of fields containing data values.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="串行文件"><a href="#串行文件" class="headerlink" title="串行文件"></a><strong>串行文件</strong></h3><p><strong>串行文件 (Serial file)</strong>是一种包含信息的文件类型，<strong>信息按其发生的顺序记录在文件中。</strong>  </p>
<p>它还可以用来记录文件信息。在这种情况下，文件信息将按照它们在串行文件中保存的顺序列出。所以说：信息或文件基本上是按时间顺序记录的。  </p>
<p><br></p>
<hr>
<h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a><strong>顺序文件</strong></h3><p><strong>顺序文件 (Sequential files)</strong>是根据某些键值排序的文件。顺序文件主要用于文件命中率较高的应用场景中。 <em>#文件命中率衡量计算机系统或程序性能的重要参数,它可以反应计算机在访问存储器时的效率。</em>  </p>
<p>顺序文件的一个示例是包含有关公司员工信息的文件。<br>该文件可以根据员工的姓氏进行排序，以便将具有相同姓氏的所有员工分组在一起。这将使根据姓氏搜索员工变得更加容易。</p>
<p><br></p>
<hr>
<h3 id="直接访问文件"><a href="#直接访问文件" class="headerlink" title="直接访问文件"></a><strong>直接访问文件</strong></h3><p><strong>直接访问文件 (Direct-access file)</strong> 有时候也被称之为<strong>随机访问文件 (Random-access files)</strong>。和内存一样，随机性表明我们可以访问文件中的任何记录，或者在任何位置写入内容，而无需按照顺序依行读取文件。在使用这种文件时，我们可以直接访问文件的某个区块。  </p>
<p><br></p>
<p>另一种方法是在将记录输入直接访问文件时使用散列算法。</p>
<p>如果每条记录中有一个数字关键字段，则可以使用一种简单的哈希算法。<br>该算法选择一个合适的数字并将该数字除以关键字段中的值。 然后，该除法的余数标识文件中用于存储该记录的地址。<br>如果合适的数字是与文件的预期大小相似的质数，则效果最佳。</p>
<p>我们举一个简单的计算例子：我们使用关键字段中的 4 位值来说明文件中的地址，其中 1000 用于除数。 以下代表三种计算，其中余数代表地址：  </p>
<p>0045 / 1000 余数为45<br>2005 / 1000 余数为5<br>3000 / 1000 余数为5</p>
<p>从这些计算中可以看出两个事实。<br>第一个事实是，计算出的地址没有任何顺序，具体取决于关键字段中的值。<br>第二个事实是，不同的关键字段值可以产生相同的余数，因此在文件中产生相同的地址。</p>
<p>正因为相同的地址可能产生，所以当同一个地址被使用的时候，可能会发生冲突。<br>哈希算法的职责是尽可能平均地分配地址，从而最大限度地减少冲突的可能性。  </p>
<p>但是哈希算法也不是万能的，无论再怎么平均分配，冲突必定出现。所以说如果冲突出现，我们有以下这些解决方案：  </p>
<ul>
<li>使用顺序搜索来查找计算出的地址后是否有空闲地址。</li>
<li>在文件末尾保留一些溢出地址。</li>
<li>创建一个可以从每个地址访问的链接列表。</li>
</ul>
<p><br></p>
<hr>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a><strong>文件访问</strong></h3><p>一旦我们选择了文件组织，并将文件中注入了数据，我们就需要考虑下如何使用这些文件，如何访问这些数据。  </p>
<p>对于<strong>串行文件</strong>来说，正常的方法是逐条读取文件。但是说如果需要再其中的一个字段中搜索特定的一个值，唯一的办法就是从头开始读取记录，直到我们找到了我们的目标。  </p>
<p>如果我们需要在<strong>顺序文件</strong>寻找特定值的话，可能也需要像串行文件一样进行搜索。但是，如果我们已知包含所需数据的关键字段，那么直接读取关键字段就可以了。  </p>
<p><strong>直接访问文件</strong>的话，首先需要将关键字段的值提供给哈希算法进行计算。</p>
<p><br></p>
<hr>
<h3 id="文件类型的选择"><a href="#文件类型的选择" class="headerlink" title="文件类型的选择"></a><strong>文件类型的选择</strong></h3><p><strong>串行文件</strong>特别适合批处理或者备份磁带上的数据，因为串行文件中的数据是与时间相关的。  </p>
<p>如果我们需要快速访问一个大文件中的单个记录，就需要使用<strong>直接访问文件</strong>。比如说需要登录一个具有许多用户的系统，在这种情况下，用户登录时用于检查密码的文件就应该是直接访问的。  </p>
<p><strong>顺序文件</strong>特别适用与从文件的一次搜索中获得多个记录的应用程序。一个例子是家谱：我们可以对所有特定家族名称的所有记录进行搜索。  </p>
<p><br></p>
<hr>
<h2 id="实数"><a href="#实数" class="headerlink" title="实数"></a><strong>实数</strong></h2><p>在计算机中，实数是带有小数部分的数。  </p>
<p>当我们在一个二进制系统中写下一个实数的值，并需要存储下来的话，我们有多个选择：我们可以选择简单的表示法，也可以使用指数表示法(科学计数法)。  </p>
<p>比如说，数字’25.3’可以写成：  </p>
<p>       <code>.253 * 10^2</code> 或 <code>2.53 * 10^1</code> 或 <code>25.3 * 10^0</code> 或 <code>253 * 10^-1</code></p>
<p>就对于’25.3’来说，直接表达是最好的存储方案。<br>但如果数字非常大或非常小，就需要尽可能地使用科学计数法。  </p>
<p><br></p>
<hr>
<h3 id="浮点-amp-定点表示法"><a href="#浮点-amp-定点表示法" class="headerlink" title="浮点&定点表示法"></a><strong>浮点&amp;定点表示法</strong></h3><p>在计算机系统中，我们只能是有二进制码来存储实数。其中的一种方法就是使用<strong>定点表示法 (Fixed-point representation)</strong>。  </p>
<p>在定点表示法中，首先需要确定总位数。其中总位数中的一部分位来表示整数部分，其余的位表示小数部分。  </p>
<p>另一种方法就是使用<strong>浮点表示法 (Floating-point representation)</strong>。所有使用浮数都可以改写成下面这种形式：  </p>
<p>         <code>±M × R^E</code></p>
<p>其中，有效的位数由<code>±M</code>表示，我们叫做<strong>尾数 (Mantissa)</strong>。<code>E</code>表示指数。浮点数中的 “指数 “并不代表原数的整数部分。相反，它表示在确定浮点表示数的值时，基数（在计算机系统中通常为 2）所升高的整数幂。  </p>
<p>一般来说基数<code>R</code>不会存储进这个浮点数内，因为<code>R</code>有一个隐含值“2”。具体原因是我们在使用二进制表示数字时逢2进一。    </p>
<article class="message is-info"><div class="message-body">

<b>Floating-point representation: a representation of real numbers that stores a value for the mantissa and a value for the exponent.</b>

</div></article> 

<p><br></p>
<p><em>p.s. mantissa是尾数的意思。</em></p>
<p><br></p>
<hr>
<p>我们来举例子了解一下两种表示法之间的区别：  </p>
<p>对于定点表示法来说，在一个字节内，我们可以使用最高的有效位作为符号位，然后再使用接下来的五位表示整数部分。这就会为小数部分的表示留下两个位。  </p>
<p>下表给出了一些比较重要的非零值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:center">二进制码</th>
<th style="text-align:center">(对应的)十进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">最大的正值</td>
<td style="text-align:center"><code>011111 11</code></td>
<td style="text-align:center">31.75</td>
</tr>
<tr>
<td style="text-align:left">最小的正值</td>
<td style="text-align:center"><code>000000 01</code></td>
<td style="text-align:center">0.25</td>
</tr>
<tr>
<td style="text-align:left">绝对值最小的负值</td>
<td style="text-align:center"><code>100000 01</code></td>
<td style="text-align:center">-0.25</td>
</tr>
<tr>
<td style="text-align:left">绝对值最大的负值</td>
<td style="text-align:center"><code>111111 11</code></td>
<td style="text-align:center">-31.75</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>浮点表示法的话，我们可以使用4个位来表示尾数，然后再使用另外的4位表示指数。每一个位都使用2的补码来表示。<br>其中，指数存储为有符号的整数，尾数存储为定点实数。  </p>
<p>那么我们应该如何确定哪一位是二进制点。</p>
<p>下面的表格给出了使用4位来表示尾数的两个选项：<br>在每种情况下，我们都选择了等价的二进制点，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>011 1</code></td>
<td style="text-align:center"><code>3.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>011 0</code></td>
<td style="text-align:center"><code>3.0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>010 1</code></td>
<td style="text-align:center"><code>2.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>101 0</code></td>
<td style="text-align:center"><code>-3.0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>100 1</code></td>
<td style="text-align:center"><code>-3.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>100 0</code></td>
<td style="text-align:center"><code>-4.0</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0 111</code></td>
<td style="text-align:center"><code>0.875</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0 110</code></td>
<td style="text-align:center"><code>0.75</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0 101</code></td>
<td style="text-align:center"><code>0.625</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 010</code></td>
<td style="text-align:center"><code>-0.75</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 001</code></td>
<td style="text-align:center"><code>-0.875</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 000</code></td>
<td style="text-align:center"><code>-1.0</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0111</code></td>
<td style="text-align:center"><code>7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0110</code></td>
<td style="text-align:center"><code>6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0101</code></td>
<td style="text-align:center"><code>5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1010</code></td>
<td style="text-align:center"><code>-6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1001</code></td>
<td style="text-align:center"><code>-7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1000</code></td>
<td style="text-align:center"><code>-8</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>浮点表示法的特殊值如下表所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:center">二进制码</th>
<th style="text-align:center">(对应的)十进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">最大的正值</td>
<td style="text-align:center"><code>0 111 0111</code></td>
<td style="text-align:center">0.875 × 2^7 = <strong>112</strong></td>
</tr>
<tr>
<td style="text-align:left">最小的正值</td>
<td style="text-align:center"><code>0 001 1000</code></td>
<td style="text-align:center">0.125 × 2^(-8) = <strong>1/2048</strong></td>
</tr>
<tr>
<td style="text-align:left">绝对值最小的负值</td>
<td style="text-align:center"><code>1 111 1000</code></td>
<td style="text-align:center">-0.125 × 2^(-8) = <strong>-1/2048</strong></td>
</tr>
<tr>
<td style="text-align:left">绝对值最大的负值</td>
<td style="text-align:center"><code>1 000 0111</code></td>
<td style="text-align:center">-1 × 2^7 = <strong>-128</strong></td>
</tr>
</tbody>
</table>
</div>
<p><em>p.s. 上课时候有人提出了一个问题：Exponent部分的第一位为什么不是1从而达到最大值？老师的解释是“因为Exponent部分也同样存在符号位，所以最大的正值只能将后三位填充为一。”</em></p>
<p><br></p>
<hr>
<h3 id="精度与标准化"><a href="#精度与标准化" class="headerlink" title="精度与标准化"></a><strong>精度与标准化</strong></h3><p>当使用浮点表示法表示数据时，需要从两个方面着重考虑。  </p>
<p>首先需要决定使用的总位数，然后还要决定分割线的位置 <em>(表示尾数的位数和表示指数的位数之间的分割线)</em>  </p>
<p>然而在我们使用的时候只需要选择使用的总位数就可以了。具体的位数分割就会交给浮点处理器来决定。  </p>
<p>当然这也不代表你没法决定尾数和指数位数的数量了：一般来说，增加尾数位数可以提供更高的精度，但是同样会减少指数位数。如此一来就会减少可以表示的值的范围。  </p>
<p>所以说为了获取最大精度，我们就必须要标准化浮点数。因为<strong>越多的尾数位数代表着更高的精准度</strong>，所以在考虑提升精度时，要尽可能对表示尾数的位数使用多的位数。  </p>
<p><strong>将浮点表示法中的数字标准化意味着选择一个指数，以防止在尾数中出现前导零。</strong>。举个例子：<code>0 1000.11</code>并没有标准化：小数点前面一共有5位。如果想要标准化这一串数据，就要将其变成<code>0.100011</code>。小数点向左移动了四位，因此在此情景中指数为4。</p>
<p><br></p>
<p>我们可以使用八位浮点表示一个数值。因为要表示正数，十进制表示以2进位。<br>比如说：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制表示</th>
<th style="text-align:center">浮点二进制表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0.125 × 2^4</code></td>
<td style="text-align:center"><code>0 001 0100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0.25 × 2^3</code></td>
<td style="text-align:center"><code>0 010 0011</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0.5 × 2^2</code></td>
<td style="text-align:center"><code>0 100 0010</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>表示负数也没有问题。这里用-4作为十进制表示的底数：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制表示</th>
<th style="text-align:center">浮点二进制表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-0.25 × 2^4</code></td>
<td style="text-align:center"><code>1 110 0100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-0.5 × 2^3</code></td>
<td style="text-align:center"><code>1 100 0011</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-1.0 × 2^2</code></td>
<td style="text-align:center"><code>1 000 0010</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="表示法的转换"><a href="#表示法的转换" class="headerlink" title="表示法的转换"></a><strong>表示法的转换</strong></h3><p>在AS部分的第一章，我们讨论了多种将数字转换为不同形式的方法。</p>
<p>先来看定点二进制表示法。举个例子：4.75转换为定点二进制表示法  </p>
<p>打眼一看挺简单的：4可以转换为<code>100</code>，.75转化为二进制的<code>.11</code>，所以4.75的定点二进制表示法大概是<code>100.11</code>。但是别忘了正数的首位需要以0开头。这样的话就只添加一个符号位就可以解决问题了。这样，4.75就可以以定点二进制表示法写成<code>0100.11</code>。  </p>
<p>那么负数怎么办呢？比如说-4.75，就可以先从4.75的表示开始，然后再将它转换成对应的二进制补码：  </p>
<p>     <code>0100.11</code> 转换为： <code>1011.00</code>（一次补码）<br>     <code>1011.01</code>就是-4.75的二次补码。</p>
<p>有关于二次补码的内容，可以去AS部分的第一张扒翻一下。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>转换成浮点就有一些复杂了。在转换之前，我们应该注意：大多数小数部分无法精确地转换为浮点数值。因为二进制小数部分的因数有1/2， 1/4， 1/8， 1/16等等。所以说除非被转换的值正好是这些因数的和，否则无法进行精确的转换。<br>比如说，从0.1到0.9之间的的值中，只有0.5可以被精确的转换。</p>
<p><br></p>
<p>转换正值的方法如下：  </p>
<ol>
<li>使用我们在AS第一章中描述的方法转换整数部分。</li>
<li>添加在开头添加符号位</li>
<li>使用下面的方法转换小数位  </li>
<li>将整数和小数部分组合起来，并将它们输入到分配用于表示尾数的最高有效位中。</li>
<li>用零填充尾数的剩余位和指数的位。</li>
<li>通过改变指数值来调整二进制小数点的位置，以实现归一化的表示。</li>
</ol>
<p><br></p>
<p>第三步提到的方法如下：  </p>
<p>我们试着转化一下8.75：  </p>
<ol>
<li>整数位8转换成<code>1000</code>，然后添加符号位。这样就变成了<code>0 1000</code></li>
<li>小数部分“.75”可以在二进制中表示为<code>.11</code></li>
</ol>
<blockquote>
<p><strong>将小数转换为二进制时，可以将小数部分乘以2，然后观察得到的整数部分和小数部分。</strong>然后再乘以2直到得到的小数部分等于0。稍后需要将每次乘法结果的整数部分写成等价的二进制数。0.75十进制到二进制的答案是0.11。<br><br>小数部分“0.75”的转换步骤大概是：<br><br>1. <code>0.75 * 2 = 1.5</code>，1.5的整数位包含1，因此位数部分的第一位需要写<code>1</code>。<br>2. 去掉刚才的乘积的整数部分，<code>0.5 * 2 = 1.0</code>。1.0的整数部分包含1，因此尾数部分的第一位需要写<code>1</code>。正因为整数位的1减去后，小数位不包含任何信息，所以转换到此结束。<br><br>所以<code>0.75</code>转化过后就是<code>.11</code>。</p>
</blockquote>
<ol>
<li>该组合给出 <code>0 1000.11</code>，其指数值为零。  </li>
<li>移动二进制小数点后，我们得到 <code>0.100011</code>，小数点相比原来向左移动了四位，因此在此情景中指数为4其指数值为十进制的4。  </li>
<li>下一阶段取决于为尾数和指数定义的位数； 如果为尾数分配10位，为指数分配4位，则最终表示为尾数为 <code>0100011000</code>，指数为 <code>0100</code>。</li>
</ol>
<p><br></p>
<hr>
<h3 id="使用浮点数的问题"><a href="#使用浮点数的问题" class="headerlink" title="使用浮点数的问题"></a><strong>使用浮点数的问题</strong></h3><p>如上所述，将十进制实数值转换为二进制表示形式几乎可以保证一定程度的近似。 用于存储尾数的位数也有限制。</p>
<p>浮点数用于<strong>涉及重复计算的扩展数学过程</strong>。 例如，在使用大气数学模型的天气预报中，或在经济预测中。 在这样的编程中，在记录每次计算的结果时存在轻微的近似。<br>如果计算重复足够多次，这些所谓的舍入误差可能会变得很大。 防止错误成为严重问题的唯一方法是通过使用更多的尾数位来提高浮点表示的精度。<br>因此，编程语言提供了以“双精度”或“四精度”工作的选项。</p>
<p>另外，浮点数还可能引发溢出错误条件，因为浮点数能够存储的数字范围有限。</p>
<p><br></p>
<hr>
<h1 id="第十七章：通讯及互联网技术"><a href="#第十七章：通讯及互联网技术" class="headerlink" title="第十七章：通讯及互联网技术"></a><strong>第十七章：通讯及互联网技术</strong></h1><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a><strong>传输方式</strong></h2><p>对于通过互联网进行的通信，有两种可能的方法：<strong>电路交换 (Circuit switching)</strong>或<strong>分组交换 (Packet switching)</strong>。  </p>
<p><br></p>
<hr>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a><strong>电路交换</strong></h3><p>电路交换在传统电话系统中运用的比较广泛。  </p>
<p>电路交换是实现电信网络的一种方法。在这种方法中，两个网络节点通过网络建立专用的通信信道（通过电路），然后才能进行通信。<br>电路的特征决定了信道的带宽，并且这个专用通讯链路会在使用期间一直保持连接。<br>电路交换法师一种面向连接的网络，通过在发送方和接收方之间建立专用路径，提供了有保证的数据传输速率。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB0d939d18b99654b52231aaedd9491e5e?method=download&amp;shareKey=7ca23d690c92033f34eb8055e9f8c426" alt=""></p>
<p><br></p>
<p>通过电路交换传输数据的大致流程如下：  </p>
<ol>
<li>发送方提供预期的接收方的身份信息  </li>
<li>由系统来检查接收方是否准备好接收数据  </li>
<li>如果接收方可以接收数据，那么就会在网络上建立一些连接  </li>
<li>数据随后被传输</li>
<li>移除所有的建立的连接</li>
</ol>
<p>在这种情况下，我们暂时没有必要对电路交换网络中的每个节点进行定义。<br>节点之间的链路师共享传输介质中的专用信道，可以保证传输的畅通无阻、<br>当连接结束后，随着链路的断开，连接也就明确结束了。<br>不过，对于租用线路数据连接而言，可能会建立永久性的连线。  </p>
<p><br></p>
<hr>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><strong>分组交换</strong></h2><p><strong>分组交换 (Packet-switching)</strong>允许我们再不建立电路的情况下进行数据传输。  </p>
<p>数据不能以连续的流的形式发送，相反，数据被打包成一个一个数据包内然后被发送出去。  </p>
<p>数据包由包含传送指令的标头和数据主题构成。这个方法有点像邮政服务发送信件一样，但是要更加复杂。比如说在电路交换那一章的图片仍然可以描述数据包交换，只不过所使用的链路在发送方传输数据包的时候还没有被定义。  </p>
<p>此外，与电路交换传输所需的功能相比，节点将具有更多扩展的功能。我们将会在下面的一个章节中探讨路由器如何充当节点并且支持数据包的发送与接受。  </p>
<p><br></p>
<p>当我们使用分组交换法的时候，网络可以通过两种方式提供服务：<strong>无连接服务 (Connectionless service)</strong> 或者是 <strong>面向连接的服务 (Connection-oriented service)</strong>。  </p>
<p>对于无连接服务来说，我们在发送数据包的时候不知道接收者是否准备好接受数据包，而且我们无法确认数据包是否会传输成功。  </p>
<p>在面向连接的服务中，我们发送第一个数据包的目的是为了确认对方是否能够正常的接受数据包。如果收到了确认的话，那么发送方就会发送更多的数据包。如果没有收到确认，那么发送方就会再次尝试发送第一个数据包来确认状态。  </p>
<p><br></p>
<hr>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a><strong>传输协议</strong></h2><p>网络协议的基本定义很简单：它是一组规则。但问题是这些规则与什么东西有关呢？  </p>
<p>在回答这个问题之前，我们应该明白：我们通常所说的“协议”是指的包含许多单独协议的协议栈，因为网络的复杂性需要我们去制定许多单独的协议。<br>另一个复杂因素是：一个协议可能有许多不同的版本。<br>而且通常有一类协议可以用来补充另一类协议的作用。    </p>
<article class="message is-info"><div class="message-body">

<b>Protocol: a set of rules for data transmission which are agreed by sender and receiver.</b>

</div></article> 

<p><br></p>
<p>任何通过网络传输的通信，都必须在发送方和接收方之间商定一套构成协议的传输规则。<br>在最简单的层面上，协议可以规定成正电压代表比特值为1。协议也可以规定发送方不得超过的传输速度。<br>许多规则与信息的格式或信息的组成部分有关。比如说，定义数据包中前40哥字节的格式。  </p>
<p><br></p>
<hr>
<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a><strong>协议栈</strong></h2><p>对于协议套件而言，协议可以被是认作为协议栈中的层。这一概念设计了多个方面：  </p>
<ul>
<li><p>每一层只能接受上一层或者下一层的输入。  </p>
</li>
<li><p>相邻的层之间有一个明确的界限，这是层与层之间唯一允许的互动。  </p>
</li>
<li><p>一个层由下层的行动提供服务。  </p>
</li>
<li><p>除了最底层之外，各层的功能都是由安装的软件创建的。  </p>
</li>
<li><p>层可以包括子层。  </p>
</li>
<li><p>任何用户交互都将使用与堆栈中最高层相关的协议。  </p>
</li>
<li><p>对于硬件的任何直接访问都仅限于堆栈的最底层。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="TCP-IP-协议套件"><a href="#TCP-IP-协议套件" class="headerlink" title="TCP/IP 协议套件"></a><strong>TCP/IP 协议套件</strong></h2><p>TCP/IP是为支持互联网使用二创建的协议套件。<br>TCP/IP可以根据下图所示的模型来进行解释：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfdae828f6e782a26d5c50baafadfe83a?method=download&amp;shareKey=b16b227c06708c287e7ee21d0263a4cb" alt="">  </p>
<p>不难看出，TCP/IP协议只占用了这个模型的前三层。</p>
<p>图中显示了两个终端系统 （<em>最左边和最右边的两列</em>），并且也显示了这两个系统中相应层之间的逻辑连接。<br>一个应用程序可以在一个终端系统上运行，并与另一个终端系统上运行的应用程序建立直接连接。<br>发送端系统上的应用层协议向同一系统上的传输层协议发送信息，然后传输层协议启动一个进程，将相同的信息传送到接收端系统。<br>在接收端系统上，最后阶段是传输层协议将信息传送给应用层协议。  </p>
<p><br></p>
<p>TCP/IP协议套件由许多子协议组成，包括以下协议：  </p>
<ul>
<li>应用层协议： HTTP SMTP DNS FTP POP3 IMAP</li>
<li>传输层： TCP UDP SCTP IP</li>
<li>网络层： IP IGMP ICMP ARP</li>
</ul>
<p>选择这些协议是为了说明TCP/IP协议套件包含了应用范围非常广泛的协议，而且这些协议仍然在不断地发展。  </p>
<p><br></p>
<hr>
<h3 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP (传输控制协议)"></a><strong>TCP (传输控制协议)</strong></h3><p><strong>传输控制协议 (Transmission Control Protocol, TCP)</strong>是指TCP协议套件中定义的一个协议。它起源于最初的网络实施，是互联网协议（IP）的补充。因此，整个协议套件通常被称为 TCP/IP。  </p>
<p>TCP 是面向连接的。客户端和服务器之间必须先建立连接，然后才能发送数据。<br>在建立连接之前，服务器必须监听（被动开放）客户端的连接请求。<br>三方握手（主动打开）、重传和错误检测增加了可靠性，但延长了延迟。  </p>
<p>（所以如果不需要可靠数据流服务的应用程序可以使用<strong>用户数据报协议 (User Datagram Protocol, UDP)</strong>。它提供的无连接数据报服务优先考虑的是最低延迟，而不是可靠性。）  </p>
<p>TCP 可避免网络拥塞，不过，TCP 也存在漏洞，包括拒绝服务、连接劫持、TCP 否决和重置攻击。  </p>
<p><br></p>
<p>如果在终端系统上运行的应用程序要向不同终端的系统上面发送信息，那么这个应用程序会被收到上面说过的应用层协议所控制。<br>该协议会将用户的数据传送给传输层，然后由传输层运行的TCP协议负责讲信息安全的发送给接收方。  </p>
<p>TCP协议会创建足够的数据包来容纳所有的数据，而且每一个数据包都会由报头和用户数据组成。  </p>
<p><br></p>
<p>除了确保数据的安全传输外，TCP协议还需要确保任何相应都会被引导回应用层级，因此，报文头中的一项内容就是<strong>端口号 (Port number)</strong>。端口号用于标识应用层的协议，比如说，HTTP的端口号就是80。  </p>
<p>数据包还必须包括接收端系统应用层协议的端口号，虽然说TCP不关心接收端的系统地址。  </p>
<p>在一个序列里的数据包会包含一个序列号，目的是为了在数据传输的重点能够正确的按照顺序重新组装数据。  </p>
<p><br></p>
<p>TCP 协议是面向连接的。一旦网络层向传输层返回确认，表明连接已经建立，TCP 就会发送其他数据包并接收包含确认的响应数据包。而且还可以识别并重新发送丢失的数据包。  </p>
<p><br></p>
<hr>
<h3 id="IP-互联网协议"><a href="#IP-互联网协议" class="headerlink" title="IP (互联网协议)"></a><strong>IP (互联网协议)</strong></h3><p><strong>互联网协议 (Internet Protocol)</strong>是一种协议或者一组规则，用于数据包的路由和寻址，使其能够穿越网络到达它要去的目的地。<br>穿越互联网的数据被分为一个个较小的块，我们之前提到过，叫做数据包。每个数据包的报头都附有IP信息，这些信息有助于</p>
<p>在网络层中，IP的是能够确保终端连接互联网的一个重要因素。<br>IP协议从传输层接受数据包，然后添加一个报头。报头包含发送方和接收方的IP地址。要找到接收方的IP地址，很可能需要使用DNS服务来找到与用户数据中提供的URL相对应的地址。  </p>
<p><br></p>
<p>IP数据包通常被叫做“<strong>数据报 (Datagram)</strong>”。它被发送到数据链路层，然后被发送到不同的协议套件中。  </p>
<p>数据链路层会把数据报组装成一个“帧”，然后再进行发送。有关这个“帧”的内容下一章我们会进一步解释。  </p>
<p><br></p>
<p>IP具有无连接服务的功能，一旦发送了数据包，IP无法知道他是不是真正的到达了目的地。如果IP收到了一个包含对先前发送的数据包的确认数据包，那么它只会把该数据包传递给TCP，自己不会了解其中的内容。  </p>
<p><br></p>
<hr>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a><strong>路由器</strong></h3><p>上面的图片显示，数据链路层发送的“帧”在传送之前会到达一个路由器（或者是多个路由器）。在这一阶段，帧的数据报内容会被反馈给IP。现在路由器软件的功能是在传输过程中选择下一个目标主机。  </p>
<p>用白话来说，当数据从一台设备发送到另一台设备时，会被分解成叫做“帧”的微小单元，然后通过网络发送。这些帧首先会被路由器接受，因为路由器是引导网络数据流的设备。<br>路由器检查包含数据报内的帧内容，并使用路由表来确认数据的下一个目的地。<br>路由表是每个路由器特有的，包含数据通过网络的最佳路径等其他信息。一旦路由器确认了下一个目的地，它就会更新数据报中的地址，然后将其传回数据链路层，由数据链路层继续发送。这一过程在每一个路由器上都会重复运行。  </p>
<p><br></p>
<p>作为网络中的一个节点，交换机和路由器的主要区别是在于：当一个帧到达交换机的时候，交换机不做任何的路由操作，而是直接发送数据。交换机在数据链路层运行，但是无法进入网络层。  </p>
<p><br></p>
<hr>
<h2 id="以太网-Ethernet-协议栈"><a href="#以太网-Ethernet-协议栈" class="headerlink" title="以太网(Ethernet)协议栈"></a><strong>以太网(Ethernet)协议栈</strong></h2><p>在AS部分的第二章，我们就已经了解过以太网了。以太网是一套专门为局域网设计的协议，因此它可以在不予互联网或者任何网络连接的本地局域网中运行。<br>但是现在的局域网几乎不可避免地需要与互联网产生链接，所以说局域网的协议套件现在已经添加了对于互联网协议套件的支持。  </p>
<p><br></p>
<p>如果我们仔细查看一个终端系统的协议栈(<em>还是上面的那个图</em>)， 你就会发现TCP/IP协议套件占据了五层协议栈的最上面的三层，因此我们可以说，TCP/IP协议套件得到了下面两层的支持。<br>TCP/IP与这两个较低层的功能无关，它的设计目的是能够得到任何可用协议的支持。  </p>
<p>值得注意的是，有些数据来源只对终端系统使用了4层栈。这种情况下，可能是数据决定只调用完全由软件处理的层，也可能是将TCP/IP的所有支持合并到了同一层中。  </p>
<p><br></p>
<hr>
<p>以太网是最有可能用来提供两个较低层所需功能的协议。从逻辑上来说，以太网套件包括了数据链路层和物理层两个子层，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c778329b108c9457c86bd268d99339b?method=download&amp;shareKey=6006174e1cb318f6cff4dd5c7fc5f809" alt=""></p>
<p>下面的这几点说明了以太网在支持TCP/IP的时候的功能： </p>
<ul>
<li><p><strong>逻辑链路控制(Logic Link Control, LcC)</strong>协议负责与网络层的交互。它管理数据传输并确保数据传输的完整性。不过由于以太网是一种无连接协议，所以它不负责检查传输是否成功发送。  </p>
</li>
<li><p><strong>介质访问控制(Medium Access Control, mac)</strong>协议负责组装被称之为“帧”的以太网数据包。其中的两个组成部分是发送器地址和接收器地址。此外，MAC协议还负责启动帧传输，并处理因碰撞(可能因为使用了CSMA/CD)导致的传输失败之后的恢复工作。  </p>
</li>
<li><p><strong>物理编码子层（Physical Coding Sublayer, PCS）</strong>,协议负责对准备传输的数据进行编码，或对于收到的数据进行解码。  </p>
</li>
<li><p><strong>物理介质附件(Physical Medium Attachment, PMA)</strong>协议负责信号的收发。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a><strong>MAC地址</strong></h3><p>在以太网中，一个以太网帧使用的地址是物理地址或者MAC地址。<br>MAC地址值分配给网络接口控制器（NIC）的唯一标识符，用作网段内通信的网络地址。这部分的内容同样在AS部分的第二章提到过。简单来说，MAC地址标识一个唯一的网卡。<br>在大多数IEEE 802网络技术（包括以太网，Wi-Fi和蓝牙）中，这种用法都十分常见。  </p>
<p>迄今为止，定义MAC地址使用的48位可以保证每一个设备都分配到他们自己的MAC地址。不过，除了使用48位方案，现在还有一种64位的替代方案。这种方案已经偶尔使用，但是在将来48位地址不够用的时候就真正派上用场了。  </p>
<p>48位地址通常使用十六进制标识，比如说：  </p>
<p>        <code>4A:30:12:24:1A:10</code>  </p>
<p><br></p>
<hr>
<h2 id="与TCP-IP有关的应用层协议"><a href="#与TCP-IP有关的应用层协议" class="headerlink" title="与TCP/IP有关的应用层协议"></a><strong>与TCP/IP有关的应用层协议</strong></h2><h3 id="HTTP-HyperText-Transfer-Protocol"><a href="#HTTP-HyperText-Transfer-Protocol" class="headerlink" title="HTTP (HyperText Transfer Protocol)"></a><strong>HTTP (HyperText Transfer Protocol)</strong></h3><p><strong>超文本传输协议(HyperText Transfer Protocol, HTTP)</strong>，是最重要的应用层协议，因为这是万维网的基础。<br>每次用户使用网络浏览器访问网站的时候都会用到HTTP，但它的功能对用户是隐藏的。换句话说，当你访问一个网站的时候，你的浏览器会向网站的服务器发送一个HTTP请求，而服务器则使用HTTP回应用户网站的内容。这个过程发生在幕后，用户是看不到的。  </p>
<p>HTTP协议定义了报文的格式。请求信息的第一行是“<strong>请求行 (Request Line)</strong>”，请求行之后还可以加上<strong>标题行 (Header Line)</strong>。所有这些信息都是用ASCII编码。请求行的格式如下：  </p>
<p>        <code>&lt;Method&gt; &lt;URL&gt; &lt;Version&gt;CRLF</code>  </p>
<p>其中后面的CR和LF是ASCII的回车和换行符。  </p>
<p>请求行通常使用GET作为获取方法。不过除了GET方法，还存在其他的获取内容方法。这使得HTTP成为一种适用范围更广的协议，而不仅仅用于网页访问。<br>在使用HTTP的时候，我们必须指定HTTP的版本，因为HTTP发展到现在已经存在了好多版本。  </p>
<p><br></p>
<hr>
<h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a><strong>电子邮件协议</strong></h3><p>发送和接受电子邮件的传统方法如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2850a0d087d768b07083c5289fe9cd21?method=download&amp;shareKey=acbc8c637f4a495999dfecfde993215b" alt=""></p>
<p>这其中设计三个单独的客户端到服务器的交互。客户端的电子邮件发件人必须和邮件服务器建立连接，然后该服务器必须变成“客户端”向真正客户端的电子邮件接收者所使用的邮件服务器进行传输。  </p>
<p><br></p>
<p>目前存在以下三种主流的电子邮件协议：  </p>
<p><strong>简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)</strong>，是一种“Push”协议，即用于从一个服务器向另一个服务器发送电子邮件。而<strong>邮局协议版本3 (POP3)</strong>是一种“Pull”协议，即用于从服务器检索电子邮件并下载到客户端计算机。  </p>
<p>还有一种协议叫做<strong>互联网消息访问协议 (Internet Message Access Protocol, IMAP)</strong>，这是POP3的最新替代方案。POP3是将电子邮件下载到客户端计算机上，但是IMAP允许将电子邮件保存在服务器上，同时客户端也可以访问存储的电子邮件。<br>这意味着如果使用IMAP协议，你可以在任何设备上访问你的邮件。而使用POP3，我们只能从下载邮件的客户端系统访问你的邮件。  </p>
<p>一般来说，POP3在抵御网络攻击方面可能会更加安全，因为电子邮件都存在客户端计算机的本地。不过使用IMAP存储电子邮件的服务器可能会定期备份，但是本地客户端大概率不会。  </p>
<p><br></p>
<hr>
<h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP (文件传输协议)"></a><strong>FTP (文件传输协议)</strong></h3><p><strong>文件传输协议 (File Transfer Protocol, FTP)</strong>是一种标准通信协议，用于在计算机网络中将计算机文件从服务器传输到客户端。  </p>
<p>FTP 基于客户机-服务器模型架构，在客户机和服务器之间使用独立的控制和数据连接。FTP 用户可以通过明文登录协议（通常以用户名和密码的形式）进行身份验证，但如果服务器配置允许，也可以匿名连接。  </p>
<p>为了保护用户名和密码并对内容进行加密的安全传输，FTP 通常使用 SSL/TLS (FTPS) 或用 SSH 文件传输协议 (SFTP) 代替。  </p>
<p><br></p>
<hr>
<h2 id="P2P文件共享"><a href="#P2P文件共享" class="headerlink" title="P2P文件共享"></a><strong>P2P文件共享</strong></h2><p><strong>点对点文件共享 (Peer-to-peer file sharing, P2P file sharing)</strong>产生的网络流是互联网使用的主要特征之一。  </p>
<p>P2P 是一种没有结构和控制机制的架构。点对点既是客户端也是服务器，每个点对点只是一个终端系统。当对等体充当服务器时，它被称为 “种子”。</p>
<p><br></p>
<p>在P2P中，BitTorrent协议是最常用的协议，因为它可以快速的共享文件。 BitTorrent 是一种用于点对点文件共享（P2P）的通信协议，它使用户能够以分散的方式在互联网上分发数据和电子文件。要发送或接收文件，用户需要在联网电脑上使用 BitTorrent 客户端。  </p>
<p>BitTorrent 客户端是实现 BitTorrent 协议的计算机程序。BitTorrent 客户端适用于各种计算平台和操作系统，包括 Rainberry 公司发布的官方客户端。流行的客户端包括 μTorrent、迅雷、Transmission、qBittorrent、Vuze、Deluge、BitComet 和 Tixati等等。</p>
<p>BitTorrent 跟踪器提供可用于传输的文件列表，并允许客户端查找可传输文件的对等用户（称为 “种子”）。程序员布拉姆-科恩于 2001 年 4 月设计了该协议，并于 2001 年 7 月 2 日发布了第一个可用版本。BitTorrent 协议可用于减少分发大文件对服务器和网络的影响。BitTorrent 协议允许用户加入一个主机 “群”，同时相互上传和下载文件，而不是从单个源服务器下载文件。  </p>
<p><br></p>
<p>如果我们决定在终端系统使用BitTorrent，我们需要解决下面这三个基本问题：  </p>
<ol>
<li>如何确保计算机能够在网络上找到拥有目标资源的计算机？  </li>
</ol>
<blockquote>
<p>首先每个内容的供应者都提供一个内容描述，叫做torrent。这是一个包含跟踪器 （<em>引导计算机找到内容的服务器</em>）名称和内容块列表的文件。torrent文件比内容至少要小上三个过更多的数量级，因此这样的种子文件更易于我们传播。<br>跟踪器是一个服务器，它的任务是维护正在下载和上传内容的所有其他的终端的列表。  </p>
</blockquote>
<ol>
<li>在这样的对等网络上，如何为所有人提供高速的下载？  </li>
</ol>
<blockquote>
<p>对等网络在下载和上传的过程是同时发生的，但是对等网络必须同时交换数据块列表，来确保优先下载稀有的数据块。只要下载一次稀有的片段，那么这个数据块的稀有程度就会降低。  </p>
</blockquote>
<ol>
<li>每个终端如何鼓励其他的终端提供内容，而不是仅仅使用协议下载文件造福自己？  </li>
</ol>
<blockquote>
<p>在经济中有一个名词叫做”Free-rider”。在这里我们需要对付的就是这类的终端。解决的方法如下：<br>首先一个终端先随机尝试连接其他的终端，然后仅仅向那些提供常规下载的节点传输数据。如果发现有一个节点不下载或者下载速度贼慢，那么这个节点最后就会被“隔离”或者“阻塞”。  </p>
</blockquote>
<p><br></p>
<hr>
<h1 id="第十八章：硬件与虚拟机"><a href="#第十八章：硬件与虚拟机" class="headerlink" title="第十八章：硬件与虚拟机"></a><strong>第十八章：硬件与虚拟机</strong></h1><h2 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a><strong>控制单元</strong></h2><p><strong>控制单元 (Control unit, CU)</strong>是计算机中CPU的一个组件，用于指导处理器的运行。它通常使用二进制解码器将编码指令转换为定时和控制信号，从而直到内存，算术逻辑单元(ALU)和IO设备等其他单元的运行。  </p>
<p>控制单元管理大部分计算机的资源，并直到中央处理器与其他设备之间的数据流。在现在计算机设计中，控制单元通常是中央处理器的内部组成部分，其整体作用和运行方式自推出以来一直没有发生改变。  </p>
<p><br></p>
<hr>
<p>在执行程序时，中央处理器会接收一连串机器码指令。中央处理器内的控制单元有责任确保正确处理每一条机器指令。有两种方法可以设计控制单元，使其发挥功能：  </p>
<ul>
<li><p><strong>将控制单元构建为逻辑电路</strong>：这也称为<strong>硬连线控制单元 (Hardwired control unit)</strong>。硬连线控制单元通过逻辑电路将从中央处理器内存接收到的指令转化为控制信号。来自计算机主机内存的指令被发送到指令寄存器，指令寄存器负责识别其“操作码”。随后操作码被传递给指令解码器，指令解码器使用操作码来解释要生成的控制信号。然后，逻辑电路根据任何外部输入和条件代码创建了信号。&lt;/br&gt; &lt;/br&gt;整个过程由系统时钟同步，系统时钟产生有规律的脉冲，在低电平和高电平之间持续切换，形成了0和1。这种控制单元之所以是“硬连线”，是因为他们的逻辑电路是由硬件以逻辑门电路的物理排列。&lt;/br&gt; &lt;/br&gt;硬接线控制单元的一些缺点是成本相对较高，难以用于复杂的操作，而且无法在不进行物理改动的情况下对它进行修改。此外，每个电路只能处理一种形式的指令。不过，硬接线控制单元速度更快，因为每一种指令都由自己指定的电路来完成计算。  </p>
</li>
<li><p><strong>使用微编程构建微程序控制单元</strong>：这样的方法叫做<strong>微程序控制单元 (Microprogrammed control unit)</strong>。微编程控制单元采用编程的方法实现。在微程序控制中，微操作是通过执行由微指令组成的程序来实现的。<br> <br> 控制存储器地址寄存器用来指定微指令的地址。控制存储器被用为ROM，其永久存储了左右的控制信息我们一般称为<strong>固件 (Firmware)</strong>。控制寄存器保存从存储器获取的微指令。微指令包含一个控制字，为数据处理器指定一个或者多个微操作。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="CISC和RISC处理器"><a href="#CISC和RISC处理器" class="headerlink" title="CISC和RISC处理器"></a><strong>CISC和RISC处理器</strong></h2><p>处理器的架构是指其物理结构。不过，处理器也有所谓的 “指令集架构”。</p>
<p>指令集架构涉及到： </p>
<ul>
<li>指令集</li>
<li>指令格式</li>
<li>寻址模式</li>
<li>指令可以访问的寄存器</li>
</ul>
<p>其中，指令集的选择是区分指令集架构的主要因素。  </p>
<p><br></p>
<hr>
<p>在计算机发展的早期，选择计算机指令集架构的一个重要因素是，该架构是否能够使高级语言编译器的编写变得更加容易。我们现在将这一种架构叫做<strong>复杂指令集计算机 (Complex Instruction Set Computer, CISC)</strong>。</p>
<p>直到20世纪70年代末期，人们开始对这一理念产生质疑。有人认为，使用<strong>精简指令集计算机 (Reduces Instruction Set Computer, RISC)</strong>会是一种更好的方法。  </p>
<p><br></p>
<p>下面介绍一下这两位：  </p>
<p>CISC和RISC是两种不同类型的计算机体系结构。二者的主要区别在于<strong>中央处理器可执行的指令数</strong>和<strong>执行这些指令所需要的周期数</strong>。  </p>
<p>CISC试图尽量减少每个程序的指令数，但是代价是这会增加每个指令的周期数。这就意味着CISC处理器一般<u>拥有大量的复杂指令</u>，但是可以在一条指令中执行多种操作。这些指令通常更长，功能更强大，可以用更少的单条指令来完成复杂的任务。  </p>
<p>现在转过头来看看另一边的RISC。RISC是一种以每个程序的指令数量为代价来减少每条指令周期的方法。这就意味着RISC处理器的<strong>简单指令数量较少</strong>，<strong>只能执行单一的操作</strong>。这样，RISC处理器的指令集就设计的比CISC更简单，更小了。这些指令通常更短更简单，需要更多的单独指令才能完成复杂的任务。  </p>
<p>这两种方法各有利弊。CISC处理器通常<strong>更容易编程</strong>，因为它们有更强大的指令。但由于每条指令的周期数多，所以运行速度可能会慢一些。RISC处理器由于减少了每条指令的周期数，因此运行的速度普遍较快，但是因为需要更多的单独指令来执行复杂的任务，因此这可能会使得编程的难度直线上升。  </p>
<article class="message is-info"><div class="message-body">

<b>Complex Instruction Set Computer (CISC): a single instruction can be more complex and involve more loading of data from memory.</b>

<br>

<b>Reduced Instruction Set Computer (RISC): s single instruction is simpler, requiring minimal loading of data from memory.</b>

</div></article> 



<p><br></p>
<hr>
<p>下表列出了RISC区别于CISC的一些特征：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">RISC</th>
<th style="text-align:left">CISC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">更少的指令数</td>
<td style="text-align:left">更多的指令数</td>
</tr>
<tr>
<td style="text-align:left">更简单的指令</td>
<td style="text-align:left">更复杂的指令</td>
</tr>
<tr>
<td style="text-align:left">指令格式相对简单</td>
<td style="text-align:left">指令格式复杂</td>
</tr>
<tr>
<td style="text-align:left">尽可能使用单周期指令</td>
<td style="text-align:left">多周期指令</td>
</tr>
<tr>
<td style="text-align:left">定长指令</td>
<td style="text-align:left">可变长度指令</td>
</tr>
<tr>
<td style="text-align:left">只对内存地址执行加载和存储指令</td>
<td style="text-align:left">向内存地址存储多种指令</td>
</tr>
<tr>
<td style="text-align:left">更少的寻址模式</td>
<td style="text-align:left">更多的寻址模式</td>
</tr>
<tr>
<td style="text-align:left">多个寄存器组</td>
<td style="text-align:left">更少的寄存器</td>
</tr>
<tr>
<td style="text-align:left">多为<strong>硬连线控制单元</strong></td>
<td style="text-align:left">多为<strong>微程序控制单元</strong></td>
</tr>
<tr>
<td style="text-align:left">更利于流水线作业</td>
<td style="text-align:left">不太利于流水线作业</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，RISC处理器大多使用硬连线控制单元，而CISC处理器大多使用微编程控制单元。</p>
<p>指令数量的减少并不是使用RISC的主要驱动力，降低指令的复杂性才是RISC的主要特征。  </p>
<p>典型的CISC架构包含很多的专用指令，专用指令的设计符合高级编程语言的要求。专用指令需要多次访问内存。与直接访问寄存器相比，访问内存的速度可谓是相当慢。  </p>
<p>RISC处理器的指令非常简单，因此数据可以存储在寄存器中，并在寄存器中进行操作。除了初始化和资源存储请求之外，无需对存储器进行任何的访问。   </p>
<p>RISC指令的简单性使得硬连线控制单元的使用更加容易。而许多CISC指令的复杂性使得硬连线控制单元的构建更加复杂，因此我们使用微程序控制单元。  </p>
<p><br></p>
<hr>
<h3 id="流水线作业-Pipelining"><a href="#流水线作业-Pipelining" class="headerlink" title="流水线作业 (Pipelining)"></a><strong>流水线作业 (Pipelining)</strong></h3><p>创建 RISC 处理器的主要驱动力之一，就是为高效流水线提供机会。  </p>
<p><strong>流水线 (Pipelining)</strong>是一种专门应用于指令执行的并行方式。其他并行形式将在下一节中讨论。  </p>
<p><em>好像翻译成“流水线”不是很恰当，但是懂我意思就行</em></p>
<article class="message is-info"><div class="message-body">

<b>Pipelining: instruction-level parallelism.</b>

</div></article> 

<p><br></p>
<hr>
<p>流水线作业的基本原理是第五章中介绍的F-E Cycle可以分为若干阶段。其中的一个形式是“五阶段模型”。要实现流水线操作，处理器的结构必须含有5个独立的单元，这样每个单元就可以单独处理五个阶段中的其中一个阶段。这同样解释了为什么RISC处理器需要许多的寄存器组，因为存在多个处理单元，而每个单元必须需要寄存器来访问将要使用的数据。</p>
<p>五阶段模型如下表所述：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">时钟周期 →</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Instruction Fetch<br>(指令读取，IF)</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">3.1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">5.1</td>
<td style="text-align:center">(6.1)</td>
<td style="text-align:center">(7.1)</td>
</tr>
<tr>
<td style="text-align:left">Instruction Decode<br>(指令解码，ID)</td>
<td style="text-align:center"></td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">2.2</td>
<td style="text-align:center">3.2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">5.2</td>
<td style="text-align:center">(6.2)</td>
</tr>
<tr>
<td style="text-align:left">Operand Fetch<br>(操作数抓取，OF)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.3</td>
<td style="text-align:center">2.3</td>
<td style="text-align:center">3.3</td>
<td style="text-align:center">4.3</td>
<td style="text-align:center">5.3</td>
</tr>
<tr>
<td style="text-align:left">Instruction Execute<br>(指令执行，IE)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.4</td>
<td style="text-align:center">2.4</td>
<td style="text-align:center">3.4</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Result Write Back<br>(结果回写，WB)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.5</td>
<td style="text-align:center">2.5</td>
<td style="text-align:center">3.5</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>在上面的表格中，每一行代表流水线中的一个阶段： 指令读取 (IF)、指令解码 (ID)、操作数读取 (OF)、指令执行 (IE) 和结果回写 (WB)，同时每列代表一个时钟周期。单元中的数字代表指令编号和该指令的阶段。例如，”1.1 “表示指令 1 处于 第一步 “IF” 阶段，”2.5 “表示指令 2 处于第五步 “WB” 阶段。  </p>
<p>解读一下表格：最初只有第一条指令的第一阶段进入了流水线。在第六个时钟周期，当第一个指令已经离开流水线时 <em>（因为不存在第六个流水线阶段）</em>，指令2的最后一步仍在处理，而且指令6才刚刚进入流水线作业 <em>（因为没有第六个流水线阶段，所以第六个指令的流程并没有画在表上。但如果第六个指令需要处理的话，会在第六个时钟周期进入流水线）</em>。</p>
<p>流水线一旦开始运行，就要处理五个阶段的五条单独指令。特别是在每个时钟周期，都需要完成一条指令的处理工作。如果没有流水线并行作业，那么处理时间将延长五倍。</p>
<p><br></p>
<p>在流水线系统中，多条指令在流水线的不同阶段同时处理。当中断发生时，流水线中就会有几条指令尚未执行完毕。<br>有两种解决中断问题的解决方案：  </p>
<ul>
<li><p>第一种：<strong>清除最近进入的四条指令的流水线内容，只留下最早进入的指令。</strong>然后，正常的中断处理程序就可以应用于剩余的指令。</p>
</li>
<li><p>第二种：<strong>在处理器中构建具有独立程序计数器寄存器的独立单元。</strong>这样就可以在处理中断时为流水线中的所有指令存储当前数据。</p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="基本计算机架构"><a href="#基本计算机架构" class="headerlink" title="基本计算机架构"></a><strong>基本计算机架构</strong></h2><p>描述不同计算机体系结构的一种有效的方法是：考虑指令流的数量和数据流的数量。因此这区分出了四种类型的架构：  </p>
<p><br></p>
<hr>
<h3 id="单指令流单数据流-SISD"><a href="#单指令流单数据流-SISD" class="headerlink" title="单指令流单数据流 (SISD)"></a><strong>单指令流单数据流 (SISD)</strong></h3><p><strong>单指令流单数据流 (Single Instruction Stream Single Data Stream, SISD)</strong>是早期计算机中的典型架构，同样也是早期的微处理器所采用的排列方式。具体来说，SISD代表了包含一个控制单元，一个处理器单元和一个存储器单元的单台计算机的组织结构。所有的指令按照顺序执行，系统内部可能有并行能力，也可能没有。  </p>
<p>虽说是这样，但是课本上写的是SISD纯粹是顺序性的产物，没有一点点并行性。我们就按照这条来记吧。</p>
<p><br></p>
<p>下图展示了如何使用SISD来操作数组中的单个元素：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB30316d3629bca49a5815cbb453ffaab7?method=download&amp;shareKey=3ed3432f2423c78b6885dccd0b2e3c68" alt="">  </p>
<p>图中给出了一个原始的数组。如果机器需要将这个数组内的元素乘以2，那么SISD就会按照顺序一个一个地处理数组内部的数据，从右到左。换言之，SISD对于数组内每一个元素都执行了相同的“乘以2”的操作。  </p>
<article class="message is-info"><div class="message-body">

<b>SISD: Stands for Single Instruction Stream Single Data stream; a single processor accessing one memory.</b>

</div></article> 


<p><br></p>
<hr>
<h3 id="单指令流多数据流-SIMD"><a href="#单指令流多数据流-SIMD" class="headerlink" title="单指令流多数据流 (SIMD)"></a><strong>单指令流多数据流 (SIMD)</strong></h3><p><strong>单指令流多数据流 (Single Instruction Stream Multiple Data Stream, SIMD)</strong>所描述的计算机具有多个处理元件，可以<u>同时对多个数据点执行相同的操作</u>。这类计算机利用数据级的并行性，但是不利用它们的并发性。 </p>
<p>SIMD是一种并行处理方式，也就是多个处理元件同时对多个数据点执行相同操作。这意味着计算机就可以使用相同的指令同时处理多个数据点，而不是一步只能处理一个数据点。这可以大大提升某些类型计算的速度。也就是说，虽然说存在并行计算，但是每个单元在任何给定的时刻都执行完全相同的指令。  </p>
<p><br></p>
<hr>
<p>下图是一个SIMD的图示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7144d89b55622ba1765c5b94a0c5e21e?method=download&amp;shareKey=1d05101205bb890f3f1a34bb47dd9fde" alt=""></p>
<p>由图可见，所有在数组中的元素都在同一个指令周期完成了处理，而不像SISD一样每一个元素都需要单独处理。  </p>
<p><br></p>
<p>SIMD 的结构通常用图表表示，就像下图一样：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6215f557d53c58f88328a11754ac405e?method=download&amp;shareKey=2f07fdbe2d15d4e0cc24e974bdcd90c8" alt=""></p>
<p>在本图中，结构图显示数据流进入了四个单独的组件，这些组件都提供了相同的指令。这些组件被称之为<strong>处理单元(Processing Unit, PU)</strong>，有时这些组件也被称为<strong>处理原件(Processing Element, PE)</strong>。无论使用什么名称，这些组件都全部是ALU，也就是算术逻辑单元。有多个名称的原因是因为实现SIMD有多种方法：  </p>
<p>第一种实现方法是使用阵列或者向量处理器(Matrix &amp; Vector processors)。他们有一组并行的寄存器，每一个数据流都会被安排一个寄存器。我们可以使用一4位或者128位的大型寄存器，来同时存储多个数值。在这种实现方式中，并行性仅仅内置在一个处理器中，允许这个处理器同时处理多个数据流。</p>
<p>另一种方法是使用多核处理器。现在大多数的电脑都搭载了多核处理器。比如说使用4核处理器，就代表四个处理器并行工作。在这种情况下，每一个处理器都可能有自己专用的告诉缓存来提供可靠的数据流。</p>
<article class="message is-info"><div class="message-body">

<b>SIMD: Stands for Single Instruction Stream Multiple Data Stream; processing of parallel data input requiring one control unit instructing multiple processing units.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="多指令流单数据流-MISD"><a href="#多指令流单数据流-MISD" class="headerlink" title="多指令流单数据流 (MISD)"></a><strong>多指令流单数据流 (MISD)</strong></h3><p><strong>多指令流单数据流 (Multiple Instruction Stream Single Data Stream, MISD)</strong>是一种并行计算架构，其中<u>许多功能单元对同样的数据执行不同的操作。</u>  </p>
<p>与SIMD相比，MISD的应用就少得多，因为MISD通常更适合常用的数据并行技术。具体来说，他们可以更好的扩展和使用计算资源。话虽这么讲，MISD也是有应用的，比如说用于航天飞机的飞行控制计算机。大家也知道航天方面的数据计算是不容有失的，-在这种情况下，使用 MISD 架构可将多条指令应用于同一数据流，从而提供冗余并提高系统的可靠性。</p>
<article class="message is-info"><div class="message-body">

<b>MISD: Stands for Multiple Instruction Stream Single Data Stream; does not exist in a single architecture.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="多指令流多数据流-MIMD"><a href="#多指令流多数据流-MIMD" class="headerlink" title="多指令流多数据流 (MIMD)"></a><strong>多指令流多数据流 (MIMD)</strong></h3><p><strong>多指令流多数据流 (Multiple Instruction Stream Multiple Data Stream, MIMD)</strong>是一种并行计算架构。在这种架构中，有许多个处理器异步独立运行。<u>在任何时候，不同的处理器都可能对不同的数据执行不同的指令。</u>  </p>
<p>MIMD架构被应用于多个领域，如计算机辅助设计，仿真，建模或者是通信交换机。MIMD机器可以分为共享内存和分布式内存两类，他们的类别是基于MIMD处理器访问内存的方式决定的。共享机器模型可以是总线型、扩展型或者分层型。</p>
<article class="message is-info"><div class="message-body">

<b>MIMD: Stands for Multiple Instruction Stream Multiple Data Stream; multiple processors asynchronously processing parallel data input.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="大规模并行计算机系统"><a href="#大规模并行计算机系统" class="headerlink" title="大规模并行计算机系统"></a><strong>大规模并行计算机系统</strong></h3><p><strong>大规模并行计算机系统 (Massively parallel computer systems)</strong>是指使用大量计算机处理器（或者是独立的计算机）同时并行执行一组协调计算的计算架构。这可以通过各种各样的方法实现，比如说网格计算 (Grid computing)，就是透过使用大量的异构计算机的未使用资源，将其作为嵌入在分布式电信基础设施中的一个虚拟的计算机集群，为解决大规模的计算问题提供模型的方案。大名鼎鼎的SETI@home项目就是使用了这项技术，通过筹集大量计算机用户的剩余资源来分布式计算问题。这些小的计算机结合起来的算力同样强大，丝毫不亚于超级计算机。  </p>
<p>大规模并行计算机系统与超级计算机的区别在于，负责驱动多个处理器的不是总线结构，而是支持多个计算机单元的网络基础设施。不同计算机上面运行的程序可以通过网络传递信息进行通信。 </p>
<p><br></p>
<hr>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><strong>虚拟机</strong></h2><p>虚拟机听起来像是个硬件，但其实不是。最常见的虚拟机类型是<strong>系统虚拟机 (System virtual machine)</strong>，它的作用是模拟真实计算机系统硬件的软件。  </p>
<article class="message is-info"><div class="message-body">

<b>System virtual machine: the emulation of computer system hardware using software.</b>

</div></article> 

<p><br></p>
<p>一般来说，应用程序需要在操作系统支持的情况下才能在硬件上直接运行。虚拟机的原理是进程直接与操作系统提供的软件界面进行交互，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBad58e3603d7ce6727ad0207a279a5d47?method=download&amp;shareKey=ae8057b16074d482045345abe63369db" alt="">  </p>
<p>从上图我们需要注意这几点：  </p>
<ol>
<li><p>应用程序是在客户操作系统的协助下安装的。客座操作系统将通过与虚拟机交互来支持运行中的应用程序，就好像客座操作系统通常运行的硬件一样。  </p>
</li>
<li><p>虚拟机实施软件可被视为一种实用程序，运行时受特定主机操作系统的支持，而主机操作系统又是主机硬件所特有的。  </p>
</li>
<li><p>在主机操作系统的控制下，主机硬件上可以同时直接运行应用程序。  </p>
</li>
</ol>
<p><br></p>
<p>虚拟机方法的主要优点是可以在一个计算机系统上提供多个不同的操作系统。如果一个组织拥有遗留系统，希望继续使用旧软件，但又不想保留旧硬件，这一点就特别有价值。  </p>
<p>另外，拥有大型主机并提供服务器整合设施的公司也可以多次提供相同的操作系统。不同的公司可以获得自己的虚拟机，作为服务器运行。  </p>
<p>使用虚拟机的一个缺点是需要花费大量时间和精力来实施。另一个缺点是虚拟机的性能无法达到普通系统的性能水平。  </p>
<p><br></p>
<p>之前在第八章讨论的 Java 虚拟机是进程虚拟机的一个例子，它基于不同的基本概念。进程虚拟机提供了一个与平台无关的编程环境，允许程序在任何平台上以相同的方式执行。这是一种仅支持运行 Java 程序的特定软件。</p>
<p><br></p>
<hr>
<h1 id="第十九章：逻辑门与布尔代数"><a href="#第十九章：逻辑门与布尔代数" class="headerlink" title="第十九章：逻辑门与布尔代数"></a><strong>第十九章：逻辑门与布尔代数</strong></h1><h2 id="逻辑电路"><a href="#逻辑电路" class="headerlink" title="逻辑电路"></a><strong>逻辑电路</strong></h2><p>早在第四章，我们就已经接触过了逻辑电路中使用的逻辑门符号，并讨论了逻辑电路，真值表和逻辑表达式之间的关系。本章会介绍一些额外的内容，比如一些用于构建计算机硬件功能组建的特定电路。  </p>
<h3 id="半加法器-The-half-adder"><a href="#半加法器-The-half-adder" class="headerlink" title="半加法器 (The half adder)"></a><strong>半加法器 (The half adder)</strong></h3><p>在计算机中，二进制加法运算随处可见。两个比特的结果相加结果要么为1，要么为0。在一些特殊情况下，如1和1相加，会导致当前位结果为0，同时它的下一位会被加一，也就是进位。  </p>
<p>执行二进制加法最简单的电路是<strong>半加法器 (Half adder)</strong>。如下图所示，半加法器会接受两个值的输入，然后输出“和位(S)”和一个“进位(C)”。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB50fb2efc7af272739fbc1a90ed75d8fb?method=download&amp;shareKey=c676b82aaa0cdaed3a57929e73110e3b" alt=""></p>
<p>这个电路的真值表看起来就是这样的：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input</th>
<th style="text-align:center">Input</th>
<th style="text-align:center">Output</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center"><strong>C</strong></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>通过检查这个真值表，我们大概可以推测出半加法器的成分如何。<br>可以看到，只有在两个输入位都为1的时候，进位C才会出现1的结果。因此，C输出的真值表就可能是基于AND逻辑门实现的。<br>和位S输出的真值表与之前聊过的XOR运算符的真值表一致，所以我们也可以推测半加法器里面还存在一个XOR逻辑门。<br>因此，产生半加法器功能的电路可以包含一个AND门和一个XOR门，其中这两个逻辑门都会接受A和B两个输入。</p>
<p>当然，上面列出的只是完成这个功能的其中一种情况，还有更多逻辑门的搭配方式可以实现这样的功能。冷知识：NAND逻辑门和NOR门是两个通用门，这意味着任何的逻辑电路都可以使用这两种逻辑门进行构建。再加上NAND和NOR门易于制造的特点，导致电路制造商们很喜欢使用它们俩。下面这个图片就是仅仅使用NAND门和NOR门构建出来的一个半加法器：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB534f2fe40966c4cfe4f07994cae4f61c?method=download&amp;shareKey=8ab4d250399ae72eeb307bba668d92d5" alt=""></p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Half adder circuit: a circuit which performs binary addition of two individual bits.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="全加法器-The-full-adder"><a href="#全加法器-The-full-adder" class="headerlink" title="全加法器 (The full adder)"></a><strong>全加法器 (The full adder)</strong></h3><p>一般来说，如果我们需要计算两个二进制数字相加，则我们必须要从两个数字的最小位开始计算，一直计算到最大位。在计算的每一个阶段，前一个加法的结果的进位数字都必须并入到当前的计算中。<br>如果每次使用半加法器，就必须需要使用单独的电路来处理进位问题，因为半加法器仅仅接受两个输入。  </p>
<p><strong>全加法器 (Full adder)</strong>是一种执行加法运算的一种电路。这种加法器接受三个输入：两个需要相加的数字和上一位产生的进位，并产生三个输出，分别是三个输入的和以及下一位的进位。  </p>
<p>当我们需要对不止一位进行二进制加法运算时，我们最好使用全加法器，因为全加法器考虑了前一位假发的金文，所以它能够处理所有的进位问题。例如我们设计对多位二进制数（如4位，8位，16位二进制数等）进行算术运算的电路，我们就需要使用全加法器。</p>
<p>全加法器的真值表如下：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Input</th>
<th>Input</th>
<th>Output</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>Cin</td>
<td>S</td>
<td>Cout</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>全加法器的一种可能的构造如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf506c3d9a0c9e9dcad6f14905ad95347?method=download&amp;shareKey=cf712be00f7aa9f64cd2ea3b41c00895" alt=""></p>
<p><br></p>
<p>我们之前说过，所有的电路理论上都可以使用NAND和NOR逻辑门来构建。所以全加法器的另一种构造如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7f4a38b0b4d46b3034ead532ffb7a7a5?method=download&amp;shareKey=212c866467e455e7c6f529fe74bea972" alt=""></p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Full adder circuit: a circuit which performs binary addition of two individual bits and an input carry bit.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="时序电路"><a href="#时序电路" class="headerlink" title="时序电路"></a><strong>时序电路</strong></h2><p>到目前为止，本书中介绍过的所有电路全部都是 组合电路 (Combinational circuit)。对于这样的电路来说，输出的值只由输入的值决定。<br>接下来我们会介绍时序电路，它的输出取决于输入和前一个输出项。  </p>
<p><strong>时序电路 (Sequential logic circuit)</strong>是一种数字电路，它存储上一个输出信息并使用它来计算下一个输出。我们刚说过，时序电路于组合电路不同之处就在于，时序电路既依赖当前输入值，同样也依赖存储在某一个存储元件中的上一个输出状态。  </p>
<article class="message is-info"><div class="message-body">

<b>Combinational circuit: a circuit in which the output is dependent only on the input values.</b>

<br>

<b>Sequential circuit: a circuit in which the output depends n the input values and the previous output.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="SR-触发器-SR-Flip-flop"><a href="#SR-触发器-SR-Flip-flop" class="headerlink" title="SR 触发器 (SR Flip-flop)"></a><strong>SR 触发器 (SR Flip-flop)</strong></h3><p>下面我们要介绍的SR触发器，是时序电路的一个简单例子。  </p>
<p><strong>SR触发器 (SR Flip-flop)</strong>，又称之为SR锁存器，是数字电子产品中经常会用到的一种基本触发器。SR触发器是一种双稳定器件，这意味着SR触发器有两个稳定状态，而这两种稳定状态可以被无限期保存。正因为这种独特的记忆特性，卫门叫它“锁存器”。它可以由两个NAND门和一个NOR门组成，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf6c36ffa6f6e12b7716959b642e9bd4f?method=download&amp;shareKey=a83e7e149cc8b4acf2c767a8f0011cdc" alt=""></p>
<p>SR触发器有两个输入端，分别是 <strong>“置位” (S)</strong>和 <strong>“复位” (R)</strong>。以及两个输出端，分别是<strong>Q</strong>和<strong>Q’</strong>。<br>SR触发器的工作原理如下：  </p>
<ul>
<li><strong>设置 (set) 状态</strong>： 当设置(S)为1，(R)为0时，这时输出(Q)就会变为1。这表示锁存器进入了设置状态。  </li>
<li><strong>复位 (reset) 状态</strong>： 当设置(R)为1，(S)为0时，这时输出(Q)就会变为0。这表示锁存器进入了复位状态。  </li>
<li><strong>保持 (hold) 状态</strong>： 当输入端的(S)和(R)均为0时，无论上一个状态是设置状态还是复位状态，触发器会保持原来的状态。也就是说，输出还是会与上次相同。 <br> 比如说，如果SR触发器的上一个状态处于“set”状态，也就是Q的输出为1，并且输入S和R都是0，那么触发器会继续输出Q为1。  </li>
</ul>
<p>SR触发器的真值表如下所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input Signals</th>
<th style="text-align:center">Input Signals</th>
<th style="text-align:center">Initial State</th>
<th style="text-align:center">Initial State</th>
<th style="text-align:center">Final State</th>
<th style="text-align:center">Final State</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">R</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">Q’</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">Q’</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>从真值表中我们可以发现，表中不包含当R = 1或者S = 1的行，因为如果当S与R同时等于1，会导致输出“非法”。因为当遵循布尔代数原则时，Q和Q’不会同时输出0。Q与Q’本身应该就是彼此互补的，即当一个值为1时，另一个值应该为0。所以，输出是违反这个逻辑，是“非法”的。  </p>
<p>在实际运用中，我们要避免使S和R都同时为1，因为它会导致数字电路中不可预测的行为。因此为了保证电路的可靠运行，我们需要尽可能避开这种用法。</p>
<p><br></p>
<hr>
<h3 id="JK-触发器-JK-Flip-flop"><a href="#JK-触发器-JK-Flip-flop" class="headerlink" title="JK 触发器 (JK Flip-flop)"></a><strong>JK 触发器 (JK Flip-flop)</strong></h3><p>我们在数字电路中最讨厌的就是像刚才SR触发器中，任何可能导致电路发生“不可预测”的无效输出或者错误处理。<br>实际上，除了在电路中存在S与R都为1导致的无效输出之外，如果信号无法同时到达触发器，也会导致输出的不可预测性。为了解决这个问题，电路可以包含一个时钟脉冲输入，以提供同步输入的更好机会。<strong>JK触发器 (JK Flip-flip)</strong>，也叫JK锁存器，就是这样的一个例子。  </p>
<p>JK触发器是一种连续双状态单比特存储设备，是以它的发明者杰克·基尔命名的。<br>这个不重要，重要的是JK触发器有一个时钟输入引脚(Clock, CLK)，两个数据输入引脚(J和K)和两个输出引脚(Q和Q’)。如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa259e5b4f4f0cd30f9d02342b97c1b82?method=download&amp;shareKey=c369533d4b892af9c697199f4227abc4" alt=""></p>
<p>JK触发器可以画成左边的简略形式，它的展开形式如右图所示。  </p>
<p><br></p>
<p>在时钟周期的情况下，JK触发器可以在时钟的前缘触发，或者是后缘触发。将时钟周期想象成一个方波。前缘就是电平从0变成1的电平上升时刻，而后缘就是电平从1变成0的电平下降时刻。</p>
<p>要理解电路是如何运作的，我们需要先理解一个大前提。除非所有的输入都为1，否则与非门的输出为1。如果电路处于未设置状态，那么Q = 0， Q’ = 1。这种状态是稳定并且自洽的，就正如下面的参数所示：  </p>
<ol>
<li>时钟和J都输入为0</li>
<li>因此左上角的NAND门输出为1</li>
<li>右上角的NAND门会接受两个为1的值的输入。</li>
<li>Q = 0</li>
</ol>
<p>如果J的输入变成了1，时钟的输入也变成了1，那么就会发生下面这些事情：  </p>
<ol>
<li>左上角的NAND门就会接受两个为1的值的输入</li>
<li>所以它的输出为0</li>
<li>这就会导致右上角的NAND门以1的值输出Q</li>
<li>这样一来，右下角的NAND门就会接受两个为1的值的输入。 </li>
<li>所以Q’的输出为0</li>
</ol>
<p><br></p>
<hr>
<p>JK触发器的真值表如下： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>J</strong></th>
<th><strong>K</strong></th>
<th><strong>Clock</strong></th>
<th><strong>Q</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>↑</td>
<td>Q unchanged</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>↑</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>↑</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>↑</td>
<td>Q toggles</td>
</tr>
</tbody>
</table>
</div>
<p>由此可见，当J和K的输入均为1的时候，Q与Q’的值会发生变换。</p>
<p>J可以被称作为“集合输入”。当J被设置为1，并K被设置为0的时候，它会导致输出Q也被设置为1。<br>K可以被叫做“清除输入”。当K被设置为1，J被设置为0的时候，会导致Q被清除（设置为0）。  </p>
<p>JK与SR触发器不一样的是，每两个输入任意发生组合都会产生一个有效的输出，输入J和K的每一个组合都对Q和Q’产生明确定义的影响，而不像SR触发器一样，包含一个无效输出。这个特性导致JK触发器更加可靠，更有预测性，因为没有导致任何不确定因素或者未定义输出的情况出现。</p>
<p><br></p>
<hr>
<h2 id="布尔代数基础"><a href="#布尔代数基础" class="headerlink" title="布尔代数基础"></a><strong>布尔代数基础</strong></h2><p>本书的第四章讲过了如何使用逻辑命题来使用布尔运算符来组合成逻辑表达式。而布尔代数为编写简洁的逻辑表达式提供了方法，并提供了一种简化表达式的“公式”。  </p>
<p>当使用一种代数形式的时候，理解它的含义是十分重要的。举个简单的例子，1+1可以被解释成很多不同的情况： </p>
<p>1 + 1 = 2<br>1 + 1 = 10<br>1 + 1 = 0<br>1 + 1 = 1</p>
<p>一式表示的是十进制算术，二式表示二进制算术，三式表示位算术，而四式可以表示布尔代数。这是因为在布尔代数中，1表示为<code>TRUE</code>，0表示为<code>FALSE</code>，而<code>+</code>可以表示或。因此，第四个计算式可以以下面这种形式表示出来：  </p>
<p>                         <code>TRUE OR TRUE is TRUE</code></p>
<p>布尔代数的表示有它的专有符号。比如说<code>AND</code>可以表示为∧，<code>OR</code>可以表示为∨。或者，<code>A AND B</code>可以写成<code>A.B</code>或者<code>AB</code>。在本章中，我们会使用这种类似“点乘”的<code>AND</code>表示方法。<code>NOT</code>的具体方式是在字母上面加一个横线。比如说<code>NOT A</code>可以表示为<code>Ā</code>。  </p>
<p><br></p>
<hr>
<p>在建立了基本的表示法之后，我们就需要考虑我们的计算规则了。<br>下表中的内容可以被叫做“法则”或者“定义式”：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Identity / Law</th>
<th style="text-align:center">AND form</th>
<th style="text-align:center">OR form</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Identity</td>
<td style="text-align:center"><code>1.A = A</code></td>
<td style="text-align:center"><code>0 + A = A</code></td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center"><code>0.A = 0</code></td>
<td style="text-align:center"><code>1 + A = 1</code></td>
</tr>
<tr>
<td style="text-align:center">Idempotent</td>
<td style="text-align:center"><code>A.A = A</code></td>
<td style="text-align:center"><code>A + A = A</code></td>
</tr>
<tr>
<td style="text-align:center">Inverse</td>
<td style="text-align:center"><code>A.Ā = 0</code></td>
<td style="text-align:center"><code>A + Ā = 1</code></td>
</tr>
<tr>
<td style="text-align:center">Commutative</td>
<td style="text-align:center"><code>A.B = B.A</code></td>
<td style="text-align:center"><code>A + B = B + A</code></td>
</tr>
<tr>
<td style="text-align:center">Associative</td>
<td style="text-align:center"><code>(A.B).C = A.(B.C)</code></td>
<td style="text-align:center"><code>(A + B) + C = A + (B + C)</code></td>
</tr>
<tr>
<td style="text-align:center">Distributive</td>
<td style="text-align:center"><code>A + B.C = (A + B).(A + C)</code></td>
<td style="text-align:center"><code>A.(B + C) = A.B + A.C</code></td>
</tr>
<tr>
<td style="text-align:center">Absorption</td>
<td style="text-align:center"><code>A.(A + B) = A</code></td>
<td style="text-align:center"><code>A + A.B = A</code></td>
</tr>
<tr>
<td style="text-align:center">De Morgan’s</td>
<td style="text-align:center"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="13.617ex" height="2.523ex" role="img" focusable="false" viewBox="0 -1033 6018.7 1115"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(1194.7,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="1953.7" height="237" x="0" y="148" viewBox="488.4 148 1953.7 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(5.861,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(2231.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(3287.2,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="750" height="237" x="0" y="148" viewBox="187.5 148 750 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.25,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(4259.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mover" transform="translate(5259.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(0,615)"><svg width="759" height="237" x="0" y="148" viewBox="189.8 148 759 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.277,1)"></path></svg></g></g></g></g></svg></mjx-container></td>
<td style="text-align:center"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="13.617ex" height="2.523ex" role="img" focusable="false" viewBox="0 -1033 6018.7 1115"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="2731.4" height="237" x="0" y="148" viewBox="682.9 148 2731.4 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(8.194,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(3009.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(4065,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="750" height="237" x="0" y="148" viewBox="187.5 148 750 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.25,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(4815,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mover" transform="translate(5259.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(0,615)"><svg width="759" height="237" x="0" y="148" viewBox="189.8 148 759 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.277,1)"></path></svg></g></g></g></g></svg></mjx-container></td>
</tr>
<tr>
<td style="text-align:center">Double Complement</td>
<td style="text-align:center"><code>̿A = A</code></td>
<td style="text-align:center"><code>̿A = A</code></td>
</tr>
</tbody>
</table>
</div>
<p><em>打表格太费劲了，下次直接截图算了</em>  </p>
<p><em>下文中出现的<code>Ā</code>或者<code>A'</code>都代表<code>NOT A</code></em></p>
<p>上面的表格展示了在布尔代数中的一系列恒等式。就拿德摩根定律举例子：德摩根定律允许我们交换<code>FALSE</code>和<code>TRUE</code>，或者交换<code>AND</code>和<code>OR</code>来将形式变换掉。  </p>
<p>比如说这里有一个表达式：<code>0.A = 0</code>，读作”FALSE AND A is FALSE”。根据德摩根定律，我们可以将<code>AND</code>换成<code>OR</code>,并将所有元素取反。这样就能得到另一个相等的形式：<code>1 + A = 1</code>。总结一下，德摩根定律的变化法则是：  </p>
<ol>
<li><strong>变换时交换<code>TRUE</code>和<code>FALSE</code>（0和1）</strong>  </li>
<li><strong>变换时交换<code>AND</code>和<code>OR</code>（<code>.</code>和<code>+</code>）</strong>  </li>
</ol>
<p><br></p>
<hr>
<p><span class="tag is-warning">Example</span></p>
<p>来做个例题。  </p>
<p>考虑一下这个表达式：<code>A + Ā.B</code>。我们如何化简它？  </p>
<p>有意思的是，要化简这个式子，我们首先需要将式子先变得更复杂。<br>表中提到了有这样一个公式：<code>A + A.B = A</code>。可以通过这一点把原式中的A换掉，就变成了这样：  </p>
<p>                <code>A + A.B + Ā.B</code>  </p>
<p>下一步我们暂时忽略<code>A</code>，然后对<code>A.B + Ā.B</code>使用交换律。步骤如下：  </p>
<p>                <code>A.B + Ā.B = B.A + B.Ā = B.(A + Ā)</code>  </p>
<p>                <code>B.(A + Ā) = B.1</code>    </p>
<p>这一步应用了公式<code>A + Ā = 1</code>。  </p>
<p>将结果带回原式，即可得到化简最终答案：<code>A + B.1</code>。  </p>
<p><br></p>
<hr>
<h2 id="布尔代数运用"><a href="#布尔代数运用" class="headerlink" title="布尔代数运用"></a><strong>布尔代数运用</strong></h2><h3 id="从真值表中创建布尔表达式"><a href="#从真值表中创建布尔表达式" class="headerlink" title="从真值表中创建布尔表达式"></a><strong>从真值表中创建布尔表达式</strong></h3><p>为特定问题创建布尔表达式，有时可以以真值表作为切入点。  </p>
<p>直接上例子把：  </p>
<p><br></p>
<hr>
<p><span class="tag is-warning">Example</span></p>
<p>我们来举一个两个输出的AND门的例子。真值表如下所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>我们即将使用的”Sum of product”的方法是为真值表中的每一行创建一个最小项，输出为1。然后再对这些最小和求和，得到最终的布尔表达式。  </p>
<p><strong>最小项 (Minterm)</strong>是输出为1的特定组合。<br>在这个真值表里，只有一个最小项，那就是当<code>A = 1</code>或者<code>B = 1</code>时。我们将这个最小项记为<code>A.B</code>。<br>因为这个真值表只有一个最小项，所以说这个真值表的最终布尔表达式就是<code>A.B</code>。  </p>
<p><br></p>
<p>但是如果不只有一个最小项怎么办？或者，表中不只有一个输出项怎么办？  </p>
<p>下面是一个半加法器的真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input</th>
<th style="text-align:center">Input</th>
<th style="text-align:center">Output</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center"><strong>Sum</strong></td>
<td style="text-align:center"><strong>Carry</strong></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>首先，我们对”Sum”这一列输出创建最小项：  </p>
<ul>
<li>第二行 (<code>A = 0</code>, <code>B = 1</code>)，最小项是<code>Ā.B</code> (NOT A AND B)</li>
<li>第三行 (<code>A = 1</code>, <code>B = 0</code>)，最小项是<code>A.B'</code> (A AND NOT B)</li>
</ul>
<p>我们使用<code>OR</code>将所有的最小项连接在一起，这样的话就形成了Sum的布尔表达式：   </p>
<p>                <code>Sum = A'.B + A.B'</code>  </p>
<p>同理可得，<code>Carry = A.B</code>  </p>
<p>化简只能够将两列输出分别对应一个布尔表达式，所以最终的答案是：  </p>
<p><code>Sum = A'.B + A.B'</code><br><code>Carry = A.B</code> </p>
<p><br></p>
<hr>
<h3 id="逻辑电路的布尔代数式"><a href="#逻辑电路的布尔代数式" class="headerlink" title="逻辑电路的布尔代数式"></a><strong>逻辑电路的布尔代数式</strong></h3><p><span class="tag is-warning">Example</span></p>
<p>有时候我们需要通过一个逻辑电路来写出布尔代数式。那这个半加法器电路举例子：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB64571bca6b2aebf3bf9e4ad5d2645fcc?method=download&amp;shareKey=418cfa3d73daa608b02e026411a220d2" alt=""></p>
<p>我们跟着A和B两个输入项，来到了第一个NAND门。根据NAND的真值表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>NAND真值表的前三行都为1，所以我们需要为此构建三个最小项。结合起来如下：  </p>
<p><code>W = A'.B' + A'.B + A.B'</code></p>
<p>下一步，W的输出会去到三个NAND门里进行运算。我们这里以X门举例子。如果要画出X的真值表不是很容易，因此我们会考虑NAND门的本质计算方法，那就是先进行一个AND运算，然后将结果取反，也就是跟一个NOT运算。而AND的结果正式两个值的乘积。  </p>
<p>我们先来进行AND运算：  </p>
<p>                <code>A.(A'.B' + A'.B + A.B')</code>  </p>
<p>接着应用布尔分配式，也就是<code>A.(B + C) = A.B + A.C</code>：  </p>
<p>                <code>A.A'.B' + A.A'.B + A.A.B'</code></p>
<p><code>A.A'</code>的结果是0。在AND运算中，只要输入有0，那么输出必然为0。所以我们可以简化成：  </p>
<p>                <code>A.A.B'</code></p>
<p>因为<code>A.A = A</code>，所以最后化简出来的式子就是：  </p>
<p>                <code>A.B'</code></p>
<p>然而事情到这里还没有结束。因为我们只完成了NAND运算里的AND部分，接下来我们会执行NOT运算，也就是将上面的表达式求逆。根据德摩根定律 (元素取反，AND和OR交换)，我们可以得到原式的逆式：  </p>
<p>                <code>A' + B</code>  </p>
<p>到这一步就可以出X的结果了。同样的流程也可以适用于Y的结果：  </p>
<p>                <code>X = A' + B</code>  , <code>Y = A + B'</code>  </p>
<p>这两位合起来，就是S的输出。同样，我们需要先执行AND运算，再通过德摩根定律执行NOT运算：   </p>
<p>                <code>(A + B').(A' + B)</code> (AND执行后)</p>
<p>                <code>S = A'.B + A.B'</code> (NOT执行后)</p>
<p>C的结论，也可以通过这样的流程算出来了。  </p>
<p><br></p>
<hr>
<h2 id="卡诺图-Karnaugh-map"><a href="#卡诺图-Karnaugh-map" class="headerlink" title="卡诺图 (Karnaugh map)"></a><strong>卡诺图 (Karnaugh map)</strong></h2><p><strong>卡诺图 (Karnaugh map, K-map)</strong>是一种从真值表创建布尔代数表达式的方法。<br>K-map可以使这个过程比使用乘积之和来创建最小项要简单得多。如果应用正确，那么卡诺图就可以生成布尔代数表达式的最简单形式。</p>
<p>下表是一个OR逻辑门的真值表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>我们如果使用Sum of products方式来写出的布尔逻辑式如下:  </p>
<p><code>X = A'.B + A.B' + A.B</code></p>
<p>但是我们如果使用卡诺图，就会比较简单了。下面的卡诺图表示了OR逻辑门：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB63ba74660c841de4a57b6ca299f2a079?method=download&amp;shareKey=1ce8f665aec4c02e372293aa7bb7780a" alt=""></p>
<p>在解读卡诺图时，我们需要遵循这些规则：  </p>
<ul>
<li>只考虑内容为1的单元格</li>
<li>在可能的情况下，尽可能将包含1的单元格以<strong>最大矩形</strong>囊括起来。<strong>而且矩形的面积必须是2，4，8等等</strong>。</li>
<li>每一个矩形可以重叠，但也只是在必要的情况下重叠。尽量做到不重叠矩形。  </li>
<li>如果有单个1无法加入到任何矩形中，那么我们就把它自己视为一个组。</li>
</ul>
<p>这些规则决定了图中的蓝色框框。<br>竖着看：B保持不变，但是A发生了变化，所以B被保留。<br>横着看：A保持不变，所以A被保留。<br><strong>最终的布尔表达式就是这些保留值的和。</strong>，如下所示：  </p>
<p><code>X = A + B</code></p>
<p><br></p>
<hr>
<h1 id="第二十章：系统软件"><a href="#第二十章：系统软件" class="headerlink" title="第二十章：系统软件"></a><strong>第二十章：系统软件</strong></h1><h2 id="操作系统的目的"><a href="#操作系统的目的" class="headerlink" title="操作系统的目的"></a><strong>操作系统的目的</strong></h2><p>我们在第八章就提到了<strong>操作系统 (Operating System, OS)</strong>。本章会详细讨论一些有关于操作系统的更多细节。  </p>
<p>我们可以先从系统使用方面的细节开始：  </p>
<ol>
<li><p>计算机系统需要一个程序，这个程序会在计算机启动时开始运行。我们将其称之为<strong>基本输入/输出系统(Basic input/output system, BIOS)</strong>。BIOS存储在ROM中。它作为一个引导程序，目标是在计算机开始运行时，将操作系统从硬盘引导至内存中，从而使其运行。  </p>
</li>
<li><p><strong>多程序设计 (Multi-programming)</strong>是一个操作系统提供的功能，允许多个程序同时加载到内存中。问题在于在一个特定时间内，只有一个程序能够使用CPU，所以其他程序需要保持准备状态，并在合适的实际轮流使用CPU。这样做是为了最大化利用CPU，因为若当前的程序的输入或输出任务完成后，CPU就可以立即切换到下一个程序。  </p>
</li>
<li><p><strong>分时 (Time-sharing)</strong>是另一个计算机系统中的概念，此概念赋予了多用户同时使用同一个计算机系统的机会。“分时”的概念是指每个用户可以获得使用CPU的一小段时间。具体来说，分时操作系统使用CPU调度和多程序设计，一次为一个用户提供共享计算机的一小部分。每个用户在内存中至少有一个独立的程序。当程序被加载到内存中并执行后，会在短时间内完成IO的处理或者其他处理。用户获得CPU关注的这一小部分时间叫做“时间片 (Time slice)”，“时间段 (Time slot)”或者“量子 (Quantum)”。一般来说它的时间长度约为10-100毫秒。</p>
</li>
<li><p>操作系统的目的可以由两个视角来进行解释，分别是<strong>内部视角 (Internal viewpoint)</strong>和<strong>外部视角 (External viewpoint)</strong>。内部视角主要<u>关注操作系统如何组织其活动以最大化利用资源</u>。这包括管理硬件资源，如CPU、内存和各种存储设备，以及软件资源，如运行进程、系统性能和安全性。操作系统需要保证这些资源被有效的利用，才能提供给用户最棒的性能。 <br> 外部视角主要关注操作系统为用户提供的设施和服务。这些服务包括UI，对运行应用程序的支持，文件管理，网络连接，用户身份验证等等的特性。从这个角度来看，操作系统的目标是为用户提供方便有效的功能和体验。  </p>
</li>
</ol>
<p><br></p>
<hr>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a><strong>操作系统结构</strong></h3><p>操作系统的结构为资源管理和用户提供设施和功能提供了平台。它管理硬件资源，如CPU、内存和存储设备，以及软件资源，如运行进程、系统性能和安全性。它还为用户提供服务，如用户友好的界面、对运行应用程序的支持、文件管理、网络连接和安全特性。  </p>
<p>操作系统的逻辑结构提供了两种<strong>运行模式 (Mode of operation)</strong>，分别是<strong>用户模式 (User mode)</strong>和<strong>内核模式 (Kernel mode)</strong>。具体解释如下：  </p>
<ul>
<li>用户模式：应用程序和部分操作系统的其中一种运行模式。在用户模式下，程序不能直接访问硬件或内存，必须使用系统调用来访问这些资源。  </li>
<li>内核模式：也称为主管模式、系统模式或特权模式。在这种模式下，操作系统可以不受限制地访问所有硬件资源和内存。在内核模式下运行的代码可以直接与系统硬件交互，并且可以执行任何CPU指令。  </li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<p>提供这两种运行模式的操作系统部分是分开的。实际上，操作系统的内核是一直运行的，但操作系统的其余部分会以用户模式持续运行。<br>一种可能的实现方式是使用分层结构，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB46af197e0a665f59df40a434625dc585?method=download&amp;shareKey=4cdc6645cf7b30b5420fab0514c7e926" alt=""></p>
<p>在这种结构中，用户通过用户界面(UI)来操作应用程序，而应用程序通过<em>Utilities</em>来对内核进行调用。为了维护系统的正常运作，每一个较高的层都需要较低的层来提供完整的服务。  </p>
<p><br></p>
<p>虽然但是，上面的这一种结构在实际实践的过程中可能会碰到一些问题。所以说一般的方法是使用一个更加灵活的模块化结构。<br>该结构会在内核需要的时候调用不同的模块来处理工作。这种结构与<strong>微内核结构 (Micro-kernel structure)</strong>联系在一起。<br>简单的解释一下微内核结构：这种结构旨在使内核尽可能小而轻，因为它只提供必要的服务，比如进程调度和进程通信。而大多数非必要的服务，比如说设备驱动程序，会交给用户空间处理。这种设计可以使得操作系统比传统的单片内核更加模块化和灵活。  </p>
<p>具体的结构如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4711318e34bd0f53a9998d0db19e41b0?method=download&amp;shareKey=436d1c8eab09f174959fe0d2ce76c6a9" alt=""></p>
<p><br></p>
<hr>
<h2 id="输入-输出系统-I-O"><a href="#输入-输出系统-I-O" class="headerlink" title="输入/输出系统 (I/O)"></a><strong>输入/输出系统 (I/O)</strong></h2><p>实际上，I/O系统不只是涉及到计算机与用户之间发生的输入和输出，同时也负责了程序运行时对存储设备的输入和输出。<br>下图展示出了I/O系统的结构：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe364bf0aea1ca3b80daa72c698a17b1d?method=download&amp;shareKey=ed789a39365bd63cd1a3e4f0d39c59f9" alt=""></p>
<p>上图中的总线结构说明，I/O设备和内存之间可以有一个数据传输选项，那就是设备驱动。如果对于大量数据来说，操作系统也可以确保在内存和I/O设备之间直接传输数据。  </p>
<p>为了理解I/O的管理问题，我们需要考虑一下时间表。<br>不难理解，一秒钟对于计算机系统来说是一个很长的时间，因为CPU大多运行在GHz频率，所以说一秒钟内会存在超过一万亿个时钟周期。<br>下表给出了I/O的典型速度：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Device</th>
<th style="text-align:left">Data rate</th>
<th style="text-align:left">Time for transfer of 1 byte</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Keyboard</td>
<td style="text-align:left">10 Bps</td>
<td style="text-align:left">0.1s</td>
</tr>
<tr>
<td style="text-align:left">Screen</td>
<td style="text-align:left">50 MBps</td>
<td style="text-align:left">2 * 10^(-8) s</td>
</tr>
<tr>
<td style="text-align:left">Disk</td>
<td style="text-align:left">5 MBps</td>
<td style="text-align:left">2 * 10^(-7) s</td>
</tr>
</tbody>
</table>
</div>
<p>不难看出，这些设备的运行速度和CPU的运行速度简直不是一个数量级。所以说CPU就需要特意注意，在I/O设备交流数据时候，CPU不能进入空闲状态。<br>具体的管理方法会在下一节讨论：  </p>
<p><br></p>
<hr>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a><strong>进程调度</strong></h2><p>在系统运行过程中，为了提供最佳性能，我们需要考虑进程调度的问题。  </p>
<p><strong>CPU调度 (CPU Scheduling)</strong>是操作系统中的一个进程，它允许一个进程在另一个进程因为I/O资源不可用或者暂停（处于等待状态）的时候使用CPU，从而发挥出CPU的最佳性能。<br>CPU调度的目标是让系统更加高效和快速。每当CPU空闲时，操作系统必须在就绪的进程队列中选择一个进程来执行。  </p>
<p><br></p>
<p>对于可以在操作系统上运行的程序来说，他们一开始是存储在磁盘上的。然而，用户可以将这些程序作为“<strong>作业 (job)</strong>”来提交给系统。<br>在操作系统的上下文中，“作业”是系统需要执行的工作单元。这可以是一个程序或一组相关的程序，以及关于它们如何运行的附加信息。<br>一份“作业”中可能包含：  </p>
<ul>
<li>实际需要执行的程序（代码）</li>
<li>程序的输入</li>
<li>有关程序所需的资源信息（如内存或者硬盘空间和地址）</li>
<li>有关如何处理输出的说明（比如说输出应该保存到哪里）</li>
</ul>
<p>一旦作业被提交给系统，操作系统就有责任管理作业的执行。这包括将程序加载到内存中，调度程序的CPU时间，管理程序对其他系统资源的使用，以及处理程序的输出。</p>
<p>在实际的情况中，如果对于多CPU系统来说，调度就会有些更加麻烦了。不过这不是我们目前需要考虑的问题。  </p>
<p><br></p>
<hr>
<p>操作系统中，长期调度器或者高级调度程序可控制选择将存储在磁盘上的程序移入主内存。<br>如果内存过于拥挤，中期调度程序需要负责将某些程序从内存中取回磁盘。<br>当程序已经被记录至在内存中时，一个短期或低级调度程序会控制程序何时可以访问 CPU</p>
<p><strong>长期调度器 (Long-term Scheduler)</strong>又称为准入调度器，负责控制新进程是否可以进入系统。它来决定哪些程序可以从作业池（包括所有进程的磁盘存储）中放入就绪队列，并加载到内存中。它可以确保选择某些合适的进程，以优化CPU的工作效率。  </p>
<p><strong>中期调度器 (Medium-term Scheduler)</strong>可以将进程暂时从主内存中移除，并在主内存空间比较紧张的时候将进程重新放回至磁盘中，使此进程变为“挂起”状态。我们将这个操作叫做<strong>换出 (Swapping out)</strong>或者<strong>滚出 (Rolling out)</strong>。中期调度器也可以评估当前主内存的情况，然后决定时候将挂起的进程重新加入至主内存中继续处理。  </p>
<p><strong>短期调度器 (Short-term Scheduler)</strong>也被称之为CPU调度器，它决定哪些已经就绪，并且存在在内存中的进程可以被CPU执行。短期调度器所做出的决定的频率要比其他两个调度器的频率要高得多，因为为了发挥最大性能，进程之间不允许出现任何中断。  </p>
<p>以上三种调度器在操作系统中一起工作，可以有效地管理进程，从而确保每个进程都获得成功执行所需的必要资源和CPU时间。</p>
<article class="message is-info"><div class="message-body">

<b>High-level scheduler: makes decisions about which program stored on disk should be moved into memory</b>

<br>

<b>Low-level scheduler: makes decisions about which process stored in memory should have access to the CPU</b>

</div></article> 


<p><br></p>
<p>所以说在运行程序时，涉及到的硬件之间的交流大概是这样子的：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB610a4dc613998d58c627e8e4f898e1e9?method=download&amp;shareKey=c5b0a214a907c69b16add3526f02c906" alt=""></p>
<p><br></p>
<hr>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h3><p>在第八章中，我们提到过：进程可以定义成“正在运行中的程序”。这个定义可以进一步加入程序第一次进入内存时的状态，来改进进程的定义。具体来说，当一个进程第一次进入到内存后，它的状态就可以叫做“新”。在这一阶段，我们可以在内存中创建一个叫做<strong>进程控制块 (Process control block, PCB)</strong>的东西，以便我们在进程执行的同时读取有关它的数据。<br>PCB是一个数据结构，操作系统可以用它来管理进程的信息。这些信息包括如下细节：  </p>
<ul>
<li><strong>进程的状态</strong>： 进程的当前状态（比如说是新，就绪，运行，挂起还是停止）</li>
<li><strong>进程ID (PID)</strong>： 这是进程的唯一标识码</li>
<li><strong>程序计数器 (Program counter)</strong>： 老朋友了。表示该进程要执行的下一条指令的地址。</li>
<li><strong>CPU寄存器</strong>： 该进程目前正在使用的CPU寄存器</li>
<li><strong>CPU调度信息</strong>： 调度进程所需的信息。可能包含优先级信息以及调度队列的指针</li>
<li><strong>I/O信息</strong>： 分配给进程的I/O设备，或者打开文件的列表等等</li>
</ul>
<p>除了列出的条目，PCB中还存在更多的细节。这里就不展开说了。  </p>
<p>一旦进程进入内存，并且设置好了PCB，进程的状态就可以随着它开始执行和与系统交互而改变。例如，当进程使用CPU的时候，进程的状态就可能从“就绪”变成“运行”。如果进程在等待用户的输入，那么它的状态就可能从“运行”变成“等待”。等等。</p>
<p>哦对了，一个进程可以拆分成不同的部分来执行，这些独立的部分叫做“<strong>线程 (Threads)</strong>”。</p>
<article class="message is-info"><div class="message-body">

<b>Process: a program in memory that has an associated control block</b>

<br>

<b>Process control block (PCB): a complex data structure containing all data relevant to the running of a process </b>

<br>

<b>Thread: part of a program which is handled as an individual process when being executed</b>

</div></article> 



<p><br></p>
<p>进程处理的流程如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB095855ea3e9913fa7d4f1105b18fc94e?method=download&amp;shareKey=bdfecf61b430451e5608fbdeff7b04b7" alt=""></p>
<p><br></p>
<hr>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a><strong>中断</strong></h3><p>有些时候，中断是因为过早终止正在运行的进程而引起的。除此之外，中断的发生也有其他两种可能性：  </p>
<ol>
<li><p>进程由交替使用CPU和I/O的处理时段共同组成。然而I/O需要的时间太长，而且CPU不可能一直闲置等待 I/O 完成。因此当处于运行状态的进程发出需要进行 I/O 操作的系统调用，并不得不转入等待状态时，就会使用中断机制。</p>
</li>
<li><p>调度程序决定停止进程的原因有多种，稍后将在 “调度算法”标题下讨论。</p>
</li>
</ol>
<p>不管发生中断的原因是什么，操作系统的内核都必须需要调用一个中断处理例程来尝试处理问题。首先，我们必须要将程序运行过程中，存储在寄存器中的当前值记录在进程控制块，也就是刚才说过的PCB中。这允许系统可以重新拾起这个进程，然后重新开始处理终端的进程。  </p>
<p><br></p>
<hr>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a><strong>调度算法</strong></h3><p>尽管长期调度器在选择将哪个程序加载到内存时需要做出决定，但这里我们只关注短期调度器或低级调度器的选项。  </p>
<p>首先，调度算法可以是<strong>抢占式 (Preemptive)</strong>的或<strong>非抢占式 (Non-preemptive)</strong>的。抢占式算法可以停止进程，否则进程将继续不受干扰地运行。如果一个算法是抢占式的，那么它可能需要涉及进程优先级的考虑工作。所谓 “抢占式”，是指当进程的分配时间（或时间片）过期时，调度器可以强行将其从 CPU 中移除。这与非抢占式调度相反，在非抢占式调度中，进程一直运行到结束或被 I/O 阻塞为止。</p>
<p>这时候我们可以使用<strong>轮询算法 (Round-robin algorithm)</strong>来处理问题。这是一种抢占式算法，是操作系统中最简单的进程调度算法之一。在轮转调度中，每个进程都被分配了一个固定的时间片。如果这个进程所分配的时间片用完了，那么这个进程会被直接停止掉。  </p>
<p>当然，进程如果以某些奇怪的方式停止掉以后，在某些情况下我们还会希望他们继续回来执行。因此，轮询算法还可以用来实现<strong>FIFO队列 (FIFO queue)</strong>，也就是“先进先出队列”来实现。进程被添加到队列的末尾，并按照到达的顺序分配 CPU。一旦某个进程轮到使用 CPU（即其时间片已过期），它就会被移到队列的后面。</p>
<p>基于优先级的调度算法则更为复杂。其中一个原因是，每次有新进程进入就绪队列或运行中的进程停止时，都需要重新评估进程的优先级。另一个原因是，无论使用什么方案来判断优先级，都需要进行一定的计算。可能的标准有：  </p>
<ul>
<li>进程执行的所需估计时间</li>
<li>进程执行剩余的时间</li>
<li>在就绪队列中已经花费的时间长度</li>
<li>进程是I/O绑定还是CPU绑定</li>
</ul>
<p>显然，在上面列出的条目里，估计执行时间并非易事。<br>有些程序需要大量的输入输出，例如为员工打印工资条。此类进程的CPU使用很少，因此为其分配高优先级是有意义的，这样就可以进行少量的CPU使用。然后，在打印发生时，就可以将本流程切换到等待状态了。</p>
<p><br></p>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h2><p>“内存管理”一词包含如下方面：</p>
<ul>
<li>内存管理为操作系统内核提供受保护的内存空间</li>
<li>将程序加载到内存中需要做准备工作，而内存管理可以为程序本身、相关的过程和程序所需的数据定义内存地址</li>
<li>当运行在多程序设计的计算机上时，内存管理就相对来说比较复杂了。与存储在硬盘上的文件一样，进程在主内存中的存储也会产生碎片。这时，中期调度器可能需要将进程移出主内存，以缓解问题。</li>
<li>内存管理必须决定应该将多大一部分内存分配给共享内存的各个进程。</li>
</ul>
<p><br></p>
<hr>
<h3 id="分区与段"><a href="#分区与段" class="headerlink" title="分区与段"></a><strong>分区与段</strong></h3><p>当不同的进程同时加载到内存中时，早期的内存管理方法是对内存进行<strong>分区 (Partition)</strong>，它的目的是尽可能将整个进程加载到一个分区中。但是如果进程的大小小于分区大小，就会浪费内存。<br>后续出现的其中一个改进方法是“<strong>动态分区 (Dynamic partitioning)</strong>”，其中允许调整分区大小以匹配进程大小。然而每个分区一个进程的规则仍然存在。</p>
<p>具体来说，分区是一种将计算机内存划分为多个分区的方法，每个分区可容纳一个进程。其目的是将一个进程的全部内容加载到一个分区中。不过，如果进程的大小小于分区的大小，这种方法可能会造成浪费，导致分区内的内存闲置。</p>
<p>动态分区是对最初方法的改进。在动态分区中，我们允许调整分区的大小以匹配进程的大小。这有助于确保每个进程只使用其所需的内存，从而减少内存浪费。不过，每个分区只能容纳一个进程的规则仍然存在，这意味着每个分区一次只能容纳一个进程。  </p>
<p><br></p>
<p>上述思想拓展出了另一个解决方案，那就是<strong>分段 (Segmentation)</strong>。分段是操作系统中的一种内存管理技术，它将计算机的主内存划分为大小可变的部分，称为<strong>段 (Segments)</strong>。其中的每个段可分配给一个进程。每个段的详细信息都存储在一个称为<strong>段表 (Segment table)</strong>的表格中。</p>
<p>分段被描述为动态分区思想的延伸，因为如果一个进程太大，那么它就无法容纳在一个分区中。所以将其划分为更小的段会是一个潜在的解决方案。然后，每个分段都可以加载到内存中的动态分区中。这种方法可以更高效地处理大型进程，因为每个分段都可以根据需要独立加载或卸载。 这也有助于减少外部碎片，因为分段可以更整齐地嵌入可用内存空间。</p>
<p><br></p>
<hr>
<h3 id="分页与虚拟内存"><a href="#分页与虚拟内存" class="headerlink" title="分页与虚拟内存"></a><strong>分页与虚拟内存</strong></h3><p>在现代计算机系统中，我们一般使用<strong>分页 (Paging)</strong>的方法来管理内存。<br>分页是一种不需要连续分配物理内存的方案，它允许计算机的物理内存以不连续的方式记录。在分页中，进程会被划分为长度相等的部分，我们将这些部分称之为“<strong>页 (Page)</strong>”。  </p>
<p>在操作系统内存管理中，内存可以被划分为固定长度的块，我们将其称为“<strong>帧 (Frames)</strong>”。<br>二级存储器(如硬盘)也可以划分为固定大小的块，通常称为“<strong>扇区 (Sectors)</strong>”或“<strong>集群 (Clusters)</strong>”，但在这里也可以称为“帧”。这些块可以保存从主内存换出的页。  </p>
<p>操作系统会跟踪哪些帧是空闲的，哪些帧是正在使用的。当程序需要将一页加载到内存中时，操作系统会找到一个空闲帧，并将该页加载到其中。如果没有空闲帧，操作系统可能需要换出当前内存中的一页，为新页腾出空间。这种技术允许操作系统有效地利用内存和辅助存储，并支持虚拟内存等特性，其中程序可以比物理内存的总量更大。</p>
<p>将所有的页同时加载到内存中实际上是可行的（如果你的计算机内存够大）。<br>但即使这是可能的，通常情况下我们也不需要使用程序的所有部分。因此将某些页放回二级存储是必要的。  </p>
<article class="message is-info"><div class="message-body">

<b>Segmentation: where a large process is divided into segments for loading into memory but the segments are not constrained to be the same size</b>

<br>

<b>Paging: where a large process is divided into pages which have to be the same size</b>

</div></article> 

<p><br></p>
<hr>
<p>这就引出了一个新的概念。  </p>
<p>分页使用的一种特殊情况是，如果程序非常大，其所需的地址空间可能会大于内存大小。<br>这时候，我们就会需要用到分页技术支持的<strong>虚拟内存管理 (Virtual memory management)</strong>来解决这种情况了。  </p>
<p>分页在执行过程中会要求CPU将地址传输到<strong>内存管理单元 (Memory management unit, MMU)</strong>，内存管理单元负责为每一个“页”分配地址。这个地址必须由两个部分组成，分别是“页码”加上该页起始处的“偏移量”。  </p>
<p>内存管理单元负责将CPU中的逻辑地址转换为内存中的物理地址。它使用一种称为<strong>页表 (Page table)</strong>的数据结构来实现这一点，页表跟踪每个页在物理内存中的位置。地址的页码部分用作页表的索引。该索引处的页表项包含物理内存中该页的基址。然后将偏移量添加到该基址，以获得所需的确切物理内存位置。</p>
<p><br></p>
<hr>
<p>有些抽象，所以我们来简单展示一个非常简化的页表：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb1fe4ad9a625703c2201225483bf201d?method=download&amp;shareKey=8b6556ecb3677f52577831150b8e3f84" alt=""></p>
<p>图片的左侧展示了一个有48条指令的程序，不难看出，这些指令占用了3个页。反过来说，这3页占用了48条内存地址。  </p>
<p>该系统的逻辑地址采用8个位存储。因为一个字节(8位)可以表示256个不同的值(从0到255)，而我们只使用16页，所以我们只需要前4位来表示页码(因为<code>2^4 = 16</code>)。剩下的4位用来表示页面内的偏移量。所以说在本系统中，逻辑地址被分为了两个部分，而他们的表示方式为：  </p>
<ul>
<li>四个最高位存储页码。</li>
<li>四个最低有效位将偏移量存储在页面中。  </li>
</ul>
<p>这使得系统可以通过其页码和偏移量快速有效地定位内存中的任何指令。  </p>
<p><br></p>
<p>而图表的右半部分展示了各个页的物理内存地址。在继续之前，我们需要先强调，<strong>页帧 (Page frame)</strong>和帧之间没啥区别。  </p>
<p>好的，我们继续。  </p>
<p>需要注意的是，所使用的页帧不必在物理内存中相邻。这意味着程序的不同部分可以加载到不同的内存区域，而不必彼此相邻。这是分页和虚拟内存的优点之一，因为它允许更有效地使用内存。从图中我们可以得到，程序的前两个页已经被加载到内存中的页帧中。  </p>
<p>图表中间的部分说明了此流程中页表的内容。在分页系统中，内存中的每个进程都有一个单独的页表。页表中每个页都有条目，而页码会作为索引。<br>表中的每个条目都包含一个表示该页当前是否在内存中的存在标志，我们叫它”<strong>Presence flag</strong>“，如图中第二列所示。<br>在这里显示的版本中，第三个条目显示了页帧号。或者，这可以记录页面框架中第一个项目的物理地址。它可以记录页面框架中第一个项目的物理地址。  </p>
<p><br></p>
<p>在使用分页的时候，在最开始的开始，包含一个进程的一组页会存储在磁盘上。在进程切换到“就绪”状态时，其中的一个页或者多个页就会被加载到内存中。当进程被指派为“运行”状态时，进程就可以开始执行了。  </p>
<p>然而，有些时候，进程可能会请求访问地址不在内存中的页，我们管这种情况叫做“<strong>缺页异常条件 (Page fault)</strong>”，或者更简单的说法——页面错误。<br>当出现页面错误时，操作系统需要将所需的页面从辅助存储(如硬盘)带到内存中。但是，如果没有可用的空闲内存，操作系统将需要选择一个当前加载的页面来替换。这就是<strong>页面替换算法 (Page replacement algorithm)</strong>发挥作用的地方。  </p>
<p>有好几种页面替换算法，比如说：  </p>
<ul>
<li><p><strong>先进先出 (First-in First-out, FIFO)</strong>:这个简单的算法替换内存中最老的页面(即，首先加载的页面)。虽然易于实现，但如果仍然频繁访问旧页面，则此方法可能导致更高的页面错误率。  </p>
</li>
<li><p><strong>LRU (Least Recently Used)</strong>:这个方法会替换最长时间未被访问的页面。它基于这样一种观察，即最近被大量使用的页面很可能在将来再次被大量使用。虽然这种方法通常执行得很好，但它需要跟踪每个页面最后访问的时间，所以这种方法带来的计算量就会变得更大一些。  </p>
</li>
</ul>
<p><br></p>
<p>虚拟内存可能会带来一些问题。可能出现的最严重的问题之一是<strong>磁盘抖动 (Disk thrashing)</strong>。当进程不断地需要在内存内和内存外交换页面时，就会发生这种情况。简单来说，虚拟存储管理中的抖动现象是指系统频繁地进行磁盘交换，导致系统的性能下降的现象。  </p>
<p>比如说当系统内存不足时，操作系统会将一部分数据交换到磁盘中以释放内存。但是，当系统再次需要这些数据时，又需要将其从磁盘中加载回来，这就会产生磁盘交换。当系统的内存利用率接近饱和状态时，这种抖动现象会变得更加明显。因为系统需要频繁的交换数据，导致磁盘的负载变高，同时也降低了系统的响应速度和性能。为了避免这种情况的发生，我们可以增加系统内存，或者优化虚拟内存的存储策略来缓解问题。</p>
<article class="message is-info"><div class="message-body">

<b>Disk thrashing: when paging is being used and a repetitive state has been reached where loading one page causes a need for another page to be loaded almost immediately but the loading of this new page causes the same immediate need</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="提供给用户的操作系统设施"><a href="#提供给用户的操作系统设施" class="headerlink" title="提供给用户的操作系统设施"></a><strong>提供给用户的操作系统设施</strong></h2><p>操作系统需要让用户来使用，所以它需要提供<strong>用户界面 (User interface, UI)</strong>。用户界面可以以命令行、图形显示或语音识别系统等方式来体现，但是请记住，用户界面的功能始终是允许用户与正在运行的程序进行交互。  </p>
<p>当程序涉及到设备的使用时，操作系统提供<strong>设备驱动程序 (Device driver program)</strong>。  </p>
<p>操作系统还必须提供一个<strong>文件系统 (File system)</strong>来存储数据和程序。在实际使用的时候，用户必须选择用户名并组织文件在文件夹中的结构，但是用户用不着管理磁盘上的物理数据是怎样存储的——因为这些是文件系统的活儿。  </p>
<p>如果用户是程序员，则操作系统支持提供<strong>编程环境 (Programming environment)</strong>。这样，程序员就可以在操作系统的帮助下，即便在不熟悉处理器功能的情况下也能创建和运行程序。  </p>
<p>当一个程序被运行时，我们可以将其认为是一个<strong>用户类型 (Type of user)</strong>，程序就像人类用户可能通过单击或键入来告诉计算机要做什么一样，程序使用一种称为<strong>系统调用 (System call)</strong>的东西向操作系统发出请求，这些类似于程序的点击或输入方式。例如，如果程序需要从文件中读取数据，它不会去查找文件本身。相反，它使用系统调用来要求操作系统执行此操作。然后操作系统接管，找到文件，并将数据提供给程序。<br>这样就引申出来了一个新的概念，叫做<strong>程序编程接口 (Application programming interface, API)</strong>。API就像操作系统为程序提供的选项菜单。菜单上的每个选项(每个API调用)都做一件特定的事情，比如在屏幕上创建一个图标。为了完成它的工作，API调用可能会使用一个或多个系统调用。  </p>
<p><br></p>
<hr>
<h2 id="转译软件"><a href="#转译软件" class="headerlink" title="转译软件"></a><strong>转译软件</strong></h2><p>同样是在第八章，我们概述了编译器和解释器的使用与特性。现在我们来深入介绍一下解释器的工作原理，并同时介绍解释器的工作原理。<br>编译器和解释器的编写工作是一项专业性极强的工作，通常情况下都由专家完成，而每个人的编写方式都各不相同。因此，本小节会探讨一些比较常见的思路。  </p>
<p>编译器可以被分解成一个“前端”和“后端”。前端程序对代码进行分析，它检查代码的语法和语义，确保它遵循编程语言的规则并具有逻辑意义。如果没有错误，它会生成<strong>中间代码 (Intermediate code)</strong>。中间代码是一种完全捕获源代码含义(语义)的表示形式。  </p>
<p>而编译器的“后端”将这些中间代码作为输入。然后，它从这个中间表示合成或创建目标代码。目标代码是计算机能够执行的最终机器码。</p>
<p>这样的一个分析-综合模型如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf24bfb42acabc62fca77dde3bd4bec2e?method=download&amp;shareKey=d093f91182e7f059ae2d0bd2ce3188aa" alt=""></p>
<p><br></p>
<p>先说好，我们假设上面的结构处理的源代码没有任何错误。接下来我们解释一下每一个步骤：  </p>
<p>首先，源代码是逐行读取的，而且是重复逐行读取的。对于每一行来说，编译器都会生成它们对应的中间代码。上图还展示了解释器程序如何在前端进行分析过程。在这种情况下，一旦发现某一行源代码没有错误，并将其转换为中间代码，就会执行该行源代码。  </p>
<p><br></p>
<hr>
<h3 id="前端分析阶段"><a href="#前端分析阶段" class="headerlink" title="前端分析阶段"></a><strong>前端分析阶段</strong></h3><p>如下图所示，我们可以将前端的处理阶段分成这样的四个部分：  </p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>生成中间代码</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd56b4dd092332686b3ab5445260b5bc7?method=download&amp;shareKey=6fc3b6e0d1356832c10556ca79b3112b" alt=""></p>
<p><br></p>
<p>编译器或解释器的输入数据是程序的源代码，我们叫它<strong>字符序列 (Sequence of characters)</strong>，而<strong>词素 (Lexeme)</strong>是这个序列中一个有意义的单个字符或字符集合。 例如，词素可以是程序员定义的标识符（如变量名），也可以是编程语言预定义的关键字、运算符或符号。</p>
<p><strong>第一步：词法分析</strong>：就是将源代码分解为这些单个词法的过程。<br>一种方法是首先删除源代码中的所有空白（空格、制表符、换行符）和注释。然后，检查源代码的每一行并识别每个词素。简单来说，词法分析就像是将一个句子分解成一个个单词，并了解每个单词在句子中的作用。  </p>
<p>以伪代码的形式表述：<code>Var Count : integer;</code>，会被解释成一个存在五个词素的指令，分别是<code>Var Count : integer ;</code>。<br>同样，<code>PercentMark[Count] := Score * 10</code>会被解释成一个存在八个词素的指令，分别是<code>PercentMark [ Count ] := Score * 10</code>。</p>
<p>词法分析器现在必须对每个词素进行分类，以便将代码行标记化。例如，在第一个例子中，<code>var</code>和<code>integer</code>必须被识别为关键字，<code>;</code>被识别为标识符，<code>:</code>以及<code>;</code>必须被视为不同的词素。  </p>
<p>对于每个识别到的标识符，我们都必须在<strong>符号表 (Symbol table)</strong>中创建一个条目。符号表中包含了每个标识符的属性，比如说数据类型，在何处被声明以及在何处被赋值。<br>符号表是编译器的一个重要的数据结构，虽然上面的的图显示了它只会在语法分析程序中使用，但是到了后期的编译阶段，我们同样也会继续使用它。<br>值得强调的是，因为大多数的编译器是多遍的，所以说符号表里面的内容是可以频繁的更新的。  </p>
<article class="message is-info"><div class="message-body">

<b>Symbol table: a data structure in which each record contains the name and attributes of an identifier</b>

</div></article> 


<p>也不是所有的内容都可以转换为标识符，所以我们需要另一个表来记录非标识符词法的内容。<br>总之，无论采用何种方案，词法分析的输出都是源代码的分词版本。文献中提到了用于表示标记的各种格式。  </p>
<p><br></p>
<p><strong>第二部：语法解析</strong>：也称之为解析，涉及对程序结构的分析。分析的结果会被记录为语法或者是解析树。<br>下面的图片展示了这个语句”<code>y := 2 * x + 4</code>“的解析树：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6b978d0fb2694bec7ddd774abcc1002f?method=download&amp;shareKey=1b501575072ae80fbfdf497e7eedd173" alt=""></p>
<p>如果树被成功的解析了，那么程序会在+4之前先去将x乘以2。  </p>
<p><br></p>
<p><strong>第三步：语义分析</strong>：语义分析是为了确定代码的全部含义。 为记录这些信息，我们构建了一棵带注释的抽象语法树。 对于语法树中的标识符，会建立一套相关的属性，包括数据类型等。 这些属性也记录在符号表中。  </p>
<p>前端分析的最后阶段经常创建的中间代码的格式是三地址码。例如，下面的赋值语句有5个标识符，对应5个地址:</p>
<p><code>y := a + (b * c - d) / e</code></p>
<p>这一个赋值语句可以转换为以下4个语句，每个语句最多需要3个地址:  </p>
<p><code>temp := b * c</code><br><code>temp := temp - d</code><br><code>temp := temp / e</code><br><code>y := a + temp</code></p>
<p><br></p>
<hr>
<h3 id="语言的语法表示"><a href="#语言的语法表示" class="headerlink" title="语言的语法表示"></a><strong>语言的语法表示</strong></h3><p>每种编程语言都有自己定义的语法。为了使语言可以正常使用，这个语法必须被程序员和编译器作者理解。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7b03490853d0d2cbcbdc90b52d54a871?method=download&amp;shareKey=a8b731d4fbb0228ee6936de7dfb9896a" alt=""></p>
<p>表示语法的一种方法是使用<strong>语法图 (Syntax diagram)</strong>，上图就是一个实例语法图。<br>比如，上面的语法图规定了这样一条语法规则：标识符必须以字母开头，而后面可以是无字符或者多个字母或数字的集合。  </p>
<p><br></p>
<p>另一种方法是使用<strong>巴科斯范式 (Backus-Naur Form)</strong>来表示。下面是一些使用巴科斯范式的例子：  </p>
<p><code>&lt;Identifier&gt;::=&lt;Letter&gt;|&lt;Identifier&gt;&lt;Letter&gt;|&lt;Identifier&gt;&lt;Digit&gt;</code><br><code>&lt;Digit&gt;::=0|1|2|3|4|5|6|7|8|9</code><br><code>&lt;Letter&gt;::=&lt;UpperCaseLetter&gt;|&lt;LowerCaseLetter&gt;</code><br><code>&lt;UpperCaseLetter&gt;::=A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z</code><br><code>&lt;LowerCaseLetter&gt;::=a|b|c|d|e|f|g|h|i|j|K|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z</code></p>
<p>在巴科斯范式中，<code>|</code>为了分离单独的每一个选项，<code>::=</code>可以被描述成“被定义为”。<br>在上面的例子中，<code>&lt;Identifier&gt;</code>是使用递归的方式定义的。但如果我们要定义的内容无法抽象到这个级别，那么我们也可以使用列举的方式定义内容。  </p>
<p><br></p>
<hr>
<h3 id="后端合成阶段"><a href="#后端合成阶段" class="headerlink" title="后端合成阶段"></a><strong>后端合成阶段</strong></h3><p>如果前端分析已经确定源代码存在语法错误，那么后端过程的唯一目标就是通过列表的形式来呈现这些错误。<br>每个发生的错误，都会有两个属性：错误的解释和在程序源代码中的位置。这些信息可以帮助到程序员，让他们更方便的调试软件。  </p>
<p>但是如果在没有错误的情况下，主要的后端阶段是从中间代码生成机器代码，同时可能涉及代码优化。<br>优化的目的是创建一个高效的程序。有一种优化方式专注于优化原始源代码中固有的、已经传播到中间代码中的特性。<br>举个简单的例子，以下连续的赋值语句:  </p>
<p><code>x := (a + b) * (a - b)</code><br><code>y := (a + 2 * b) * (a - b)</code></p>
<p>它的优化方式就可以是这样：  </p>
<p><code>temp := (a - b)</code><br><code>x := (a + b) * temp</code><br><code>y := x + temp * b</code></p>
<p><br></p>
<hr>
<h3 id="表达式的求值"><a href="#表达式的求值" class="headerlink" title="表达式的求值"></a><strong>表达式的求值</strong></h3><p>赋值语句通常是一个为标识符定义新值的代数表达式。<br>计算表达式时，首先要将代码中的中缀表示法转换为<strong>反向波兰表示法(Reverse Polish Notation, RPN)</strong>。<br>在 RPN 中，运算符（如 +、-、*、/）写在操作数的后面。例如，表达式 <code>5 + 3</code> 在 RPN 中会写成 <code>5 3 +</code>。这可以简化表达式的求值过程，因为一旦将表达式转换成 RPN，就可以从左到右地求值，而无需跟踪优先级规则或括号。  </p>
<p>举一些例子:  </p>
<p>Absolutely! Here are some examples of Reverse Polish Notation (RPN):</p>
<ol>
<li><p>中缀表示法: <code>2 + 3</code><br>RPN: <code>2 3 +</code></p>
</li>
<li><p>中缀表示法: <code>4 * 5</code><br>RPN: <code>4 5 *</code></p>
</li>
<li><p>中缀表示法: <code>(1 + 2) * 3</code><br>RPN: <code>1 2 + 3 *</code></p>
</li>
<li><p>中缀表示法: <code>2 + 3 * 4</code><br>RPN: <code>2 3 4 * +</code></p>
</li>
<li><p>中缀表示法: <code>(7 - 2) / (5 + 3)</code><br>RPN: <code>7 2 - 5 3 + /</code></p>
</li>
</ol>
<p><br></p>
<hr>
<h3 id="计算RPN表达式"><a href="#计算RPN表达式" class="headerlink" title="计算RPN表达式"></a><strong>计算RPN表达式</strong></h3><p>我们可以使用栈来计算RPN表达式。<br>让我们下面这个RPN表达式的执行，其中x的值为3,y的值为4:</p>
<p><code>x 2 * y 3 * + 6 /</code>  </p>
<p>这里遵循的规则是依次将值添加到栈中。<br>如果RPN表达式中的下一项是操作符，则进程中断。这将导致前两个元素从栈中弹出。<br>随后需要使用运算符从这两个值创建一个新值，并将新值添加到栈中，然后该过程继续进行。<br>下图给出了栈的连续内容，指出了何时使用了操作符。当弹出两个值时，栈的中间状态不会显示。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB662084ed9ed021ff6fdb92d969139a44?method=download&amp;shareKey=2cbcbaa31654831501c5c03da8282b42" alt=""></p>
<p>如果使用的是第6章讨论的具有有限指令集的简单处理器，那么RPN的使用就没有什么价值。<br>因为现代处理器的指令集中会有处理堆栈操作的指令，因此编译器可以将表达式转换为RPN，因为它知道将表达式转换为机器码可以利用这些内容并允许在程序执行中进行堆栈处理。 </p>
<p><br></p>
<hr>
<h1 id="第二十一章：数据安全"><a href="#第二十一章：数据安全" class="headerlink" title="第二十一章：数据安全"></a><strong>第二十一章：数据安全</strong></h1><h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a><strong>加密原理</strong></h2><p>在计算机系统中，加密可以用来作为存储数据的常规方法。不过，本章讨论的加密的重点是在数据通过网络的传输时而使用。  </p>
<p>本章会主要探讨下面这三个问题：  </p>
<ul>
<li>加密算法是不是足够稳健，以至于加密数据不会对未经授权的第三方应用（或者任何个体）解密？  </li>
<li>如何确认加密数据时用的密钥，是保密的呢？  </li>
<li>通信的接收者如何知道是谁发送了加密通信？  </li>
</ul>
<p><br></p>
<p>加密的流程如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb68b5fb3de1daa54df1157f381a26d05?method=download&amp;shareKey=c1aab18fd4fb3279e4b3fa0eec64dcb8" alt=""></p>
<p>首先，数据以<strong>明文 (Plaintext)</strong>的形式进入加密环节。首先，明文会使用<strong>密钥 (Key)</strong>进行<strong>加密 (Encryption)</strong>步骤。<br>明文经过加密后，就会变成<strong>密文 (Ciphertext)</strong>，随后密文就会被发送到它传输的目的地。<br>当另一台计算机收到了密文的时候，它也可以使用密钥来对密文进行<strong>解密 (Decryption)</strong>来还原原本的明文。</p>
<article class="message is-info"><div class="message-body">

<b>Plaintext: data before encryption</b>

<br>

<b>Ciphertext: the result of applying an encryption algorithm to data</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a><strong>安全问题</strong></h3><p>在进行加密传输的时候，下面这些安全问题确实是值得一提的：  </p>
<ul>
<li><strong>保密性 (Confidentiality)</strong>：确保只有接收方能解密密文，而其他未经授权的终端无法解密密文</li>
<li><strong>真实性 (Authenticity)</strong>：接收方能够确定到底是谁发送了密文</li>
<li><strong>完整性 (Integrity)</strong>：密文在传输过程中无法发生修改</li>
<li><strong>不可否认性 (Non-repudiation)</strong>：发送方和接收方都不能否认参与了数据的传输</li>
<li><strong>可用性 (Availability)</strong>：不应该发生任何事情来阻止接收方接收传输</li>
</ul>
<p>而在本章的讨论中，我们只考虑前三点：保密性，真实性和完整性。<br>由于讯息在传送过程中可能会被截取，而内容可能会被未获授权的人士阅读，因此我们需要考虑保密性问题。<br>同时对完整性的关注反映了这样一个事实:传输可能被故意干扰，但也可能在传输过程中意外损坏数据。  </p>
<p><br></p>
<hr>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a><strong>加密方法</strong></h3><p>对于加密算法来说，首先它不能被保密，这意味着加密算法必须在公共领域公开。而且，加密密钥必须是保密的。<br>加密一般来说有两种常用的策略，一种是<strong>对称密钥加密 (Symmetric key encryption)</strong>，另一种是<strong>非对称密钥加密 (Asymmetric key encryption)</strong>，也称为<strong>公钥加密 (Public key encryption)</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Symmetric key encryption: one private key is held by both sender and receiver and is used for both encryption and decryption</b>

<br>

<b>Asymmetric key encryption: there is a public key and a private key one of which is used for encryption and the other for decryption</b>

</div></article> 

<p><br></p>
<p>在对称密钥加密中，我们自始至终只会用到一个密钥，而这个密钥只有消息的发送端和接收端知道。“只会用到一个密钥”的意思是：发送方会使用这个密钥加密信息，而接收端同时也会使用这个密钥来解密信息。  </p>
<p>而对称密钥加密就不是这种方式了，因为加密和解密的密钥不同，所以密钥的传递就会变成一个大问题。<br>发送方需要密钥来加密，但如何将密钥安全地传递给接收方以允许解密呢？<br>在非对称密钥加密中，使用两个不同的密钥，一个用于加密，另一个用于解密。两个密钥中只有一个是保密的。所以说如果我们要使用非对称密钥加密，那么发送端手中会有两个密钥，其中一个是公钥，而且这个公钥可以被发送给任何想要参与通信的人，而另一个密钥是永远不会发送给任何人的秘密私钥。如果某人(发送方)想要向密钥持有者(接收方)发送安全消息，他们使用接收方的公钥对消息进行加密。此过程将原始消息(明文)转换为不可读的格式(密文)。一旦接收方获得密文，他们可以使用他们的私钥将其解密回原始消息。因为只有接收方可以访问他们的私钥，所以他们是唯一可以解密和读取消息的人。公钥可以被多人共享。这意味着任何数量的人都可以向接收者发送安全消息，并且只有接收者能够解密和读取这些消息。  </p>
<p>需要注意以下两点：  </p>
<ul>
<li>如果两个人需要双向通信，那么通信的双方都需要一个私钥，并且必须将匹配的公钥发送给另一个人。  </li>
<li>要确保传输被截获和消息被提取时的机密性，必须满足两个要求：加密算法必须复杂，而且用于定义密钥的位数必须很大 （防止暴力穷举）。  </li>
</ul>
<p><br></p>
<hr>
<h2 id="数字签名与电子证书"><a href="#数字签名与电子证书" class="headerlink" title="数字签名与电子证书"></a><strong>数字签名与电子证书</strong></h2><p>上面提到的非对称加密，是一种使用两个不同密钥的加密类型，包括用于加密的公钥和用于解密的私钥，反之亦然。每一个个体都可以用他们的私钥加密消息。然后可以将此加密消息发送给拥有相应公钥的收件人。同时，接收方可以使用公钥将接收到的密文解密回原始消息。但因为公钥的公开性，这就导致了非对称加密不保证数据的完全保密，因为任何人都可能获得公开密钥，从而可以解密信息。  </p>
<p>不过，这种方法可用来验证发件人是谁。 由于只有发件人才拥有私人密钥，而公钥只对特定的私人密钥起作用，如果收件人发现解密成功，就意味着该信息一定是用相应的私人密钥加密的。 因此，它验证了信息确实是由私钥持有者发送的。 这就是所谓的数字签名。  </p>
<p><strong>数字签名(Digital Signature)</strong>是一种特定类型的电子签名，它要求签名者使用基于证书的数字ID来 <u> 验证其身份 </u>。数字证书通常由独立的证书颁发机构(CA)颁发，CA在颁发证书之前验证签名者的身份。  </p>
<p>现在来看，电子签名是使用非对称加密算法的公钥和私钥实现的：发送方使用他们的私钥加密消息。这就像用只有寄件人才有的私人印章来封一封信一样。而接收方拥有相应的公钥，可以对消息进行解密。这就像用合适的工具打开密封的信。如果解密成功，它验证消息确实是由私钥的持有者发送的，因为只有特定的私钥可以被用来加密消息，并且可以被相应的公钥解密。这就像一个数字签名，提供发送者身份的证明。</p>
<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc471bd9c4caf08fffabf10f50ecca5ac?method=download&amp;shareKey=7d9e77033f410ea9c98bcdc564545db0" alt=""></p>
<p>但是使用这种数字签名的缺点在于：它与整个消息的加密相关联。这可能导致计算数字签名会需要强大的算力支持，因为牵扯到所有数据来计算数字签名需要密集计算。  </p>
<p>所以另一种选择是使用加密哈希函数。这是一个特殊的函数，它接受一个输入(或’消息’)并返回一个固定大小的字节字符串。对于每个唯一的输入，输出都是唯一的——即使输入中的一个小变化也会产生如此巨大的哈希值输出变化，以至于新的哈希值看起来与旧的哈希值不相关。<br>随后，发送方将哈希函数应用于他们的消息，从而创建一个“<strong>摘要 (Digest)</strong>”。此摘要是表示消息内容的唯一数字。发送方然后使用他们的私钥加密该摘要。加密后的摘要作为数字签名。上图展示了通过摘要生成电子签名的流程。  </p>
<p>在信息发送阶段，原始消息(明文)和加密摘要(数字签名)然后一起发送，通常将摘要作为单独的文件附加到消息中。由于摘要比整个消息小得多，因此加密和传输它比加密整个消息要快得多。在一些网站下载内容时，它们可能会同时提供文件的SHA-256摘要。通过比对自己下载的文件的SHA-256与官网的进行比较，可以知道用户下载的文件是否在下载过程中发生了损坏。   </p>
<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB564dcb1844aefc51deeeb7d53142b7f0?method=download&amp;shareKey=6e09e4b98e7690464025f65ab03a5a30" alt=""></p>
<p>上图描述了信息在接收端发生的处理过程。  </p>
<p>刚才谈到SHA-256的时候说过，接收方使用与发送方使用相同的公共单向哈希函数从接收到的消息中创建摘要。这将产生一个唯一的数字，表示接收到的消息的内容。随后，接收方使用发送方的公钥解密随消息一起发送的原始摘要的加密版本。接收方将从收到的消息中计算出的摘要与解密后的原始摘要进行比较。如果它们匹配，则验证消息在传输过程中没有被篡改，并确认发送方的真实性(因为只有发送方的私钥才能以一种可以由相应的公钥解密的方式加密原始摘要)。  </p>
<p><br></p>
<p>然而，真实性只向接收者确认消息是由向他们发送公钥的人发送的，但是它没有考虑这样一个事实，即某人可能会创建公钥并假装是其他人。为了克服这一限制，需要一种更严格的方式来确保身份验证。这就是<strong>证书颁发机构 (Certification Authority, CA)</strong>的用武之地。<br>CA是一个受信任的第三方，它验证实体(如人、计算机或组织)的身份，并通过数字证书将它们绑定到公钥。 </p>
<p>而CA是一个更大的系统的一部分，被称为<strong>公钥基础设施 (Public Key Infrastructure, PKI)</strong>，它管理密钥和证书，并在不受信任的网络(如互联网)上实现安全通信。PKI确保每个公钥对于其持有者是唯一的，并提供查找、撤销和更新证书的方法。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc2b105e9ae510369c308295ffa89a248?method=download&amp;shareKey=649eae63c45dafd48372c03945b5907c" alt="">  </p>
<p>根据上图，我们可以来探讨一下从CA获取安全证书的过程：  </p>
<ol>
<li><strong>联系CA</strong>：想要接收安全消息的个体会联系本地CA来获取一对公私钥  </li>
<li><strong>身份确认</strong>：CA需要确认个体的身份，这可能涉及多种身份验证方法</li>
<li><strong>提供公钥</strong>：当身份确认通过后，个体需要将他们的公钥提供给CA</li>
<li><strong>创建数字证书</strong>：提交后，CA会创建一个数字证书，并将该个体的公钥写入该文档。此证书作为一种形式的身份证的公钥</li>
<li><strong>添加数字签名</strong>：随后CA会使用自己的私钥加密数字证书，并对其添加数字签名</li>
<li><strong>接收数字证书</strong>：然后CA将数字证书发送给该个体</li>
<li><strong>发布数字证书</strong>：该个体就可以将数字证书发布在网站或其他可访问的位置。现在，任何想要发送加密消息给该个体的人都可以在数字证书中找到他们的认证公钥</li>
</ol>
<p>这个过程可以确保当有人使用该个体的公钥向他们发送加密消息时，他们可以确信该密钥确实属于该个体，并且没有被篡改。  </p>
<p><br></p>
<hr>
<h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a><strong>对称密钥加密</strong></h2><p>多年来，数据加密标准(DES)一直是对称密钥加密的正常选择。当DES的弱点成为一个问题时，Triple DES取代了它。<br>2001年，高级加密标准(AES)作为一种优越的方法被引入。出于教育目的，我们在本章之探讨相对较简单的<strong>简化数据加密标准 (Simplified DES, S-DES)</strong>，以便更好地理解在加密中执行的各种操作。  </p>
<p>S-DES实际上是一种分组密码，这意味着它以比特为单位对数据进行加密。在S-DES中，它操作以8位构成的“块”。<br>这个过程从一个10位的密钥开始。S-DES的第一步是从原来的10位密钥创建两个8位密钥。这是通过一系列的置换(位的重新排序)和移位来实现的。<br>简单简述一下步骤：  </p>
<ol>
<li><strong>置换 (Permutation)</strong>：10位的密钥首先根据预定义的置换规则进行置换(重排)</li>
<li><strong>拆分 (Splitting)</strong>：置换后的内容被拆分为两部分</li>
<li><strong>移位 (Shifts)</strong>：每一半都要经历一系列的左移</li>
<li><strong>二次置换 (Second permutation)</strong>：移位后，将两部分合并，再进行一次置换来生成第一个8位的密钥</li>
<li><strong>更多的移位</strong>：如题，更多的移位</li>
<li><strong>最终置换 (Final permutation)</strong>：在经过这些移位步骤后，将这两部分再次组合，并进行另一次置换以生成第二个8位密钥  </li>
</ol>
<p>举一个置换过程例子吧：  </p>
<p>我们有一个10为的密钥：<code>0101010101</code>，而且定义好的置换规则为<code>35274101986</code><br>将这种排列规则应用于密钥意味着按照规则指定的位置重新排列键中的位：<br>在这种置换规则的情况下，表示：置换后的密钥的第一个位置是原始密钥的第3位，第二个位置是原始密钥的第5位，以此类推。<br>之后的置换过程就是这样继续循环下去了。  </p>
<p><br></p>
<hr>
<h2 id="公钥加密方法"><a href="#公钥加密方法" class="headerlink" title="公钥加密方法"></a><strong>公钥加密方法</strong></h2><p><strong>RSA (Rivest-Shamir-Adleman)</strong>是一种常用的公钥加密方法，这个名字是以三位发明者的名字命名的。<br>RSA中的密钥生成过程包括一系列利用素数和模运算的数学特性的步骤。下面是这种加密算法的详细说明：  </p>
<ol>
<li><strong>选择质数</strong>：首先选择两个非常大的指数，我们把它们记作<code>p</code>和<code>q</code>。这两个数字是保密的，其他设备都不会知道这两个质数。  </li>
<li><strong>计算<code>n</code></strong>：计算<code>p * q</code>，记作<code>n</code>。该值将会用作公钥和私钥的一部分。  </li>
<li><strong>计算<code>φ(n)</code></strong>：计算<code>(p - 1) * (q - 1)</code>，我们一般将这个值记作<code>φ(n)</code>。  </li>
<li><strong>选择<code>e</code></strong>：再选择一个质数<code>e</code>，使其小于<code>φ(n)</code>并这个数不是<code>φ(n)</code>的因数。我们一般选择65537这个数字，因为它在计算的时候比较好算。  </li>
<li><strong>求<code>d</code></strong>：现在我们需要求解另一个数字<code>d</code>，满足<code>(d * e) % φ(n) = 1</code>，也就是它们俩相除余数为1。  </li>
<li><strong>得出公钥</strong>：然后，公钥就得出来了：<code>(n,e)</code>。公钥是对所有人公开可用的。  </li>
<li><strong>得出私钥</strong>：同时我们也可以得出私钥：<code>(n,d)</code>。私钥是保密的，不对外公开的。  </li>
</ol>
<p>RSA的安全性基于这样一个数学原理：虽然两个大质数相乘得到n相对容易，但反过来得出两个质数是几乎不可能的。  </p>
<p>因为RSA的加密是基于数字的，所以在进行加密之前，我们需要将信息转换为数字的形式。这通常使用ASCII或Unicode等标准编码方案完成。<br>一旦文本被转换成数字<code>x</code>，就会使用公钥<code>(n,e)</code>对其进行加密，以生成加密的数字<code>y</code>。<br>加密使用公式<code>y = (x^e) mod n</code>完成。<br>公式的意思是：<code>x</code>被取<code>e</code>的幂，然后当结果除以<code>n</code>时的余数得到<code>y</code>。  </p>
<p>类似的过程耶同样用于用于解密，但它解密过程设计私钥<code>(n,d)</code>，而不是公钥。<br>使用公式<code>x = (y^d) mod n</code>，可以从加密的数字<code>y</code>中恢复原始数字<code>x</code>。  </p>
<p>像RSA这样的公钥加密比对称密钥加密更安全，因为它不需要安全交换密钥。<br>但是，公钥加密中使用的算法不如对称密钥加密中使用的算法快。因此，通常使用公钥加密来安全地传递密钥，然后将密钥用于更快的对称密钥加密。</p>
<p><br></p>
<hr>
<h2 id="SSL-和-TLS"><a href="#SSL-和-TLS" class="headerlink" title="SSL 和 TLS"></a><strong>SSL 和 TLS</strong></h2><p>当访问一个网站时，用户通常有两个主要的关注点。<br>首先，用户他们希望确保网站是官方的网站，而不是看起来很像官方的钓鱼或者诈骗网站。<br>其次，用户在有需求的时候（比如网购时），希望能够安全地传输敏感的个人数据。而SSL协议的创建是为了解决这些问题。    </p>
<p><strong>安全套接字层 (Secure Socket Layer, SSL)</strong>是为网络通信提供安全及数据完整性的一种安全协议。如今被广泛使用，如网页，电子邮件，互联网传真，即时消息和语音在IP电话（VoIP）。其中网站是通过使用TLS来保护WEB浏览器与服务器之间的通信安全。<br>它为基于客户端-服务器的应用程序提供了一个安全层，确保在用户浏览器(客户端)和网站服务器之间传输的数据是加密和安全的。  </p>
<p>在网络中，“<strong>套接字 (Socket)</strong>”是IP地址和端口号的组合。传输控制协议(TCP)使用端口号为特定的应用程序提供服务。如果没有SSL这样的安全协议，TCP将使用此端口号直接与应用程序交互。<br>但是当有SSL时，它会作为传输层中的TCP和网络协议栈的应用层之间的附加层。这意味着从应用程序传递到TCP的数据要经过SSL，反之亦然。当数据被发送时，会在SSL中进行加密；在接收时会进行解密。<br>所以启用SSL后，应用协议<strong>HTTP(超文本传输协议)</strong>会变成变成<strong>HTTPS (HTTP Secure)</strong>。这表明客户端和服务器之间的通信是加密和安全的。  </p>
<p>需要注意下面这些有关于SSL的内容：  </p>
<ul>
<li>SSL通常被称为一个协议，但它实际上是一组协议套件  </li>
<li>SSL协议处理数据传输的格式，确保数据被正确打包以进行传输  </li>
<li>SSL协议负责建立安全连接。SSL为了达成目的会涉及以下几个步骤，包括对服务器的身份验证和对加密算法和密钥的协商  </li>
<li>SSL的操作不需要用户操作即可发生。它集成到网络协议栈中，并在需要安全连接时自动操作  </li>
<li>SSL实现的起点是通过TCP (Transport Control Protocol，传输控制协议)在客户端和服务器之间建立的连接  </li>
<li>客户端浏览器需要调用SSL套件中的握手协议来确保安全连接。这涉及几个步骤：  <ul>
<li>首先握手协议要求服务器提供SSL证书，即验证服务器身份的数字证书  </li>
<li>随后，服务器将此SSL证书连同其公钥一起发送  </li>
<li>最后，浏览器使用此公钥加密密钥，该密钥将在数据传输会话期间作为对称密钥加密的一次性会话密钥  </li>
</ul>
</li>
</ul>
<p>SSL最初是一个专有协议，但后来被互联网工程任务组(Internet Engineering Task Force, IETF)接管，形成了一个标准化版本。<br>当IETF意识到需要一个改进的版本时，他们决定使用一个新的名称。因此，<strong>传输层安全 (Transport Layer Security, TLS)</strong>作为SSL的升级版、更安全的版本被引入。<br>尽管SSL存在一些安全问题，但它现在仍然被广泛使用。现在，当你听说“SSL证书”时，它通常意味着SSL/TLS证书。<br>SSL现在多与TLS协议一起用于安全通信，所以在今天的实践中，即使人们提到“SSL”，TLS也很有可能被使用。  </p>
<p><br></p>
<hr>
<h2 id="量子密码"><a href="#量子密码" class="headerlink" title="量子密码"></a><strong>量子密码</strong></h2><p>不开玩笑，这下真的需要讨论一下量子力学了：  </p>
<p>量子力学提供了支配最小尺度粒子行为的基本物理定律。<strong>光子 (Photons)</strong>是传输光的粒子。它们表现出波状的行为，这意味着每个光子似乎在垂直于其传播方向的特定方向上振动。<br>每个光子振动的方向称为<strong>偏振度 (Polarization)</strong>。在图表中，偏振度通常用双端箭头表示。<br>而我们在计算机中，可以使用特定的偏振来创建光子来表示比特的值，而比特是计算中信息的基本单位。如果我们允许四种极化状态的可能性，我们可以用两种不同的方式表示一个二进制值(0或1)。这可能被用于增加每个光子中可编码的信息量，或在量子通信或计算系统中提供冗余或错误纠正。</p>
<p>具体的编码方式如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc6c3ba32a301870cb84f4ee5ee03399f?method=download&amp;shareKey=14aff5506d204203b5273f887e45698c" alt=""></p>
<p>因此，该方案可用于使发送方和接收方创建由若干比特组成的“秘密代码”。下表详细描述了量子密钥的分发过程：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5375706f72bd166da3d4697b6abaabde?method=download&amp;shareKey=8c303e4e230c95713ebdf7c98cf14222" alt=""></p>
<ol>
<li><strong>被发送的比特值</strong>：发送方（我们一般称之为Alice），选择一个随机的比特序列进行发送。上图第一行表示了一段被选中的比特值，它是<code>1 0 1 1 0 0 0 1 0 1</code>。  </li>
<li><strong>发送方的极化基</strong>：随后，Alice会为每一个比特位选择一个随机的极化基。在这个表格中，<code>+</code>表示垂直和水平偏振，<code>×</code>表示对角偏振。  </li>
<li><strong>接收方的极化基</strong>：接收方（我们一般称之为Bob），会在Alice不知情的情况下为每一个位选择一个随机的极化基。</li>
<li><strong>传输并揭示极化基</strong>：随后数据会被传输。最后，Alice会告诉Bob她使用的每一个位的极化基。</li>
<li><strong>确认位值</strong>：Bob会将从Alice那里拿到的极化基信息与自己选择的极化基相匹配。通过判定他们之间的匹配情况，就可以反映出哪些位是这两位之间的秘密代码。  </li>
</ol>
<p>在上图的例子中，最后的秘密代码<code>1001</code>就是通过这样的方式得到的。<br>加密的过程利用了量子力学的原理来确保安全性。如果窃听者试图截获并测量传输过程中的量子态，由于海森堡测不准原理，会干扰量子态并引入可检测误差。</p>
<p><br></p>
<hr>
<h1 id="第二十二章：人工智能-AI"><a href="#第二十二章：人工智能-AI" class="headerlink" title="第二十二章：人工智能 (AI)"></a><strong>第二十二章：人工智能 (AI)</strong></h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a><strong>综述</strong></h2><p>定义“人工智能”是什么并不容易。<br>一个关键问题是智能的定义。例如，你可能会说一个人做心算需要智力，比如43 × 13。不过，你可以使用计算器来得到答案，但不会将计算器描述为具有人工智能。这意味着像这样的定义:</p>
<p><em>“人工智能涉及智能行为的自动化。”</em></p>
<p>并不完全令人信服。  </p>
<p>人们一致认为人工智能是计算机科学的一部分。很明显，这个主题有许多不同的子节，本章将讨论其中一些。结论是一个模糊的定义是最好的。例如:</p>
<blockquote><p>Artificial Intelligence is concerned with “how to make computers do things at which, at the moment, people are better.”<br>                <em>(E. Rich. Artificial Intelligence. McGraw-Hill, 1983)</em></p>
</blockquote>
<p>我个人认为人工智能行业在近年来发展十分迅速，迭代速度十分离谱。所以说本章可能会出现一些过时的理论，但是也没办法，毕竟我们需要考试嘛。  </p>
<p><br></p>
<hr>
<h2 id="人工智能与图表"><a href="#人工智能与图表" class="headerlink" title="人工智能与图表"></a><strong>人工智能与图表</strong></h2><p>我们在AI这一块使用的图标大多是像下面这种类型的：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBce302e5663dcb28db6d5bd3fa7481585?method=download&amp;shareKey=1140b5efb80af601fd9a87508b4aaaee" alt=""></p>
<p>这样的图片由节点和连接线组成。每一条线连接两个节点，连接线上面存在一个相关联的标签，这个标签是一个数值。  </p>
<p>这样的图可以用来表示各种场景。一种常见的表示方法是，节点表示位置，边缘标签表示这些位置之间的距离。只有当节点对之间存在可直接移动的路径时，图中才包含连接线。例如，这种图可以找到两个不相邻的节点之间的最短路径。  </p>
<p>我们可以通过考虑所有可能的路线并计算每条路线的总距离，利用我们的模型来找到节点A和节点D之间的最短路线:  </p>
<p>A → B → C → D   40 + 10 + 40 = 90  </p>
<p>A → B → F → E → D  40 + 15 + 20 + 5 = 80</p>
<p>A → F → E → D  60 + 20 + 5 = 85</p>
<p>A → B → B → C → D  60 + 15 + 10 + 40 = 125  </p>
<p>不难看出，第二种方案是路径最短的方案。<br>如果我们需要在一个包含100个节点的图像里面寻找最短距离方案，会把我们数累死。好在现在已经有了好用的人工智能算法来解决这个问题。  </p>
<p><br></p>
<hr>
<h3 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a><strong>狄克斯特拉算法</strong></h3><p>狄克斯特拉算法是一种寻找加权图中节点之间最短路径的方法。该算法可用于寻找从图中单个节点到所有其他节点的最短路径，从而生成最短路径树。它还可以用于查找从单个节点到单个目标节点的最短路径，在确定到目标节点的最短路径后停止算法。  </p>
<p>狄克斯特拉算法的准备步骤如下：  </p>
<ol>
<li><strong>标记路径开始的原点</strong>：首先标记一个我们开始的位置。  </li>
<li><strong>创建<code>ShortestPath</code>变量</strong>：这个变量将会存储从源节点到目标节点的最短路径。随着我们对于整个树的深入探索，变量内部的值也会发生改变。一开始，这个变量中的值为零，因为我么还没有探索任何可能的路径。  </li>
<li><strong>创建<code>RemainingNodes</code>变量</strong>：我们将所有的节点放入这个变量中，包括源节点，我们将源节点记作S。这个集合包含了我们目前为止还没有探索过的节点。最初，这个变量仅包含图像中的所有节点，包括源节点。  </li>
<li><p><strong>创建record</strong>：接下来我们需要创建一个record，其中包含以下数据类型：  </p>
<ul>
<li><strong>节点名称 (Node name)</strong></li>
<li><strong>从源节点到此节点的距离 (Calculated distance to the node from the source node)</strong></li>
<li><strong>到达此节点路由中的顺序 (Sequence of node in the route to the node)</strong></li>
</ul>
<p>这些record用来跟踪源节点到每个节点的最佳已知距离，以及到达这个节点的路径。</p>
</li>
<li><p><strong>源节点距离值为0</strong>：将源节点的距离值设为0（因为源节点到自身的距离总是为0）。</p>
</li>
<li><strong>其他点距离设为无穷大</strong>：我们需要将其他的点的距离设为无穷大，因为我们在算法的开始不知道源节点到其他节点的距离。为了保证正常的计算，只能使得距离值大于可能计算出来的值。</li>
</ol>
<p>接下来算法会步入一个循环，这就是狄克斯特拉算法能够寻找最短路径的核心：</p>
<ol>
<li><p><strong>从<code>RemainingNodes</code>中选择距离最小的节点</strong>：<code>RemainingNodes</code>变量中存储的是所有的未探索的节点。这一步要求程序再<code>RemainingNodes</code>变量中选择一个距离当前点距离最小的节点。  </p>
</li>
<li><p><strong>节点移动至<code>ShortestPath</code>变量中</strong>：这一步过后，我们就已经探索了该点的距离了。这时候就应该将这个节点移动到<code>ShortestPath</code>变量中。  </p>
</li>
<li><strong>最短距离的判定与计算</strong>：我们通过被链接的两个节点的最短路径上的标签的值来计算距离。所有的标签值相加既是最新的最短距离，然后将此值更新，替换当前存储的最短距离值。</li>
</ol>
<p>这时，我们就已经找出了通往每个节点的最短路径。  </p>
<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB44d0deb0a129644dd8730086a0744552?method=download&amp;shareKey=10b1aa1506399b549015bfb7da7afd91" alt=""></p>
<p>上图展示了狄克斯特拉算法的更多细节信息。<br>当节点仍在<code>RemainingNodes</code>中时，会以红色显示。 在每个阶段，节点 N 都以黑色表示。 当节点已被移动到最短路径集而无法再更改时，距离和路径数据将以灰色显示。  </p>
<p><br></p>
<hr>
<h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A* 算法"></a><strong>A* 算法</strong></h3><p>狄克斯特拉的算法的目的是找到某一个节点通向每一个节点的最短路径。而在实际应用中，我们经常需要的是寻找两点之间的最短路径，而不是寻找某个节点到所有点的最短路径。  </p>
<p>这种情况下，我们可以对狄克斯特拉算法进行一些简单的修改，使得算法只求解两个特定节点之间的最短路径。可能达成这一目标的一种方法是使用基于启发式的算法，如A*(发音为“a -star”)。不过，在查找单个最短路径时，A*可能比Dijkstra更有效，但如果需要查找从一个节点到许多其他节点的最短路径，Dijkstra可能仍然更有效，因为它不依赖于特定于目标的启发式算法。</p>
<p>A*算法的有效性在很大程度上取决于所使用的启发式算法的质量。一个质量低下的的启发式算法可能导致寻找的路径十分低效，甚至导致算法无法找到一条路径。  </p>
<p>将狄克斯特拉算法经过下方的简单修改，就可以实现A*算法的内容和功能：  </p>
<ol>
<li><p>将连接两个节点的边的标签值与已存储的 N 的距离值相加，计算出新的距离值：这一步与狄克斯特拉算法相似，都是用根据节点N的路径的不断探索来更新已知的最佳距离。  </p>
</li>
<li><p>计算 N 与目的地节点距离的估计值，并将其与新的距离值相加：这一步与狄克斯特拉算法就不一样了。A*算法使用启发性函数来估算节点到目的地的剩余距离，然后根据剩余距离的大小分别对待不同的节点。而不是对所有的未探索节点一视同仁。这个估计距离会与已知距离相加，然后总值较低的节点会被优先探索。  </p>
</li>
</ol>
<p>我们需要在选择A*算法的启发式函数时格外注意。启发式算法应该是对于实际剩余距离的预估，当选择这个函数时，它必须保证<strong>任何估计值都将小于实际值</strong>。如果这个预估值过高，就会导致A*算法探索更多的节点，从而导致A*算法找不到正确的路径。一般来说，如果在二维平面上寻找最短距离，那么这个启发式算法的一般选择是曼哈顿距离，或距离目的地的欧氏距离。  </p>
<p><br></p>
<p>为了简单理解A*算法，这里举一个在二维平面上寻路的简单例子：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB910640e151df886d88b59f8803222dbb?method=download&amp;shareKey=e9c75241e2a42a8fed14c705b56dbafb" alt=""></p>
<p>图中展示了7个城镇，每个城镇的名字都使用A-G进行编号。之所以使用这样平面的形式来呈现城镇的位置，那是因为它是通过定义每个城镇位置的一对x,y坐标绘制的，而这正是启发函数能得以应用的基础。  </p>
<p>下面是这7个城镇的坐标：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
<th style="text-align:center">G</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(40, 20)</td>
<td style="text-align:center">(30, 30)</td>
<td style="text-align:center">(80, 35)</td>
<td style="text-align:center">(130, 30)</td>
<td style="text-align:center">(120, 20)</td>
<td style="text-align:center">(45, 5)</td>
<td style="text-align:center">(100, 30)</td>
</tr>
</tbody>
</table>
</div>
<p>毕达哥拉斯定理，也就是勾股定理可以用来计算两个位置之间的直接距离，可以写作Δx方加Δy方，然后开个根。  </p>
<p>而使用这种方法计算的距离，一定会小于等于我们要实际走的路程。这个实际问题画成图像就像下图：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3f9c05a9780f3473c733557ae22c2ce8?method=download&amp;shareKey=bb2e1a84c6e90c480b1a39b3f99ab2e1" alt=""></p>
<p>首先事先说明，A*算法实际上有很多的实现方案。我们在这里使用的A*算法是CIE的某种神奇的独创方法。。。用文字表示出来是这样的：  </p>
<ol>
<li><p>创建三个列表：初始列表、开放列表和封闭列表：这些列表用来记录我们尚未探索的节点（<code>initial</code>）、正在探索的节点（<code>open</code>）和已经探索完毕的节点（<code>closed</code>）。</p>
</li>
<li><p>为图中的每个节点在初始列表中插入一条空记录：这样我们就建立了包含图中所有节点的<code>initial</code>列表。</p>
</li>
<li><p>在<code>initial</code>列表的每条记录中存储节点的 x 和 y 坐标：这将用于计算节点之间的距离。</p>
</li>
<li><p>在<code>initial</code>列表的每条记录中，将旅行距离值初始化为 0。因为在算法的开始，我们还没有走过任何距离。</p>
</li>
<li><p>创建一个查询表，为每对有直接连接道路的节点建立一个条目。该表会用于快速查找直接相连的节点之间的距离。</p>
</li>
<li><p>为表中的每对节点存储沿该道路的行驶距离。这会用于计算节点之间的距离。</p>
</li>
<li><p>确定旅行的目标节点，也就是我们的目的地。</p>
</li>
<li><p>确定旅行的起始节点，并将该节点的记录复制到开放列表中。</p>
</li>
<li><p>从<code>initial</code>列表中删除初始节点的记录：我们将起始节点从<code>initial</code>移到<code>open</code>，是因为我们即将开始探索它。</p>
</li>
<li><p>现在递归地应用下面的算法，直到所有的可能性都被检查过：</p>
<ul>
<li>对于与当前节点（父节点）相邻的每个节点，我们都要计算一个新的距离值，相应地更新我们的记录，并根据需要在列表之间移动节点。</li>
<li>我们将继续这个过程，直到探索完所有可能的路径或找到目标。</li>
</ul>
</li>
<li><p>如果目标节点在打开的列表中，则仅对该节点执行以下操作：计算实际距离，然后更新我们的记录。</p>
<ul>
<li>我们计算实际距离，更新相应记录，并根据需要在列表之间移动节点。</li>
<li>如果没有更多节点需要探索（<code>open</code>列表为空），我们会倒回去检查<code>closed</code>列表中没有包含在之前路径序列中的节点。</li>
<li>如果一条未探索的路径可能比我们当前的最佳路径短，我们就把它的起始节点移回<code>open</code>，然后继续探索。</li>
</ul>
</li>
</ol>
<p>以上的过程会一直持续到我们找到通往目标的最短路径或确定不存在这样的路径为止。</p>
<p><br></p>
<hr>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h2><p>机器学习的特性可以概括为:</p>
<ul>
<li>基于计算机的系统有一个或多个需要执行的任务</li>
<li>知识是通过执行任务的经验获得的</li>
<li>通过这些经验和获得的知识，可以改善未来任务的表现。</li>
</ul>
<p>从经验中学习的能力是智能的体现。 因此，机器学习是人工智能范畴内众多方法中的一种。 有许多方法可以描述如何进行学习。 这里将讨论其中三种：  </p>
<ol>
<li><strong>无监督学习 (Unsupervised learning)</strong></li>
</ol>
<p>在无监督学习 (Unsupervised learning)中，系统必须根据自己执行任务的经验得出结论。为此，需要有能够对所获知识进行组织或分类的算法。<br>例如，可以根据层次框架确定 “<strong>概念集群 (Conceptual clusters)</strong>“。在这种方法中，知识最初都被置于树形结构的根部。然后，根据知识的属性，将选定的群组移入树形结构的分支中。  </p>
<p>如今，无监督学习已成为一种主流活动。访问海量数据库的强大计算机系统可以被用来通过学习以往的数据与记录，从而学习对未来做出决策。<br>我们在互联网上的活动都会被记录和存储。这些存储的数据很可能会被用来做出决策，而这些决策可以决定在未来使用互联网时服务商向我们推荐哪些产品或服务。   </p>
<ol>
<li><strong>监督学习 (Supervised learning)</strong></li>
</ol>
<p>在监督学习中，系统被输入相关的分类知识。例如，我们可能正在开发一个人工智能程序，用于批改试卷。在监督学习中，试题答案可以连同每道题的分数或分类评语一起提供。这种对模型数据的分类提供就是监督学习的典型标志。  </p>
<p>专家系统是一种计算机系统，可模拟人类专家在特定领域的决策能力。 它旨在通过知识体系的推理来解决复杂的问题。<br>在这种情况下，监督学习指的是人类专家分析数据样本并提供结论的过程。 然后将这些数据样本和结论输入专家系统的知识库。<br>专家系统的有效性可以通过人类专家提供样本数据并检查系统结论的准确性来检验。 如果效果不佳，则向系统输入更多数据和结论，以提高其性能。<br>虽然专家系统是人工智能的一个例子，但它并不是机器学习的一个例子。 这是因为人们并不期望系统在无人帮助的情况下提高性能。 相比之下，机器学习系统的设计目的是自动学习和改进经验，而无需明确编程。</p>
<ol>
<li><strong>强化学习 (Reinforcement learning)</strong></li>
</ol>
<p>强化学习具有一些类似于无监督学习的特征，而另一些特征则类似于有监督学习。这种方法有自己特定的词汇。下面的语句就是用这些词汇来描述强化学习算法如何工作的。  </p>
<ol>
<li><p><strong>Agent</strong>：Agent是学习如何行为的实体（如机器人或软件应用程序）。它通过采取行动、接收反馈并从中学习来与环境互动。</p>
</li>
<li><p><strong>Environment</strong>：这是Agent运行的环境或空间。它可以是物理环境（如机器人的迷宫），也可以是虚拟环境（如下棋程序的棋盘）。  </p>
</li>
<li><p><strong>States</strong>：这是Agent在环境中可能遇到的不同条件或情况。</p>
</li>
<li><p><strong>Action</strong>：这是Agent在与环境交互时每一步所做的事情。例如，在一盘棋中，行动可以是移动一个棋子。</p>
</li>
<li><p><strong>Policy</strong>：这是Agent根据其当前状态决定其行动的策略。换句话说，这是Agent的行为函数。</p>
</li>
<li><p><strong>Reward</strong>：这是Agent在采取行动后得到的反馈。它是衡量该行动在实现总体目标方面的好坏程度。</p>
</li>
<li><p><strong>Exploitation vs Exploration</strong>：这是Agent在决定下一步行动时可以使用的两种策略。开发 (Exploitation)是指利用已知信息，根据过去的经验采取预期会产生回报的行动。探索 (Exploration)是指尝试新的行动，以发现潜在的更好策略。</p>
</li>
</ol>
<p>在强化学习中，代理通过与环境互动并接受奖励或惩罚来学习。其目标是学习一种能在一段时间内使总奖励最大化的策略。总而言之，目标是通过提高策略的质量来最大化奖励值。这是一种寻找最佳性能的反复试验。它需要对同一个问题进行多次反复的尝试。  </p>
<p>上述内容是有关于强化学习的抽象描述。如果考虑该方法应用的一些实例，那么概念就会更清晰一些。<br>比如，强化学习的一个领域是玩诸如双陆棋这样的逻辑游戏。或者是机器人技术，机器人必须学习如何有效地完成任务。比如说，机器必须学会如何在迷宫中导航。在这种情况下，当agent选择一个最终将通向目的地的左转时，奖励将被给出一个正值。如果它选择右转，则奖励为负值。  </p>
<article class="message is-info"><div class="message-body">

<b>Machine learning: where a system improves its performance through analysis of previous performance</b>

<br>

<b>Unsupervised learning: where the machine learning takes place entirely through the system analysing and categorising the available data</b>

<br>

<b>Supervised learning: where a sample data is supplied to the system with associated data relating to the outcome of its use</b>

<br>

<b>Reinforcement learning: where an agent learns by receiving graded rewards for actions taken</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="回归分析方法"><a href="#回归分析方法" class="headerlink" title="回归分析方法"></a><strong>回归分析方法</strong></h3><p>在某些应用中，人工智能的目的是根据输入到人工智能算法中的不同数量的数据值，预测并提供某些确定数量的输出数值。<br>如果要使用<strong>回归分析 (Regression analysis)</strong>，第一步需要为系统提供一些输入数据的实际值，以及人工智能系统运行时将成为输出数据的实际值。<br>机器可以利用这些数据来研究这两组数值之间是否存在任何相关性。如果相关性可以用数学公式来表示，那么在输入新数据时，就可以用这个公式来输出预测值。  </p>
<article class="message is-info"><div class="message-body">

<b>Regression analysis: finding a mathematical function that provides the best fit to the actual outcomes when outcomes are calculated from previous inputs</b>

</div></article> 

<p>回归分析最简单的应用是只输入一个量的值，并预期这些值与要预测的值之间存在线性关系。<br>例如，人工智能系统可以用来预测 A-Level 计算机科学考试考生的分数。<br>人们可能期望考生在 A-Level 计算机科学考试中的分数与他们在 IGCSE 数学考试中的分数之间存在相关性。下图显示了输入和分析一些历史数据后可能发现的情况：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2bd5fffbeca8bf927904c8ba0f6c1c0f?method=download&amp;shareKey=fb4bd0b59bc800f821c5e256b2f0e132" alt=""></p>
<p>我们可以发现，两个量之间有着很强的相关性。而这些数据拟合起来，图像中的直线就是最好的拟合直线。因此，这条线的公式可以根据IGCSE数学试卷的分数来预测A-Level计算机科学试卷的未来分数。  </p>
<p>回归分析还可以更复杂。<br>例如，如果使用三种不同考试的分数作为输入，可以进行类似的数学公式拟合。在其他情况下，非线性关系可能是合适的，因为当需要预测新产品的未来销售时，预计销售将呈指数级增长。</p>
<p><br></p>
<hr>
<h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a><strong>人工神经网络</strong></h2><p>没想到这年头学计算机都需要了解生物知识。  </p>
<p>下图我们人脑中的神经元的结构：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe3062239f13e757441bcee91323d9d3e?method=download&amp;shareKey=ece28fe1266d96d548bcaf46bb558a66" alt=""></p>
<p>在神经细胞的一端有许多可以接收信号的树突。在细胞的另一端有许多轴突终末按钮可以传递信号。突触是位于轴突终末按钮和含有神经递质的树突之间的区域。当一个神经细胞接收到输入信号时，轴突内的电压就会增加。在该电压的某个阈值时，神经递质被激活，信号被发送到邻近细胞的树突。  </p>
<p>而人工神经网络可以通过软件或硬件创建。<br>网络的组成部分可以用下图所示的图表来表示：三角形是网络中的<strong>节点 (Node)</strong>，代表人工神经元。一般来说节点会使用圆圈表示。<br>通常，节点可以接收一个或多个输入，并向其他节点提供一个或多个输出。节点动作的建模涉及到对每个输入施加一个权重因子。对加权输入值求和，然后使用激活函数计算节点的输出值。如果输入不是数值，则必须将其转换为1，以便对加权值进行求和。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB89250450455c70614fbc9121b0ad9d83?method=download&amp;shareKey=854bb8c6faf84e86166199b028af3199" alt=""></p>
<p>图中显示了一个由三层组成的非常简单的网络结构。<br>左侧的3个节点的列接收输入。右边的列提供输出。中间的两个节点形成了所谓的<strong>隐藏层 (Hidden layer)</strong>。一些人工神经网络都会包含好几个隐藏层。  </p>
<p>使用人工神经网络的人工智能系统的一个例子是根据支付的初始价格和使用寿命来估计电池的成本效益：每个输入节点代表一个特定的电池，它们的输入可包括电池的序列号，电池价格等数据。  </p>
<p>接下来的隐藏层是输入层和输出层之间的层级。在这种情况下，隐藏层中的一个节点可能与电池使用的设备类型有关，另一个节点可能与设备的用户类型有关。这些节点处理输入，并将其传递给输出层。  </p>
<p>在输出层，每个节点都会根据隐藏层处理后的输入，计算出特定电池单位时间成本的估计值。  </p>
<p>在这个神经网络中，目标是学习一个从输入（电池数据和价格）映射到输出（估计成本效益）的函数。该网络将在已知成本效益的电池数据集上进行训练，并调整其内部参数（权重和偏置），使其预测值与实际值之间的差异最小。训练完成后，该网络可用于估算新电池的成本效益。  </p>
<p>在这个系统中，每个节点都有可调节的因素。这些因素包括每个输入的权重和激活函数。<br>在初始学习时，需要对这些可调因子进行调整，以达到系统的最佳预测能力。为此，可以采用<strong>误差反向传播 (Back propagation of errors)</strong>的方法来实时调整权重和激活函数的参数。  </p>
<p>要做到这一点，我们需要从电池的实际使用中获取一些电池寿命数据，然后为所有可调因素创建一个测试数据集。  </p>
<p>在模型使用真实数据进行训练时，他会为每次输出确定一个误差，而误差是电池寿命的输出值与实际使用值之间的差值。然后，根据误差值反向传播，按需修改在某些节点上的权重和激活函数的参数，随后继续训练。这种操作可以提升模型的准确性。  </p>
<article class="message is-info"><div class="message-body">

<b>Back propagation of errors: An algorithm for machine learning that optimizes the values for parameters which are adjustable. It is applied first to the nodes in the output layer and then works backward through the nodes in hidden layers until finally the input nodes are considered</b>

</div></article> 

<p>学习过程从输出层开始，然后到隐藏层，最后到输入层。这种逐层学习的方法允许网络逐步完善其预测。随着反向传播的不断进行，我们最后会开始处理输入层节点的可调因素。<br>初始学习过程完成后，系统可应用于新的输入数据，以预测不同电池的成本效益。随着更多实际使用数据的出现，可以再次应用反向传播学习过程，以进一步提高系统性能。  </p>
<p><br></p>
<hr>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a><strong>深度学习</strong></h3><p>简单介绍下：大脑中有一层神经元结构，其中的低层具有易于理解的功能，而高层涉及更抽象的信息处理。<br>随着现在可用的计算能力的增加，人工神经网络被引入了大量的隐藏层，试图实现类似人脑的思考方式。这些方法被称为<strong>深度学习 (Deep Learning)</strong>系统。  </p>
<p>机器学习是人工智能的一个子集，它允许计算机系统在没有明确编程的情况下自动做出预测或决策。它所需的计算能力较低，可以在较小的数据集上进行训练。但是，它需要更多的人工干预来纠正和学习，而且它只做简单的线性相关。  </p>
<p>而深度学习是机器学习的一个子集，它使用人工神经网络来解决机器学习算法可能无法解决的更复杂的问题。深度学习使用以人脑为模型的复杂算法结构，能够处理文档、图像和文本等非结构化数据。它通常需要较少的持续人工干预，但需要大量数据和大量的算力（专门的 GPU来训练）。深度学习能够建立非线性的复杂关联。</p>
<p>人话讲：虽然机器学习和深度学习都涉及计算机从数据中学习，但深度学习更为复杂，可以处理更大、更多的非结构化数据集，但需要更多的计算资源。</p>
<article class="message is-info"><div class="message-body">

<b>Deep learning: where a system uses an artificial neural network with an exceptionally large number of hidden layers</b>

</div></article> 

<p>至此，A2计算机 Paper3部分全部完成。</p>
<p><br></p>
<hr>
<h1 id="PART-FOUR-进阶编程技能与问题解决"><a href="#PART-FOUR-进阶编程技能与问题解决" class="headerlink" title="PART FOUR: 进阶编程技能与问题解决"></a><strong>PART FOUR: 进阶编程技能与问题解决</strong></h1><h1 id="第二十三章：算法"><a href="#第二十三章：算法" class="headerlink" title="第二十三章：算法"></a><strong>第二十三章：算法</strong></h1><p>鉴于本人只会Python，本章的所有实例代码全部换成了Python。VB.NET还有Java那是真的一点不会。  </p>
<h2 id="线性搜索"><a href="#线性搜索" class="headerlink" title="线性搜索"></a><strong>线性搜索</strong></h2><p><strong>线性搜索 (Linear search)</strong>，也叫做顺序搜索，是一种在列表中查找元素的方法。<br>算法的实现方法是：顺序地检查列表中的每个元素，直到找到匹配的元素或搜索了整个列表才可以结束。<br>线性搜索的最差运行时间为线性时间，最多进行 n 次比较，其中 n 是列表的长度。因为最坏的情况，就是算法爬遍了整个列表才找到结果。  </p>
<p>代码如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search</span>(<span class="params"><span class="built_in">list</span>, target</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">list</span>[i] == target:</span><br><span class="line">            <span class="keyword">return</span> i  <span class="comment"># 如果元素被找到，那么就返回index值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 如果未找到元素，那么就返回None值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数测试</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(linear_search(numbers, <span class="number">5</span>))  <span class="comment"># 输出： 4</span></span><br><span class="line"><span class="built_in">print</span>(linear_search(numbers, <span class="number">10</span>))  <span class="comment"># 输出： None</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h2><p><strong>冒泡排序 (Bubble sort)</strong>，又称为下沉排序，是一种简单的排序算法。<br>它对输入列表中的元素进行逐个重复排序，比较当前元素和其后的元素，并在必要时交换它们的值。<br>这种算法会重复检查列表，直到在某一次通过中发现没有元素需要交换位置，这意味着列表已完全排序。<br>该算法因较大的元素 “冒泡 “上升到列表顶端而得名。  </p>
<p>冒泡排序的工作原理如下：  </p>
<ol>
<li>从列表的开始遍历列表</li>
<li>将列表中的第n个值与第n+1值进行比较。</li>
<li>如果第一个值较大，则交换两个值的位置。</li>
<li>移动到列表中的第二个值。再次比较该值和下一个值，如果该值较大，则交换位置。</li>
<li>继续进行，直到没有需要比较的项目为止。</li>
<li>回到列表的起点。<ul>
<li>从列表遍历的开始到结束，每一次都称为一次<strong>通过 (Pass)</strong>。</li>
</ul>
</li>
<li>冒泡排序一直持续到没有数值交换为止。此时，列表排序完毕。  </li>
</ol>
<p>下面是代码实例：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">list</span>[j] &gt; <span class="built_in">list</span>[j+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换元素位置</span></span><br><span class="line">                <span class="built_in">list</span>[j], <span class="built_in">list</span>[j+<span class="number">1</span>] = <span class="built_in">list</span>[j+<span class="number">1</span>], <span class="built_in">list</span>[j]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line">numbers = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(numbers))  <span class="comment"># 输出: [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>在本例中，<code>bubble_sort</code> 函数将一个列表作为输入。它将列表中的每个元素与其相邻元素进行比较。<br>如果某个元素大于其相邻元素，它就会交换它们。这个过程一直持续到不再需要交换为止，表明列表已经排序。  </p>
<p><br></p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h2><p><strong>插入排序 (Insertion sort)</strong>是一种简单的排序算法，它一次一个元素地建立最终的排序数组或排序列表。  </p>
<p>在大型列表中，它的效率远低于更先进的算法，如快速排序，堆排序或合并排序，不过，插入排序有几个优点：  </p>
<ul>
<li>对小数据集排序比较高效</li>
<li>在应用中，插入排序比大多数其他简单的四元算法（如选择排序）更有效。</li>
<li>对已基本排序完毕的数据集更有效率</li>
<li>稳定，即不会改变相同键元素的相对顺序</li>
<li>就地排序，即只需要一定量的 O(1) 额外内存空间  </li>
</ul>
<p>插入排序的工作原理如下：  </p>
<ol>
<li>从列表开头开始遍历</li>
<li>将列表中的当前值(n)与之前的值(n-1)进行比较。</li>
<li>如果当前值小于前一个值，则对调它们。</li>
<li>移动到列表中的下一个值，重复步骤 2 和 3。</li>
<li>一直重复，直到没有可比较的项目为止。</li>
</ol>
<p>插入排序的代码示例如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        key = <span class="built_in">list</span>[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; <span class="built_in">list</span>[j]:</span><br><span class="line">            <span class="built_in">list</span>[j + <span class="number">1</span>] = <span class="built_in">list</span>[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">list</span>[j + <span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line">numbers = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(insertion_sort(numbers))  <span class="comment"># 输出: [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>不难发现，在插入排序和冒泡排序这两种简单的排序算法中，每个元素的位置都是基于比较来决定的，这就决定了它们俩是最稳定的排序算法。因此它们不会在排序过程中交换具有相同值的键，从而保留这些元素的初始顺序。  </p>
<p>然而他们之间有些区别：  </p>
<ol>
<li>在每次迭代中，插入排序算法将当前元素与之前的元素进行比较。相反，冒泡排序算法在每次迭代中，会比较并交换相邻的元素。  </li>
<li>冒泡排序比插入排序执行更多的交换操作。对于每次迭代，插入排序在已经排序的元素中为当前元素找到合适的位置。相反，冒泡排序在每次迭代中比较和交换相邻的元素。大量的交换导致冒泡排序算法的运行时间变长。</li>
<li>虽然两种算法的时间复杂度都是O(n²)，即完成排序操作所需的时间是二次，但平均而言，由于交换次数较多，冒泡排序的性能不如插入排序。</li>
</ol>
<p>下图是一个插入排序的直观解释：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf08cf407c048e1e3007c225de4739b52?method=download&amp;shareKey=d2768dd15ced52adf02e41d1e669eebe" alt=""></p>
<p>首先，6先与它前面的数据47进行比较。6比47小，因此它们对调位置，6跑到了列表的最前面。<br>继续，54与47进行比较，54比47大，因此不执行任何操作。<br>17与54比较，因为17比54小，所以17会与54对调，并一直向前寻找元素比较大小，直到17换不动了为止。  </p>
<p>排序就这么一直执行下去，直到序列中的最后一个元素也排列完成。  </p>
<p><br></p>
<hr>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h2><p><strong>二分查找 (Binary search)</strong>，又称半区间查找，对数查找或者二进制切分，是一种好用的查找算法，用来查找目标值在排序数组中的位置。<br>它的工作原理是反复将列表中可能包含该项的部分一分为二，直到将可能的位置缩小到一个为止。  </p>
<article class="message is-info"><div class="message-body">

<b>Binary search: repeated checking of the middle item in an ordered search list and discarding the half of the list which does not contain the search item</b>

</div></article> 



<p>二分查找的工作原理如下所示：</p>
<ol>
<li>从数组的中间元素开始处理元素。</li>
<li>如果目标值等于数组的中间元素，则返回该元素的索引。</li>
<li>如果目标值小于中间元素，则重复数组左半部分的过程：寻找左半部分的中间点，然后看看目标值是小于这个数还是大于这个数。一直循环下去，直到找到匹配值。</li>
<li>如果目标值大于中间元素，则对数组的右半部分重复上述过程：寻找右半部分的中间点，然后看看目标值是小于这个数还是大于这个数。一直循环下去，直到找到匹配值。</li>
<li>如果在检查所有元素后仍未找到匹配值，则返回None。  </li>
</ol>
<p>Python代码实例：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params"><span class="built_in">list</span>, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(<span class="built_in">list</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        guess = <span class="built_in">list</span>[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> guess &gt; target:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(binary_search(numbers, <span class="number">5</span>))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(binary_search(numbers, <span class="number">10</span>))  <span class="comment"># 输出: None</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="抽象数据结构-ADT"><a href="#抽象数据结构-ADT" class="headerlink" title="抽象数据结构 (ADT)"></a><strong>抽象数据结构 (ADT)</strong></h2><p>13章我们说过，ADT是数据类型的数学模型。它从数据用户的角度来定义其行为的，特别是可能的值、对该类型数据的可能操作以及这些操作的行为。<br>例如，整数是一种 ADT，定义为…、-2、-1、0、1、2、…值，并可进行加、减、乘、除运算。用户可以使用抽象而非具体的表示方法。  </p>
<p><br></p>
<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h2><p>链表也是老朋友了。在这里我们会讲解有关于链表的各种操作：  </p>
<h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a><strong>创建链表</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = Node(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = Node(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(current.data)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试链表</span></span><br><span class="line">linked_list = LinkedList()</span><br><span class="line">linked_list.insert(<span class="number">1</span>)</span><br><span class="line">linked_list.insert(<span class="number">2</span>)</span><br><span class="line">linked_list.insert(<span class="number">3</span>)</span><br><span class="line">linked_list.print_list()  <span class="comment"># 输出: 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>链表是一种线性数据结构，其中每个元素都是一个独立的对象，我们将其称为节点。<br>每个节点包含两个字段： 节点包含的“数据”和节点连接的下一个节点的“指针信息”。<br>“数据”字段存储节点应持有的任何类型的数据，“指针信息”字段存储指向列表中下一个节点的引用。  </p>
<p>下面我们来解释一下上面的代码：  </p>
<ol>
<li><p><strong>创建<code>Node</code>类</strong>：该类代表链表中的单个元素。每个节点有两个属性：</p>
<ul>
<li><code>data</code>：这个属性用来存储节点所持有的实际数据</li>
<li><code>next</code>：这是存储列表中下一个节点的引用。它初始值为 <code>None</code>，这意味着它不指向任何其他节点。</li>
</ul>
</li>
<li><p><strong>创建<code>LinkedList</code>类</strong>：该类表示整个链表。类中包含一个属性和两个方法：</p>
<ul>
<li><code>head</code>：这是指向列表中第一个节点的引用。它初始设置为 <code>None</code>，这意味着列表是空的。</li>
<li><code>insert</code>：该方法会在列表末尾插入一个新节点。如果列表为空（即 <code>self.head</code> 为 <code>None</code>），它将创建一个新节点，并设置 <code>self.head</code> 指向它。否则，它会遍历列表，直到找到最后一个节点（即 <code>node.next</code> 为 <code>None</code> 的节点），然后创建一个新节点，并设置 <code>last_node.next</code> 指向它。  </li>
<li><code>print_list()</code>：该方法会打印列表中存在的所有元素。它从 <code>self.head</code> 开始处理，沿着 <code>next</code> 引用从一个节点到下一个节点，打印每个节点的数据，直到到达 <code>node.next</code> 为 <code>None</code> 的节点。  </li>
</ul>
</li>
</ol>
<p>实际上也不难。  </p>
<p><br></p>
<hr>
<h3 id="向有序列表中添加节点"><a href="#向有序列表中添加节点" class="headerlink" title="向有序列表中添加节点"></a><strong>向有序列表中添加节点</strong></h3><p>功能会基于创建链表的代码逐步添加新的模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_ordered</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = Node(data)</span><br><span class="line">        <span class="keyword">elif</span> data &lt; self.head.data:</span><br><span class="line">            new_node = Node(data)</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.data &lt; data:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            new_node = Node(data)</span><br><span class="line">            new_node.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(current.data)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line">linked_list = LinkedList()</span><br><span class="line">linked_list.insert_ordered(<span class="number">3</span>)</span><br><span class="line">linked_list.insert_ordered(<span class="number">1</span>)</span><br><span class="line">linked_list.insert_ordered(<span class="number">2</span>)</span><br><span class="line">linked_list.print_list()  <span class="comment"># 输出: 1 2 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>insert_ordered</code> 函数将一个值作为输入。它创建了一个新节点，然后为这个节点在列表中找到正确的位置。<br>如果列表为空或新值小于头节点中的值，它就会将新节点插入列表的开头。否则，它会遍历列表，直到找到一个节点的值大于新值或到达列表的末尾，然后将新节点插入该节点之前。</p>
<p>详细解释一下：  </p>
<ul>
<li><p><strong>创建<code>Node</code>类</strong>：<code>Node</code>类跟之前创建链表的代码是完全一样的。  </p>
</li>
<li><p><strong>创建<code>LinkedList</code>类</strong>：其余也与之前一样，但是方法<code>insert_ordered()</code>主要管的就是节点的正确插入。它的实现方法如下：  </p>
</li>
</ul>
<ol>
<li><p><strong>空列表</strong>： 如果列表为空（<code>self.head 为 None</code>），则会创建一个新节点，并设置<code>self.head</code>指向它。这个新节点将成为列表中的第一个节点。</p>
</li>
<li><p><strong>在开头插入</strong>： 如果新节点的数据小于头部节点的数据（<code>data &lt; self.head.data</code>），则创建一个新节点，设置 <code>new_node.next</code> 指向当前的头部节点，然后更新 <code>self.head</code> 指向这个新节点。这实际上是将新节点插入列表的开头。</p>
</li>
<li><p><strong>在中间或末尾插入</strong>： 如果新节点的数据大于或等于头部节点的数据，则需要在列表的其余部分为该节点找到正确的位置。<br>为此，它会从 <code>self.head</code> 开始遍历列表。对于每个节点，它会检查 <code>current.next.data&lt;data</code>。<br>如果该条件为真，它就会继续检查下一个节点（<code>current = current.next</code>）。如果该条件为假（意味着已找到数据大于或等于 <code>data</code> 的节点），或者已到达列表的末尾（<code>current.next is None</code>），则停止迭代。<br>然后，它会将新节点插入该节点之前（如果已到达列表末尾，则插入列表末尾）。</p>
</li>
</ol>
<p><br></p>
<hr>
<h3 id="从链表中查找数据"><a href="#从链表中查找数据" class="headerlink" title="从链表中查找数据"></a><strong>从链表中查找数据</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_ordered</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = Node(data)</span><br><span class="line">        <span class="keyword">elif</span> data &lt; self.head.data:</span><br><span class="line">            new_node = Node(data)</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.data &lt; data:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            new_node = Node(data)</span><br><span class="line">            new_node.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_element</span>(<span class="params">self, target</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="keyword">if</span> current.data == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> current.data &gt; target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line">linked_list = LinkedList()</span><br><span class="line">linked_list.insert_ordered(<span class="number">1</span>)</span><br><span class="line">linked_list.insert_ordered(<span class="number">2</span>)</span><br><span class="line">linked_list.insert_ordered(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(linked_list.find_element(<span class="number">2</span>))  <span class="comment"># 输出: True</span></span><br><span class="line"><span class="built_in">print</span>(linked_list.find_element(<span class="number">4</span>))  <span class="comment"># 输出: False</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>find_element</code> 函数将目标值作为输入，并负责元素的寻找。它从列表的首项开始，遍历每个节点。如果找到数据等于目标值的节点，则返回 <code>True</code>。如果找到数据大于目标值的节点（因为列表是有序的），则返回 <code>假</code>，因为它知道目标值不在列表中。<br>如果没有找到目标值就到达了列表的末尾，也会返回<code>假</code>。  </p>
<p>人话讲：该方法遍历一个有序链表，一旦发现数据等于目标节点（返回 <code>True</code>）或数据大于目标节点（返回 <code>False</code>），就立即停止。</p>
<p>我们来详细看一下<code>find_element</code>是怎么完成这一操作的：  </p>
<ol>
<li><strong>初始化</strong>： 该方法首先将 <code>current</code> 设置为列表的首项。 这是我们在循环的每次迭代中都要检查的节点。  </li>
<li><strong>循环</strong>： 只要 <code>current</code> 不是 <code>None</code>，<code>while</code> 循环就会继续。 换句话说，当我们找到目标或检查了列表中的所有节点后，循环就会停止。  </li>
<li><strong>检查是否相等</strong>： 在循环的每次迭代中，首先检查 <code>current</code> 节点的数据是否等于目标（<code>current. data == target</code>）。 如果相等，则返回 <code>True</code>，表示已在列表中找到目标。</li>
<li><strong>检查顺序</strong>： 如果 <code>current</code> 节点的数据不等于目标值，则检查它是否大于目标值（<code>current. data &gt; target</code>）。 如果是，则返回 <code>False</code>。 这是因为在有序链表中，如果我们遇到一个节点的值大于我们的目标值，我们就知道我们的目标值不可能出现在链表中更远的地方。</li>
<li><strong>移动到下一个节点</strong>： 如果上述两个条件都不满足（即 <code>current.data</code>小于 <code>target</code>），则移动到列表中的下一个节点（<code>current = current.next</code>）并重复上述过程。</li>
<li><strong>未找到目标</strong>： 如果已检查了列表中的所有节点，但仍未找到目标（即已退出 <code>while</code> 循环），则返回 <code>False</code>。</li>
</ol>
<p><br></p>
<hr>
<h3 id="从链表中删除节点"><a href="#从链表中删除节点" class="headerlink" title="从链表中删除节点"></a><strong>从链表中删除节点</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_ordered</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = Node(data)</span><br><span class="line">        <span class="keyword">elif</span> data &lt; self.head.data:</span><br><span class="line">            new_node = Node(data)</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.data &lt; data:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            new_node = Node(data)</span><br><span class="line">            new_node.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete_node</span>(<span class="params">self, target</span>):</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.head.data == target:</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.data != target:</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(current.data)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line">linked_list = LinkedList()</span><br><span class="line">linked_list.insert_ordered(<span class="number">1</span>)</span><br><span class="line">linked_list.insert_ordered(<span class="number">2</span>)</span><br><span class="line">linked_list.insert_ordered(<span class="number">3</span>)</span><br><span class="line">linked_list.delete_node(<span class="number">2</span>)</span><br><span class="line">linked_list.print_list()  <span class="comment"># 输出: 1 3</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>delete_node</code> 函数将目标值作为输入。<br>它从列表的首项开始，遍历每个节点。如果找到一个数据等于目标值的节点，它就会调整前一个节点的 <code>next</code> 引用，使其指向下一个节点，从而有效地从列表中删除目标节点。如果在检查所有节点后仍未找到这样的节点，则不会执行任何操作。  </p>
<p>人话讲：此方法遍历一个有序链表，并删除一个数据等于 <code>target</code> 的节点。如果列表中不存在这样的节点，则不执行任何操作。</p>
<p>详细看一下<code>delete_node</code>的步骤：  </p>
<ol>
<li><p><strong>空列表</strong>： 该方法首先检查列表是否为空（<code>self.head is None</code>）。如果是，则退出方法，因为没有要删除的内容。  </p>
</li>
<li><p><strong>删除头部节点</strong>： 然后，它会检查头部节点是否是要删除的节点（<code>self.head.data == target</code>）。如果是，它就会更新 <code>self.head</code> 以指向列表中的下一个节点（<code>self.head = self.head.next</code>），从而有效地从列表中删除原来的头部节点。</p>
</li>
<li><p><strong>循环</strong>： 如果头节点不是要删除的节点，它就会进入一个循环，其中 <code>current</code> 从列表的头开始，只要 <code>current.next</code> 不是 <code>None</code> （即直到到达列表的末尾）且 <code>current.next.data</code> 不等于 <code>target</code> （即直到找到要删除的节点），就会沿着列表移动。</p>
</li>
<li><p><strong>删除节点</strong>： 如果它找到了下一个节点的数据等于 <code>target</code> 的节点（<code>current.next.data == target</code>），它就会更新 <code>current.next</code> 以指向下一个节点的下一个节点（<code>current.next = current.next.next</code>）。这实际上是从列表中删除了下一个节点（要删除的节点）。</p>
</li>
</ol>
<p><br></p>
<hr>
<h3 id="访问链表中的所有节点"><a href="#访问链表中的所有节点" class="headerlink" title="访问链表中的所有节点"></a><strong>访问链表中的所有节点</strong></h3><p>这个就相对简单一些了。思路就是按照指针的顺序，按照顺序访问每个节点，然后输出节点中的内容。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = Node(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = Node(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(current.data)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line">linked_list = LinkedList()</span><br><span class="line">linked_list.insert(<span class="number">1</span>)</span><br><span class="line">linked_list.insert(<span class="number">2</span>)</span><br><span class="line">linked_list.insert(<span class="number">3</span>)</span><br><span class="line">linked_list.print_list()  <span class="comment"># 输出: 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>在本例中，<code>print_list</code> 函数从列表的首部开始，遍历每个节点，打印其数据。 它将继续执行，直到到达 <code>next</code> 为 <code>None</code> 的节点，表示已到达列表的末尾。 这样，它就访问并打印了列表中的所有节点。  </p>
<p><br></p>
<hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h2><p>在计算机科学中，<strong>二叉树 (Binary tree )</strong>是一种被称之为k-ary的数据结构，其中每个节点最多有两个延伸出来的子节点。这些节点一般被叫做<strong>左子节点 (Left child)</strong>和<strong>右子节点 (Right child)</strong>。  </p>
<p>二叉树是递归定义的，这就意味着每一棵非空二叉树都由一个根节点和两个后代二叉树组成。  </p>
<p>下面是关于二叉树的一些要点和常识：  </p>
<ul>
<li>二叉树中最顶端的节点叫做<strong>根节点 (Root)</strong></li>
<li>二叉树中的每一个元素都叫做<strong>节点 (Node)</strong></li>
<li>每个节点<strong>最多有两个子节点</strong></li>
<li>子节点一般被叫做<strong>左子节点 (Left child)</strong>和<strong>右子节点 (Right child)</strong>，这个我们刚才说过。  </li>
<li>二叉树可用于许多计算机科学应用中，包括组织层次关系、管理有序数据以及作为抽象流程的工作流。</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2d2cda1d6dfdb4d7ad1386eff176368c?method=download&amp;shareKey=1d3e8b512293bbcd2289fdb637b74404" alt=""></p>
<p><br></p>
<p>要向有序二叉树增加一个节点，我们的步骤如下：  </p>
<ol>
<li><p><strong>从作为当前节点的根节点开始</strong>： 进程从树的根节点开始，也就是最顶端的节点。</p>
</li>
<li><p><strong>重复</strong>： 接下来重复这些条件：</p>
<ul>
<li><p><strong>如果数据值大于当前节点的数据值，则沿右分支</strong>： 在二叉树中，<strong>任何数据值大于其父节点的节点都会被置于右侧</strong>。因此，如果要插入的数据值大于当前节点的数据值，则应移动到当前节点的右侧子节点。</p>
</li>
<li><p><strong>如果数据值小于当前节点的数据值，则沿左侧分支</strong>： 相反，在二叉树中，<strong>任何数据值小于其父节点的节点都会被置于左侧</strong>。因此，如果要插入的数据值小于当前节点的数据值，就会移动到当前节点的左侧子节点。</p>
</li>
</ul>
</li>
<li><p><strong>直到当前节点没有分支可循</strong>： 继续在树中移动，直到到达一个在需要移动的方向上没有子节点的节点（即向左移动时没有左子节点，向右移动时没有右子节点）。这就是你要插入新节点的地方。</p>
</li>
<li><p><strong>在此位置添加新节点</strong>： 根据数据小于或大于当前节点的数据，创建一个包含数据的新节点，并将其作为当前节点的左子节点或右子节点插入。</p>
</li>
</ol>
<p>这个过程确保了左边的所有节点都小于其父节点，而右边的所有节点都大于其父节点，这就是有序或排序二叉树的原理。</p>
<p><br></p>
<hr>
<h3 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a><strong>创建二叉树</strong></h3><p>我们可以使用Python来创建一个二分查找树：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">        self.root = Node(root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化二叉树</span></span><br><span class="line">tree = BinaryTree(<span class="number">1</span>)</span><br><span class="line">tree.root.left = Node(<span class="number">2</span>)</span><br><span class="line">tree.root.right = Node(<span class="number">3</span>)</span><br><span class="line">tree.root.left.left = Node(<span class="number">4</span>)</span><br><span class="line">tree.root.left.right = Node(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>解释一下这段代码：</p>
<ul>
<li>我们首先定义了一个 <code>Node</code> 类，它将创建一个带值的节点，以及两个初始化为 <code>None</code> 的子节点。</li>
<li>然后，我们定义一个 <code>BinaryTree</code> 类，初始化为一个根节点。</li>
<li>最后，我们创建一棵名为 <code>tree</code> 的二叉树，根节点为 1，然后在根节点上添加左侧子节点 2 和右侧子节点 3。 然后，我们在根的左子节点上添加两个子节点 4 和 5。</li>
</ul>
<p>画出图来就像这样：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>十分形象。  </p>
<p>我们详细来说一下实现步骤：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">self. value = value</span><br><span class="line">self. left = <span class="literal">None</span></span><br><span class="line">self. right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>先讲一下<code>Node</code>类的定义。每个<code>Node</code>对象都有三个属性:</p>
<ul>
<li><code>value</code>:节点持有的数据。</li>
<li><code>left</code>:指向节点的左子节点。</li>
<li><code>right</code>:指向节点的右子节点。</li>
</ul>
<p>而<code>__init__</code>方法是Python类中的一个特殊方法，当类的对象实例化时，它是自动调用的构造方法。在这个例子中，它用给定的值初始化一个节点，并将其左子节点和右子节点设置为<code>None</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">self. root = Node(root)</span><br></pre></td></tr></table></figure>
<p>在<code>BinaryTree</code>类的定义中，二叉树对象有一个属性:<code>root</code>，它是对树的根节点的引用。这里的<code>__init__</code>方法用根节点初始化一棵二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化二叉树</span></span><br><span class="line">tree = BinaryTree(<span class="number">1</span>)</span><br><span class="line">tree.root.left = Node(<span class="number">2</span>)</span><br><span class="line">tree.root.right = Node(<span class="number">3</span>)</span><br><span class="line">tree.root.left.left = Node(<span class="number">4</span>)</span><br><span class="line">tree.root.left.right = Node(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在这里，我们创建一个二叉树实例。 我们用一个包含值 1 的根节点来初始化它。<br>随后，我们通过创建新节点并将其赋值给 <code>tree.root.left</code> 和 <code>tree.root.right</code> 来为根节点添加左右两个子节点。<br>我们还将以类似的方式为根节点的左侧子节点添加两个子节点。  </p>
<p><br></p>
<hr>
<h3 id="向二叉树中添加一个新节点"><a href="#向二叉树中添加一个新节点" class="headerlink" title="向二叉树中添加一个新节点"></a><strong>向二叉树中添加一个新节点</strong></h3><p>在二叉树中，新节点可以根据一定的规则或标准插入某个位置。然而，在二分查找树（BST）中，节点会被插入到一个特定的位置，在这个位置上，节点左边的所有节点的值都小于该节点，而右边的所有节点的值都大于该节点。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">        self.root = Node(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = Node(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._insert(value, self.root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_insert</span>(<span class="params">self, value, current_node</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; current_node.value:</span><br><span class="line">            <span class="keyword">if</span> current_node.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                current_node.left = Node(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(value, current_node.left)</span><br><span class="line">        <span class="keyword">elif</span> value &gt; current_node.value:</span><br><span class="line">            <span class="keyword">if</span> current_node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                current_node.right = Node(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._insert(value, current_node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Value already in tree!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a tree</span></span><br><span class="line">tree = BinaryTree(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">1</span>)</span><br><span class="line">tree.insert(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们为原来的 <code>BinaryTree</code> 类新添加了一个 <code>insert</code> 方法，该方法将一个值作为输入。<br>如果树为空（即根节点为 <code>None</code>），它将用给定的值创建一个新的 <code>Node</code>，并将其赋值给根节点。如果树不为空，则调用 <code>_insert</code> 方法。  </p>
<p><code>_insert</code> 方法是一个辅助方法，用于为新节点找到正确的位置。<br>它是一个递归方法，用于比较要插入的值和当前节点的值。具体步骤如下：  </p>
<ul>
<li>如果待插入的值小于当前节点的值，就会插入左侧子节点。  如果左侧子节点为 <code>None</code>，则在此处插入新节点。否则，它会再次调用 <code>_insert</code>，将左侧子节点作为新的当前节点。</li>
<li>如果待插入的值大于当前节点的值，则转到右侧子节点。如果右侧子节点为 <code>None</code>，则在此处插入新节点。否则，它会再次调用 <code>_insert</code>，并将右侧子节点作为新的当前节点。</li>
<li>如果值等于当前节点的值，则会打印一条信息，说明该值已在树中，而不会插入。</li>
</ul>
<p>这样就能在二分查找树中，当插入新节点时保持它的特性不变了。</p>
<p><br></p>
<hr>
<h3 id="在二叉树中寻找指定节点"><a href="#在二叉树中寻找指定节点" class="headerlink" title="在二叉树中寻找指定节点"></a><strong>在二叉树中寻找指定节点</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">        self.root = Node(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"二叉树为空。"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._find(value, self.root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find</span>(<span class="params">self, value, current_node</span>):</span><br><span class="line">        <span class="keyword">if</span> value == current_node.value:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"已发现匹配值"</span></span><br><span class="line">        <span class="keyword">elif</span> value &lt; current_node.value <span class="keyword">and</span> current_node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self._find(value, current_node.left)</span><br><span class="line">        <span class="keyword">elif</span> value &gt; current_node.value <span class="keyword">and</span> current_node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self._find(value, current_node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"未发现匹配值"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化二叉树</span></span><br><span class="line">tree = BinaryTree(<span class="number">5</span>)</span><br><span class="line">tree.root.left = Node(<span class="number">3</span>)</span><br><span class="line">tree.root.right = Node(<span class="number">7</span>)</span><br><span class="line">tree.root.left.left = Node(<span class="number">1</span>)</span><br><span class="line">tree.root.left.right = Node(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在二叉树中寻找特定值</span></span><br><span class="line"><span class="built_in">print</span>(tree.find(<span class="number">7</span>))  <span class="comment"># 输出: "已找到匹配值"</span></span><br><span class="line"><span class="built_in">print</span>(tree.find(<span class="number">2</span>))  <span class="comment"># Output: "未找到匹配值"</span></span><br></pre></td></tr></table></figure>
<p>为了添加寻找节点功能，在这段代码中，我们为我们的 <code>BinaryTree</code> 类添加了一个 <code>find</code> 方法，该方法将一个值作为输入。<br>如果树为空（即根为 <code>None</code>），它将返回一条信息，说明树为空。如果树不为空，则调用 <code>_find</code>方法。  </p>
<p><code>_find</code> 方法是一个辅助方法，用于查找具有给定值的节点。它是一个递归方法，用于比较要查找的值和当前节点的值：</p>
<ul>
<li>如果值等于当前节点的值，则返回一条信息，说明已找到该值。</li>
<li>如果值小于当前节点的值，且左侧子节点不是 <code>None</code>，则再次调用 <code>_find</code>，并将左侧子节点作为新的当前节点。</li>
<li>如果值大于当前节点的值，且右侧子节点不是 <code>None</code>，则再次调用 <code>_find</code>，并将右侧子节点作为新的当前节点。</li>
<li>如果这些条件都不满足，则表示在树中没有找到该值，并返回一条信息说明这一点。  </li>
</ul>
<p>这将在二分查找树中查找给定值。</p>
<p><br></p>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h2><p>我们早在AS部分就已经接触过栈了。接下来我们来简单复习一下栈的性质。  </p>
<p>栈是一种作为元素集合的抽象数据类型，栈主要有两种操作：  </p>
<ul>
<li><strong>Push 推入</strong>：也就是向集合压进元素。</li>
<li><strong>Pop 弹出</strong>：弹出最近添加但尚未删除的元素。  </li>
</ul>
<p>元素加入栈或从栈中移除的顺序被描述为<strong>后进先出 (Last in first out, LIFO)</strong>。这种结构使得从栈顶移除一个项目非常容易，但要访问栈中较深的数据可能需要先移除多个其他项目。  </p>
<p>我们会声明一个<code>TopOfStack</code>指针变量，用来跟踪栈顶元素。它的值根据在栈上执行的操作而变化。  </p>
<ul>
<li>当向栈中推入一个新元素时，<code>TopOfStack</code> 会更新为指向这个新元素。</li>
<li>当从栈中弹出一个元素时，<code>TopOfStack</code> 会更新为指向栈中的下面一个元素。</li>
<li>如果栈是空的，<code>TopOfStack</code> 可能会被设置为一个特殊值，如<code>-1</code>，以表示没有顶层元素。  </li>
</ul>
<p>例如，如果要将栈作为数组来实现，一开始可以将 <code>TopOfStack</code> 设为 <code>-1</code>，以表示栈是空的。当向栈中推入一个元素时，<code>TopOfStack</code> 会递增 1；当从栈中弹出一个元素时，<code>TopOfStack</code> 会递减 1。  </p>
<p><br></p>
<hr>
<h3 id="栈的创建，压入和弹出"><a href="#栈的创建，压入和弹出" class="headerlink" title="栈的创建，压入和弹出"></a><strong>栈的创建，压入和弹出</strong></h3><p>Python内置的List数据类型可以很轻松的让我们创建一个栈：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化栈</span></span><br><span class="line">stack = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向栈中压入元素</span></span><br><span class="line">stack.append(<span class="string">"Apple"</span>)</span><br><span class="line">stack.append(<span class="string">"Banana"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从栈中弹出元素</span></span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 输出: "Banana"</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们初始化一个空列表作为栈。<br>我们使用列表的<code>append</code>方法将元素压入栈中，使用<code>pop</code>方法将元素从栈中弹出。<br>最后添加的元素是第一个弹出的元素，这与栈的LIFO行为一致。  </p>
<p><br></p>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h2><p>在计算机中，<strong>队列 (Queue)</strong>是一种遵循<strong>先进先出 (First in first out, FIFO)</strong>原则的线性数据结构。这意味着第一个添加到队列的元素将是第一个被删除的元素。你可以把它想象成一排等待服务的人，等待时间最长的人(排队的第一个人)是下一个被服务的人。相比于栈来说，这是比较符合直觉的。  </p>
<p>在队列中，我们会定义两个指针类型变量： <code>FountOfQueuePointer</code>和<code>EndOfQueuePointer</code>，分别用来追踪队列中的第一个和最后一个元素：    </p>
<ul>
<li><code>FrontOfQueuePointer</code>始终指向队列中的第一个元素，它是下一个要从队列中删除的元素。这是因为在队列中，删除操作发生在最前面。</li>
<li><code>EndOfQueuePointer</code>始终指向队列中的最后一个元素。当一个新元素被添加(或“加入”)到队列中时，它会被添加到队列的末尾，所以<code>EndOfQueuePointer</code>会递增指向这个新元素。  </li>
</ul>
<p>队列还存在所谓“环绕的可能性”。<br>这指的是循环队列（一种最后一个元素指向第一个元素的队列）中的一种情况，在这种情况下，如果将 <code>EndOfQueuePointer</code> 的增量超出底层数组的终点，就会导致它绕到数组的起点。 同样，将 <code>FrontOfQueuePointer</code> 递减到数组开头之后，也会使其绕到数组结尾。 这样就可以重复使用数组中之前被从队列中删除的元素占据的位置，从而有效地利用空间。  </p>
<p>常规队列和环绕型队列如下所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8b60aee54b0ff92ba7d26079e71c28ed?method=download&amp;shareKey=c5fe2e70395fe4a2a87200867755e063" alt="">  </p>
<p><br></p>
<hr>
<h3 id="队列的创建，压入和弹出"><a href="#队列的创建，压入和弹出" class="headerlink" title="队列的创建，压入和弹出"></a><strong>队列的创建，压入和弹出</strong></h3><p>Python的列表数据形式也同样支持我们去简单的声明并操作一个队列：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化队列</span></span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向队列内加入元素</span></span><br><span class="line">queue.append(<span class="string">"Apple"</span>)</span><br><span class="line">queue.append(<span class="string">"Banana"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列内弹出元素</span></span><br><span class="line"><span class="built_in">print</span>(queue.pop(<span class="number">0</span>))  <span class="comment"># 输出: "Apple"</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们初始化一个空列表作为队列。<br>我们使用列表的<code>append</code>方法将项目加入到队列中，并使用<strong>参数为0的<code>pop</code>方法</strong>将项目从队列中取出。这里的参数决定了这个列表是一个队列，而不是一个栈。<br>添加的第一个元素就是第一个删除的元素，这与队列的FIFO行为是一致的。  </p>
<p><br></p>
<hr>
<h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a><strong>图表</strong></h2><p>在计算机科学中，<strong>图表 (Graphs)</strong>是由顶点(或者节点)和边组成的抽象数据类型，用于实现数学中图理论领域的无向图和有向图概念，或者简单来说：记录事物之间的关系。   </p>
<p>图表是一种基本数据结构，它对一组对象（称为节点或顶点）以及它们之间的关系（称为边或弧）进行建模。  </p>
<p>图表也可以描述AI，但是在这里我们不讨论。如果需要了解这部分的内容就前往22章简单一看吧。<br>下面的图表表示伦敦地铁地图的一小部分：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1e591ab087f1c7bf6f2829597e4bfbbf?method=download&amp;shareKey=68eeffc7a87259b6d08ab9971eb0caf4" alt=""></p>
<p>从A到F的所有顶点表示地铁站，而连接线表示连接地铁站的铁路线。<br>例如，你可以直接从B乘火车到D。要从B乘火车到F，你必须经过C或E。由边连接的两个顶点被称为<strong>邻居 (Neighbours)</strong>。  </p>
<p>同时，你也可以在连接线上加入标签，也就是权重。在我们的这个实例中，我们可以使用权重来表示站点之间的旅行时间：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBed46bc816951caaf87533527859a2497?method=download&amp;shareKey=ca32533cb3e73661b5244396e5a34347" alt="">  </p>
<p>节点之间的连接线可以是有向的，也可以是无向的：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2a70cdc74196bdc4b8b4914973664f22?method=download&amp;shareKey=15befb1d71be8f99f560669d08694c39" alt=""></p>
<p><br></p>
<p>在计算机内存中，有两种常见的图表示方法：<strong>邻接矩阵 (Adjacency matrix)</strong>和<strong>邻接表 (Adjacency list)</strong>。  </p>
<p>邻接矩阵是大小为 V x V 的二维数组，其中 V 是图中的顶点数。<br>每一行和每一列代表一个顶点。如果矩阵中第 i 行和第 j 列的元素值为 1，则表示第 i 个顶点和第 j 个顶点之间有一条边。反之，如果值为0，则表示两个顶点之间没有连接。这种表示方法仅适用于无权重图表。 </p>
<p>而对于加权图表，边有相关的权重或成本，这些权重会直接写在对应的表格内。比如说第 i 个顶点和第 j 个顶点之间有链接，并且权重为5，那么矩阵中第 i 行和第 j 列的元素值为 5。<br>如果顶点之间没有边，我们通常会用一个很大的数字（通常用无穷符号∞表示）来代替 0，以表示这两个节点之间没有直接路径。  </p>
<p>下面是分别是无权图表和加权图表的邻接矩阵的实例：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6ad152e5c63fb26dd2c4523c0861bf19?method=download&amp;shareKey=1583bbda1fa2ab15a32fb08c3f8c2eae" alt=""></p>
<p><br></p>
<p>刚才提到过的邻接表是表示图形的另一种方法。  </p>
<p>在邻接列表表示法中，我们在图形对象中保留了一个包含所有顶点的主列表，然后图形中的每个顶点对象都保留了一个与其相连的其他顶点的列表。在邻接表中，每个顶点都有一个相邻顶点的列表。这非常适合需要遍历每个顶点的邻接顶点时使用，因为可以高效地访问邻接顶点集。  </p>
<p>解释的有些抽象，我们直接看下面这个邻接表的实例吧：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBea3ebc99b970c2b6eab8c8058ca2f606?method=download&amp;shareKey=56fc19134bc34f53c52fcca3b2139182" alt="">  </p>
<p>图表中的内容代表：  </p>
<ul>
<li>A与B和D相连</li>
<li>B与A,C,D,E相连</li>
<li>C与B和F相连</li>
<li>D与A,B,E相连</li>
<li>E与B,D,F相连</li>
<li>F与C,E相连</li>
</ul>
<p>不难看出这个邻接表展示了一个无权重的图表的节点之间的关系。如果需要表示节点之间的权重，就会像下图一样：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBbbd6fdd340c9487644095c2592dd31f7?method=download&amp;shareKey=155d472a5ef05bfc7620c0de30daad0f" alt=""></p>
<p>道理还是一样，不过加了个权重而已。  </p>
<p>第一行代表：“A与B相连，权重为3；A与D相连，权重为5”  </p>
<p><br></p>
<hr>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><strong>哈希表</strong></h2><p><strong>哈希表 (Hash table)</strong>，也叫散列表，是一种实现关联数组抽象数据类型的数据结构，是一种可以将键映射到值的结构。<br>它使用哈希函数来计算一个进入桶或槽数组的索引，从中可以找到所需的值。<br>哈希表背后的主要理念是，它提供了对存储在数组中的记录的直接访问。这是通过使用记录的键值计算出一个地址（数组索引），然后将记录存储在这个计算出的地址上。<br>当你想搜索一条记录时，你可以再次使用键值来计算地址，然后直接到这个地址去查找记录。这种通过密钥计算地址的过程被称为<strong>散列 (Hashing)</strong>。  </p>
<p><br></p>
<hr>
<h3 id="哈希表的创建，添加元素，与查找"><a href="#哈希表的创建，添加元素，与查找" class="headerlink" title="哈希表的创建，添加元素，与查找"></a><strong>哈希表的创建，添加元素，与查找</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的散列函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_function</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">return</span> key % <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个空哈希表</span></span><br><span class="line">hash_table = [<span class="literal">None</span>] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向哈希表中添加元素</span></span><br><span class="line">keys = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>]</span><br><span class="line">values = [<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Cherry"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(keys)):</span><br><span class="line">    address = hash_function(keys[i])</span><br><span class="line">    hash_table[address] = values[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从哈希表中搜索元素</span></span><br><span class="line">key_to_search = <span class="number">30</span></span><br><span class="line">address = hash_function(key_to_search)</span><br><span class="line"><span class="built_in">print</span>(hash_table[address])  <span class="comment"># Output: "Banana"</span></span><br></pre></td></tr></table></figure>
<p>我们来简单解释一下这写代码：  </p>
<p>在函数<code>hash_function</code>中，我们创建了一个简单的哈希函数。它接收一个值，然后返回该值除以 5 的余数。这会输出在0-4区间内的一个值。这个值会用来计算哈希表中我们要存储或查找值的索引。  </p>
<p><code>hash_table = [None] * 5</code> 将一个空的哈希表初始化为一个包含 <code>None</code> 值的列表。该<strong>列表的长度（5）应与散列函数返回的可能值范围相同</strong>。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>]</span><br><span class="line">values = [<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Cherry"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(keys)):</span><br><span class="line">    address = hash_function(keys[i])</span><br><span class="line">    hash_table[address] = values[i]</span><br></pre></td></tr></table></figure>
<p>在本节中，我们将向哈希表中插入一些内容，我们将这些内容叫做<strong>记录 (Record)</strong>。<br>我们有两个列表：<code>keys</code>（包含记录的键）和 <code>values</code>（包含相应的值）。我们遍历这些列表，使用散列函数计算每个键的地址，并将每个值存储在散列表中计算出的地址处。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key_to_search = <span class="number">30</span></span><br><span class="line">address = hash_function(key_to_search)</span><br><span class="line"><span class="built_in">print</span>(hash_table[address])  <span class="comment"># Output: "Banana"</span></span><br></pre></td></tr></table></figure>
<p>最后，我们要搜索带有给定键的记录。<br>我们使用哈希函数计算出这个键的地址，并输出存储在哈希表中这个地址的值。<br>在本例中，我们要查找的是键 “30”，它的散列地址是 “0”，在散列表的这个地址上，我们可以找到值<code>Banana</code>。  </p>
<p><br></p>
<hr>
<h2 id="词典"><a href="#词典" class="headerlink" title="词典"></a><strong>词典</strong></h2><p>在计算机科学中，<strong>词典 (Dictionary)</strong>也称为<strong>映射 (Map)</strong>，是一种用于存储键值对的数据结构，类似于现实世界中的词典。<br>键用于查找相关的值，就像在现实世界的词典中查找单词的定义一样。  </p>
<p>词典可以使用各种数据结构来实现，哈希表就是其中之一。哈希表使用哈希函数来计算的索引，从中可以找到所需的值。这样就可以使用键值高效地直接访问检索值。  </p>
<p>例如，如果您有一本将英语单词翻译成法语的词典，您可以将英语单词作为键，将法语翻译作为值。如果将该词典作为哈希表来实现，则可以通过将英语单词作为键，快速高效地查找任何给定英语单词的法语翻译。   </p>
<p><br></p>
<hr>
<h3 id="词典的创建与操作"><a href="#词典的创建与操作" class="headerlink" title="词典的创建与操作"></a><strong>词典的创建与操作</strong></h3><p>VB.NET和Java都有内置的词典数据类型，但是他们看起来好像都很复杂。  </p>
<p>好在Python也存在内置的词典数据类型：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建词典</span></span><br><span class="line">english_french_dict = {</span><br><span class="line">    <span class="string">"hello"</span>: <span class="string">"bonjour"</span>,</span><br><span class="line">    <span class="string">"goodbye"</span>: <span class="string">"au revoir"</span>,</span><br><span class="line">    <span class="string">"please"</span>: <span class="string">"s'il vous plaît"</span>,</span><br><span class="line">    <span class="string">"thank you"</span>: <span class="string">"merci"</span>,</span><br><span class="line">    <span class="string">"yes"</span>: <span class="string">"oui"</span>,</span><br><span class="line">    <span class="string">"no"</span>: <span class="string">"non"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问词典中的数据</span></span><br><span class="line"><span class="built_in">print</span>(english_french_dict[<span class="string">"hello"</span>])  <span class="comment"># 输出: "bonjour"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向词典中加入新的值</span></span><br><span class="line">english_french_dict[<span class="string">"sorry"</span>] = <span class="string">"désolé"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从词典中移除值</span></span><br><span class="line"><span class="keyword">del</span> english_french_dict[<span class="string">"goodbye"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查一个值是否在词典里</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"please"</span> <span class="keyword">in</span> english_french_dict)  <span class="comment"># 输出: True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出词典中所有元素的索引</span></span><br><span class="line"><span class="built_in">print</span>(english_french_dict.keys())  <span class="comment"># 输出: dict_keys(['hello', 'please', 'thank you', 'yes', 'no', 'sorry'])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出词典中所有的元素</span></span><br><span class="line"><span class="built_in">print</span>(english_french_dict.values())  <span class="comment"># 输出: dict_values(['bonjour', "s'il vous plaît", 'merci', 'oui', 'non', 'désolé'])</span></span><br></pre></td></tr></table></figure>
<p>挺简单的，代码我就不解释了。  </p>
<p><br></p>
<hr>
<h2 id="时间复杂度与大O符号"><a href="#时间复杂度与大O符号" class="headerlink" title="时间复杂度与大O符号"></a><strong>时间复杂度与大O符号</strong></h2><p>大O符号是一种数学符号，用于描述当参数趋向特定值或无穷大时函数的极限行为。<br>在计算机科学中，它用于根据算法对输入大小变化的反应（时间复杂度）对算法进行分类。  </p>
<p>我们来设想一个线性搜索算法。线性搜索算法的时间复杂度为 O(n)。这是因为在最坏的情况下（正在搜索的项目位于列表的末尾），运行算法所需的时间与输入的大小呈线性增长。这意味着，如果将列表的大小增加一倍，最坏情况下的时间也将大致增加一倍。  </p>
<p>值得注意的是，大O符号通常描述的是最坏情况，因为它提供了时间要求的上限，通常比最佳或平均情况更重要。不过，在某些情况下，平均情况或最佳情况也可以用大O符号来描述。</p>
<p><br></p>
<p>我们来考虑计算一下冒泡排序的时间复杂度：  </p>
<p>冒泡排序是一种简单的排序算法，它重复通过列表，比较相邻的元素，如果顺序错误，则交换它们。重复通过列表，直到列表排序完毕。  </p>
<p>最坏情况下，冒泡排序的时间复杂度为 O(n^2)。原因如下：</p>
<ul>
<li>在第一次通过列表时，冒泡排序会进行 n-1 次比较，其中 n 是列表中元素的个数。这是因为它会对每一对相邻元素进行比较（n 元素为 n-1 对）。</li>
<li>在第二次排序时，由于最大的元素已经在第一次排序的正确位置上，所以要进行 n-2 次比较。</li>
<li>这种情况一直持续到最后一次，只进行 1 次比较。</li>
</ul>
<p>因此，在最坏的情况下，泡泡排序所做的比较总数是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="33.029ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14598.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1211.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2211.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2711.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mstyle" transform="translate(3100.4,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(3489.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mstyle" transform="translate(4267.7,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(4656.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5045.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5868.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6868.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(7368.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mstyle" transform="translate(7757.3,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(8146.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mstyle" transform="translate(8924.6,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(9313.8,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mstyle" transform="translate(10485.8,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(10875,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mstyle" transform="translate(11653,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mn" transform="translate(12042.2,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mstyle" transform="translate(12542.2,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(12931.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mstyle" transform="translate(13709.4,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mn" transform="translate(14098.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>，这个总和等于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="6.204ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 2742.3 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1589,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2367,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2867,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mn" transform="translate(1194.4,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="2502.3" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>，简化为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="13.007ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 5749 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g><g data-mml-node="msup" transform="translate(1278,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(633,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mstyle" transform="translate(2314.6,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(2703.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mstyle" transform="translate(3481.8,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mn" transform="translate(3871,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g><g data-mml-node="mi" transform="translate(5149,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 。  </p>
<p>当我们讨论时间复杂度和大O符号时，我们感兴趣的是运行时间是如何随着输入大小的增长而增长的。<br>因此，我们取最高阶项（即 n^2），忽略常数和低阶项。这就是为什么我们说冒泡排序的最坏情况时间复杂度为 O(n^2)。这意味着，如果将列表的大小增加一倍，最坏情况下的时间大约会翻两番。如果将列表的大小增加两倍，最坏情况下的时间将增加约 9 倍。以此类推。  </p>
<p>下面这张表格展示了不同的大O符号代表了哪些算法：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Order of growth</th>
<th style="text-align:left">Example</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">O(1)</td>
<td style="text-align:left"><code>FUNCTION GetFirstItem(List : ARRAY); RETURN List[1]</code></td>
<td style="text-align:left">算法的复杂度不会随数据集的大小而改变</td>
</tr>
<tr>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">线性搜索<br>在已排序的列表上执行Bubble soft</td>
<td style="text-align:left">这些算法呈线性增长</td>
</tr>
<tr>
<td style="text-align:left">O(Log2(n))</td>
<td style="text-align:left">二分搜索</td>
<td style="text-align:left">随着数据集大小的增加，所花费的总时间也会增加，但每次比较都会将数据集减半。所以所用的时间增加的幅度较小，接近常数时间。</td>
</tr>
<tr>
<td style="text-align:left">O(n^2)</td>
<td style="text-align:left">冒泡排序<br>插入排序</td>
<td style="text-align:left">以平方速度增长<br>这在涉及数据集上嵌套迭代的算法中很常见</td>
</tr>
<tr>
<td style="text-align:left">O(n^3)</td>
<td style="text-align:left"></td>
<td style="text-align:left">以次方速度增长<br>常见于嵌套算法</td>
</tr>
<tr>
<td style="text-align:left">O(2^n)</td>
<td style="text-align:left">斐波那契数的递归计算</td>
<td style="text-align:left">指数速度增长</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h1 id="第二十四章：递归"><a href="#第二十四章：递归" class="headerlink" title="第二十四章：递归"></a><strong>第二十四章：递归</strong></h1></div><div class="article-licensing box"><div class="licensing-title"><p>A2CS笔记</p><p><a href="http://naughtychas.github.io/2023/07/01/A2CS笔记/">http://naughtychas.github.io/2023/07/01/A2CS笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://NaughtyChas.github.io"><p>MXK</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-07-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-10-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/" target="_blank" rel="noreferrer">邈想日集</a><br></span><span>  2.<a class="is-size-6" href="/2022/08/24/Latex%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">LaTeX自学笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/" target="_blank" rel="noreferrer">浅谈今年CAIE的POE考试</a><br></span><span>  6.<a class="is-size-6" href="/2022/09/05/%E4%BD%A0%E8%AF%B4%E5%BE%97%E5%AF%B9/" target="_blank" rel="noreferrer">收集&quot;你说得对&quot;</a><br></span></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/12/02/%E9%9F%B3%E6%95%88%E5%BA%93/"><span class="level-item">音效库</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'f4fef354d440d79d973c2bf25f8e464b',
            repo: 'Blog-Comment',
            owner: 'NaughtyChas',
            clientID: 'b602cb01d4c2668b35ae',
            clientSecret: '0a26ed5993551a9754281410ba3aa5f772dfbdf2',
            admin: ["NaughtyChas"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            proxy: 'https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1</span><span>写在前面</span></a></li><li><a class="is-flex is-mobile" href="#PART-THREE-进阶理论"><span class="mr-2">2</span><span>PART THREE: 进阶理论</span></a></li><li><a class="is-flex is-mobile" href="#第十六章：数据的表示"><span class="mr-2">3</span><span>第十六章：数据的表示</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数据类型"><span class="mr-2">3.1</span><span>数据类型</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#内置数据类型"><span class="mr-2">3.1.1</span><span>内置数据类型</span></a></li><li><a class="is-flex is-mobile" href="#用户定义的数据类型"><span class="mr-2">3.1.2</span><span>用户定义的数据类型</span></a></li><li><a class="is-flex is-mobile" href="#非复合数据类型"><span class="mr-2">3.1.3</span><span>非复合数据类型</span></a></li><li><a class="is-flex is-mobile" href="#枚举数据类型"><span class="mr-2">3.1.4</span><span>枚举数据类型</span></a></li><li><a class="is-flex is-mobile" href="#复合用户定义数据类型"><span class="mr-2">3.1.5</span><span>复合用户定义数据类型</span></a></li><li><a class="is-flex is-mobile" href="#指针数据类型"><span class="mr-2">3.1.6</span><span>指针数据类型</span></a></li><li><a class="is-flex is-mobile" href="#集合数据类型"><span class="mr-2">3.1.7</span><span>集合数据类型</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文件管理"><span class="mr-2">3.2</span><span>文件管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#串行文件"><span class="mr-2">3.2.1</span><span>串行文件</span></a></li><li><a class="is-flex is-mobile" href="#顺序文件"><span class="mr-2">3.2.2</span><span>顺序文件</span></a></li><li><a class="is-flex is-mobile" href="#直接访问文件"><span class="mr-2">3.2.3</span><span>直接访问文件</span></a></li><li><a class="is-flex is-mobile" href="#文件访问"><span class="mr-2">3.2.4</span><span>文件访问</span></a></li><li><a class="is-flex is-mobile" href="#文件类型的选择"><span class="mr-2">3.2.5</span><span>文件类型的选择</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#实数"><span class="mr-2">3.3</span><span>实数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#浮点-amp-定点表示法"><span class="mr-2">3.3.1</span><span>浮点&amp;定点表示法</span></a></li><li><a class="is-flex is-mobile" href="#精度与标准化"><span class="mr-2">3.3.2</span><span>精度与标准化</span></a></li><li><a class="is-flex is-mobile" href="#表示法的转换"><span class="mr-2">3.3.3</span><span>表示法的转换</span></a></li><li><a class="is-flex is-mobile" href="#使用浮点数的问题"><span class="mr-2">3.3.4</span><span>使用浮点数的问题</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第十七章：通讯及互联网技术"><span class="mr-2">4</span><span>第十七章：通讯及互联网技术</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#传输方式"><span class="mr-2">4.1</span><span>传输方式</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#电路交换"><span class="mr-2">4.1.1</span><span>电路交换</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#分组交换"><span class="mr-2">4.2</span><span>分组交换</span></a></li><li><a class="is-flex is-mobile" href="#传输协议"><span class="mr-2">4.3</span><span>传输协议</span></a></li><li><a class="is-flex is-mobile" href="#协议栈"><span class="mr-2">4.4</span><span>协议栈</span></a></li><li><a class="is-flex is-mobile" href="#TCP-IP-协议套件"><span class="mr-2">4.5</span><span>TCP/IP 协议套件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#TCP-传输控制协议"><span class="mr-2">4.5.1</span><span>TCP (传输控制协议)</span></a></li><li><a class="is-flex is-mobile" href="#IP-互联网协议"><span class="mr-2">4.5.2</span><span>IP (互联网协议)</span></a></li><li><a class="is-flex is-mobile" href="#路由器"><span class="mr-2">4.5.3</span><span>路由器</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#以太网-Ethernet-协议栈"><span class="mr-2">4.6</span><span>以太网(Ethernet)协议栈</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#MAC地址"><span class="mr-2">4.6.1</span><span>MAC地址</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#与TCP-IP有关的应用层协议"><span class="mr-2">4.7</span><span>与TCP/IP有关的应用层协议</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#HTTP-HyperText-Transfer-Protocol"><span class="mr-2">4.7.1</span><span>HTTP (HyperText Transfer Protocol)</span></a></li><li><a class="is-flex is-mobile" href="#电子邮件协议"><span class="mr-2">4.7.2</span><span>电子邮件协议</span></a></li><li><a class="is-flex is-mobile" href="#FTP-文件传输协议"><span class="mr-2">4.7.3</span><span>FTP (文件传输协议)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#P2P文件共享"><span class="mr-2">4.8</span><span>P2P文件共享</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十八章：硬件与虚拟机"><span class="mr-2">5</span><span>第十八章：硬件与虚拟机</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#控制单元"><span class="mr-2">5.1</span><span>控制单元</span></a></li><li><a class="is-flex is-mobile" href="#CISC和RISC处理器"><span class="mr-2">5.2</span><span>CISC和RISC处理器</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#流水线作业-Pipelining"><span class="mr-2">5.2.1</span><span>流水线作业 (Pipelining)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#基本计算机架构"><span class="mr-2">5.3</span><span>基本计算机架构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#单指令流单数据流-SISD"><span class="mr-2">5.3.1</span><span>单指令流单数据流 (SISD)</span></a></li><li><a class="is-flex is-mobile" href="#单指令流多数据流-SIMD"><span class="mr-2">5.3.2</span><span>单指令流多数据流 (SIMD)</span></a></li><li><a class="is-flex is-mobile" href="#多指令流单数据流-MISD"><span class="mr-2">5.3.3</span><span>多指令流单数据流 (MISD)</span></a></li><li><a class="is-flex is-mobile" href="#多指令流多数据流-MIMD"><span class="mr-2">5.3.4</span><span>多指令流多数据流 (MIMD)</span></a></li><li><a class="is-flex is-mobile" href="#大规模并行计算机系统"><span class="mr-2">5.3.5</span><span>大规模并行计算机系统</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#虚拟机"><span class="mr-2">5.4</span><span>虚拟机</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十九章：逻辑门与布尔代数"><span class="mr-2">6</span><span>第十九章：逻辑门与布尔代数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#逻辑电路"><span class="mr-2">6.1</span><span>逻辑电路</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#半加法器-The-half-adder"><span class="mr-2">6.1.1</span><span>半加法器 (The half adder)</span></a></li><li><a class="is-flex is-mobile" href="#全加法器-The-full-adder"><span class="mr-2">6.1.2</span><span>全加法器 (The full adder)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#时序电路"><span class="mr-2">6.2</span><span>时序电路</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#SR-触发器-SR-Flip-flop"><span class="mr-2">6.2.1</span><span>SR 触发器 (SR Flip-flop)</span></a></li><li><a class="is-flex is-mobile" href="#JK-触发器-JK-Flip-flop"><span class="mr-2">6.2.2</span><span>JK 触发器 (JK Flip-flop)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#布尔代数基础"><span class="mr-2">6.3</span><span>布尔代数基础</span></a></li><li><a class="is-flex is-mobile" href="#布尔代数运用"><span class="mr-2">6.4</span><span>布尔代数运用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#从真值表中创建布尔表达式"><span class="mr-2">6.4.1</span><span>从真值表中创建布尔表达式</span></a></li><li><a class="is-flex is-mobile" href="#逻辑电路的布尔代数式"><span class="mr-2">6.4.2</span><span>逻辑电路的布尔代数式</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#卡诺图-Karnaugh-map"><span class="mr-2">6.5</span><span>卡诺图 (Karnaugh map)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第二十章：系统软件"><span class="mr-2">7</span><span>第二十章：系统软件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#操作系统的目的"><span class="mr-2">7.1</span><span>操作系统的目的</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#操作系统结构"><span class="mr-2">7.1.1</span><span>操作系统结构</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#输入-输出系统-I-O"><span class="mr-2">7.2</span><span>输入/输出系统 (I/O)</span></a></li><li><a class="is-flex is-mobile" href="#进程调度"><span class="mr-2">7.3</span><span>进程调度</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#进程状态"><span class="mr-2">7.3.1</span><span>进程状态</span></a></li><li><a class="is-flex is-mobile" href="#中断"><span class="mr-2">7.3.2</span><span>中断</span></a></li><li><a class="is-flex is-mobile" href="#调度算法"><span class="mr-2">7.3.3</span><span>调度算法</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#内存管理"><span class="mr-2">7.4</span><span>内存管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#分区与段"><span class="mr-2">7.4.1</span><span>分区与段</span></a></li><li><a class="is-flex is-mobile" href="#分页与虚拟内存"><span class="mr-2">7.4.2</span><span>分页与虚拟内存</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#提供给用户的操作系统设施"><span class="mr-2">7.5</span><span>提供给用户的操作系统设施</span></a></li><li><a class="is-flex is-mobile" href="#转译软件"><span class="mr-2">7.6</span><span>转译软件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#前端分析阶段"><span class="mr-2">7.6.1</span><span>前端分析阶段</span></a></li><li><a class="is-flex is-mobile" href="#语言的语法表示"><span class="mr-2">7.6.2</span><span>语言的语法表示</span></a></li><li><a class="is-flex is-mobile" href="#后端合成阶段"><span class="mr-2">7.6.3</span><span>后端合成阶段</span></a></li><li><a class="is-flex is-mobile" href="#表达式的求值"><span class="mr-2">7.6.4</span><span>表达式的求值</span></a></li><li><a class="is-flex is-mobile" href="#计算RPN表达式"><span class="mr-2">7.6.5</span><span>计算RPN表达式</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第二十一章：数据安全"><span class="mr-2">8</span><span>第二十一章：数据安全</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#加密原理"><span class="mr-2">8.1</span><span>加密原理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#安全问题"><span class="mr-2">8.1.1</span><span>安全问题</span></a></li><li><a class="is-flex is-mobile" href="#加密方法"><span class="mr-2">8.1.2</span><span>加密方法</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#数字签名与电子证书"><span class="mr-2">8.2</span><span>数字签名与电子证书</span></a></li><li><a class="is-flex is-mobile" href="#对称密钥加密"><span class="mr-2">8.3</span><span>对称密钥加密</span></a></li><li><a class="is-flex is-mobile" href="#公钥加密方法"><span class="mr-2">8.4</span><span>公钥加密方法</span></a></li><li><a class="is-flex is-mobile" href="#SSL-和-TLS"><span class="mr-2">8.5</span><span>SSL 和 TLS</span></a></li><li><a class="is-flex is-mobile" href="#量子密码"><span class="mr-2">8.6</span><span>量子密码</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第二十二章：人工智能-AI"><span class="mr-2">9</span><span>第二十二章：人工智能 (AI)</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#综述"><span class="mr-2">9.1</span><span>综述</span></a></li><li><a class="is-flex is-mobile" href="#人工智能与图表"><span class="mr-2">9.2</span><span>人工智能与图表</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#狄克斯特拉算法"><span class="mr-2">9.2.1</span><span>狄克斯特拉算法</span></a></li><li><a class="is-flex is-mobile" href="#A-算法"><span class="mr-2">9.2.2</span><span>A* 算法</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#机器学习"><span class="mr-2">9.3</span><span>机器学习</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#回归分析方法"><span class="mr-2">9.3.1</span><span>回归分析方法</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#人工神经网络"><span class="mr-2">9.4</span><span>人工神经网络</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#深度学习"><span class="mr-2">9.4.1</span><span>深度学习</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#PART-FOUR-进阶编程技能与问题解决"><span class="mr-2">10</span><span>PART FOUR: 进阶编程技能与问题解决</span></a></li><li><a class="is-flex is-mobile" href="#第二十三章：算法"><span class="mr-2">11</span><span>第二十三章：算法</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#线性搜索"><span class="mr-2">11.1</span><span>线性搜索</span></a></li><li><a class="is-flex is-mobile" href="#冒泡排序"><span class="mr-2">11.2</span><span>冒泡排序</span></a></li><li><a class="is-flex is-mobile" href="#插入排序"><span class="mr-2">11.3</span><span>插入排序</span></a></li><li><a class="is-flex is-mobile" href="#二分查找"><span class="mr-2">11.4</span><span>二分查找</span></a></li><li><a class="is-flex is-mobile" href="#抽象数据结构-ADT"><span class="mr-2">11.5</span><span>抽象数据结构 (ADT)</span></a></li><li><a class="is-flex is-mobile" href="#链表"><span class="mr-2">11.6</span><span>链表</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#创建链表"><span class="mr-2">11.6.1</span><span>创建链表</span></a></li><li><a class="is-flex is-mobile" href="#向有序列表中添加节点"><span class="mr-2">11.6.2</span><span>向有序列表中添加节点</span></a></li><li><a class="is-flex is-mobile" href="#从链表中查找数据"><span class="mr-2">11.6.3</span><span>从链表中查找数据</span></a></li><li><a class="is-flex is-mobile" href="#从链表中删除节点"><span class="mr-2">11.6.4</span><span>从链表中删除节点</span></a></li><li><a class="is-flex is-mobile" href="#访问链表中的所有节点"><span class="mr-2">11.6.5</span><span>访问链表中的所有节点</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#二叉树"><span class="mr-2">11.7</span><span>二叉树</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#创建二叉树"><span class="mr-2">11.7.1</span><span>创建二叉树</span></a></li><li><a class="is-flex is-mobile" href="#向二叉树中添加一个新节点"><span class="mr-2">11.7.2</span><span>向二叉树中添加一个新节点</span></a></li><li><a class="is-flex is-mobile" href="#在二叉树中寻找指定节点"><span class="mr-2">11.7.3</span><span>在二叉树中寻找指定节点</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#栈"><span class="mr-2">11.8</span><span>栈</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#栈的创建，压入和弹出"><span class="mr-2">11.8.1</span><span>栈的创建，压入和弹出</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#队列"><span class="mr-2">11.9</span><span>队列</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#队列的创建，压入和弹出"><span class="mr-2">11.9.1</span><span>队列的创建，压入和弹出</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#图表"><span class="mr-2">11.10</span><span>图表</span></a></li><li><a class="is-flex is-mobile" href="#哈希表"><span class="mr-2">11.11</span><span>哈希表</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#哈希表的创建，添加元素，与查找"><span class="mr-2">11.11.1</span><span>哈希表的创建，添加元素，与查找</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#词典"><span class="mr-2">11.12</span><span>词典</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#词典的创建与操作"><span class="mr-2">11.12.1</span><span>词典的创建与操作</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#时间复杂度与大O符号"><span class="mr-2">11.13</span><span>时间复杂度与大O符号</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第二十四章：递归"><span class="mr-2">12</span><span>第二十四章：递归</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a><p class="size-small"><span>&copy; 2023 MXK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noreferrer">Icarus</a> &amp; <a href="https://github.com/LittleYe233/hexo-theme-amazingremake" target="_blank" rel="noreferrer">Amazing-Remake</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022.8.11 17:07:12')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/LittleYe233/hexo-theme-amazingremake"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    enabled: true,
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { // 加载mathjax
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    autoload: {
                        color: [],
                        colorv2: ['color']
                    },
                    packages: {'[+]': ['noerrors']}
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                },
                loader: {
                    load: ['input/asciimath', '[tex]/noerrors']
                }
            };
            $.getScript('//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);});
            }
            if('undefined' === 'mathjax'){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>