<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>A2CS笔记 - ntcs&#039; blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ntcs&#039; blog"><meta name="msapplication-TileImage" content="img/icon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ntcs&#039; blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="CS课堂笔记 (A2)"><meta property="og:type" content="article"><meta property="og:title" content="A2CS笔记"><meta property="og:url" content="http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="ntcs&#039; blog"><meta property="og:description" content="CS课堂笔记 (A2)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><meta property="article:published_time" content="2023-07-01T09:18:28.000Z"><meta property="article:modified_time" content="2023-09-22T07:43:28.640Z"><meta property="article:author" content="MXK"><meta property="article:tag" content="笔记"><meta property="article:tag" content="CIE"><meta property="article:tag" content="计算机"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"},"headline":"ntcs' blog","image":["http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"],"datePublished":"2023-07-01T09:18:28.000Z","dateModified":"2023-09-22T07:43:28.640Z","author":{"@type":"Person","name":"MXK"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"CS课堂笔记 (A2)"}</script><link rel="canonical" href="http://naughtychas.github.io/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/icon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="ntcs' blog" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/thumbnails/CS.jpg" alt="A2CS笔记"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-07-01  <a class="commentCountImg" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">f4fef354d440d79d973c2bf25f8e464b</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f4fef354d440d79d973c2bf25f8e464b">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 小时  <i class="fas fa-pencil-alt"> </i>23.7 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">A2CS笔记</h1><div class="content"><blockquote>
<p>CS课堂笔记 (A2)<br><span id="more"></span></p>
</blockquote>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h1><p>学了一段时间的计算机，觉得继续写这些笔记还是蛮有用的，于是乎就打算继续下去。<br>这次是A2阶段的计算机笔记。<br>和AS部分一样，写下本文的目的是帮助自己更好地学习CS这门科目，因此，希望路过的大佬轻喷。  </p>
<hr>
<p>本笔记内容基于《Computer Science for Cambridge International AS &amp; A Level》，剑桥大学出版社出版，教材为第二版，A-Level课程编号为<code>9618</code>。  </p>
<hr>
<h1 id="PART-THREE-进阶理论"><a href="#PART-THREE-进阶理论" class="headerlink" title="PART THREE: 进阶理论"></a><strong>PART THREE: 进阶理论</strong></h1><h1 id="第十六章：数据的表示"><a href="#第十六章：数据的表示" class="headerlink" title="第十六章：数据的表示"></a><strong>第十六章：数据的表示</strong></h1><p>崭新的故事从第十六章继续开始了。  </p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>早在第13章我们介绍过变量的数据类型的概念。具体是：当一个程序在使用变量之前，必须要显示别该变量的数据类型。  </p>
<p>当时介绍了一些最常用的数据类型，但是在本章我们将会接触一些更深入的数据类型。  </p>
<p><br></p>
<h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a><strong>内置数据类型</strong></h3><p><strong>内置数据类型 (Built-in data types)</strong>，顾名思义，就是已经默认集成在编译器中的数据类型，是<strong>被编程语言预先定义的数据类型</strong>。一般来说，这些数据类型被认为成执行数据操作最快的类型。  </p>
<p>比如说在Python里面，内置数据类型就有这些：str, int, float等。  </p>
<p>这些数据类型具体的操作，值分配的操作全部由编程语言定义。  </p>
<p><br></p>
<hr>
<h3 id="用户定义的数据类型"><a href="#用户定义的数据类型" class="headerlink" title="用户定义的数据类型"></a><strong>用户定义的数据类型</strong></h3><p>和内置数据类型相对立的，就是可以由用户定义的数据类型。</p>
<p>一般来说，“用户”通常是使用操作系统提供“用户界面”的人：“用户”是向正在运行的程序提供输入并从其接收输出的人。然而在编写程序时，程序员就成为了编程语言所指的“用户”。名词 <strong>用户定义的数据类型(User-defined data types)</strong> 中的“用户”就是指程序员们。  </p>
<p>这种数据类型是由用户在程序中根据需要所定义的，以便根据幼存储相同或者不同类型的数据类型。  </p>
<p>尽管用户定义的数据类型不是内置数据类型，但是只有在编程语言提供对该类型构造的支持情况下，才可以使用某种特定的用户定义数据类型。  </p>
<article class="message is-info"><div class="message-body">

<b>User-defined data type: where the programmer includes the definition in the program.</b>

</div></article> 


<p><br></p>
<hr>
<h3 id="非复合数据类型"><a href="#非复合数据类型" class="headerlink" title="非复合数据类型"></a><strong>非复合数据类型</strong></h3><p><strong>非复合数据类型 (Non-composite data types)</strong> 是不引用其他数据类型的数据类型。也就是说，这些数据类型的定义没有用到其他的数据类型。  </p>
<p>某些用户定义的数据类型也有可能是非符合的数据类型。  </p>
<article class="message is-info"><div class="message-body">

<b>Non-composite data type: a data type defined without reference to another data type.</b>

</div></article> 



<p><br></p>
<hr>
<h3 id="枚举数据类型"><a href="#枚举数据类型" class="headerlink" title="枚举数据类型"></a><strong>枚举数据类型</strong></h3><p><strong>枚举数据类型 (Enumerated data type)</strong>是用户定义的数据类型，它是根据有序值列表定义的。 </p>
<p>同时，它是一种非复合数据类型。</p>
<p>简单举一个例子就很好理解了：这里使用Python来定义一个数据类型<code>Color</code>:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    RED = <span class="number">1</span></span><br><span class="line">    GREEN = <span class="number">2</span></span><br><span class="line">    BLUE = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Color.RED)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行了<code>print(Color.RED)</code>之后，会输出<code>1</code>。因为<code>RED</code>定义的值正好为<code>1</code>。  </p>
<p>我们通过上面的代码定义了一个名叫<code>Color</code>的枚举数据类型，其中包含三个值：<code>RED</code>,<code>GREEN</code>和<code>BLUE</code>。  </p>
<p>需要注意的是，枚举数据类型中定义的值是有序的，这意味着枚举数据类型具有隐含的值顺序。</p>
<article class="message is-info"><div class="message-body">

<b>Enumerated data type: a non-composite user-defined data type for which the definition identifies all possible values.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="复合用户定义数据类型"><a href="#复合用户定义数据类型" class="headerlink" title="复合用户定义数据类型"></a><strong>复合用户定义数据类型</strong></h3><p>开始变复杂了。  </p>
<p><strong>复合用户定义数据类型 (Composite user-defined data types)</strong>具有引用至少一种其他类型的定义。  </p>
<p>复合用户定义数据类型有两个非常重要的实例：  </p>
<ol>
<li><p>在第十三章介绍过的<strong>记录数据类型 (Record data type)</strong>是描述值和变量的数据类型。这是程序员定义的数据类型，允许程序员定义新的记录类型。这允许程序员们使用精确匹配特定程序的数据要求的组件来创建并记录数据类型。Python不支持这样的数据类型。  </p>
</li>
<li><p><strong>类 (Class)</strong>是面向对象编程中用于对象的数据类型。换句话说，类是创建对象(或者特定数据结构)，提供窗台初始值，以及行为实现的蓝图。  </p>
</li>
</ol>
<p>下面的代码就是在Python中的一个类：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"Hello, my name is <span class="subst">{self.name}</span> and I am <span class="subst">{self.age}</span> years old."</span>)</span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">"John"</span>, <span class="number">25</span>)</span><br><span class="line">person.say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们定义了一个名叫<code>Person</code>的类，其中包含两个子变量：<code>name</code>和<code>age</code>，和一个子函数<code>say_hello()</code>。  </p>
<p><br></p>
<hr>
<h3 id="指针数据类型"><a href="#指针数据类型" class="headerlink" title="指针数据类型"></a><strong>指针数据类型</strong></h3><p>在计算机编程中，<strong>指针 (Pointer)</strong>是一个存储另一个变量的内存地址的变量。<strong>指针数据类型 (Pointer data type)</strong>是用于声明指针变量的数据类型。  </p>
<p>在AS部分学的链表(Linked list)<strong>不是</strong>一个指针数据类型。因为链表是一种包含指向其他节点的指针的数据结构。不是指针数据类型的原因是它存储的不是内存地址的变量。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>学学伪代码：  </p>
<p>当需要使用指针的时候，就可以使用这个符号声明：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TYPE</span><br><span class="line">TIntegerPointer ← ^Integer</span><br></pre></td></tr></table></figure>
<p>定义了<code>TIntegerPointer</code>的数据类型是整形的指针。  </p>
<p>我们也可以这么写：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE MyIntegerPointer : TIntegerPointer</span><br></pre></td></tr></table></figure>
<p>这是一个不需要使用插入符 (^) 的方法。  </p>
<p><br></p>
<p><br></p>
<p>接下来我们来定义一些数据：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE Number1, Number2 : INTEGER</span><br><span class="line">Number1 ← 100</span><br><span class="line"></span><br><span class="line">MyIntegerPointer ← @Number1</span><br></pre></td></tr></table></figure>
<p>最后一行代码向指针变量赋了值。变量<code>MyIntegerPointer</code>现在存储着<code>Number1</code>的地址。   </p>
<p>然后我们可以使用下面的这种方法为<code>Number2</code>赋予一个<code>200</code>的值：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number2 ← MyIntegerPointer^ * 2</span><br></pre></td></tr></table></figure>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Pointer variable: one for which the value is the address in memory of a different variable.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="集合数据类型"><a href="#集合数据类型" class="headerlink" title="集合数据类型"></a><strong>集合数据类型</strong></h3><p>计算机科学中也存在集合的定义：<strong>集合是一种抽象数据类型，可以存储某些值，没有任何特定的顺序，并且没有重复的值。</strong>  </p>
<p><strong>集合数据类型 (Set data type)</strong>与大多数其他集合类型不同，通常不是从集合中检索特定元素，而是测试集合中的成员资格值，可以说是将一整个整体来进行处理(?)</p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Set: a collection of data items that lacks any structure;contains no duplicates and has a number of defined operations that can be performed on it.</b>

</div></article> 

<p><br></p>
<p>常用的操作有这些：  </p>
<ul>
<li>检查集合中是否存在某个值</li>
<li>添加新的数据值</li>
<li>删除现有的数据值</li>
<li>将一个集合添加到另一个集合当中</li>
</ul>
<p><br></p>
<hr>
<p>Python的其中一个亮点就和集合数据类型有关。在Python中，处理集合数据类型十分方便。  </p>
<p>下面是在Python中操作集合数据类型的一些实例：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个集合</span></span><br><span class="line">my_set = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向集合中添加一个值</span></span><br><span class="line">my_set.add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合中剔除一个值</span></span><br><span class="line">my_set.remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查值是否在集合内</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> <span class="keyword">in</span> my_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2 is in the set"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- 华丽的分割线 ------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个集合</span></span><br><span class="line">set1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">set2 = {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的并集</span></span><br><span class="line">union_set = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(union_set) <span class="comment"># 输出为: {1, 2, 3, 4, 5}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的交集</span></span><br><span class="line">intersection_set = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(intersection_set) <span class="comment"># 输出为: {3}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个集合的差</span></span><br><span class="line">difference_set = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(difference_set) <span class="comment"># 输出为: {1, 2}</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h2><p>在日常计算机使用中，会遇到各种各样的文件类型，例如图形文件、文字处理文件、电子表格文件等。<br>无论文件类型如何，内容都使用特定的二进制代码存储，从而保证文件的正常使用。  </p>
<p>这里就出现了新东西：<strong>二进制文件 (Binary file)</strong>和<strong>记录 (Record)</strong>  </p>
<p>二进制文件是包含二进制格式信息的文件，二进制格式是 0 和 1 的序列。二进制文件用于以计算机可以读取但人类不易理解的格式存储数据。二进制文件的示例包括可执行文件、图像文件和音频文件。</p>
<p>记录是一种包含一个或多个字段的数据结构，每个字段包含一条数据。记录用于以易于访问和操作的方式存储和组织数据。在计算机科学中，记录通常用于表示数据库和其他数据存储系统中的数据。</p>
<article class="message is-info"><div class="message-body">

<b>Binary file: a file designed for storing data to be used by a computer program.</b>

<br>

<b>Record: a collection of fields containing data values.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="串行文件"><a href="#串行文件" class="headerlink" title="串行文件"></a><strong>串行文件</strong></h3><p><strong>串行文件 (Serial file)</strong>是一种包含信息的文件类型，<strong>信息按其发生的顺序记录在文件中。</strong>  </p>
<p>它还可以用来记录文件信息。在这种情况下，文件信息将按照它们在串行文件中保存的顺序列出。所以说：信息或文件基本上是按时间顺序记录的。  </p>
<p><br></p>
<hr>
<h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a><strong>顺序文件</strong></h3><p><strong>顺序文件 (Sequential files)</strong>是根据某些键值排序的文件。顺序文件主要用于文件命中率较高的应用场景中。 <em>#文件命中率衡量计算机系统或程序性能的重要参数,它可以反应计算机在访问存储器时的效率。</em>  </p>
<p>顺序文件的一个示例是包含有关公司员工信息的文件。<br>该文件可以根据员工的姓氏进行排序，以便将具有相同姓氏的所有员工分组在一起。这将使根据姓氏搜索员工变得更加容易。</p>
<p><br></p>
<hr>
<h3 id="直接访问文件"><a href="#直接访问文件" class="headerlink" title="直接访问文件"></a><strong>直接访问文件</strong></h3><p><strong>直接访问文件 (Direct-access file)</strong> 有时候也被称之为<strong>随机访问文件 (Random-access files)</strong>。和内存一样，随机性表明我们可以访问文件中的任何记录，或者在任何位置写入内容，而无需按照顺序依行读取文件。在使用这种文件时，我们可以直接访问文件的某个区块。  </p>
<p><br></p>
<p>另一种方法是在将记录输入直接访问文件时使用散列算法。</p>
<p>如果每条记录中有一个数字关键字段，则可以使用一种简单的哈希算法。<br>该算法选择一个合适的数字并将该数字除以关键字段中的值。 然后，该除法的余数标识文件中用于存储该记录的地址。<br>如果合适的数字是与文件的预期大小相似的质数，则效果最佳。</p>
<p>我们举一个简单的计算例子：我们使用关键字段中的 4 位值来说明文件中的地址，其中 1000 用于除数。 以下代表三种计算，其中余数代表地址：  </p>
<p>0045 / 1000 余数为45<br>2005 / 1000 余数为5<br>3000 / 1000 余数为5</p>
<p>从这些计算中可以看出两个事实。<br>第一个事实是，计算出的地址没有任何顺序，具体取决于关键字段中的值。<br>第二个事实是，不同的关键字段值可以产生相同的余数，因此在文件中产生相同的地址。</p>
<p>正因为相同的地址可能产生，所以当同一个地址被使用的时候，可能会发生冲突。<br>哈希算法的职责是尽可能平均地分配地址，从而最大限度地减少冲突的可能性。  </p>
<p>但是哈希算法也不是万能的，无论再怎么平均分配，冲突必定出现。所以说如果冲突出现，我们有以下这些解决方案：  </p>
<ul>
<li>使用顺序搜索来查找计算出的地址后是否有空闲地址。</li>
<li>在文件末尾保留一些溢出地址。</li>
<li>创建一个可以从每个地址访问的链接列表。</li>
</ul>
<p><br></p>
<hr>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a><strong>文件访问</strong></h3><p>一旦我们选择了文件组织，并将文件中注入了数据，我们就需要考虑下如何使用这些文件，如何访问这些数据。  </p>
<p>对于<strong>串行文件</strong>来说，正常的方法是逐条读取文件。但是说如果需要再其中的一个字段中搜索特定的一个值，唯一的办法就是从头开始读取记录，直到我们找到了我们的目标。  </p>
<p>如果我们需要在<strong>顺序文件</strong>寻找特定值的话，可能也需要像串行文件一样进行搜索。但是，如果我们已知包含所需数据的关键字段，那么直接读取关键字段就可以了。  </p>
<p><strong>直接访问文件</strong>的话，首先需要将关键字段的值提供给哈希算法进行计算。</p>
<p><br></p>
<hr>
<h3 id="文件类型的选择"><a href="#文件类型的选择" class="headerlink" title="文件类型的选择"></a><strong>文件类型的选择</strong></h3><p><strong>串行文件</strong>特别适合批处理或者备份磁带上的数据，因为串行文件中的数据是与时间相关的。  </p>
<p>如果我们需要快速访问一个大文件中的单个记录，就需要使用<strong>直接访问文件</strong>。比如说需要登录一个具有许多用户的系统，在这种情况下，用户登录时用于检查密码的文件就应该是直接访问的。  </p>
<p><strong>顺序文件</strong>特别适用与从文件的一次搜索中获得多个记录的应用程序。一个例子是家谱：我们可以对所有特定家族名称的所有记录进行搜索。  </p>
<p><br></p>
<hr>
<h2 id="实数"><a href="#实数" class="headerlink" title="实数"></a><strong>实数</strong></h2><p>在计算机中，实数是带有小数部分的数。  </p>
<p>当我们在一个二进制系统中写下一个实数的值，并需要存储下来的话，我们有多个选择：我们可以选择简单的表示法，也可以使用指数表示法(科学计数法)。  </p>
<p>比如说，数字’25.3’可以写成：  </p>
<p>       <code>.253 * 10^2</code> 或 <code>2.53 * 10^1</code> 或 <code>25.3 * 10^0</code> 或 <code>253 * 10^-1</code></p>
<p>就对于’25.3’来说，直接表达是最好的存储方案。<br>但如果数字非常大或非常小，就需要尽可能地使用科学计数法。  </p>
<p><br></p>
<hr>
<h3 id="浮点-amp-定点表示法"><a href="#浮点-amp-定点表示法" class="headerlink" title="浮点&定点表示法"></a><strong>浮点&amp;定点表示法</strong></h3><p>在计算机系统中，我们只能是有二进制码来存储实数。其中的一种方法就是使用<strong>定点表示法 (Fixed-point representation)</strong>。  </p>
<p>在定点表示法中，首先需要确定总位数。其中总位数中的一部分位来表示整数部分，其余的位表示小数部分。  </p>
<p>另一种方法就是使用<strong>浮点表示法 (Floating-point representation)</strong>。所有使用浮数都可以改写成下面这种形式：  </p>
<p>         <code>±M × R^E</code></p>
<p>其中，有效的位数由<code>±M</code>表示，我们叫做<strong>尾数 (Mantissa)</strong>。<code>E</code>表示指数。浮点数中的 “指数 “并不代表原数的整数部分。相反，它表示在确定浮点表示数的值时，基数（在计算机系统中通常为 2）所升高的整数幂。  </p>
<p>一般来说基数<code>R</code>不会存储进这个浮点数内，因为<code>R</code>有一个隐含值“2”。具体原因是我们在使用二进制表示数字时逢2进一。    </p>
<article class="message is-info"><div class="message-body">

<b>Floating-point representation: a representation of real numbers that stores a value for the mantissa and a value for the exponent.</b>

</div></article> 

<p><br></p>
<p><em>p.s. mantissa是尾数的意思。</em></p>
<p><br></p>
<hr>
<p>我们来举例子了解一下两种表示法之间的区别：  </p>
<p>对于定点表示法来说，在一个字节内，我们可以使用最高的有效位作为符号位，然后再使用接下来的五位表示整数部分。这就会为小数部分的表示留下两个位。  </p>
<p>下表给出了一些比较重要的非零值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:center">二进制码</th>
<th style="text-align:center">(对应的)十进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">最大的正值</td>
<td style="text-align:center"><code>011111 11</code></td>
<td style="text-align:center">31.75</td>
</tr>
<tr>
<td style="text-align:left">最小的正值</td>
<td style="text-align:center"><code>000000 01</code></td>
<td style="text-align:center">0.25</td>
</tr>
<tr>
<td style="text-align:left">绝对值最小的负值</td>
<td style="text-align:center"><code>100000 01</code></td>
<td style="text-align:center">-0.25</td>
</tr>
<tr>
<td style="text-align:left">绝对值最大的负值</td>
<td style="text-align:center"><code>111111 11</code></td>
<td style="text-align:center">-31.75</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>浮点表示法的话，我们可以使用4个位来表示尾数，然后再使用另外的4位表示指数。每一个位都使用2的补码来表示。<br>其中，指数存储为有符号的整数，尾数存储为定点实数。  </p>
<p>那么我们应该如何确定哪一位是二进制点。</p>
<p>下面的表格给出了使用4位来表示尾数的两个选项：<br>在每种情况下，我们都选择了等价的二进制点，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>011 1</code></td>
<td style="text-align:center"><code>3.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>011 0</code></td>
<td style="text-align:center"><code>3.0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>010 1</code></td>
<td style="text-align:center"><code>2.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>101 0</code></td>
<td style="text-align:center"><code>-3.0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>100 1</code></td>
<td style="text-align:center"><code>-3.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>100 0</code></td>
<td style="text-align:center"><code>-4.0</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0 111</code></td>
<td style="text-align:center"><code>0.875</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0 110</code></td>
<td style="text-align:center"><code>0.75</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0 101</code></td>
<td style="text-align:center"><code>0.625</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 010</code></td>
<td style="text-align:center"><code>-0.75</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 001</code></td>
<td style="text-align:center"><code>-0.875</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1 000</code></td>
<td style="text-align:center"><code>-1.0</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">First bit pattern</th>
<th style="text-align:center">Real value in denary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0111</code></td>
<td style="text-align:center"><code>7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0110</code></td>
<td style="text-align:center"><code>6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0101</code></td>
<td style="text-align:center"><code>5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1010</code></td>
<td style="text-align:center"><code>-6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1001</code></td>
<td style="text-align:center"><code>-7</code></td>
</tr>
<tr>
<td style="text-align:center"><code>1000</code></td>
<td style="text-align:center"><code>-8</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>浮点表示法的特殊值如下表所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:center">二进制码</th>
<th style="text-align:center">(对应的)十进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">最大的正值</td>
<td style="text-align:center"><code>0 111 0111</code></td>
<td style="text-align:center">0.875 × 2^7 = <strong>112</strong></td>
</tr>
<tr>
<td style="text-align:left">最小的正值</td>
<td style="text-align:center"><code>0 001 1000</code></td>
<td style="text-align:center">0.125 × 2^(-8) = <strong>1/2048</strong></td>
</tr>
<tr>
<td style="text-align:left">绝对值最小的负值</td>
<td style="text-align:center"><code>1 111 1000</code></td>
<td style="text-align:center">-0.125 × 2^(-8) = <strong>-1/2048</strong></td>
</tr>
<tr>
<td style="text-align:left">绝对值最大的负值</td>
<td style="text-align:center"><code>1 000 0111</code></td>
<td style="text-align:center">-1 × 2^7 = <strong>-128</strong></td>
</tr>
</tbody>
</table>
</div>
<p><em>p.s. 上课时候有人提出了一个问题：Exponent部分的第一位为什么不是1从而达到最大值？老师的解释是“因为Exponent部分也同样存在符号位，所以最大的正值只能将后三位填充为一。”</em></p>
<p><br></p>
<hr>
<h3 id="精度与标准化"><a href="#精度与标准化" class="headerlink" title="精度与标准化"></a><strong>精度与标准化</strong></h3><p>当使用浮点表示法表示数据时，需要从两个方面着重考虑。  </p>
<p>首先需要决定使用的总位数，然后还要决定分割线的位置 <em>(表示尾数的位数和表示指数的位数之间的分割线)</em>  </p>
<p>然而在我们使用的时候只需要选择使用的总位数就可以了。具体的位数分割就会交给浮点处理器来决定。  </p>
<p>当然这也不代表你没法决定尾数和指数位数的数量了：一般来说，增加尾数位数可以提供更高的精度，但是同样会减少指数位数。如此一来就会减少可以表示的值的范围。  </p>
<p>所以说为了获取最大精度，我们就必须要标准化浮点数。因为<strong>越多的尾数位数代表着更高的精准度</strong>，所以在考虑提升精度时，要尽可能对表示尾数的位数使用多的位数。  </p>
<p><strong>将浮点表示法中的数字标准化意味着选择一个指数，以防止在尾数中出现前导零。</strong>。举个例子：<code>0 1000.11</code>并没有标准化：小数点前面一共有5位。如果想要标准化这一串数据，就要将其变成<code>0.100011</code>。小数点向左移动了四位，因此在此情景中指数为4。</p>
<p><br></p>
<p>我们可以使用八位浮点表示一个数值。因为要表示正数，十进制表示以2进位。<br>比如说：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制表示</th>
<th style="text-align:center">浮点二进制表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>0.125 × 2^4</code></td>
<td style="text-align:center"><code>0 001 0100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0.25 × 2^3</code></td>
<td style="text-align:center"><code>0 010 0011</code></td>
</tr>
<tr>
<td style="text-align:center"><code>0.5 × 2^2</code></td>
<td style="text-align:center"><code>0 100 0010</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>表示负数也没有问题。这里用-4作为十进制表示的底数：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制表示</th>
<th style="text-align:center">浮点二进制表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-0.25 × 2^4</code></td>
<td style="text-align:center"><code>1 110 0100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-0.5 × 2^3</code></td>
<td style="text-align:center"><code>1 100 0011</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-1.0 × 2^2</code></td>
<td style="text-align:center"><code>1 000 0010</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="表示法的转换"><a href="#表示法的转换" class="headerlink" title="表示法的转换"></a><strong>表示法的转换</strong></h3><p>在AS部分的第一章，我们讨论了多种将数字转换为不同形式的方法。</p>
<p>先来看定点二进制表示法。举个例子：4.75转换为定点二进制表示法  </p>
<p>打眼一看挺简单的：4可以转换为<code>100</code>，.75转化为二进制的<code>.11</code>，所以4.75的定点二进制表示法大概是<code>100.11</code>。但是别忘了正数的首位需要以0开头。这样的话就只添加一个符号位就可以解决问题了。这样，4.75就可以以定点二进制表示法写成<code>0100.11</code>。  </p>
<p>那么负数怎么办呢？比如说-4.75，就可以先从4.75的表示开始，然后再将它转换成对应的二进制补码：  </p>
<p>     <code>0100.11</code> 转换为： <code>1011.00</code>（一次补码）<br>     <code>1011.01</code>就是-4.75的二次补码。</p>
<p>有关于二次补码的内容，可以去AS部分的第一张扒翻一下。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>转换成浮点就有一些复杂了。在转换之前，我们应该注意：大多数小数部分无法精确地转换为浮点数值。因为二进制小数部分的因数有1/2， 1/4， 1/8， 1/16等等。所以说除非被转换的值正好是这些因数的和，否则无法进行精确的转换。<br>比如说，从0.1到0.9之间的的值中，只有0.5可以被精确的转换。</p>
<p><br></p>
<p>转换正值的方法如下：  </p>
<ol>
<li>使用我们在AS第一章中描述的方法转换整数部分。</li>
<li>添加在开头添加符号位</li>
<li>使用下面的方法转换小数位  </li>
<li>将整数和小数部分组合起来，并将它们输入到分配用于表示尾数的最高有效位中。</li>
<li>用零填充尾数的剩余位和指数的位。</li>
<li>通过改变指数值来调整二进制小数点的位置，以实现归一化的表示。</li>
</ol>
<p><br></p>
<p>第三步提到的方法如下：  </p>
<p>我们试着转化一下8.75：  </p>
<ol>
<li>整数位8转换成<code>1000</code>，然后添加符号位。这样就变成了<code>0 1000</code></li>
<li>小数部分“.75”可以在二进制中表示为<code>.11</code></li>
</ol>
<blockquote>
<p><strong>将小数转换为二进制时，可以将小数部分乘以2，然后观察得到的整数部分和小数部分。</strong>然后再乘以2直到得到的小数部分等于0。稍后需要将每次乘法结果的整数部分写成等价的二进制数。0.75十进制到二进制的答案是0.11。<br><br>小数部分“0.75”的转换步骤大概是：<br><br>1. <code>0.75 * 2 = 1.5</code>，1.5的整数位包含1，因此位数部分的第一位需要写<code>1</code>。<br>2. 去掉刚才的乘积的整数部分，<code>0.5 * 2 = 1.0</code>。1.0的整数部分包含1，因此尾数部分的第一位需要写<code>1</code>。正因为整数位的1减去后，小数位不包含任何信息，所以转换到此结束。<br><br>所以<code>0.75</code>转化过后就是<code>.11</code>。</p>
</blockquote>
<ol>
<li>该组合给出 <code>0 1000.11</code>，其指数值为零。  </li>
<li>移动二进制小数点后，我们得到 <code>0.100011</code>，小数点相比原来向左移动了四位，因此在此情景中指数为4其指数值为十进制的4。  </li>
<li>下一阶段取决于为尾数和指数定义的位数； 如果为尾数分配10位，为指数分配4位，则最终表示为尾数为 <code>0100011000</code>，指数为 <code>0100</code>。</li>
</ol>
<p><br></p>
<hr>
<h3 id="使用浮点数的问题"><a href="#使用浮点数的问题" class="headerlink" title="使用浮点数的问题"></a><strong>使用浮点数的问题</strong></h3><p>如上所述，将十进制实数值转换为二进制表示形式几乎可以保证一定程度的近似。 用于存储尾数的位数也有限制。</p>
<p>浮点数用于<strong>涉及重复计算的扩展数学过程</strong>。 例如，在使用大气数学模型的天气预报中，或在经济预测中。 在这样的编程中，在记录每次计算的结果时存在轻微的近似。<br>如果计算重复足够多次，这些所谓的舍入误差可能会变得很大。 防止错误成为严重问题的唯一方法是通过使用更多的尾数位来提高浮点表示的精度。<br>因此，编程语言提供了以“双精度”或“四精度”工作的选项。</p>
<p>另外，浮点数还可能引发溢出错误条件，因为浮点数能够存储的数字范围有限。</p>
<p><br></p>
<hr>
<h1 id="第十七章：通讯及互联网技术"><a href="#第十七章：通讯及互联网技术" class="headerlink" title="第十七章：通讯及互联网技术"></a><strong>第十七章：通讯及互联网技术</strong></h1><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a><strong>传输方式</strong></h2><p>对于通过互联网进行的通信，有两种可能的方法：<strong>电路交换 (Circuit switching)</strong>或<strong>分组交换 (Packet switching)</strong>。  </p>
<p><br></p>
<hr>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a><strong>电路交换</strong></h3><p>电路交换在传统电话系统中运用的比较广泛。  </p>
<p>电路交换是实现电信网络的一种方法。在这种方法中，两个网络节点通过网络建立专用的通信信道（通过电路），然后才能进行通信。<br>电路的特征决定了信道的带宽，并且这个专用通讯链路会在使用期间一直保持连接。<br>电路交换法师一种面向连接的网络，通过在发送方和接收方之间建立专用路径，提供了有保证的数据传输速率。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB0d939d18b99654b52231aaedd9491e5e?method=download&amp;shareKey=7ca23d690c92033f34eb8055e9f8c426" alt=""></p>
<p><br></p>
<p>通过电路交换传输数据的大致流程如下：  </p>
<ol>
<li>发送方提供预期的接收方的身份信息  </li>
<li>由系统来检查接收方是否准备好接收数据  </li>
<li>如果接收方可以接收数据，那么就会在网络上建立一些连接  </li>
<li>数据随后被传输</li>
<li>移除所有的建立的连接</li>
</ol>
<p>在这种情况下，我们暂时没有必要对电路交换网络中的每个节点进行定义。<br>节点之间的链路师共享传输介质中的专用信道，可以保证传输的畅通无阻、<br>当连接结束后，随着链路的断开，连接也就明确结束了。<br>不过，对于租用线路数据连接而言，可能会建立永久性的连线。  </p>
<p><br></p>
<hr>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><strong>分组交换</strong></h2><p><strong>分组交换 (Packet-switching)</strong>允许我们再不建立电路的情况下进行数据传输。  </p>
<p>数据不能以连续的流的形式发送，相反，数据被打包成一个一个数据包内然后被发送出去。  </p>
<p>数据包由包含传送指令的标头和数据主题构成。这个方法有点像邮政服务发送信件一样，但是要更加复杂。比如说在电路交换那一章的图片仍然可以描述数据包交换，只不过所使用的链路在发送方传输数据包的时候还没有被定义。  </p>
<p>此外，与电路交换传输所需的功能相比，节点将具有更多扩展的功能。我们将会在下面的一个章节中探讨路由器如何充当节点并且支持数据包的发送与接受。  </p>
<p><br></p>
<p>当我们使用分组交换法的时候，网络可以通过两种方式提供服务：<strong>无连接服务 (Connectionless service)</strong> 或者是 <strong>面向连接的服务 (Connection-oriented service)</strong>。  </p>
<p>对于无连接服务来说，我们在发送数据包的时候不知道接收者是否准备好接受数据包，而且我们无法确认数据包是否会传输成功。  </p>
<p>在面向连接的服务中，我们发送第一个数据包的目的是为了确认对方是否能够正常的接受数据包。如果收到了确认的话，那么发送方就会发送更多的数据包。如果没有收到确认，那么发送方就会再次尝试发送第一个数据包来确认状态。  </p>
<p><br></p>
<hr>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a><strong>传输协议</strong></h2><p>网络协议的基本定义很简单：它是一组规则。但问题是这些规则与什么东西有关呢？  </p>
<p>在回答这个问题之前，我们应该明白：我们通常所说的“协议”是指的包含许多单独协议的协议栈，因为网络的复杂性需要我们去制定许多单独的协议。<br>另一个复杂因素是：一个协议可能有许多不同的版本。<br>而且通常有一类协议可以用来补充另一类协议的作用。    </p>
<article class="message is-info"><div class="message-body">

<b>Protocol: a set of rules for data transmission which are agreed by sender and receiver.</b>

</div></article> 

<p><br></p>
<p>任何通过网络传输的通信，都必须在发送方和接收方之间商定一套构成协议的传输规则。<br>在最简单的层面上，协议可以规定成正电压代表比特值为1。协议也可以规定发送方不得超过的传输速度。<br>许多规则与信息的格式或信息的组成部分有关。比如说，定义数据包中前40哥字节的格式。  </p>
<p><br></p>
<hr>
<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a><strong>协议栈</strong></h2><p>对于协议套件而言，协议可以被是认作为协议栈中的层。这一概念设计了多个方面：  </p>
<ul>
<li><p>每一层只能接受上一层或者下一层的输入。  </p>
</li>
<li><p>相邻的层之间有一个明确的界限，这是层与层之间唯一允许的互动。  </p>
</li>
<li><p>一个层由下层的行动提供服务。  </p>
</li>
<li><p>除了最底层之外，各层的功能都是由安装的软件创建的。  </p>
</li>
<li><p>层可以包括子层。  </p>
</li>
<li><p>任何用户交互都将使用与堆栈中最高层相关的协议。  </p>
</li>
<li><p>对于硬件的任何直接访问都仅限于堆栈的最底层。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="TCP-IP-协议套件"><a href="#TCP-IP-协议套件" class="headerlink" title="TCP/IP 协议套件"></a><strong>TCP/IP 协议套件</strong></h2><p>TCP/IP是为支持互联网使用二创建的协议套件。<br>TCP/IP可以根据下图所示的模型来进行解释：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfdae828f6e782a26d5c50baafadfe83a?method=download&amp;shareKey=b16b227c06708c287e7ee21d0263a4cb" alt="">  </p>
<p>不难看出，TCP/IP协议只占用了这个模型的前三层。</p>
<p>图中显示了两个终端系统 （<em>最左边和最右边的两列</em>），并且也显示了这两个系统中相应层之间的逻辑连接。<br>一个应用程序可以在一个终端系统上运行，并与另一个终端系统上运行的应用程序建立直接连接。<br>发送端系统上的应用层协议向同一系统上的传输层协议发送信息，然后传输层协议启动一个进程，将相同的信息传送到接收端系统。<br>在接收端系统上，最后阶段是传输层协议将信息传送给应用层协议。  </p>
<p><br></p>
<p>TCP/IP协议套件由许多子协议组成，包括以下协议：  </p>
<ul>
<li>应用层协议： HTTP SMTP DNS FTP POP3 IMAP</li>
<li>传输层： TCP UDP SCTP IP</li>
<li>网络层： IP IGMP ICMP ARP</li>
</ul>
<p>选择这些协议是为了说明TCP/IP协议套件包含了应用范围非常广泛的协议，而且这些协议仍然在不断地发展。  </p>
<p><br></p>
<hr>
<h3 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP (传输控制协议)"></a><strong>TCP (传输控制协议)</strong></h3><p><strong>传输控制协议 (Transmission Control Protocol, TCP)</strong>是指TCP协议套件中定义的一个协议。它起源于最初的网络实施，是互联网协议（IP）的补充。因此，整个协议套件通常被称为 TCP/IP。  </p>
<p>TCP 是面向连接的。客户端和服务器之间必须先建立连接，然后才能发送数据。<br>在建立连接之前，服务器必须监听（被动开放）客户端的连接请求。<br>三方握手（主动打开）、重传和错误检测增加了可靠性，但延长了延迟。  </p>
<p>（所以如果不需要可靠数据流服务的应用程序可以使用<strong>用户数据报协议 (User Datagram Protocol, UDP)</strong>。它提供的无连接数据报服务优先考虑的是最低延迟，而不是可靠性。）  </p>
<p>TCP 可避免网络拥塞，不过，TCP 也存在漏洞，包括拒绝服务、连接劫持、TCP 否决和重置攻击。  </p>
<p><br></p>
<p>如果在终端系统上运行的应用程序要向不同终端的系统上面发送信息，那么这个应用程序会被收到上面说过的应用层协议所控制。<br>该协议会将用户的数据传送给传输层，然后由传输层运行的TCP协议负责讲信息安全的发送给接收方。  </p>
<p>TCP协议会创建足够的数据包来容纳所有的数据，而且每一个数据包都会由报头和用户数据组成。  </p>
<p><br></p>
<p>除了确保数据的安全传输外，TCP协议还需要确保任何相应都会被引导回应用层级，因此，报文头中的一项内容就是<strong>端口号 (Port number)</strong>。端口号用于标识应用层的协议，比如说，HTTP的端口号就是80。  </p>
<p>数据包还必须包括接收端系统应用层协议的端口号，虽然说TCP不关心接收端的系统地址。  </p>
<p>在一个序列里的数据包会包含一个序列号，目的是为了在数据传输的重点能够正确的按照顺序重新组装数据。  </p>
<p><br></p>
<p>TCP 协议是面向连接的。一旦网络层向传输层返回确认，表明连接已经建立，TCP 就会发送其他数据包并接收包含确认的响应数据包。而且还可以识别并重新发送丢失的数据包。  </p>
<p><br></p>
<hr>
<h3 id="IP-互联网协议"><a href="#IP-互联网协议" class="headerlink" title="IP (互联网协议)"></a><strong>IP (互联网协议)</strong></h3><p><strong>互联网协议 (Internet Protocol)</strong>是一种协议或者一组规则，用于数据包的路由和寻址，使其能够穿越网络到达它要去的目的地。<br>穿越互联网的数据被分为一个个较小的块，我们之前提到过，叫做数据包。每个数据包的报头都附有IP信息，这些信息有助于</p>
<p>在网络层中，IP的是能够确保终端连接互联网的一个重要因素。<br>IP协议从传输层接受数据包，然后添加一个报头。报头包含发送方和接收方的IP地址。要找到接收方的IP地址，很可能需要使用DNS服务来找到与用户数据中提供的URL相对应的地址。  </p>
<p><br></p>
<p>IP数据包通常被叫做“<strong>数据报 (Datagram)</strong>”。它被发送到数据链路层，然后被发送到不同的协议套件中。  </p>
<p>数据链路层会把数据报组装成一个“帧”，然后再进行发送。有关这个“帧”的内容下一章我们会进一步解释。  </p>
<p><br></p>
<p>IP具有无连接服务的功能，一旦发送了数据包，IP无法知道他是不是真正的到达了目的地。如果IP收到了一个包含对先前发送的数据包的确认数据包，那么它只会把该数据包传递给TCP，自己不会了解其中的内容。  </p>
<p><br></p>
<hr>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a><strong>路由器</strong></h3><p>上面的图片显示，数据链路层发送的“帧”在传送之前会到达一个路由器（或者是多个路由器）。在这一阶段，帧的数据报内容会被反馈给IP。现在路由器软件的功能是在传输过程中选择下一个目标主机。  </p>
<p>用白话来说，当数据从一台设备发送到另一台设备时，会被分解成叫做“帧”的微小单元，然后通过网络发送。这些帧首先会被路由器接受，因为路由器是引导网络数据流的设备。<br>路由器检查包含数据报内的帧内容，并使用路由表来确认数据的下一个目的地。<br>路由表是每个路由器特有的，包含数据通过网络的最佳路径等其他信息。一旦路由器确认了下一个目的地，它就会更新数据报中的地址，然后将其传回数据链路层，由数据链路层继续发送。这一过程在每一个路由器上都会重复运行。  </p>
<p><br></p>
<p>作为网络中的一个节点，交换机和路由器的主要区别是在于：当一个帧到达交换机的时候，交换机不做任何的路由操作，而是直接发送数据。交换机在数据链路层运行，但是无法进入网络层。  </p>
<p><br></p>
<hr>
<h2 id="以太网-Ethernet-协议栈"><a href="#以太网-Ethernet-协议栈" class="headerlink" title="以太网(Ethernet)协议栈"></a><strong>以太网(Ethernet)协议栈</strong></h2><p>在AS部分的第二章，我们就已经了解过以太网了。以太网是一套专门为局域网设计的协议，因此它可以在不予互联网或者任何网络连接的本地局域网中运行。<br>但是现在的局域网几乎不可避免地需要与互联网产生链接，所以说局域网的协议套件现在已经添加了对于互联网协议套件的支持。  </p>
<p><br></p>
<p>如果我们仔细查看一个终端系统的协议栈(<em>还是上面的那个图</em>)， 你就会发现TCP/IP协议套件占据了五层协议栈的最上面的三层，因此我们可以说，TCP/IP协议套件得到了下面两层的支持。<br>TCP/IP与这两个较低层的功能无关，它的设计目的是能够得到任何可用协议的支持。  </p>
<p>值得注意的是，有些数据来源只对终端系统使用了4层栈。这种情况下，可能是数据决定只调用完全由软件处理的层，也可能是将TCP/IP的所有支持合并到了同一层中。  </p>
<p><br></p>
<hr>
<p>以太网是最有可能用来提供两个较低层所需功能的协议。从逻辑上来说，以太网套件包括了数据链路层和物理层两个子层，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c778329b108c9457c86bd268d99339b?method=download&amp;shareKey=6006174e1cb318f6cff4dd5c7fc5f809" alt=""></p>
<p>下面的这几点说明了以太网在支持TCP/IP的时候的功能：<br>下面的这几点说明了以太网在支持TCP/IP的时候的功能： </p>
<ul>
<li><strong>逻辑链路控制(Logic Link Control, LcC)</strong>协议负责与网络层的交互。它管理数据传输并确保数据传输的完整性。不过由于以太网是一种无连接协议，所以它不负责检查传输是否成功发送。  </li>
<li><p><strong>逻辑链路控制(Logic Link Control, LcC)</strong>协议负责与网络层的交互。它管理数据传输并确保数据传输的完整性。不过由于以太网是一种无连接协议，所以它不负责检查传输是否成功发送。  </p>
</li>
<li><p><strong>介质访问控制(Medium Access Control, mac)</strong>协议负责组装被称之为“帧”的以太网数据包。其中的两个组成部分是发送器地址和接收器地址。此外，MAC协议还负责启动帧传输，并处理因碰撞(可能因为使用了CSMA/CD)导致的传输失败之后的恢复工作。  </p>
</li>
<li><p><strong>介质访问控制(Medium Access Control, mac)</strong>协议负责组装被称之为“帧”的以太网数据包。其中的两个组成部分是发送器地址和接收器地址。此外，MAC协议还负责启动帧传输，并处理因碰撞(可能因为使用了CSMA/CD)导致的传输失败之后的恢复工作。  </p>
</li>
<li><p><strong>物理编码子层（Physical Coding Sublayer, PCS）</strong>,协议负责对准备传输的数据进行编码，或对于收到的数据进行解码。  </p>
</li>
<li><p><strong>物理编码子层（Physical Coding Sublayer, PCS）</strong>,协议负责对准备传输的数据进行编码，或对于收到的数据进行解码。  </p>
</li>
<li><p><strong>物理介质附件(Physical Medium Attachment, PMA)</strong>协议负责信号的收发。  </p>
</li>
<li><strong>物理介质附件(Physical Medium Attachment, PMA)</strong>协议负责信号的收发。  </li>
</ul>
<p><br><br><br></p>
<h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a><strong>MAC地址</strong></h3><h3 id="MAC地址-1"><a href="#MAC地址-1" class="headerlink" title="MAC地址"></a><strong>MAC地址</strong></h3><p>在以太网中，一个以太网帧使用的地址是物理地址或者MAC地址。<br>MAC地址值分配给网络接口控制器（NIC）的唯一标识符，用作网段内通信的网络地址。这部分的内容同样在AS部分的第二章提到过。简单来说，MAC地址标识一个唯一的网卡。<br>在大多数IEEE 802网络技术（包括以太网，Wi-Fi和蓝牙）中，这种用法都十分常见。<br>在以太网中，一个以太网帧使用的地址是物理地址或者MAC地址。<br>MAC地址值分配给网络接口控制器（NIC）的唯一标识符，用作网段内通信的网络地址。这部分的内容同样在AS部分的第二章提到过。简单来说，MAC地址标识一个唯一的网卡。<br>在大多数IEEE 802网络技术（包括以太网，Wi-Fi和蓝牙）中，这种用法都十分常见。  </p>
<p>迄今为止，定义MAC地址使用的48位可以保证每一个设备都分配到他们自己的MAC地址。不过，除了使用48位方案，现在还有一种64位的替代方案。这种方案已经偶尔使用，但是在将来48位地址不够用的时候就真正派上用场了。<br>迄今为止，定义MAC地址使用的48位可以保证每一个设备都分配到他们自己的MAC地址。不过，除了使用48位方案，现在还有一种64位的替代方案。这种方案已经偶尔使用，但是在将来48位地址不够用的时候就真正派上用场了。  </p>
<p>48位地址通常使用十六进制标识，比如说：<br>48位地址通常使用十六进制标识，比如说：  </p>
<p>        <code>4A:30:12:24:1A:10</code><br>        <code>4A:30:12:24:1A:10</code>  </p>
<p><br><br><br></p>
<h2 id="—-1"><a href="#—-1" class="headerlink" title="—-"></a>—-</h2><h2 id="与TCP-IP有关的应用层协议"><a href="#与TCP-IP有关的应用层协议" class="headerlink" title="与TCP/IP有关的应用层协议"></a><strong>与TCP/IP有关的应用层协议</strong></h2><h2 id="与TCP-IP有关的应用层协议-1"><a href="#与TCP-IP有关的应用层协议-1" class="headerlink" title="与TCP/IP有关的应用层协议"></a><strong>与TCP/IP有关的应用层协议</strong></h2><h3 id="HTTP-HyperText-Transfer-Protocol"><a href="#HTTP-HyperText-Transfer-Protocol" class="headerlink" title="HTTP (HyperText Transfer Protocol)"></a><strong>HTTP (HyperText Transfer Protocol)</strong></h3><h3 id="HTTP-HyperText-Transfer-Protocol-1"><a href="#HTTP-HyperText-Transfer-Protocol-1" class="headerlink" title="HTTP (HyperText Transfer Protocol)"></a><strong>HTTP (HyperText Transfer Protocol)</strong></h3><p><strong>超文本传输协议(HyperText Transfer Protocol, HTTP)</strong>，是最重要的应用层协议，因为这是万维网的基础。<br>每次用户使用网络浏览器访问网站的时候都会用到HTTP，但它的功能对用户是隐藏的。换句话说，当你访问一个网站的时候，你的浏览器会向网站的服务器发送一个HTTP请求，而服务器则使用HTTP回应用户网站的内容。这个过程发生在幕后，用户是看不到的。<br><strong>超文本传输协议(HyperText Transfer Protocol, HTTP)</strong>，是最重要的应用层协议，因为这是万维网的基础。<br>每次用户使用网络浏览器访问网站的时候都会用到HTTP，但它的功能对用户是隐藏的。换句话说，当你访问一个网站的时候，你的浏览器会向网站的服务器发送一个HTTP请求，而服务器则使用HTTP回应用户网站的内容。这个过程发生在幕后，用户是看不到的。  </p>
<p>HTTP协议定义了报文的格式。请求信息的第一行是“<strong>请求行 (Request Line)</strong>”，请求行之后还可以加上<strong>标题行 (Header Line)</strong>。所有这些信息都是用ASCII编码。请求行的格式如下：<br>HTTP协议定义了报文的格式。请求信息的第一行是“<strong>请求行 (Request Line)</strong>”，请求行之后还可以加上<strong>标题行 (Header Line)</strong>。所有这些信息都是用ASCII编码。请求行的格式如下：  </p>
<p>        <code>&lt;Method&gt; &lt;URL&gt; &lt;Version&gt;CRLF</code><br>        <code>&lt;Method&gt; &lt;URL&gt; &lt;Version&gt;CRLF</code>  </p>
<p>其中后面的CR和LF是ASCII的回车和换行符。<br>其中后面的CR和LF是ASCII的回车和换行符。  </p>
<p>请求行通常使用GET作为获取方法。不过除了GET方法，还存在其他的获取内容方法。这使得HTTP成为一种适用范围更广的协议，而不仅仅用于网页访问。<br>在使用HTTP的时候，我们必须指定HTTP的版本，因为HTTP发展到现在已经存在了好多版本。<br>请求行通常使用GET作为获取方法。不过除了GET方法，还存在其他的获取内容方法。这使得HTTP成为一种适用范围更广的协议，而不仅仅用于网页访问。<br>在使用HTTP的时候，我们必须指定HTTP的版本，因为HTTP发展到现在已经存在了好多版本。  </p>
<p><br><br><br></p>
<h2 id="—-2"><a href="#—-2" class="headerlink" title="—-"></a>—-</h2><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a><strong>电子邮件协议</strong></h3><h3 id="电子邮件协议-1"><a href="#电子邮件协议-1" class="headerlink" title="电子邮件协议"></a><strong>电子邮件协议</strong></h3><p>发送和接受电子邮件的传统方法如下图所示：<br>发送和接受电子邮件的传统方法如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2850a0d087d768b07083c5289fe9cd21?method=download&amp;shareKey=acbc8c637f4a495999dfecfde993215b" alt=""><br><img src="https://note.youdao.com/yws/api/personal/file/WEB2850a0d087d768b07083c5289fe9cd21?method=download&amp;shareKey=acbc8c637f4a495999dfecfde993215b" alt=""></p>
<p>这其中设计三个单独的客户端到服务器的交互。客户端的电子邮件发件人必须和邮件服务器建立连接，然后该服务器必须变成“客户端”向真正客户端的电子邮件接收者所使用的邮件服务器进行传输。<br>这其中设计三个单独的客户端到服务器的交互。客户端的电子邮件发件人必须和邮件服务器建立连接，然后该服务器必须变成“客户端”向真正客户端的电子邮件接收者所使用的邮件服务器进行传输。  </p>
<p><br><br><br></p>
<p>目前存在以下三种主流的电子邮件协议：<br>目前存在以下三种主流的电子邮件协议：  </p>
<p><strong>简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)</strong>，是一种“Push”协议，即用于从一个服务器向另一个服务器发送电子邮件。而<strong>邮局协议版本3 (POP3)</strong>是一种“Pull”协议，即用于从服务器检索电子邮件并下载到客户端计算机。<br><strong>简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)</strong>，是一种“Push”协议，即用于从一个服务器向另一个服务器发送电子邮件。而<strong>邮局协议版本3 (POP3)</strong>是一种“Pull”协议，即用于从服务器检索电子邮件并下载到客户端计算机。  </p>
<p>还有一种协议叫做<strong>互联网消息访问协议 (Internet Message Access Protocol, IMAP)</strong>，这是POP3的最新替代方案。POP3是将电子邮件下载到客户端计算机上，但是IMAP允许将电子邮件保存在服务器上，同时客户端也可以访问存储的电子邮件。<br>这意味着如果使用IMAP协议，你可以在任何设备上访问你的邮件。而使用POP3，我们只能从下载邮件的客户端系统访问你的邮件。<br>还有一种协议叫做<strong>互联网消息访问协议 (Internet Message Access Protocol, IMAP)</strong>，这是POP3的最新替代方案。POP3是将电子邮件下载到客户端计算机上，但是IMAP允许将电子邮件保存在服务器上，同时客户端也可以访问存储的电子邮件。<br>这意味着如果使用IMAP协议，你可以在任何设备上访问你的邮件。而使用POP3，我们只能从下载邮件的客户端系统访问你的邮件。  </p>
<p>一般来说，POP3在抵御网络攻击方面可能会更加安全，因为电子邮件都存在客户端计算机的本地。不过使用IMAP存储电子邮件的服务器可能会定期备份，但是本地客户端大概率不会。<br>一般来说，POP3在抵御网络攻击方面可能会更加安全，因为电子邮件都存在客户端计算机的本地。不过使用IMAP存储电子邮件的服务器可能会定期备份，但是本地客户端大概率不会。  </p>
<p><br><br><br></p>
<h2 id="—-3"><a href="#—-3" class="headerlink" title="—-"></a>—-</h2><h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP (文件传输协议)"></a><strong>FTP (文件传输协议)</strong></h3><p><strong>文件传输协议 (File Transfer Protocol, FTP)</strong>是一种标准通信协议，用于在计算机网络中将计算机文件从服务器传输到客户端。  </p>
<p>FTP 基于客户机-服务器模型架构，在客户机和服务器之间使用独立的控制和数据连接。FTP 用户可以通过明文登录协议（通常以用户名和密码的形式）进行身份验证，但如果服务器配置允许，也可以匿名连接。  </p>
<p>为了保护用户名和密码并对内容进行加密的安全传输，FTP 通常使用 SSL/TLS (FTPS) 或用 SSH 文件传输协议 (SFTP) 代替。  </p>
<p><br></p>
<hr>
<h2 id="P2P文件共享"><a href="#P2P文件共享" class="headerlink" title="P2P文件共享"></a><strong>P2P文件共享</strong></h2><p><strong>点对点文件共享 (Peer-to-peer file sharing, P2P file sharing)</strong>产生的网络流是互联网使用的主要特征之一。  </p>
<p>P2P 是一种没有结构和控制机制的架构。点对点既是客户端也是服务器，每个点对点只是一个终端系统。当对等体充当服务器时，它被称为 “种子”。</p>
<p><br></p>
<p>在P2P中，BitTorrent协议是最常用的协议，因为它可以快速的共享文件。 BitTorrent 是一种用于点对点文件共享（P2P）的通信协议，它使用户能够以分散的方式在互联网上分发数据和电子文件。要发送或接收文件，用户需要在联网电脑上使用 BitTorrent 客户端。  </p>
<p>BitTorrent 客户端是实现 BitTorrent 协议的计算机程序。BitTorrent 客户端适用于各种计算平台和操作系统，包括 Rainberry 公司发布的官方客户端。流行的客户端包括 μTorrent、迅雷、Transmission、qBittorrent、Vuze、Deluge、BitComet 和 Tixati等等。</p>
<p>BitTorrent 跟踪器提供可用于传输的文件列表，并允许客户端查找可传输文件的对等用户（称为 “种子”）。程序员布拉姆-科恩于 2001 年 4 月设计了该协议，并于 2001 年 7 月 2 日发布了第一个可用版本。BitTorrent 协议可用于减少分发大文件对服务器和网络的影响。BitTorrent 协议允许用户加入一个主机 “群”，同时相互上传和下载文件，而不是从单个源服务器下载文件。  </p>
<p><br></p>
<p>如果我们决定在终端系统使用BitTorrent，我们需要解决下面这三个基本问题：  </p>
<ol>
<li>如何确保计算机能够在网络上找到拥有目标资源的计算机？  </li>
</ol>
<blockquote>
<p>首先每个内容的供应者都提供一个内容描述，叫做torrent。这是一个包含跟踪器 （<em>引导计算机找到内容的服务器</em>）名称和内容块列表的文件。torrent文件比内容至少要小上三个过更多的数量级，因此这样的种子文件更易于我们传播。<br>跟踪器是一个服务器，它的任务是维护正在下载和上传内容的所有其他的终端的列表。  </p>
</blockquote>
<ol>
<li>在这样的对等网络上，如何为所有人提供高速的下载？  </li>
</ol>
<blockquote>
<p>对等网络在下载和上传的过程是同时发生的，但是对等网络必须同时交换数据块列表，来确保优先下载稀有的数据块。只要下载一次稀有的片段，那么这个数据块的稀有程度就会降低。  </p>
</blockquote>
<ol>
<li>每个终端如何鼓励其他的终端提供内容，而不是仅仅使用协议下载文件造福自己？  </li>
</ol>
<blockquote>
<p>在经济中有一个名词叫做”Free-rider”。在这里我们需要对付的就是这类的终端。解决的方法如下：<br>首先一个终端先随机尝试连接其他的终端，然后仅仅向那些提供常规下载的节点传输数据。如果发现有一个节点不下载或者下载速度贼慢，那么这个节点最后就会被“隔离”或者“阻塞”。  </p>
</blockquote>
<p><br></p>
<hr>
<h1 id="第十八章：硬件与虚拟机"><a href="#第十八章：硬件与虚拟机" class="headerlink" title="第十八章：硬件与虚拟机"></a><strong>第十八章：硬件与虚拟机</strong></h1><h2 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a><strong>控制单元</strong></h2><p><strong>控制单元 (Control unit, CU)</strong>是计算机中CPU的一个组件，用于指导处理器的运行。它通常使用二进制解码器将编码指令转换为定时和控制信号，从而直到内存，算术逻辑单元(ALU)和IO设备等其他单元的运行。  </p>
<p>控制单元管理大部分计算机的资源，并直到中央处理器与其他设备之间的数据流。在现在计算机设计中，控制单元通常是中央处理器的内部组成部分，其整体作用和运行方式自推出以来一直没有发生改变。  </p>
<p><br></p>
<hr>
<p>在执行程序时，中央处理器会接收一连串机器码指令。中央处理器内的控制单元有责任确保正确处理每一条机器指令。有两种方法可以设计控制单元，使其发挥功能：  </p>
<ul>
<li><p><strong>将控制单元构建为逻辑电路</strong>：这也称为<strong>硬连线控制单元 (Hardwired control unit)</strong>。硬连线控制单元通过逻辑电路将从中央处理器内存接收到的指令转化为控制信号。来自计算机主机内存的指令被发送到指令寄存器，指令寄存器负责识别其“操作码”。随后操作码被传递给指令解码器，指令解码器使用操作码来解释要生成的控制信号。然后，逻辑电路根据任何外部输入和条件代码创建了信号。&lt;/br&gt; &lt;/br&gt;整个过程由系统时钟同步，系统时钟产生有规律的脉冲，在低电平和高电平之间持续切换，形成了0和1。这种控制单元之所以是“硬连线”，是因为他们的逻辑电路是由硬件以逻辑门电路的物理排列。&lt;/br&gt; &lt;/br&gt;硬接线控制单元的一些缺点是成本相对较高，难以用于复杂的操作，而且无法在不进行物理改动的情况下对它进行修改。此外，每个电路只能处理一种形式的指令。不过，硬接线控制单元速度更快，因为每一种指令都由自己指定的电路来完成计算。  </p>
</li>
<li><p><strong>使用微编程构建微程序控制单元</strong>：这样的方法叫做<strong>微程序控制单元 (Microprogrammed control unit)</strong>。微编程控制单元采用编程的方法实现。在微程序控制中，微操作是通过执行由微指令组成的程序来实现的。<br> <br> 控制存储器地址寄存器用来指定微指令的地址。控制存储器被用为ROM，其永久存储了左右的控制信息我们一般称为<strong>固件 (Firmware)</strong>。控制寄存器保存从存储器获取的微指令。微指令包含一个控制字，为数据处理器指定一个或者多个微操作。  </p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="CISC和RISC处理器"><a href="#CISC和RISC处理器" class="headerlink" title="CISC和RISC处理器"></a><strong>CISC和RISC处理器</strong></h2><p>处理器的架构是指其物理结构。不过，处理器也有所谓的 “指令集架构”。</p>
<p>指令集架构涉及到： </p>
<ul>
<li>指令集</li>
<li>指令格式</li>
<li>寻址模式</li>
<li>指令可以访问的寄存器</li>
</ul>
<p>其中，指令集的选择是区分指令集架构的主要因素。  </p>
<p><br></p>
<hr>
<p>在计算机发展的早期，选择计算机指令集架构的一个重要因素是，该架构是否能够使高级语言编译器的编写变得更加容易。我们现在将这一种架构叫做<strong>复杂指令集计算机 (Complex Instruction Set Computer, CISC)</strong>。</p>
<p>直到20世纪70年代末期，人们开始对这一理念产生质疑。有人认为，使用<strong>精简指令集计算机 (Reduces Instruction Set Computer, RISC)</strong>会是一种更好的方法。  </p>
<p><br></p>
<p>下面介绍一下这两位：  </p>
<p>CISC和RISC是两种不同类型的计算机体系结构。二者的主要区别在于<strong>中央处理器可执行的指令数</strong>和<strong>执行这些指令所需要的周期数</strong>。  </p>
<p>CISC试图尽量减少每个程序的指令数，但是代价是这会增加每个指令的周期数。这就意味着CISC处理器一般<u>拥有大量的复杂指令</u>，但是可以在一条指令中执行多种操作。这些指令通常更长，功能更强大，可以用更少的单条指令来完成复杂的任务。  </p>
<p>现在转过头来看看另一边的RISC。RISC是一种以每个程序的指令数量为代价来减少每条指令周期的方法。这就意味着RISC处理器的<strong>简单指令数量较少</strong>，<strong>只能执行单一的操作</strong>。这样，RISC处理器的指令集就设计的比CISC更简单，更小了。这些指令通常更短更简单，需要更多的单独指令才能完成复杂的任务。  </p>
<p>这两种方法各有利弊。CISC处理器通常<strong>更容易编程</strong>，因为它们有更强大的指令。但由于每条指令的周期数多，所以运行速度可能会慢一些。RISC处理器由于减少了每条指令的周期数，因此运行的速度普遍较快，但是因为需要更多的单独指令来执行复杂的任务，因此这可能会使得编程的难度直线上升。  </p>
<article class="message is-info"><div class="message-body">

<b>Complex Instruction Set Computer (CISC): a single instruction can be more complex and involve more loading of data from memory.</b>

<br>

<b>Reduced Instruction Set Computer (RISC): s single instruction is simpler, requiring minimal loading of data from memory.</b>

</div></article> 



<p><br></p>
<hr>
<p>下表列出了RISC区别于CISC的一些特征：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">RISC</th>
<th style="text-align:left">CISC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">更少的指令数</td>
<td style="text-align:left">更多的指令数</td>
</tr>
<tr>
<td style="text-align:left">更简单的指令</td>
<td style="text-align:left">更复杂的指令</td>
</tr>
<tr>
<td style="text-align:left">指令格式相对简单</td>
<td style="text-align:left">指令格式复杂</td>
</tr>
<tr>
<td style="text-align:left">尽可能使用单周期指令</td>
<td style="text-align:left">多周期指令</td>
</tr>
<tr>
<td style="text-align:left">定长指令</td>
<td style="text-align:left">可变长度指令</td>
</tr>
<tr>
<td style="text-align:left">只对内存地址执行加载和存储指令</td>
<td style="text-align:left">向内存地址存储多种指令</td>
</tr>
<tr>
<td style="text-align:left">更少的寻址模式</td>
<td style="text-align:left">更多的寻址模式</td>
</tr>
<tr>
<td style="text-align:left">多个寄存器组</td>
<td style="text-align:left">更少的寄存器</td>
</tr>
<tr>
<td style="text-align:left">多为<strong>硬连线控制单元</strong></td>
<td style="text-align:left">多为<strong>微程序控制单元</strong></td>
</tr>
<tr>
<td style="text-align:left">更利于流水线作业</td>
<td style="text-align:left">不太利于流水线作业</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，RISC处理器大多使用硬连线控制单元，而CISC处理器大多使用微编程控制单元。</p>
<p>指令数量的减少并不是使用RISC的主要驱动力，降低指令的复杂性才是RISC的主要特征。  </p>
<p>典型的CISC架构包含很多的专用指令，专用指令的设计符合高级编程语言的要求。专用指令需要多次访问内存。与直接访问寄存器相比，访问内存的速度可谓是相当慢。  </p>
<p>RISC处理器的指令非常简单，因此数据可以存储在寄存器中，并在寄存器中进行操作。除了初始化和资源存储请求之外，无需对存储器进行任何的访问。   </p>
<p>RISC指令的简单性使得硬连线控制单元的使用更加容易。而许多CISC指令的复杂性使得硬连线控制单元的构建更加复杂，因此我们使用微程序控制单元。  </p>
<p><br></p>
<hr>
<h3 id="流水线作业-Pipelining"><a href="#流水线作业-Pipelining" class="headerlink" title="流水线作业 (Pipelining)"></a><strong>流水线作业 (Pipelining)</strong></h3><p>创建 RISC 处理器的主要驱动力之一，就是为高效流水线提供机会。  </p>
<p><strong>流水线 (Pipelining)</strong>是一种专门应用于指令执行的并行方式。其他并行形式将在下一节中讨论。  </p>
<p><em>好像翻译成“流水线”不是很恰当，但是懂我意思就行</em></p>
<article class="message is-info"><div class="message-body">

<b>Pipelining: instruction-level parallelism.</b>

</div></article> 

<p><br></p>
<hr>
<p>流水线作业的基本原理是第五章中介绍的F-E Cycle可以分为若干阶段。其中的一个形式是“五阶段模型”。要实现流水线操作，处理器的结构必须含有5个独立的单元，这样每个单元就可以单独处理五个阶段中的其中一个阶段。这同样解释了为什么RISC处理器需要许多的寄存器组，因为存在多个处理单元，而每个单元必须需要寄存器来访问将要使用的数据。</p>
<p>五阶段模型如下表所述：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">时钟周期 →</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Instruction Fetch<br>(指令读取，IF)</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">3.1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">5.1</td>
<td style="text-align:center">(6.1)</td>
<td style="text-align:center">(7.1)</td>
</tr>
<tr>
<td style="text-align:left">Instruction Decode<br>(指令解码，ID)</td>
<td style="text-align:center"></td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">2.2</td>
<td style="text-align:center">3.2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">5.2</td>
<td style="text-align:center">(6.2)</td>
</tr>
<tr>
<td style="text-align:left">Operand Fetch<br>(操作数抓取，OF)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.3</td>
<td style="text-align:center">2.3</td>
<td style="text-align:center">3.3</td>
<td style="text-align:center">4.3</td>
<td style="text-align:center">5.3</td>
</tr>
<tr>
<td style="text-align:left">Instruction Execute<br>(指令执行，IE)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.4</td>
<td style="text-align:center">2.4</td>
<td style="text-align:center">3.4</td>
<td style="text-align:center">4.4</td>
</tr>
<tr>
<td style="text-align:left">Result Write Back<br>(结果回写，WB)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1.5</td>
<td style="text-align:center">2.5</td>
<td style="text-align:center">3.5</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>在上面的表格中，每一行代表流水线中的一个阶段： 指令读取 (IF)、指令解码 (ID)、操作数读取 (OF)、指令执行 (IE) 和结果回写 (WB)，同时每列代表一个时钟周期。单元中的数字代表指令编号和该指令的阶段。例如，”1.1 “表示指令 1 处于 第一步 “IF” 阶段，”2.5 “表示指令 2 处于第五步 “WB” 阶段。  </p>
<p>解读一下表格：最初只有第一条指令的第一阶段进入了流水线。在第六个时钟周期，当第一个指令已经离开流水线时 <em>（因为不存在第六个流水线阶段）</em>，指令2的最后一步仍在处理，而且指令6才刚刚进入流水线作业 <em>（因为没有第六个流水线阶段，所以第六个指令的流程并没有画在表上。但如果第六个指令需要处理的话，会在第六个时钟周期进入流水线）</em>。</p>
<p>流水线一旦开始运行，就要处理五个阶段的五条单独指令。特别是在每个时钟周期，都需要完成一条指令的处理工作。如果没有流水线并行作业，那么处理时间将延长五倍。</p>
<p><br></p>
<p>在流水线系统中，多条指令在流水线的不同阶段同时处理。当中断发生时，流水线中就会有几条指令尚未执行完毕。<br>有两种解决中断问题的解决方案：  </p>
<ul>
<li><p>第一种：<strong>清除最近进入的四条指令的流水线内容，只留下最早进入的指令。</strong>然后，正常的中断处理程序就可以应用于剩余的指令。</p>
</li>
<li><p>第二种：<strong>在处理器中构建具有独立程序计数器寄存器的独立单元。</strong>这样就可以在处理中断时为流水线中的所有指令存储当前数据。</p>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="基本计算机架构"><a href="#基本计算机架构" class="headerlink" title="基本计算机架构"></a><strong>基本计算机架构</strong></h2><p>描述不同计算机体系结构的一种有效的方法是：考虑指令流的数量和数据流的数量。因此这区分出了四种类型的架构：  </p>
<p><br></p>
<hr>
<h3 id="单指令流单数据流-SISD"><a href="#单指令流单数据流-SISD" class="headerlink" title="单指令流单数据流 (SISD)"></a><strong>单指令流单数据流 (SISD)</strong></h3><p><strong>单指令流单数据流 (Single Instruction Stream Single Data Stream, SISD)</strong>是早期计算机中的典型架构，同样也是早期的微处理器所采用的排列方式。具体来说，SISD代表了包含一个控制单元，一个处理器单元和一个存储器单元的单台计算机的组织结构。所有的指令按照顺序执行，系统内部可能有并行能力，也可能没有。  </p>
<p>虽说是这样，但是课本上写的是SISD纯粹是顺序性的产物，没有一点点并行性。我们就按照这条来记吧。</p>
<p><br></p>
<p>下图展示了如何使用SISD来操作数组中的单个元素：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB30316d3629bca49a5815cbb453ffaab7?method=download&amp;shareKey=3ed3432f2423c78b6885dccd0b2e3c68" alt="">  </p>
<p>图中给出了一个原始的数组。如果机器需要将这个数组内的元素乘以2，那么SISD就会按照顺序一个一个地处理数组内部的数据，从右到左。换言之，SISD对于数组内每一个元素都执行了相同的“乘以2”的操作。  </p>
<article class="message is-info"><div class="message-body">

<b>SISD: Stands for Single Instruction Stream Single Data stream; a single processor accessing one memory.</b>

</div></article> 


<p><br></p>
<hr>
<h3 id="单指令流多数据流-SIMD"><a href="#单指令流多数据流-SIMD" class="headerlink" title="单指令流多数据流 (SIMD)"></a><strong>单指令流多数据流 (SIMD)</strong></h3><p><strong>单指令流多数据流 (Single Instruction Stream Multiple Data Stream, SIMD)</strong>所描述的计算机具有多个处理元件，可以<u>同时对多个数据点执行相同的操作</u>。这类计算机利用数据级的并行性，但是不利用它们的并发性。 </p>
<p>SIMD是一种并行处理方式，也就是多个处理元件同时对多个数据点执行相同操作。这意味着计算机就可以使用相同的指令同时处理多个数据点，而不是一步只能处理一个数据点。这可以大大提升某些类型计算的速度。也就是说，虽然说存在并行计算，但是每个单元在任何给定的时刻都执行完全相同的指令。  </p>
<p><br></p>
<hr>
<p>下图是一个SIMD的图示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7144d89b55622ba1765c5b94a0c5e21e?method=download&amp;shareKey=1d05101205bb890f3f1a34bb47dd9fde" alt=""></p>
<p>由图可见，所有在数组中的元素都在同一个指令周期完成了处理，而不像SISD一样每一个元素都需要单独处理。  </p>
<p><br></p>
<p>SIMD 的结构通常用图表表示，就像下图一样：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6215f557d53c58f88328a11754ac405e?method=download&amp;shareKey=2f07fdbe2d15d4e0cc24e974bdcd90c8" alt=""></p>
<p>在本图中，结构图显示数据流进入了四个单独的组件，这些组件都提供了相同的指令。这些组件被称之为<strong>处理单元(Processing Unit, PU)</strong>，有时这些组件也被称为<strong>处理原件(Processing Element, PE)</strong>。无论使用什么名称，这些组件都全部是ALU，也就是算术逻辑单元。有多个名称的原因是因为实现SIMD有多种方法：  </p>
<p>第一种实现方法是使用阵列或者向量处理器(Matrix &amp; Vector processors)。他们有一组并行的寄存器，每一个数据流都会被安排一个寄存器。我们可以使用一4位或者128位的大型寄存器，来同时存储多个数值。在这种实现方式中，并行性仅仅内置在一个处理器中，允许这个处理器同时处理多个数据流。</p>
<p>另一种方法是使用多核处理器。现在大多数的电脑都搭载了多核处理器。比如说使用4核处理器，就代表四个处理器并行工作。在这种情况下，每一个处理器都可能有自己专用的告诉缓存来提供可靠的数据流。</p>
<article class="message is-info"><div class="message-body">

<b>SIMD: Stands for Single Instruction Stream Multiple Data Stream; processing of parallel data input requiring one control unit instructing multiple processing units.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="多指令流单数据流-MISD"><a href="#多指令流单数据流-MISD" class="headerlink" title="多指令流单数据流 (MISD)"></a><strong>多指令流单数据流 (MISD)</strong></h3><p><strong>多指令流单数据流 (Multiple Instruction Stream Single Data Stream, MISD)</strong>是一种并行计算架构，其中<u>许多功能单元对同样的数据执行不同的操作。</u>  </p>
<p>与SIMD相比，MISD的应用就少得多，因为MISD通常更适合常用的数据并行技术。具体来说，他们可以更好的扩展和使用计算资源。话虽这么讲，MISD也是有应用的，比如说用于航天飞机的飞行控制计算机。大家也知道航天方面的数据计算是不容有失的，-在这种情况下，使用 MISD 架构可将多条指令应用于同一数据流，从而提供冗余并提高系统的可靠性。</p>
<article class="message is-info"><div class="message-body">

<b>MISD: Stands for Multiple Instruction Stream Single Data Stream; does not exist in a single architecture.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="多指令流多数据流-MIMD"><a href="#多指令流多数据流-MIMD" class="headerlink" title="多指令流多数据流 (MIMD)"></a><strong>多指令流多数据流 (MIMD)</strong></h3><p><strong>多指令流多数据流 (Multiple Instruction Stream Multiple Data Stream, MIMD)</strong>是一种并行计算架构。在这种架构中，有许多个处理器异步独立运行。<u>在任何时候，不同的处理器都可能对不同的数据执行不同的指令。</u>  </p>
<p>MIMD架构被应用于多个领域，如计算机辅助设计，仿真，建模或者是通信交换机。MIMD机器可以分为共享内存和分布式内存两类，他们的类别是基于MIMD处理器访问内存的方式决定的。共享机器模型可以是总线型、扩展型或者分层型。</p>
<article class="message is-info"><div class="message-body">

<b>MIMD: Stands for Multiple Instruction Stream Multiple Data Stream; multiple processors asynchronously processing parallel data input.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="大规模并行计算机系统"><a href="#大规模并行计算机系统" class="headerlink" title="大规模并行计算机系统"></a><strong>大规模并行计算机系统</strong></h3><p><strong>大规模并行计算机系统 (Massively parallel computer systems)</strong>是指使用大量计算机处理器（或者是独立的计算机）同时并行执行一组协调计算的计算架构。这可以通过各种各样的方法实现，比如说网格计算 (Grid computing)，就是透过使用大量的异构计算机的未使用资源，将其作为嵌入在分布式电信基础设施中的一个虚拟的计算机集群，为解决大规模的计算问题提供模型的方案。大名鼎鼎的SETI@home项目就是使用了这项技术，通过筹集大量计算机用户的剩余资源来分布式计算问题。这些小的计算机结合起来的算力同样强大，丝毫不亚于超级计算机。  </p>
<p>大规模并行计算机系统与超级计算机的区别在于，负责驱动多个处理器的不是总线结构，而是支持多个计算机单元的网络基础设施。不同计算机上面运行的程序可以通过网络传递信息进行通信。 </p>
<p><br></p>
<hr>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><strong>虚拟机</strong></h2><p>虚拟机听起来像是个硬件，但其实不是。最常见的虚拟机类型是<strong>系统虚拟机 (System virtual machine)</strong>，它的作用是模拟真实计算机系统硬件的软件。  </p>
<article class="message is-info"><div class="message-body">

<b>System virtual machine: the emulation of computer system hardware using software.</b>

</div></article> 

<p><br></p>
<p>一般来说，应用程序需要在操作系统支持的情况下才能在硬件上直接运行。虚拟机的原理是进程直接与操作系统提供的软件界面进行交互，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBad58e3603d7ce6727ad0207a279a5d47?method=download&amp;shareKey=ae8057b16074d482045345abe63369db" alt="">  </p>
<p>从上图我们需要注意这几点：  </p>
<ol>
<li><p>应用程序是在客户操作系统的协助下安装的。客座操作系统将通过与虚拟机交互来支持运行中的应用程序，就好像客座操作系统通常运行的硬件一样。  </p>
</li>
<li><p>虚拟机实施软件可被视为一种实用程序，运行时受特定主机操作系统的支持，而主机操作系统又是主机硬件所特有的。  </p>
</li>
<li><p>在主机操作系统的控制下，主机硬件上可以同时直接运行应用程序。  </p>
</li>
</ol>
<p><br></p>
<p>虚拟机方法的主要优点是可以在一个计算机系统上提供多个不同的操作系统。如果一个组织拥有遗留系统，希望继续使用旧软件，但又不想保留旧硬件，这一点就特别有价值。  </p>
<p>另外，拥有大型主机并提供服务器整合设施的公司也可以多次提供相同的操作系统。不同的公司可以获得自己的虚拟机，作为服务器运行。  </p>
<p>使用虚拟机的一个缺点是需要花费大量时间和精力来实施。另一个缺点是虚拟机的性能无法达到普通系统的性能水平。  </p>
<p><br></p>
<p>之前在第八章讨论的 Java 虚拟机是进程虚拟机的一个例子，它基于不同的基本概念。进程虚拟机提供了一个与平台无关的编程环境，允许程序在任何平台上以相同的方式执行。这是一种仅支持运行 Java 程序的特定软件。</p>
<p><br></p>
<hr>
<h1 id="第十九章：逻辑门与布尔代数"><a href="#第十九章：逻辑门与布尔代数" class="headerlink" title="第十九章：逻辑门与布尔代数"></a><strong>第十九章：逻辑门与布尔代数</strong></h1><h2 id="逻辑电路"><a href="#逻辑电路" class="headerlink" title="逻辑电路"></a><strong>逻辑电路</strong></h2><p>早在第四章，我们就已经接触过了逻辑电路中使用的逻辑门符号，并讨论了逻辑电路，真值表和逻辑表达式之间的关系。本章会介绍一些额外的内容，比如一些用于构建计算机硬件功能组建的特定电路。  </p>
<h3 id="半加法器-The-half-adder"><a href="#半加法器-The-half-adder" class="headerlink" title="半加法器 (The half adder)"></a><strong>半加法器 (The half adder)</strong></h3><p>在计算机中，二进制加法运算随处可见。两个比特的结果相加结果要么为1，要么为0。在一些特殊情况下，如1和1相加，会导致当前位结果为0，同时它的下一位会被加一，也就是进位。  </p>
<p>执行二进制加法最简单的电路是<strong>半加法器 (Half adder)</strong>。如下图所示，半加法器会接受两个值的输入，然后输出“和位(S)”和一个“进位(C)”。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB50fb2efc7af272739fbc1a90ed75d8fb?method=download&amp;shareKey=c676b82aaa0cdaed3a57929e73110e3b" alt=""></p>
<p>这个电路的真值表看起来就是这样的：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input</th>
<th style="text-align:center">Input</th>
<th style="text-align:center">Output</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center"><strong>C</strong></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>通过检查这个真值表，我们大概可以推测出半加法器的成分如何。<br>可以看到，只有在两个输入位都为1的时候，进位C才会出现1的结果。因此，C输出的真值表就可能是基于AND逻辑门实现的。<br>和位S输出的真值表与之前聊过的XOR运算符的真值表一致，所以我们也可以推测半加法器里面还存在一个XOR逻辑门。<br>因此，产生半加法器功能的电路可以包含一个AND门和一个XOR门，其中这两个逻辑门都会接受A和B两个输入。</p>
<p>当然，上面列出的只是完成这个功能的其中一种情况，还有更多逻辑门的搭配方式可以实现这样的功能。冷知识：NAND逻辑门和NOR门是两个通用门，这意味着任何的逻辑电路都可以使用这两种逻辑门进行构建。再加上NAND和NOR门易于制造的特点，导致电路制造商们很喜欢使用它们俩。下面这个图片就是仅仅使用NAND门和NOR门构建出来的一个半加法器：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB534f2fe40966c4cfe4f07994cae4f61c?method=download&amp;shareKey=8ab4d250399ae72eeb307bba668d92d5" alt=""></p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Half adder circuit: a circuit which performs binary addition of two individual bits.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="全加法器-The-full-adder"><a href="#全加法器-The-full-adder" class="headerlink" title="全加法器 (The full adder)"></a><strong>全加法器 (The full adder)</strong></h3><p>一般来说，如果我们需要计算两个二进制数字相加，则我们必须要从两个数字的最小位开始计算，一直计算到最大位。在计算的每一个阶段，前一个加法的结果的进位数字都必须并入到当前的计算中。<br>如果每次使用半加法器，就必须需要使用单独的电路来处理进位问题，因为半加法器仅仅接受两个输入。  </p>
<p><strong>全加法器 (Full adder)</strong>是一种执行加法运算的一种电路。这种加法器接受三个输入：两个需要相加的数字和上一位产生的进位，并产生三个输出，分别是三个输入的和以及下一位的进位。  </p>
<p>当我们需要对不止一位进行二进制加法运算时，我们最好使用全加法器，因为全加法器考虑了前一位假发的金文，所以它能够处理所有的进位问题。例如我们设计对多位二进制数（如4位，8位，16位二进制数等）进行算术运算的电路，我们就需要使用全加法器。</p>
<p>全加法器的真值表如下：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Input</th>
<th>Input</th>
<th>Output</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>Cin</td>
<td>S</td>
<td>Cout</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>全加法器的一种可能的构造如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf506c3d9a0c9e9dcad6f14905ad95347?method=download&amp;shareKey=cf712be00f7aa9f64cd2ea3b41c00895" alt=""></p>
<p><br></p>
<p>我们之前说过，所有的电路理论上都可以使用NAND和NOR逻辑门来构建。所以全加法器的另一种构造如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7f4a38b0b4d46b3034ead532ffb7a7a5?method=download&amp;shareKey=212c866467e455e7c6f529fe74bea972" alt=""></p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Full adder circuit: a circuit which performs binary addition of two individual bits and an input carry bit.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="时序电路"><a href="#时序电路" class="headerlink" title="时序电路"></a><strong>时序电路</strong></h2><p>到目前为止，本书中介绍过的所有电路全部都是 组合电路 (Combinational circuit)。对于这样的电路来说，输出的值只由输入的值决定。<br>接下来我们会介绍时序电路，它的输出取决于输入和前一个输出项。  </p>
<p><strong>时序电路 (Sequential logic circuit)</strong>是一种数字电路，它存储上一个输出信息并使用它来计算下一个输出。我们刚说过，时序电路于组合电路不同之处就在于，时序电路既依赖当前输入值，同样也依赖存储在某一个存储元件中的上一个输出状态。  </p>
<article class="message is-info"><div class="message-body">

<b>Combinational circuit: a circuit in which the output is dependent only on the input values.</b>

<br>

<b>Sequential circuit: a circuit in which the output depends n the input values and the previous output.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="SR-触发器-SR-Flip-flop"><a href="#SR-触发器-SR-Flip-flop" class="headerlink" title="SR 触发器 (SR Flip-flop)"></a><strong>SR 触发器 (SR Flip-flop)</strong></h3><p>下面我们要介绍的SR触发器，是时序电路的一个简单例子。  </p>
<p><strong>SR触发器 (SR Flip-flop)</strong>，又称之为SR锁存器，是数字电子产品中经常会用到的一种基本触发器。SR触发器是一种双稳定器件，这意味着SR触发器有两个稳定状态，而这两种稳定状态可以被无限期保存。正因为这种独特的记忆特性，卫门叫它“锁存器”。它可以由两个NAND门和一个NOR门组成，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf6c36ffa6f6e12b7716959b642e9bd4f?method=download&amp;shareKey=a83e7e149cc8b4acf2c767a8f0011cdc" alt=""></p>
<p>SR触发器有两个输入端，分别是 <strong>“置位” (S)</strong>和 <strong>“复位” (R)</strong>。以及两个输出端，分别是<strong>Q</strong>和<strong>Q’</strong>。<br>SR触发器的工作原理如下：  </p>
<ul>
<li><strong>设置 (set) 状态</strong>： 当设置(S)为1，(R)为0时，这时输出(Q)就会变为1。这表示锁存器进入了设置状态。  </li>
<li><strong>复位 (reset) 状态</strong>： 当设置(R)为1，(S)为0时，这时输出(Q)就会变为0。这表示锁存器进入了复位状态。  </li>
<li><strong>保持 (hold) 状态</strong>： 当输入端的(S)和(R)均为0时，无论上一个状态是设置状态还是复位状态，触发器会保持原来的状态。也就是说，输出还是会与上次相同。 <br> 比如说，如果SR触发器的上一个状态处于“set”状态，也就是Q的输出为1，并且输入S和R都是0，那么触发器会继续输出Q为1。  </li>
</ul>
<p>SR触发器的真值表如下所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input Signals</th>
<th style="text-align:center">Input Signals</th>
<th style="text-align:center">Initial State</th>
<th style="text-align:center">Initial State</th>
<th style="text-align:center">Final State</th>
<th style="text-align:center">Final State</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">R</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">Q’</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">Q’</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>从真值表中我们可以发现，表中不包含当R = 1或者S = 1的行，因为如果当S与R同时等于1，会导致输出“非法”。因为当遵循布尔代数原则时，Q和Q’不会同时输出0。Q与Q’本身应该就是彼此互补的，即当一个值为1时，另一个值应该为0。所以，输出是违反这个逻辑，是“非法”的。  </p>
<p>在实际运用中，我们要避免使S和R都同时为1，因为它会导致数字电路中不可预测的行为。因此为了保证电路的可靠运行，我们需要尽可能避开这种用法。</p>
<p><br></p>
<hr>
<h3 id="JK-触发器-JK-Flip-flop"><a href="#JK-触发器-JK-Flip-flop" class="headerlink" title="JK 触发器 (JK Flip-flop)"></a><strong>JK 触发器 (JK Flip-flop)</strong></h3><p>我们在数字电路中最讨厌的就是像刚才SR触发器中，任何可能导致电路发生“不可预测”的无效输出或者错误处理。<br>实际上，除了在电路中存在S与R都为1导致的无效输出之外，如果信号无法同时到达触发器，也会导致输出的不可预测性。为了解决这个问题，电路可以包含一个时钟脉冲输入，以提供同步输入的更好机会。<strong>JK触发器 (JK Flip-flip)</strong>，也叫JK锁存器，就是这样的一个例子。  </p>
<p>JK触发器是一种连续双状态单比特存储设备，是以它的发明者杰克·基尔命名的。<br>这个不重要，重要的是JK触发器有一个时钟输入引脚(Clock, CLK)，两个数据输入引脚(J和K)和两个输出引脚(Q和Q’)。如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa259e5b4f4f0cd30f9d02342b97c1b82?method=download&amp;shareKey=c369533d4b892af9c697199f4227abc4" alt=""></p>
<p>JK触发器可以画成左边的简略形式，它的展开形式如右图所示。  </p>
<p><br></p>
<p>在时钟周期的情况下，JK触发器可以在时钟的前缘触发，或者是后缘触发。将时钟周期想象成一个方波。前缘就是电平从0变成1的电平上升时刻，而后缘就是电平从1变成0的电平下降时刻。</p>
<p>要理解电路是如何运作的，我们需要先理解一个大前提。除非所有的输入都为1，否则与非门的输出为1。如果电路处于未设置状态，那么Q = 0， Q’ = 1。这种状态是稳定并且自洽的，就正如下面的参数所示：  </p>
<ol>
<li>时钟和J都输入为0</li>
<li>因此左上角的NAND门输出为1</li>
<li>右上角的NAND门会接受两个为1的值的输入。</li>
<li>Q = 0</li>
</ol>
<p>如果J的输入变成了1，时钟的输入也变成了1，那么就会发生下面这些事情：  </p>
<ol>
<li>左上角的NAND门就会接受两个为1的值的输入</li>
<li>所以它的输出为0</li>
<li>这就会导致右上角的NAND门以1的值输出Q</li>
<li>这样一来，右下角的NAND门就会接受两个为1的值的输入。 </li>
<li>所以Q’的输出为0</li>
</ol>
<p><br></p>
<hr>
<p>JK触发器的真值表如下： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>J</strong></th>
<th><strong>K</strong></th>
<th><strong>Clock</strong></th>
<th><strong>Q</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>↑</td>
<td>Q unchanged</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>↑</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>↑</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>↑</td>
<td>Q toggles</td>
</tr>
</tbody>
</table>
</div>
<p>由此可见，当J和K的输入均为1的时候，Q与Q’的值会发生变换。</p>
<p>J可以被称作为“集合输入”。当J被设置为1，并K被设置为0的时候，它会导致输出Q也被设置为1。<br>K可以被叫做“清除输入”。当K被设置为1，J被设置为0的时候，会导致Q被清除（设置为0）。  </p>
<p>JK与SR触发器不一样的是，每两个输入任意发生组合都会产生一个有效的输出，输入J和K的每一个组合都对Q和Q’产生明确定义的影响，而不像SR触发器一样，包含一个无效输出。这个特性导致JK触发器更加可靠，更有预测性，因为没有导致任何不确定因素或者未定义输出的情况出现。</p>
<p><br></p>
<hr>
<h2 id="布尔代数基础"><a href="#布尔代数基础" class="headerlink" title="布尔代数基础"></a><strong>布尔代数基础</strong></h2><p>本书的第四章讲过了如何使用逻辑命题来使用布尔运算符来组合成逻辑表达式。而布尔代数为编写简洁的逻辑表达式提供了方法，并提供了一种简化表达式的“公式”。  </p>
<p>当使用一种代数形式的时候，理解它的含义是十分重要的。举个简单的例子，1+1可以被解释成很多不同的情况： </p>
<p>1 + 1 = 2<br>1 + 1 = 10<br>1 + 1 = 0<br>1 + 1 = 1</p>
<p>一式表示的是十进制算术，二式表示二进制算术，三式表示位算术，而四式可以表示布尔代数。这是因为在布尔代数中，1表示为<code>TRUE</code>，0表示为<code>FALSE</code>，而<code>+</code>可以表示或。因此，第四个计算式可以以下面这种形式表示出来：  </p>
<p>                         <code>TRUE OR TRUE is TRUE</code></p>
<p>布尔代数的表示有它的专有符号。比如说<code>AND</code>可以表示为∧，<code>OR</code>可以表示为∨。或者，<code>A AND B</code>可以写成<code>A.B</code>或者<code>AB</code>。在本章中，我们会使用这种类似“点乘”的<code>AND</code>表示方法。<code>NOT</code>的具体方式是在字母上面加一个横线。比如说<code>NOT A</code>可以表示为<code>Ā</code>。  </p>
<p><br></p>
<hr>
<p>在建立了基本的表示法之后，我们就需要考虑我们的计算规则了。<br>下表中的内容可以被叫做“法则”或者“定义式”：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Identity / Law</th>
<th style="text-align:center">AND form</th>
<th style="text-align:center">OR form</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Identity</td>
<td style="text-align:center"><code>1.A = A</code></td>
<td style="text-align:center"><code>0 + A = A</code></td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center"><code>0.A = 0</code></td>
<td style="text-align:center"><code>1 + A = 1</code></td>
</tr>
<tr>
<td style="text-align:center">Idempotent</td>
<td style="text-align:center"><code>A.A = A</code></td>
<td style="text-align:center"><code>A + A = A</code></td>
</tr>
<tr>
<td style="text-align:center">Inverse</td>
<td style="text-align:center"><code>A.Ā = 0</code></td>
<td style="text-align:center"><code>A + Ā = 1</code></td>
</tr>
<tr>
<td style="text-align:center">Commutative</td>
<td style="text-align:center"><code>A.B = B.A</code></td>
<td style="text-align:center"><code>A + B = B + A</code></td>
</tr>
<tr>
<td style="text-align:center">Associative</td>
<td style="text-align:center"><code>(A.B).C = A.(B.C)</code></td>
<td style="text-align:center"><code>(A + B) + C = A + (B + C)</code></td>
</tr>
<tr>
<td style="text-align:center">Distributive</td>
<td style="text-align:center"><code>A + B.C = (A + B).(A + C)</code></td>
<td style="text-align:center"><code>A.(B + C) = A.B + A.C</code></td>
</tr>
<tr>
<td style="text-align:center">Absorption</td>
<td style="text-align:center"><code>A.(A + B) = A</code></td>
<td style="text-align:center"><code>A + A.B = A</code></td>
</tr>
<tr>
<td style="text-align:center">De Morgan’s</td>
<td style="text-align:center"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="13.617ex" height="2.523ex" role="img" focusable="false" viewBox="0 -1033 6018.7 1115"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(1194.7,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="1953.7" height="237" x="0" y="148" viewBox="488.4 148 1953.7 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(5.861,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(2231.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(3287.2,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="750" height="237" x="0" y="148" viewBox="187.5 148 750 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.25,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(4259.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mover" transform="translate(5259.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(0,615)"><svg width="759" height="237" x="0" y="148" viewBox="189.8 148 759 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.277,1)"></path></svg></g></g></g></g></svg></mjx-container></td>
<td style="text-align:center"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="13.617ex" height="2.523ex" role="img" focusable="false" viewBox="0 -1033 6018.7 1115"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="2731.4" height="237" x="0" y="148" viewBox="682.9 148 2731.4 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(8.194,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(3009.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(4065,0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(0,648)"><svg width="750" height="237" x="0" y="148" viewBox="187.5 148 750 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.25,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(4815,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mover" transform="translate(5259.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(0,615)"><svg width="759" height="237" x="0" y="148" viewBox="189.8 148 759 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(2.277,1)"></path></svg></g></g></g></g></svg></mjx-container></td>
</tr>
<tr>
<td style="text-align:center">Double Complement</td>
<td style="text-align:center"><code>̿A = A</code></td>
<td style="text-align:center"><code>̿A = A</code></td>
</tr>
</tbody>
</table>
</div>
<p><em>\</em>打表格太费劲了，下次直接截图算了*  </p>
<p><em>\</em>下文中出现的<code>Ā</code>或者<code>A'</code>都代表<code>NOT A</code>*</p>
<p>上面的表格展示了在布尔代数中的一系列恒等式。就拿德摩根定律举例子：德摩根定律允许我们交换<code>FALSE</code>和<code>TRUE</code>，或者交换<code>AND</code>和<code>OR</code>来将形式变换掉。  </p>
<p>比如说这里有一个表达式：<code>0.A = 0</code>，读作”FALSE AND A is FALSE”。根据德摩根定律，我们可以将<code>AND</code>换成<code>OR</code>,并将所有元素取反。这样就能得到另一个相等的形式：<code>1 + A = 1</code>。总结一下，德摩根定律的变化法则是：  </p>
<ol>
<li><strong>变换时交换<code>TRUE</code>和<code>FALSE</code>（0和1）</strong>  </li>
<li><strong>变换时交换<code>AND</code>和<code>OR</code>（<code>.</code>和<code>+</code>）</strong>  </li>
</ol>
<p><br></p>
<hr>
<p><span class="tag is-warning">Example</span></p>
<p>来做个例题。  </p>
<p>考虑一下这个表达式：<code>A + Ā.B</code>。我们如何化简它？  </p>
<p>有意思的是，要化简这个式子，我们首先需要将式子先变得更复杂。<br>表中提到了有这样一个公式：<code>A + A.B = A</code>。可以通过这一点把原式中的A换掉，就变成了这样：  </p>
<p>                <code>A + A.B + Ā.B</code>  </p>
<p>下一步我们暂时忽略<code>A</code>，然后对<code>A.B + Ā.B</code>使用交换律。步骤如下：  </p>
<p>                <code>A.B + Ā.B = B.A + B.Ā = B.(A + Ā)</code>  </p>
<p>                <code>B.(A + Ā) = B.1</code>    </p>
<p>这一步应用了公式<code>A + Ā = 1</code>。  </p>
<p>将结果带回原式，即可得到化简最终答案：<code>A + B.1</code>。  </p>
<p><br></p>
<hr>
<h2 id="布尔代数运用"><a href="#布尔代数运用" class="headerlink" title="布尔代数运用"></a><strong>布尔代数运用</strong></h2><h3 id="从真值表中创建布尔表达式"><a href="#从真值表中创建布尔表达式" class="headerlink" title="从真值表中创建布尔表达式"></a><strong>从真值表中创建布尔表达式</strong></h3><p>为特定问题创建布尔表达式，有时可以以真值表作为切入点。  </p>
<p>直接上例子把：  </p>
<p><br></p>
<hr>
<p><span class="tag is-warning">Example</span></p>
<p>我们来举一个两个输出的AND门的例子。真值表如下所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>我们即将使用的”Sum of product”的方法是为真值表中的每一行创建一个最小项，输出为1。然后再对这些最小和求和，得到最终的布尔表达式。  </p>
<p><strong>最小项 (Minterm)</strong>是输出为1的特定组合。<br>在这个真值表里，只有一个最小项，那就是当<code>A = 1</code>或者<code>B = 1</code>时。我们将这个最小项记为<code>A.B</code>。<br>因为这个真值表只有一个最小项，所以说这个真值表的最终布尔表达式就是<code>A.B</code>。  </p>
<p><br></p>
<p>但是如果不只有一个最小项怎么办？或者，表中不只有一个输出项怎么办？  </p>
<p>下面是一个半加法器的真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Input</th>
<th style="text-align:center">Input</th>
<th style="text-align:center">Output</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center"><strong>Sum</strong></td>
<td style="text-align:center"><strong>Carry</strong></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>首先，我们对”Sum”这一列输出创建最小项：  </p>
<ul>
<li>第二行 (<code>A = 0</code>, <code>B = 1</code>)，最小项是<code>Ā.B</code> (NOT A AND B)</li>
<li>第三行 (<code>A = 1</code>, <code>B = 0</code>)，最小项是<code>A.B'</code> (A AND NOT B)</li>
</ul>
<p>我们使用<code>OR</code>将所有的最小项连接在一起，这样的话就形成了Sum的布尔表达式：   </p>
<p>                <code>Sum = A'.B + A.B'</code>  </p>
<p>同理可得，<code>Carry = A.B</code>  </p>
<p>化简只能够将两列输出分别对应一个布尔表达式，所以最终的答案是：  </p>
<p><code>Sum = A'.B + A.B'</code><br><code>Carry = A.B</code> </p>
<p><br></p>
<hr>
<h3 id="逻辑电路的布尔代数式"><a href="#逻辑电路的布尔代数式" class="headerlink" title="逻辑电路的布尔代数式"></a><strong>逻辑电路的布尔代数式</strong></h3><p><span class="tag is-warning">Example</span></p>
<p>有时候我们需要通过一个逻辑电路来写出布尔代数式。那这个半加法器电路举例子：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB64571bca6b2aebf3bf9e4ad5d2645fcc?method=download&amp;shareKey=418cfa3d73daa608b02e026411a220d2" alt=""></p>
<p>我们跟着A和B两个输入项，来到了第一个NAND门。根据NAND的真值表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>NAND真值表的前三行都为1，所以我们需要为此构建三个最小项。结合起来如下：  </p>
<p><code>W = A'.B' + A'.B + A.B'</code></p>
<p>下一步，W的输出会去到三个NAND门里进行运算。我们这里以X门举例子。如果要画出X的真值表不是很容易，因此我们会考虑NAND门的本质计算方法，那就是先进行一个AND运算，然后将结果取反，也就是跟一个NOT运算。而AND的结果正式两个值的乘积。  </p>
<p>我们先来进行AND运算：  </p>
<p>                <code>A.(A'.B' + A'.B + A.B')</code>  </p>
<p>接着应用布尔分配式，也就是<code>A.(B + C) = A.B + A.C</code>：  </p>
<p>                <code>A.A'.B' + A.A'.B + A.A.B'</code></p>
<p><code>A.A'</code>的结果是0。在AND运算中，只要输入有0，那么输出必然为0。所以我们可以简化成：  </p>
<p>                <code>A.A.B'</code></p>
<p>因为<code>A.A = A</code>，所以最后化简出来的式子就是：  </p>
<p>                <code>A.B'</code></p>
<p>然而事情到这里还没有结束。因为我们只完成了NAND运算里的AND部分，接下来我们会执行NOT运算，也就是将上面的表达式求逆。根据德摩根定律 (元素取反，AND和OR交换)，我们可以得到原式的逆式：  </p>
<p>                <code>A' + B</code>  </p>
<p>到这一步就可以出X的结果了。同样的流程也可以适用于Y的结果：  </p>
<p>                <code>X = A' + B</code>  , <code>Y = A + B'</code>  </p>
<p>这两位合起来，就是S的输出。同样，我们需要先执行AND运算，再通过德摩根定律执行NOT运算：   </p>
<p>                <code>(A + B').(A' + B)</code> (AND执行后)</p>
<p>                <code>S = A'.B + A.B'</code> (NOT执行后)</p>
<p>C的结论，也可以通过这样的流程算出来了。  </p>
<p><br></p>
<hr>
<h2 id="卡诺图-Karnaugh-map"><a href="#卡诺图-Karnaugh-map" class="headerlink" title="卡诺图 (Karnaugh map)"></a><strong>卡诺图 (Karnaugh map)</strong></h2></div><div class="article-licensing box"><div class="licensing-title"><p>A2CS笔记</p><p><a href="http://naughtychas.github.io/2023/07/01/A2CS笔记/">http://naughtychas.github.io/2023/07/01/A2CS笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://NaughtyChas.github.io"><p>MXK</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-07-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-09-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/" target="_blank" rel="noreferrer">邈想日集</a><br></span><span>  2.<a class="is-size-6" href="/2022/08/24/Latex%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">LaTeX自学笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span><span>  5.<a class="is-size-6" href="/2023/06/10/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noreferrer">有关深度学习</a><br></span><span>  6.<a class="is-size-6" href="/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/" target="_blank" rel="noreferrer">浅谈今年CAIE的POE考试</a><br></span></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/06/10/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-item">有关深度学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'f4fef354d440d79d973c2bf25f8e464b',
            repo: 'Blog-Comment',
            owner: 'NaughtyChas',
            clientID: 'b602cb01d4c2668b35ae',
            clientSecret: '0a26ed5993551a9754281410ba3aa5f772dfbdf2',
            admin: ["NaughtyChas"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            proxy: 'https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1</span><span>写在前面</span></a></li><li><a class="is-flex is-mobile" href="#PART-THREE-进阶理论"><span class="mr-2">2</span><span>PART THREE: 进阶理论</span></a></li><li><a class="is-flex is-mobile" href="#第十六章：数据的表示"><span class="mr-2">3</span><span>第十六章：数据的表示</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数据类型"><span class="mr-2">3.1</span><span>数据类型</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#内置数据类型"><span class="mr-2">3.1.1</span><span>内置数据类型</span></a></li><li><a class="is-flex is-mobile" href="#用户定义的数据类型"><span class="mr-2">3.1.2</span><span>用户定义的数据类型</span></a></li><li><a class="is-flex is-mobile" href="#非复合数据类型"><span class="mr-2">3.1.3</span><span>非复合数据类型</span></a></li><li><a class="is-flex is-mobile" href="#枚举数据类型"><span class="mr-2">3.1.4</span><span>枚举数据类型</span></a></li><li><a class="is-flex is-mobile" href="#复合用户定义数据类型"><span class="mr-2">3.1.5</span><span>复合用户定义数据类型</span></a></li><li><a class="is-flex is-mobile" href="#指针数据类型"><span class="mr-2">3.1.6</span><span>指针数据类型</span></a></li><li><a class="is-flex is-mobile" href="#集合数据类型"><span class="mr-2">3.1.7</span><span>集合数据类型</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文件管理"><span class="mr-2">3.2</span><span>文件管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#串行文件"><span class="mr-2">3.2.1</span><span>串行文件</span></a></li><li><a class="is-flex is-mobile" href="#顺序文件"><span class="mr-2">3.2.2</span><span>顺序文件</span></a></li><li><a class="is-flex is-mobile" href="#直接访问文件"><span class="mr-2">3.2.3</span><span>直接访问文件</span></a></li><li><a class="is-flex is-mobile" href="#文件访问"><span class="mr-2">3.2.4</span><span>文件访问</span></a></li><li><a class="is-flex is-mobile" href="#文件类型的选择"><span class="mr-2">3.2.5</span><span>文件类型的选择</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#实数"><span class="mr-2">3.3</span><span>实数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#浮点-amp-定点表示法"><span class="mr-2">3.3.1</span><span>浮点&amp;定点表示法</span></a></li><li><a class="is-flex is-mobile" href="#精度与标准化"><span class="mr-2">3.3.2</span><span>精度与标准化</span></a></li><li><a class="is-flex is-mobile" href="#表示法的转换"><span class="mr-2">3.3.3</span><span>表示法的转换</span></a></li><li><a class="is-flex is-mobile" href="#使用浮点数的问题"><span class="mr-2">3.3.4</span><span>使用浮点数的问题</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第十七章：通讯及互联网技术"><span class="mr-2">4</span><span>第十七章：通讯及互联网技术</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#传输方式"><span class="mr-2">4.1</span><span>传输方式</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#电路交换"><span class="mr-2">4.1.1</span><span>电路交换</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#分组交换"><span class="mr-2">4.2</span><span>分组交换</span></a></li><li><a class="is-flex is-mobile" href="#传输协议"><span class="mr-2">4.3</span><span>传输协议</span></a></li><li><a class="is-flex is-mobile" href="#协议栈"><span class="mr-2">4.4</span><span>协议栈</span></a></li><li><a class="is-flex is-mobile" href="#TCP-IP-协议套件"><span class="mr-2">4.5</span><span>TCP/IP 协议套件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#TCP-传输控制协议"><span class="mr-2">4.5.1</span><span>TCP (传输控制协议)</span></a></li><li><a class="is-flex is-mobile" href="#IP-互联网协议"><span class="mr-2">4.5.2</span><span>IP (互联网协议)</span></a></li><li><a class="is-flex is-mobile" href="#路由器"><span class="mr-2">4.5.3</span><span>路由器</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#以太网-Ethernet-协议栈"><span class="mr-2">4.6</span><span>以太网(Ethernet)协议栈</span></a></li><li><a class="is-flex is-mobile" href="#—"><span class="mr-2">4.7</span><span>—-</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#MAC地址"><span class="mr-2">4.7.1</span><span>MAC地址</span></a></li><li><a class="is-flex is-mobile" href="#MAC地址-1"><span class="mr-2">4.7.2</span><span>MAC地址</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#—-1"><span class="mr-2">4.8</span><span>—-</span></a></li><li><a class="is-flex is-mobile" href="#与TCP-IP有关的应用层协议"><span class="mr-2">4.9</span><span>与TCP/IP有关的应用层协议</span></a></li><li><a class="is-flex is-mobile" href="#与TCP-IP有关的应用层协议-1"><span class="mr-2">4.10</span><span>与TCP/IP有关的应用层协议</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#HTTP-HyperText-Transfer-Protocol"><span class="mr-2">4.10.1</span><span>HTTP (HyperText Transfer Protocol)</span></a></li><li><a class="is-flex is-mobile" href="#HTTP-HyperText-Transfer-Protocol-1"><span class="mr-2">4.10.2</span><span>HTTP (HyperText Transfer Protocol)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#—-2"><span class="mr-2">4.11</span><span>—-</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#电子邮件协议"><span class="mr-2">4.11.1</span><span>电子邮件协议</span></a></li><li><a class="is-flex is-mobile" href="#电子邮件协议-1"><span class="mr-2">4.11.2</span><span>电子邮件协议</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#—-3"><span class="mr-2">4.12</span><span>—-</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#FTP-文件传输协议"><span class="mr-2">4.12.1</span><span>FTP (文件传输协议)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#P2P文件共享"><span class="mr-2">4.13</span><span>P2P文件共享</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十八章：硬件与虚拟机"><span class="mr-2">5</span><span>第十八章：硬件与虚拟机</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#控制单元"><span class="mr-2">5.1</span><span>控制单元</span></a></li><li><a class="is-flex is-mobile" href="#CISC和RISC处理器"><span class="mr-2">5.2</span><span>CISC和RISC处理器</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#流水线作业-Pipelining"><span class="mr-2">5.2.1</span><span>流水线作业 (Pipelining)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#基本计算机架构"><span class="mr-2">5.3</span><span>基本计算机架构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#单指令流单数据流-SISD"><span class="mr-2">5.3.1</span><span>单指令流单数据流 (SISD)</span></a></li><li><a class="is-flex is-mobile" href="#单指令流多数据流-SIMD"><span class="mr-2">5.3.2</span><span>单指令流多数据流 (SIMD)</span></a></li><li><a class="is-flex is-mobile" href="#多指令流单数据流-MISD"><span class="mr-2">5.3.3</span><span>多指令流单数据流 (MISD)</span></a></li><li><a class="is-flex is-mobile" href="#多指令流多数据流-MIMD"><span class="mr-2">5.3.4</span><span>多指令流多数据流 (MIMD)</span></a></li><li><a class="is-flex is-mobile" href="#大规模并行计算机系统"><span class="mr-2">5.3.5</span><span>大规模并行计算机系统</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#虚拟机"><span class="mr-2">5.4</span><span>虚拟机</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十九章：逻辑门与布尔代数"><span class="mr-2">6</span><span>第十九章：逻辑门与布尔代数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#逻辑电路"><span class="mr-2">6.1</span><span>逻辑电路</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#半加法器-The-half-adder"><span class="mr-2">6.1.1</span><span>半加法器 (The half adder)</span></a></li><li><a class="is-flex is-mobile" href="#全加法器-The-full-adder"><span class="mr-2">6.1.2</span><span>全加法器 (The full adder)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#时序电路"><span class="mr-2">6.2</span><span>时序电路</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#SR-触发器-SR-Flip-flop"><span class="mr-2">6.2.1</span><span>SR 触发器 (SR Flip-flop)</span></a></li><li><a class="is-flex is-mobile" href="#JK-触发器-JK-Flip-flop"><span class="mr-2">6.2.2</span><span>JK 触发器 (JK Flip-flop)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#布尔代数基础"><span class="mr-2">6.3</span><span>布尔代数基础</span></a></li><li><a class="is-flex is-mobile" href="#布尔代数运用"><span class="mr-2">6.4</span><span>布尔代数运用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#从真值表中创建布尔表达式"><span class="mr-2">6.4.1</span><span>从真值表中创建布尔表达式</span></a></li><li><a class="is-flex is-mobile" href="#逻辑电路的布尔代数式"><span class="mr-2">6.4.2</span><span>逻辑电路的布尔代数式</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#卡诺图-Karnaugh-map"><span class="mr-2">6.5</span><span>卡诺图 (Karnaugh map)</span></a></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a><p class="size-small"><span>&copy; 2023 MXK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noreferrer">Icarus</a> &amp; <a href="https://github.com/LittleYe233/hexo-theme-amazingremake" target="_blank" rel="noreferrer">Amazing-Remake</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022.8.11 17:07:12')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/LittleYe233/hexo-theme-amazingremake"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    enabled: true,
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { // 加载mathjax
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    autoload: {
                        color: [],
                        colorv2: ['color']
                    },
                    packages: {'[+]': ['noerrors']}
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                },
                loader: {
                    load: ['input/asciimath', '[tex]/noerrors']
                }
            };
            $.getScript('//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);});
            }
            if('undefined' === 'mathjax'){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>