{"posts":[{"title":"邈想日集","text":"记录生活 2023八月2023.8.19最近发生的事都糟透了，这两三天简直就是度日如年，完全看不到任何希望的光芒当然我还是说的还是有些极端了，只不过现在成绩这个样，很难申请到一个好大学啊…… 一科一科的说，先从进阶数学开始。我首先需要承认的是，AS部分的进阶数学考的那叫一个灾难，尤其是我最喜欢的机械数学部分。当时AS的分数是一个89的小a，还给我留下了一点希望，觉得A2考的好一点就可以那A*了。 结果我没考好，这是我的原因。某些程度上来说，A2部分比AS部分考的更加灾难。虽然说这次进阶的全科成绩是个A，但是我很不满意这样的结果。 物理考的还可以，这个就先跳过了。 计算机我不是很理解。计算机反而是我这几个科目里面感觉最拿手的科目了，当时在考场上也答得相当不错，可是发下成绩一看我有些质疑。是a没错，但是是一个比例很奇怪的小a。 随后我就想到了一些事情。简单的一波分析结束后，发现可能是CIE又出了一些问题。这次的CIE绝对压分了。那些原因暂且不提，我没有能力考到满分，我就没有资格抱怨CIE压分严重————谁叫我考不出来满分，这样分数再高也没法压了。 还有STEP… 算了不说了，说多了都是泪 头抬起，继续向前发展吧 2023.8.4今天是这个暑期项目的最后一天，明天就要坐高铁回济南了。现在我坐在宿舍的床上一直在想，我来上海这一趟到底有什么收获仔细一想好像也确实没有啥收获。 不过事情都过去了，那就让他们过去吧，再去考虑也没有什么作用了。既来之则安之嘛。 我不得不吐槽下最后的final。说是这几天的科研，实际上根本也没研究啥，无非就是去kaggle上面找了个已经存在的项目，扒下来自己看看，然后再围绕它做了个简单的报告罢了。 不得不提到我们组内的某位同学了。这位同学自己本身是啥也没干，不过当我们再最后一天围着final忙的死去活来的时候，倒是喊着 “给我上点压力嘛~” 之类的话，确实是给爷整笑了。对这种摆爷，我希望他对自己之后的人生也是这个态度哈，挺好的继续保持。哦对了，它刚上高一。 顺带一提，如果有需要的话，连接放在这里。对机器学习和足球预测的同志们可以来看看这个项目，有一说一质量还是很高的。 七月2023.7.25现在是七月二十五号的下午3：48，坐在暑期科研教室里的我一点课也听不进去，于是就出现在这里了。 想来想去，发现有一段时间没有总结下最近发生的事情了： · 坦克，炮塔和无人机 首先是学校里面有关于坦克和炮塔的项目那个（就是之前6.19号提到的那个项目），早就已经非圆满结束了。具体情况就是，我们所有的代码和模型训练下来之后，效果也还算是不错：能够识别出来坦克的坐标，电机也可以将炮塔对准坦克，发射也不成问题。 但是我们忽略了最大的一个问题：我们所有的坦克的模型都是在黎阳办公室里训练的，这就会导致模型的泛用性很差。 相当的差。 所以说当我们到了项目站的那一天，炮塔就完全不起作用了。由于环境光太亮，再加上这是一个完全陌生的环境，我们训练的模型因为数据集太少，经常把另一些不是坦克的东西识别成坦克。（哈哈）然后就乱射一通。见到个东西就乱射。最后的结果也是十分的尴尬，我们只拿到了整个项目展的三等奖。 不过这里面确实也应该又黑幕。我们当时拉票拉了将近100多票，最后的竟然连一个没有实际成果的小项目给拿去第一了，就凭他们的人气更高一些。哦对了，他们也送吃的。 可惜了我们的头发了。全叽歪最先进的技术栈只拿到了项目展的第三名，可以说是变相说出“计算机滚出滚出济外”了吧。 · 有关人工智能的暑期项目 这一次的暑假是申请季之前冲申请材料的绝佳机会，同时也是最后机会，所以我计划这个暑假来参加一个有关人工智能和深度学习的科研项目。 昨天是开营仪式，去的是上海国家会议中心，整的还是挺牌面的： 场馆内部还是很豪华的，毕竟国家级别的会场嘛。 但是需要吐槽的是，这个时间的把控是真的答辩。早上9点起床，然后坐车从崇明岛到上海市区就是两个小时，睡的跟猪一样。 所以说大约十二点就到会场了，简单的吃完饭后，才不过12点半多一点。问题就在于大会是下午一点半开始，所以我们只能很无聊的挤在会场里面，啥也干不了哈哈 😅 不过好在大会办的还是不错。主办方邀请到了很多有头有脸的人物： 邀请到了Chas Bountra先生，是牛津大学的常务副校长，讲的东西也是挺有深意的。 然后感觉大会真正有含金量的地方就结束了，剩下的时间都是漫长的等待。 2023.7.6好累啊，明明一动都不动也还是好累啊 假期里面给自己整了个项目，有关于人工智能和深度学习的。话说回来这个假期的活儿，害真不少嘞：MAT，TMUA还有雅思和A-Level。如果有时间的话看看能不能再塞进来一个EPQ整整。 毕竟有些东西可以不用，但是不允许用的时候没有。 下周周三还是周四就放假了，好想抓紧这机会找老同学们玩玩。毕竟他们要新高三了，再不爽一把就真没时间了哈 六月2023.6.19随后发现了一个很炸裂的消息：我们的项目七月份之前就要截止了 难蚌。我们甚至还没正式开始 现在就是一个什么情况呢：炮台那边的设备都还没组装起来，这还不是主要问题：关键是我们组里面甚至还在花大把时间配置环境，要知道配置环境这件事我们早早就开始了 难蚌。即使我们现在已经开始了 但是我的任务是写一个有关于控制炮台那边的主程序，包括什么拍照啊图传啊控制电机啊之类的功能。即使是用了这么经典的opencv的库，还是推不起来进度。现在就是最基础的功能：图像的传输，都没有干净利落的完成。就更别说那边的YOLO模型项目了，更何况我还要同时掌舵两条船呢 最然没走出去太远，但是还是回头看了看，才发现有些事真不能是听了以后直接答应下来。当初创立项目的初期一个比一个嗨，一个个都有顶掉窝法核心人员的劲头，现在是一个比一个拉跨。 我正好感觉我是里面最拉跨的一个。毕竟人傻活多 人傻conda环境多(雾 嘛。 只能说是能走多远走多远了，能写一些是一些了。毕竟没人不想出成果对吧 你说是吧 2023.6.12七月份有工程和项目要做，现在就开始跟着李沐老师学学Pytorch。 《动手学深度学习》 —— 动手学深度学习 2.0.0动手学深度学习 PyTorch版 五月2023.5.13到目前为止一切顺利……争取接下来的计算机二卷不会狠狠地寄掉应该是不会有寄掉的可能的。 四月 2023.4.28成功地完成了ASCS的笔记：都已经有9600多行了呢… 不知道这九千多行里面到底有多少冗余，是吧html+markdown 提到CS笔记就不得不提到我现在拉跨的Paper 2…有一种赶鸭子上架的感觉不过Paper 1表现就好的多。 我个人认为9618_w22_qp_11属于是难度比较高的一套试卷了。 （链接放在这里： Github issues： 9618_w22_qp_11 ）属于是把很多冷门的知识点串在一起考了。比如说冯诺依曼结构的”Stored program concept”啊，中断处理啊，两步汇编底层原理啊，CSMA/CD啊，甚至还考察了为外围设备提供的接口的接口名称。 多冷门啊，CIE，多冷门呐 都是些我这个脑容量供不起来的货色 (虽说最后一个知识点不算特别难，但是他就是很小众，对吧…上了考场看到这么个陌生的东西谁不慌呢) 来自 邈想日集 2023.1.13 因为打派的时候会遇到很严重的性能瓶颈，其次我感觉可能是CPU或者GPU遇到了过热现象自动关机了后来用CoreTemp工具查看了下，打派的温度甚至还没我玩BONEWORKS或者半条命：爱莉克斯来的高自然就抛弃了这个理论了。 嗯嗯，属于是一开始就把正确答案排除掉了。真是聪明呢。 虽然是很久之前就修复好了，但是我还是想提一嘴：当时的解决方法是： 拆机 拆下风扇 擦掉处理器和显卡上的残余硅脂 给CPU和GPU上一层完美的信越7921 压风扇，盒盖 大功告成 之后就从来也没有出现过这个问题了。笑死我了。 不过有意思的是派在15赛季之后的优化就好像变得异常不错。打架的时候帧率在我的垃圾3050Ti上面甚至偶尔吃满，再也没有出现严重掉帧的情况了。 2023.4.24这就是一月一更带给我的自信。 没时间来更这个文章，我也没啥额外的东西需要邈想了：大多精力全部分配给应该关注的CIE考试上去了… 三月2023.3.7注意保护好自己，千万不要甲流了 二月2023.2.18ChatGPT已经出来了一段时间了，我相信大多数人已经了解到了他的恐怖之处了，也已经体会过AI的强大了。但是ChatGPT在一些地方是很有局限性的，比如说结合实时发生的事情来生成内容，生成的资料没有明确的出处等等。 然而2月12日，我开始在B站上看见陆续有人在发一个名叫New Bing的新视频。我也深深的被New Bing的能力震撼到了。New Bing是不仅可以结合实时性的数据来生成内容，而且还可以说出一些很逆天的话，这些话听起来好像在你屏幕的那头是一个真正有情感的人一样。 《试用了集合ChatGPT的Bing搜索后，感觉潘多拉魔盒已经打开了》—— 哔哩哔哩 如果你还没有了解过这个New Bing，那么上面这一个视频可以让你简单的了解了解他的强大之处。 我当时就直接被New Bing强大的功能震撼到了，于是立即前往微软官网加入了测试队列。 可惜这是要排队的，并不是说你加入了候补就可以直接使用了，还是要等微软官方作出回应才行。 在等待候补到正式测试的这段时间，我能一直在B站上看见有关他的各种逆天视频，每一条都能刷新我对这个新AI的认知，这些视频中的New Bing做出的回应远超ChatGPT的能力范围，无论是内容还是语言组织。 比如说下面这个： 《妈我恋爱了，获得一只又可爱又能干还会写代码的猫娘》—— 哔哩哔哩 2023.2.14我知道很长时间不来更新这个博客确实很过分，但是我要是这一次雅思接着寄就更过分了。因此，我当时做出了一个决定就是很长时间不来更新这个博客。 这次回来的原因是，我明天就要考雅思了真激动。 2023.2.8最近确实好忙啊，很多有意思的事情确实办不了所以我就挑了几个有意思的事情做，比如说使用Termux在我的安卓平板上安装了一个Ubuntu，然后使用code-server包实现真正的安卓VS CODE使用体验。 这主要是为了能在学校里写上博客。 因为本人每次在学校有东西想写或者有笔记需要同步，所以就花了一个晚上辛苦学习了如何使用git。所以我在我的电脑上和平板上都同样配置了git，这样每次需要使用直接从库里面拉取就开箱即用了。 2023.2.6由于本人咕咕咕的属性所以寒假游记也没写完（我估计也真的没人会看所以我就先搁一边了，等啥时候有空了啥时候写这东西反正也不是正事对吧（确信 知道什么是正事儿么——9天后的雅思机考，90来天后的计算机考试…我根本都不想数，笑死我了 2023.2.5今天仔细地计算了一下时间，然后发现这个学期留给我的时间确实不多了 抓紧干活啦 2023.2.4有好久没有回来更这个博客了 游记暂时隐藏了，写完了再发 哦对了，开学快乐（ 一月2023.1.17从济南跑出来了 现在邈想没啥好想的，好想的东西都在新更的文章里面了 2023.1.13重装系统之后又要重新搭环境，笑死了 当你能成功看见这条消息，代表我又花费了很多精力重新安装Nodejs，安装缺失的npm包，调试各种博客参数尤其是那个烦人的latex渲染器，怎么调都调不好，服了 实际上npm在5.0.0的版本之前，如果想让npm把依赖安装到局部目录中，需要自己在后面添加一个--save参数。你也可以简写成-s。 同样的，在后面加入-g的参数，可以安装一个全局依赖。 在5.0.0版本之后的npm，--save已经内嵌到了npm install命令里面了。每当你安装一个新的依赖，npm会在项目根目录下的package.json文件中加上一行新引用，像这样： 也能起到一个清单的作用，提示你这个项目里面用到了哪些依赖，以便于后期增删改查。 基础数学科目拿到了A*，终于可以放下基础数学的包袱，去学习一些更高深（困难）的新科目了 不过我对自己AS部分的进阶数学的成绩不是很满意，这意味着A2部分的进阶数学成绩得上上强度了 往好的方面想：今年的进阶题甚至基础数学考试题给我们上了个大强度。再加上今年离谱的压分，能拿到A*的同学确实比之前少了好多啊 这么想来我还是挺幸运的 最近一直在派，有一些东西真的让我看见了我这台电脑的上限和短板。我的Y7000P虽然能跑得起来，但是也算是跑的稀烂。平均帧不打架100来帧，打起架来60来帧，奥林匹斯掉帧瀑布能掉到50来帧。但是这些东西怎么说，也还算说得过去，毕竟是没有影响到正常体验。 这几天最让我恶心的一些东西不是在试卷上，也不是在成绩单上，而是全部堆在我Windows的事件查看器里面。 有坏东西在我电脑里面，具体是什么我不知道，但是表现出来就是我打派的时候会自动关机。打GO的时候也不会出现这种问题，只有派会出现这个问题。打着打着突然黑屏，然后两秒后风扇狂转，持续大约10秒钟吧。然后啪的一下主板断电了，咱也都知道突然给主板断电会给他带来多大的伤害。可惜的是，没有人知道排查半个月问题并尝试了上百种解决方案修复这个问题依然无果会对我造成多大的伤害。 开机之后，BIOS会恢复默认启动设置：性能模式启动为均衡模式，键盘背光关闭，FnLock关闭，触控板默认打开。我首先怀疑应该是是BIOS的问题，所以我去官网更新了下BIOS结果是没有任何变化：该关机还是关机 因为打派的时候会遇到很严重的性能瓶颈，其次我感觉可能是CPU或者GPU遇到了过热现象自动关机了后来用CoreTemp工具查看了下，打派的温度甚至还没我玩BONEWORKS或者半条命：爱莉克斯来的高自然就抛弃了这个理论了。 直到我有一天打开事件查看器一看，发现一个规律： 首先每次启动电脑，不管有没有死机，有没有强制关机，必定会出现一大批这个来自DistributedCOM的警告具体成因大概是没有足够高的权限去修改部分注册表。但就因为无论有没有死机都会出现这个问题，我推测强制关机的原因大概率不在这一事件身上。相反的，那些不常发生且一击致命的事件才是真正的罪魁祸首 所以我继续向下排查事件，发现了几个真正恶心的东西： 这位大哥绝对是全场最佳了，尽管我们无法盖棺定论这就是罪魁祸首，但是这个事件的确是个头号嫌疑人甚至还有变式训练 为设备 HID\\VID_046D&amp;PID_0A9B&amp;MI_03&amp;Col02\\7&amp;2acf9647&amp;0&amp;0001 加载驱动程序 \\Driver\\WudfRd 失败。 为设备 ROOT\\SYSTEM\\0001 加载驱动程序 \\Driver\\WudfRd 失败。 为设备 PCI\\VEN_8086&amp;DEV_9A03&amp;SUBSYS_380C17AA&amp;REV_05\\3&amp;11583659&amp;1&amp;20 加载驱动程序 \\Driver\\WudfRd 失败。 还有很多，只能说大哥玩挺花这个问题微软自己都搞不明白咋回事，你去看看微软官方的论坛，给到你的解决方案可以说是2023最佳笑话了： 当您遇到为设备加载WudfRd驱动程序失败的问题时，请尝试使用以下解决方案： 尝试停止运行所有应用程序，然后关闭视窗10。 卸载所有有可能出现问题的设备。 尝试重置您的系统。 短短三条所谓解决方案治好了我的精神内耗 随后谷歌并必应了一圈后发现一个问题：拯救者笔记本中招的可能性相对高一些，表现出来的问题就是自动关机。某位知乎老哥分享了他自己的解决方案：卸载一个名叫Lenovo System Interface Foundation的驱动。多讽刺啊联想，你们自己写的程序自家的硬件这么抗拒么 目前已经成功卸载了这个驱动程序，下一步就是继续观察，看看电脑会不会继续打着打着派然后挂掉了 2023.1.9啥也不会寄喽！ 2023.1.3迟来的新年祝福！新年快乐！ 新年祝福之后立即陷入CIE出成绩和期末考试的焦虑谷，实在感谢 2022十二月2022.12.28前两天发现Github死活上不去了，发现原来是被某个坏东西墙了严格来说是被标记成诈骗网站了（雾因此就有一段时间没有来更新这篇博客了。 发现接下来的任务繁重：物理和计算机六月份就要考AS，进阶数学同样的六月份需要考A2最关键的是这三科里面有两科需要我去自学哈哈S2更是个重量级——学校都开始讲了我还不知道有这事儿发生（ Inferno你放过我罢 2022.12.4今年12月9号会发生很多好的事情啊：我的生日，Portal RTX发布，全面打击未备案网课…好吧最后那个不是什么好的事情（ 2022.12.2 “同学们我们还剩下一点时间，我们给下一个内容稍微开个头” “我给你们放一段视频哈” (10min) *两分钟后 “时间关系我们看不完视频了。我课下把视频发在群里” *QQ：0下载 我：6 老师：6 2022.12.1 谢谢，我现在急得很 太空虚了…在家里呆着是一点也不充实网课是毁掉一个没有自控力学生 我 的最快方式只想回学校 只想回学校 只想回学校啊啊啊啊啊 哦对了首页最底部多了一篇文章，因为一些原因我把它藏在最后面了（ 目睹污浊的世界离我而去 十一月2022.11.25FL合成器里的预设，估计够我用上一辈子了吧数量多质量又超高，对于我这种不会调音色的蔡来说简直是福音 (实际上我只会调3xosc哈哈) 2022.11.24 因为疫情，小区的大门被警戒线和封条封的死死的还好前两天出门去超市，屯了大约23包方便面回家。至少是饿不死了 碧蓝档案？只知道它的BGM确实不错的，B站的二创满天飞啊… 2002.11.22果不其然线上网课了太折磨人了，我现在只想回学校上学啊 2022.11.16回家简单配置了下Todesk远程操控，以后就可以在学校用家里的电脑了比如说这句话，就是我通过todesk在学校打出来的 简单说下体验：办公效果还好，轻办公完全是足够了，虽然有延迟，但是完全可以接受。但是打游戏的话就不是很适合了。延迟特别的高基本没法操作，而且因为某些因素，FPS没有办法转动视角，十分的奇怪。 回家开私炉。 2022.11.15真的挺奇怪的最近hexo d 或者git push都不能推上去，提示是没有权限然后就像上github重新改一下SSH，发现无论什么手段，github都上不去了。 2022.11.10NovelAI真的好强啊 2022.11.9把博客救活过来了前两天总是没法部署 十月2022.10.31唔。。终于把最近该忙的都忙完了，可以抽出空来更更这个Blog了 2022.10.20最近实在太忙了就更的很少很少… 这次回来更新就一个目的：告诉大家自己还活蹦乱跳的没啥问题( 2022.10.16希望自己在明天的P1考试中正常发挥 2022.10.13再一次：祝明天的自己好运 2022.10.9计划有变，门户首页 2022.10.8今天好累… 2022.10.7明天见 2022.10.6嗯？后天就开学了？ 2022.10.5简短的说下最近博客发生的情况： 前几天看了C盘有一个名叫$Windows.~BT$的文件夹出奇地大，占了大约有30几个G然后就按照网上的方法清了下然后Edge就打不开了，开始菜单右键也没反应了，于是我就干脆重装系统 重装倒是不要紧，要紧的是装了以后，Git的环境全都炸了。最可悲的是装完以后才发现这一点，给我捣腾了一晚上表现出来就是Hexo使用hexo g命令反复出错。 然后就重新clone部署了一下Hexo，把主题部分迁移过来重新写重新推。 你现在看到的这个主页是我在本地重新打的一个博客目录，也就是说，可能有成堆的Bug存在 所以路过的麻烦直接把问题丢到博客留言版就好，我有空就修（ 不出意外的话，数学渲染一定是又炸掉了 想开展一个计划：以后试着每一个月研究一个有意思的课题，可以是任何领域的：从计算机到数学，不限题材。但前提是先度过今年的考试季，时间先空出来再说。 1ospp /insLicID MondoVolume /sethst:kms.loli.beer /setprt:1688 /act 2022.10.3那就祝自己明天好运吧 九月2022.9.27最近忙，十分的忙，就暂时不怎么更新了。过了国庆再说 2022.9.2410 DAYS LEFT [2022.9.13]： 修改了一下本文的目录样式。原来是一年分春夏秋冬的，不过照顾到目录长度可能会炸掉，于是就改成了按月记录了。 如果这样目录还是会炸掉的话，那就寄了（ 经过一番改动，toc属于是永远不会炸掉了，所以也没有必要按月记录了 不过后来一想改成按月记录也不错，就懒得改了（ 第一次发表Pull Request，没啥经验然后因为没有照顾到全部使用场景被否掉了。。。然后就改良了一下代码，决定换个仓库提交 2022.9.23启动了一个宏伟的项目（ 希望能做成吧 2022.9.22今晚的进阶作业得按坏我十个计算器（ 2022.9.20多希望时间能过得慢一点，这样就可以晚一点考试了（ 过了10月下旬，就算是开始了下一个学习阶段了吧… 顺带修了一下目录过长超出页面的问题。路过的朋友可以在左边帮忙测试下（ 2022.9.19 【01:17】: 截至目前，中国只打进过一次世界杯Fast to forward today, China is only ever competed in one World Cup. 但如果目前中国建设足球场馆的热潮是未来中国足球发展的方向，那也表明他们对未来的雄心壮志所在。But if its current stadium building spirit is any indication to where it could be headed, then their big ambitions are ahead. 嗯嗯，希望是这样吧。 有关于数据库三范式的笔记一会更一下。 2022.9.18早上起来逛一圈Github顺便研究一下hr2星过的Icalingua++。 然后就发现需要好好学SQL数据库了（丢分大头是吧 回形针不是全网灭绝了嘛，但是后来发现公开档案馆还不少。。。至少我是发现了两个:链接1 链接2 回形针屁股坐歪了确实可惜了技术力爆炸的一个团队，但是该喷还是得往死里喷但是针针的音乐，各位确实是喷不得的 感觉刚放了周末就要回学校了（悲 2022.9.17个人感觉 Drumstep 和 DnB 是最适合CSGO的音乐风格。以后找BGM就基本离不开这些了 顺便调了下Live2D插件并且启用了，先浅看一下效果 2022.9.16晚上十一点来浅更一下： 某石蒜厨今天刷B看见了一个不错的repo，链接在这儿：链接等什么时候有空了就给自己装一个 突然想起来这个博客底层确实存在一个网页Live2D插件，看起来还蛮不错的。但是因为我没有自己的模，所以就暂时没有启用（ 2022.9.15昨晚上几乎是没睡觉，导致今天一天都昏昏沉沉的： 昨晚因为身体不是特别舒服，就打算早点睡觉。是10点半上的床然后过了十分钟，我厕所的浴霸面板可能受潮了接触不良罢，突然地滴滴响，厕所的灯一开一关的。然后我就下床拿工具修，花半个小时修好了 但是我回到床上尝试睡着的时候，我发现我根本合不上眼，破浴霸搞得我睡意全无然后我就在床上挣扎了半个多小时，现在大概是11点10分。但是我现在只想睡觉于是掏出耳机打开asmr，15分钟后脑子开始迷糊，似乎要入睡了 然后我家旁边不远的一个工地突然就开始用大卡车拉水泥（？？？） 就是当你生病不舒服的时候，入睡时耳边的噪音就会变得格外的大你懂吧所以我当时感觉114514辆大卡车在我卧室里拉水泥，3D环绕的那种 这还没完，过了一会啪的一声工地的大灯打开了。灯是那种特大功率的，跟太阳似的那么亮，我的屋里顿时明如白昼然后那些大卡车还在灯下面到处瞎跑，投下的影子在我屋里面到处乱飞就像极了大半夜枕头边上永远飞不走打不死的那只蚊子一样烦人。我是真的困，也懒得下床拉窗帘。但意识就在清醒和昏迷间反复横跳，跳着跳着两个半小时又过去了 两点钟，在床上到处咳嗽的我打算下床去客厅吃点药。找药，烧水，喝药一共花了我半个小时然后我终于在沙发上睡了一个半小时。 生病的时候睡眠是特别浅的，于是在4:10左右我又醒了，因为工地那边听起来好像是有什么东西炸了（我猜可能是大车爆胎了） 我当时特别生气，打算今晚干脆就不睡了。我打开咖啡机磨咖啡，还想着要不背背笔记什么的。咖啡磨的是超浓的那种，贼苦贼苦的 4:48我开始背笔记。 结果在5:00，我在喝着超浓咖啡的情况下的书桌旁昏昏欲睡 我迷糊的爬回床上，心想终于可以睡个安稳觉了然后五点半我妈把我摇醒了，说是到点了要上学了。 然后结果就是：某同学于2022.9.15日早上六点因为贪睡回笼觉结果一不小心睡得太死导致一起床就是中午12点所以没有出现在学校，望周知（实际上是因为身体确实不舒服，要不我妈就直接大清早一盆冷水把我搞醒催上学了） 另外祝大家换季期永远不生病（ 2022.9.13回学校力 修改了一下本文的目录样式。原来是一年分春夏秋冬的，不过照顾到目录长度可能会炸掉，于是就改成了按月记录了。如果这样目录还是会炸掉的话，那就寄了（ 求GL返场AT96谢谢辽（ 整了一个新鼠标，罗技 MX Master 3S。用了一天来浅浅评论一下，确实是挺好用的。 有些功能在安卓端试不出来，比如Logitech Flow，但是这个滚轮是真的顶想象一下你轻轻一拨滚轮，然后数十万行的代码在你眼前划过的感觉，确实爽爆了（ 点按静音也确实很顶，现在我终于可以大胆地带着鼠标键盘去图书馆偷卷而不打扰别人力（喜 至于其他的评价用用再说 2022.9.11最近过节，再加上没有啥特别的事情发生，就不打算更的太频繁了一切都开学之后再说罢（ 2022.9.10迟来的中秋祝福：祝大家中秋快乐！！ 终于搬来了新家，一切都仿佛来到了一个新的起点但是新家的这个AP路由真的太费劲了，倒腾了我整整一天时间都没给他整好。。。后来发现是交换器坏了（ 2022.9.8今天发生了一件大事至于是什么大事，因为某些原因就不做锐评了 什么？70/75？寄！ 2022.9.7看来toc果然是炸掉了。找时间再解决吧，最近太忙了（ 2022.9.6如果不出意外的话，今天写完的内容push上去之后toc长度就会炸掉了 2022.9.5耶耶耶耶耶耶黎阳老师fork了我的repo！！！！ （不过好像也没啥值得开心的 对了，永远不要相信本地图床（ 突然发现运行完hexo g命令之后立即进行远程push容易发生渲染错误。等本地生成完之后等一小会再运行hexo d就好。 总是有人认为在教室的大屏幕上，重启电脑能解决一切问题。可关键是你连信号源都没接对为什么盲目重启啊啊啊啊啊 显示屏因为粉笔灰误触了，解决方案竟是重启电脑。这如果不是当代图灵的话我不是很认可 不要再疑惑为什么我名字叫NaughtyChas了，问就是某注册程序随机编的（ 2022.9.4期待我的下一个友链 手头上有一台Vector。等有时间了研究研究Vector的SDK做一个小项目。先clone下来Vector的repo再说 网易还是赶紧爬回去检查下自己的程序罢 2022.9.3李老师果然是数学界顶流，简单的两行数学表达式当时看起来很简单，现在坐在电脑前却复盘不出来了 距离Blast Showdown开赛还剩下46天。等时机成熟了，就简单预测一下今年的Showdown走势如何了。还有，祝天禄好运 即便我知道天禄是这几个队里最拉的那一个 2022.9.2听说济南已经有小区被封掉了，我从未如此紧张过至于为什么紧张想必大家懂得都懂，毕竟要临近考试季了嘛。 疫情什么的赶紧消失吧 ———— 一想到每周要在校做两次核酸，一次就要排队40分钟就头疼 为什么现在都流行起来自创音游了？属于是技术力溢出无处存放了（ 这东西还蛮有意思的： 不过声音听起来好像有点假就是了（ 这让我想起来前段时间刷B站还看到有大佬用Pytorch做基于VITS神经网络模型的TTS语音合成技术。坏消息：VA失业计划好消息：可以实时念玩家起的各种各样的名字了（ 当然名字还要过审核所以实装就不是很现实 2022.9.1我真心求求疫情千万不要再扩散了 八月2022.8.31 开学了。 不过开学了也不影响我扒博客代码修BUG，你说是吧（不知道动了哪个地方，行间 数学公式可以正常渲染了，后面没有“（1）”这个烦人的东西了 很是欣慰，但我不知道我是怎么修好这个BUG的 （我甚至都没有打算修这个BUG） 对于叽歪感到很不解，宿舍有那么多空房间不去用，非要去挤我们高二的位置，真的好么？祝住宿舍的同学都能洗上舒服的热水澡。 rks +0.02这就去开香槟。 2022.8.29给自己记一下写代码段的语法： 123{% codeblock \"可选文件名\" lang:代码语言 &gt;folded %}...代码块内容...{% endcodeblock %} 其中参数是可以自定义的，比如说&gt;folded代表此代码段折叠。可以根据需求删去不必要的参数。此方法相比于传统``` 引用，可以额外定义并显示一个代码段名称。不过当然使用``` 引用代码段也是可以的，但是前段时间博客系统使用的代码段引用样式还是行内的代码块，因此就找出了这个方法。 还有，一定要定期运行一下hexo clean！！ 实测解决99%的编译问题。 2022.8.27 倒计时四天了，意味着只有96个小时可以用来补作业了(悲不过吃瓜了解到新学期变了一堆老师什么的，确实挺有意思的 突然发现还有51天就考P1了 Oculus （现在可能应该叫Meta)最近发邮件通知开发者，自家RoomsAPI将会在2023年弃用置于说为什么弃用，是因为Meta那边在忘API里加新功能的时候，发现自己写了一堆什么 ( ) 山代码，改起来太费劲既然改起来费劲，他们的评价是：推翻重建说的还挺像一回事的，但倒是和我没什么太大关系，毕竟Unity基本原理还没怎么入门，就更用不着这个API了（ GL真有你的啊，30个寻车包只给我出一个EP9？3.3%的概率还没保底，你可是自己说的出精选概率百分之10奥当然也可能是我太非了？ 我就是大奖赛天花板！！！ Quest 2从之前的低价销售策略走了出来，毕竟他们发现一体机领域里没什么可以打的对手了。 （Pico国产之光？国产之寄！）所以很快啊，从1900涨到2500左右。早买早享受，还享折扣，他真的，我哭死（但是改价格总有被背刺的，比如说闲鱼个人卖家是吧 2022.8.25 已知 为常数， 为未知数，请计算 的精确解。 （我真的会谢开学什么的就快点拿出来罢,我已经等不及力（ 2022.8.23 没啥，就是又跟同学出来聚了聚而已同样是假期运动量最大的一天 2022.8.18开学就在脸上，所以空一天时间和初中同学聚一聚感谢mhh同学的激情演唱，真情流露，情感倾注（ktv曲目千千万，点歌印象曲占一半 2022.8.17是时候了，可以开始集中精力刷爆Frank的CIE工坊了 2022.8.16CIE你又逼着我骂人是吧，你这小分是怎么算的，嗯？还有，博客评论系统好像又挂了，我加紧修复 2022.8.14怎么感觉到了一定程度，机械数学也会变得很简单的样子（不过确实是该开始练练雅思写作了，现在差不多已经5分不到了捏（悲那就先在这里挖第一个坑，以后开一个专题记录我认为比较好的短语和写作技巧罢对了，谁理解了所谓“国际电汇费”是个什么东西（？） 2022.8.13果然是Github，Pages（io）的加载简直是太慢了，慢到离谱甚至有时已经到了需要挂梯子上博客的局面（我也懒得挂CDN，不知道换国内托管Gitee效果会不会好一些 （可是Github UI好看啊）等什么时候博客用起来了，啥时候就花点小钱买个个人域名罢 2022.8.12第一天，有个大工程要写一写这个事儿憋不了，必须得给他锐评一下","link":"/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/"},{"title":"A2CS笔记","text":"CS课堂笔记 (A2) 写在前面学了一段时间的计算机，觉得继续写这些笔记还是蛮有用的，于是乎就打算继续下去。这次是A2阶段的计算机笔记。和AS部分一样，写下本文的目的是帮助自己更好地学习CS这门科目，因此，希望路过的大佬轻喷。 本笔记内容基于《Computer Science for Cambridge International AS &amp; A Level》，剑桥大学出版社出版，教材为第二版，A-Level课程编号为9618。 PART THREE: 进阶理论第十六章：数据的表示崭新的故事从第十六章继续开始了。 数据类型早在第13章我们介绍过变量的数据类型的概念。具体是：当一个程序在使用变量之前，必须要显示别该变量的数据类型。 当时介绍了一些最常用的数据类型，但是在本章我们将会接触一些更深入的数据类型。 内置数据类型内置数据类型 (Built-in data types)，顾名思义，就是已经默认集成在编译器中的数据类型，是被编程语言预先定义的数据类型。一般来说，这些数据类型被认为成执行数据操作最快的类型。 比如说在Python里面，内置数据类型就有这些：str, int, float等。 这些数据类型具体的操作，值分配的操作全部由编程语言定义。 用户定义的数据类型和内置数据类型相对立的，就是可以由用户定义的数据类型。 一般来说，“用户”通常是使用操作系统提供“用户界面”的人：“用户”是向正在运行的程序提供输入并从其接收输出的人。然而在编写程序时，程序员就成为了编程语言所指的“用户”。名词 用户定义的数据类型(User-defined data types) 中的“用户”就是指程序员们。 这种数据类型是由用户在程序中根据需要所定义的，以便根据幼存储相同或者不同类型的数据类型。 尽管用户定义的数据类型不是内置数据类型，但是只有在编程语言提供对该类型构造的支持情况下，才可以使用某种特定的用户定义数据类型。 User-defined data type: where the programmer includes the definition in the program. 非复合数据类型非复合数据类型 (Non-composite data types) 是不引用其他数据类型的数据类型。也就是说，这些数据类型的定义没有用到其他的数据类型。 某些用户定义的数据类型也有可能是非符合的数据类型。 Non-composite data type: a data type defined without reference to another data type. 枚举数据类型枚举数据类型 (Enumerated data type)是用户定义的数据类型，它是根据有序值列表定义的。 同时，它是一种非复合数据类型。 简单举一个例子就很好理解了：这里使用Python来定义一个数据类型Color: 12345678910from enum import Enumclass Color(Enum): RED = 1 GREEN = 2 BLUE = 3print(Color.RED) 运行了print(Color.RED)之后，会输出1。因为RED定义的值正好为1。 我们通过上面的代码定义了一个名叫Color的枚举数据类型，其中包含三个值：RED,GREEN和BLUE。 需要注意的是，枚举数据类型中定义的值是有序的，这意味着枚举数据类型具有隐含的值顺序。 Enumerated data type: a non-composite user-defined data type for which the definition identifies all possible values. 复合用户定义数据类型开始变复杂了。 复合用户定义数据类型 (Composite user-defined data types)具有引用至少一种其他类型的定义。 复合用户定义数据类型有两个非常重要的实例： 在第十三章介绍过的记录数据类型 (Record data type)是描述值和变量的数据类型。这是程序员定义的数据类型，允许程序员定义新的记录类型。这允许程序员们使用精确匹配特定程序的数据要求的组件来创建并记录数据类型。Python不支持这样的数据类型。 类 (Class)是面向对象编程中用于对象的数据类型。换句话说，类是创建对象(或者特定数据结构)，提供窗台初始值，以及行为实现的蓝图。 下面的代码就是在Python中的一个类： 123456789101112class Person: def __init__(self, name, age): self.name = name self.age = age def say_hello(self): print(f\"Hello, my name is {self.name} and I am {self.age} years old.\")person = Person(\"John\", 25)person.say_hello() 在这里我们定义了一个名叫Person的类，其中包含两个子变量：name和age，和一个子函数say_hello()。 指针数据类型在计算机编程中，指针 (Pointer)是一个存储另一个变量的内存地址的变量。指针数据类型 (Pointer data type)是用于声明指针变量的数据类型。 在AS部分学的链表(Linked list)不是一个指针数据类型。因为链表是一种包含指向其他节点的指针的数据结构。不是指针数据类型的原因是它存储的不是内存地址的变量。 学学伪代码： 当需要使用指针的时候，就可以使用这个符号声明： 12TYPETIntegerPointer ← ^Integer 定义了TIntegerPointer的数据类型是整形的指针。 我们也可以这么写： 1DECLARE MyIntegerPointer : TIntegerPointer 这是一个不需要使用插入符 (^) 的方法。 接下来我们来定义一些数据： 1234DECLARE Number1, Number2 : INTEGERNumber1 ← 100MyIntegerPointer ← @Number1 最后一行代码向指针变量赋了值。变量MyIntegerPointer现在存储着Number1的地址。 然后我们可以使用下面的这种方法为Number2赋予一个200的值： 1Number2 ← MyIntegerPointer^ * 2 Pointer variable: one for which the value is the address in memory of a different variable. 集合数据类型计算机科学中也存在集合的定义：集合是一种抽象数据类型，可以存储某些值，没有任何特定的顺序，并且没有重复的值。 集合数据类型 (Set data type)与大多数其他集合类型不同，通常不是从集合中检索特定元素，而是测试集合中的成员资格值，可以说是将一整个整体来进行处理(?) Set: a collection of data items that lacks any structure;contains no duplicates and has a number of defined operations that can be performed on it. 常用的操作有这些： 检查集合中是否存在某个值 添加新的数据值 删除现有的数据值 将一个集合添加到另一个集合当中 Python的其中一个亮点就和集合数据类型有关。在Python中，处理集合数据类型十分方便。 下面是在Python中操作集合数据类型的一些实例： 1234567891011121314151617181920212223242526272829303132# 创建一个集合my_set = {1, 2, 3}# 向集合中添加一个值my_set.add(4)# 从集合中剔除一个值my_set.remove(3)# 检查值是否在集合内if 2 in my_set: print(\"2 is in the set\")# ---- 华丽的分割线 ------# 创建两个集合set1 = {1, 2, 3}set2 = {3, 4, 5}# 两个集合的并集union_set = set1.union(set2)print(union_set) # 输出为: {1, 2, 3, 4, 5}# 两个集合的交集intersection_set = set1.intersection(set2)print(intersection_set) # 输出为: {3}# 两个集合的差difference_set = set1.difference(set2)print(difference_set) # 输出为: {1, 2} 文件管理在日常计算机使用中，会遇到各种各样的文件类型，例如图形文件、文字处理文件、电子表格文件等。无论文件类型如何，内容都使用特定的二进制代码存储，从而保证文件的正常使用。 这里就出现了新东西：二进制文件 (Binary file)和记录 (Record) 二进制文件是包含二进制格式信息的文件，二进制格式是 0 和 1 的序列。二进制文件用于以计算机可以读取但人类不易理解的格式存储数据。二进制文件的示例包括可执行文件、图像文件和音频文件。 记录是一种包含一个或多个字段的数据结构，每个字段包含一条数据。记录用于以易于访问和操作的方式存储和组织数据。在计算机科学中，记录通常用于表示数据库和其他数据存储系统中的数据。 Binary file: a file designed for storing data to be used by a computer program. Record: a collection of fields containing data values. 串行文件串行文件 (Serial file)是一种包含信息的文件类型，信息按其发生的顺序记录在文件中。 它还可以用来记录文件信息。在这种情况下，文件信息将按照它们在串行文件中保存的顺序列出。所以说：信息或文件基本上是按时间顺序记录的。 顺序文件顺序文件 (Sequential files)是根据某些键值排序的文件。顺序文件主要用于文件命中率较高的应用场景中。 #文件命中率衡量计算机系统或程序性能的重要参数,它可以反应计算机在访问存储器时的效率。 顺序文件的一个示例是包含有关公司员工信息的文件。该文件可以根据员工的姓氏进行排序，以便将具有相同姓氏的所有员工分组在一起。这将使根据姓氏搜索员工变得更加容易。 直接访问文件直接访问文件 (Direct-access file) 有时候也被称之为随机访问文件 (Random-access files)。和内存一样，随机性表明我们可以访问文件中的任何记录，或者在任何位置写入内容，而无需按照顺序依行读取文件。在使用这种文件时，我们可以直接访问文件的某个区块。 另一种方法是在将记录输入直接访问文件时使用散列算法。 如果每条记录中有一个数字关键字段，则可以使用一种简单的哈希算法。该算法选择一个合适的数字并将该数字除以关键字段中的值。 然后，该除法的余数标识文件中用于存储该记录的地址。如果合适的数字是与文件的预期大小相似的质数，则效果最佳。 我们举一个简单的计算例子：我们使用关键字段中的 4 位值来说明文件中的地址，其中 1000 用于除数。 以下代表三种计算，其中余数代表地址： 0045 / 1000 余数为452005 / 1000 余数为53000 / 1000 余数为5 从这些计算中可以看出两个事实。第一个事实是，计算出的地址没有任何顺序，具体取决于关键字段中的值。第二个事实是，不同的关键字段值可以产生相同的余数，因此在文件中产生相同的地址。 正因为相同的地址可能产生，所以当同一个地址被使用的时候，可能会发生冲突。哈希算法的职责是尽可能平均地分配地址，从而最大限度地减少冲突的可能性。 但是哈希算法也不是万能的，无论再怎么平均分配，冲突必定出现。所以说如果冲突出现，我们有以下这些解决方案： 使用顺序搜索来查找计算出的地址后是否有空闲地址。 在文件末尾保留一些溢出地址。 创建一个可以从每个地址访问的链接列表。 文件访问一旦我们选择了文件组织，并将文件中注入了数据，我们就需要考虑下如何使用这些文件，如何访问这些数据。 对于串行文件来说，正常的方法是逐条读取文件。但是说如果需要再其中的一个字段中搜索特定的一个值，唯一的办法就是从头开始读取记录，直到我们找到了我们的目标。 如果我们需要在顺序文件寻找特定值的话，可能也需要像串行文件一样进行搜索。但是，如果我们已知包含所需数据的关键字段，那么直接读取关键字段就可以了。 直接访问文件的话，首先需要将关键字段的值提供给哈希算法进行计算。 文件类型的选择串行文件特别适合批处理或者备份磁带上的数据，因为串行文件中的数据是与时间相关的。 如果我们需要快速访问一个大文件中的单个记录，就需要使用直接访问文件。比如说需要登录一个具有许多用户的系统，在这种情况下，用户登录时用于检查密码的文件就应该是直接访问的。 顺序文件特别适用与从文件的一次搜索中获得多个记录的应用程序。一个例子是家谱：我们可以对所有特定家族名称的所有记录进行搜索。 实数在计算机中，实数是带有小数部分的数。 当我们在一个二进制系统中写下一个实数的值，并需要存储下来的话，我们有多个选择：我们可以选择简单的表示法，也可以使用指数表示法(科学计数法)。 比如说，数字’25.3’可以写成： .253 * 10^2 或 2.53 * 10^1 或 25.3 * 10^0 或 253 * 10^-1 就对于’25.3’来说，直接表达是最好的存储方案。但如果数字非常大或非常小，就需要尽可能地使用科学计数法。 浮点&amp;定点表示法在计算机系统中，我们只能是有二进制码来存储实数。其中的一种方法就是使用定点表示法 (Fixed-point representation)。 在定点表示法中，首先需要确定总位数。其中总位数中的一部分位来表示整数部分，其余的位表示小数部分。 另一种方法就是使用浮点表示法 (Floating-point representation)。所有使用浮数都可以改写成下面这种形式： ±M × R^E 其中，有效的位数由±M表示，我们叫做尾数 (Mantissa)。E表示指数。浮点数中的 “指数 “并不代表原数的整数部分。相反，它表示在确定浮点表示数的值时，基数（在计算机系统中通常为 2）所升高的整数幂。 一般来说基数R不会存储进这个浮点数内，因为R有一个隐含值“2”。具体原因是我们在使用二进制表示数字时逢2进一。 Floating-point representation: a representation of real numbers that stores a value for the mantissa and a value for the exponent. p.s. mantissa是尾数的意思。 我们来举例子了解一下两种表示法之间的区别： 对于定点表示法来说，在一个字节内，我们可以使用最高的有效位作为符号位，然后再使用接下来的五位表示整数部分。这就会为小数部分的表示留下两个位。 下表给出了一些比较重要的非零值： 描述 二进制码 (对应的)十进制数 最大的正值 011111 11 31.75 最小的正值 000000 01 0.25 绝对值最小的负值 100000 01 -0.25 绝对值最大的负值 111111 11 -31.75 浮点表示法的话，我们可以使用4个位来表示尾数，然后再使用另外的4位表示指数。每一个位都使用2的补码来表示。其中，指数存储为有符号的整数，尾数存储为定点实数。 那么我们应该如何确定哪一位是二进制点。 下面的表格给出了使用4位来表示尾数的两个选项：在每种情况下，我们都选择了等价的二进制点， First bit pattern Real value in denary 011 1 3.5 011 0 3.0 010 1 2.5 101 0 -3.0 100 1 -3.5 100 0 -4.0 First bit pattern Real value in denary 0 111 0.875 0 110 0.75 0 101 0.625 1 010 -0.75 1 001 -0.875 1 000 -1.0 First bit pattern Real value in denary 0111 7 0110 6 0101 5 1010 -6 1001 -7 1000 -8 浮点表示法的特殊值如下表所示： 描述 二进制码 (对应的)十进制数 最大的正值 0 111 0111 0.875 × 2^7 = 112 最小的正值 0 001 1000 0.125 × 2^(-8) = 1/2048 绝对值最小的负值 1 111 1000 -0.125 × 2^(-8) = -1/2048 绝对值最大的负值 1 000 0111 -1 × 2^7 = -128 p.s. 上课时候有人提出了一个问题：Exponent部分的第一位为什么不是1从而达到最大值？老师的解释是“因为Exponent部分也同样存在符号位，所以最大的正值只能将后三位填充为一。” 精度与标准化当使用浮点表示法表示数据时，需要从两个方面着重考虑。 首先需要决定使用的总位数，然后还要决定分割线的位置 (表示尾数的位数和表示指数的位数之间的分割线) 然而在我们使用的时候只需要选择使用的总位数就可以了。具体的位数分割就会交给浮点处理器来决定。 当然这也不代表你没法决定尾数和指数位数的数量了：一般来说，增加尾数位数可以提供更高的精度，但是同样会减少指数位数。如此一来就会减少可以表示的值的范围。 所以说为了获取最大精度，我们就必须要标准化浮点数。因为越多的尾数位数代表着更高的精准度，所以在考虑提升精度时，要尽可能对表示尾数的位数使用多的位数。 将浮点表示法中的数字标准化意味着选择一个指数，以防止在尾数中出现前导零。。举个例子：0 1000.11并没有标准化：小数点前面一共有5位。如果想要标准化这一串数据，就要将其变成0.100011。小数点向左移动了四位，因此在此情景中指数为4。 我们可以使用八位浮点表示一个数值。因为要表示正数，十进制表示以2进位。比如说： 十进制表示 浮点二进制表示法 0.125 × 2^4 0 001 0100 0.25 × 2^3 0 010 0011 0.5 × 2^2 0 100 0010 表示负数也没有问题。这里用-4作为十进制表示的底数： 十进制表示 浮点二进制表示法 -0.25 × 2^4 1 110 0100 -0.5 × 2^3 1 100 0011 -1.0 × 2^2 1 000 0010 表示法的转换在AS部分的第一章，我们讨论了多种将数字转换为不同形式的方法。 先来看定点二进制表示法。举个例子：4.75转换为定点二进制表示法 打眼一看挺简单的：4可以转换为100，.75转化为二进制的.11，所以4.75的定点二进制表示法大概是100.11。但是别忘了正数的首位需要以0开头。这样的话就只添加一个符号位就可以解决问题了。这样，4.75就可以以定点二进制表示法写成0100.11。 那么负数怎么办呢？比如说-4.75，就可以先从4.75的表示开始，然后再将它转换成对应的二进制补码： 0100.11 转换为： 1011.00（一次补码） 1011.01就是-4.75的二次补码。 有关于二次补码的内容，可以去AS部分的第一张扒翻一下。 转换成浮点就有一些复杂了。在转换之前，我们应该注意：大多数小数部分无法精确地转换为浮点数值。因为二进制小数部分的因数有1/2， 1/4， 1/8， 1/16等等。所以说除非被转换的值正好是这些因数的和，否则无法进行精确的转换。比如说，从0.1到0.9之间的的值中，只有0.5可以被精确的转换。 转换正值的方法如下： 使用我们在AS第一章中描述的方法转换整数部分。 添加在开头添加符号位 使用下面的方法转换小数位 将整数和小数部分组合起来，并将它们输入到分配用于表示尾数的最高有效位中。 用零填充尾数的剩余位和指数的位。 通过改变指数值来调整二进制小数点的位置，以实现归一化的表示。 第三步提到的方法如下： 我们试着转化一下8.75： 整数位8转换成1000，然后添加符号位。这样就变成了0 1000 小数部分“.75”可以在二进制中表示为.11 将小数转换为二进制时，可以将小数部分乘以2，然后观察得到的整数部分和小数部分。然后再乘以2直到得到的小数部分等于0。稍后需要将每次乘法结果的整数部分写成等价的二进制数。0.75十进制到二进制的答案是0.11。小数部分“0.75”的转换步骤大概是：1. 0.75 * 2 = 1.5，1.5的整数位包含1，因此位数部分的第一位需要写1。2. 去掉刚才的乘积的整数部分，0.5 * 2 = 1.0。1.0的整数部分包含1，因此尾数部分的第一位需要写1。正因为整数位的1减去后，小数位不包含任何信息，所以转换到此结束。所以0.75转化过后就是.11。 该组合给出 0 1000.11，其指数值为零。 移动二进制小数点后，我们得到 0.100011，小数点相比原来向左移动了四位，因此在此情景中指数为4其指数值为十进制的4。 下一阶段取决于为尾数和指数定义的位数； 如果为尾数分配10位，为指数分配4位，则最终表示为尾数为 0100011000，指数为 0100。 使用浮点数的问题如上所述，将十进制实数值转换为二进制表示形式几乎可以保证一定程度的近似。 用于存储尾数的位数也有限制。 浮点数用于涉及重复计算的扩展数学过程。 例如，在使用大气数学模型的天气预报中，或在经济预测中。 在这样的编程中，在记录每次计算的结果时存在轻微的近似。如果计算重复足够多次，这些所谓的舍入误差可能会变得很大。 防止错误成为严重问题的唯一方法是通过使用更多的尾数位来提高浮点表示的精度。因此，编程语言提供了以“双精度”或“四精度”工作的选项。 另外，浮点数还可能引发溢出错误条件，因为浮点数能够存储的数字范围有限。 第十七章：通讯及互联网技术传输方式对于通过互联网进行的通信，有两种可能的方法：电路交换 (Circuit switching)或分组交换 (Packet switching)。 电路交换电路交换在传统电话系统中运用的比较广泛。 电路交换是实现电信网络的一种方法。在这种方法中，两个网络节点通过网络建立专用的通信信道（通过电路），然后才能进行通信。电路的特征决定了信道的带宽，并且这个专用通讯链路会在使用期间一直保持连接。电路交换法师一种面向连接的网络，通过在发送方和接收方之间建立专用路径，提供了有保证的数据传输速率。 通过电路交换传输数据的大致流程如下： 发送方提供预期的接收方的身份信息 由系统来检查接收方是否准备好接收数据 如果接收方可以接收数据，那么就会在网络上建立一些连接 数据随后被传输 移除所有的建立的连接 在这种情况下，我们暂时没有必要对电路交换网络中的每个节点进行定义。节点之间的链路师共享传输介质中的专用信道，可以保证传输的畅通无阻、当连接结束后，随着链路的断开，连接也就明确结束了。不过，对于租用线路数据连接而言，可能会建立永久性的连线。 分组交换分组交换 (Packet-switching)允许我们再不建立电路的情况下进行数据传输。 数据不能以连续的流的形式发送，相反，数据被打包成一个一个数据包内然后被发送出去。 数据包由包含传送指令的标头和数据主题构成。这个方法有点像邮政服务发送信件一样，但是要更加复杂。比如说在电路交换那一章的图片仍然可以描述数据包交换，只不过所使用的链路在发送方传输数据包的时候还没有被定义。 此外，与电路交换传输所需的功能相比，节点将具有更多扩展的功能。我们将会在下面的一个章节中探讨路由器如何充当节点并且支持数据包的发送与接受。 当我们使用分组交换法的时候，网络可以通过两种方式提供服务：无连接服务 (Connectionless service) 或者是 面向连接的服务 (Connection-oriented service)。 对于无连接服务来说，我们在发送数据包的时候不知道接收者是否准备好接受数据包，而且我们无法确认数据包是否会传输成功。 在面向连接的服务中，我们发送第一个数据包的目的是为了确认对方是否能够正常的接受数据包。如果收到了确认的话，那么发送方就会发送更多的数据包。如果没有收到确认，那么发送方就会再次尝试发送第一个数据包来确认状态。 传输协议网络协议的基本定义很简单：它是一组规则。但问题是这些规则与什么东西有关呢？ 在回答这个问题之前，我们应该明白：我们通常所说的“协议”是指的包含许多单独协议的协议栈，因为网络的复杂性需要我们去制定许多单独的协议。另一个复杂因素是：一个协议可能有许多不同的版本。而且通常有一类协议可以用来补充另一类协议的作用。 Protocol: a set of rules for data transmission which are agreed by sender and receiver. 任何通过网络传输的通信，都必须在发送方和接收方之间商定一套构成协议的传输规则。在最简单的层面上，协议可以规定成正电压代表比特值为1。协议也可以规定发送方不得超过的传输速度。许多规则与信息的格式或信息的组成部分有关。比如说，定义数据包中前40哥字节的格式。 协议栈对于协议套件而言，协议可以被是认作为协议栈中的层。这一概念设计了多个方面： 每一层只能接受上一层或者下一层的输入。 相邻的层之间有一个明确的界限，这是层与层之间唯一允许的互动。 一个层由下层的行动提供服务。 除了最底层之外，各层的功能都是由安装的软件创建的。 层可以包括子层。 任何用户交互都将使用与堆栈中最高层相关的协议。 对于硬件的任何直接访问都仅限于堆栈的最底层。 TCP/IP 协议套件TCP/IP是为支持互联网使用二创建的协议套件。TCP/IP可以根据下图所示的模型来进行解释： 不难看出，TCP/IP协议只占用了这个模型的前三层。 图中显示了两个终端系统 （最左边和最右边的两列），并且也显示了这两个系统中相应层之间的逻辑连接。一个应用程序可以在一个终端系统上运行，并与另一个终端系统上运行的应用程序建立直接连接。发送端系统上的应用层协议向同一系统上的传输层协议发送信息，然后传输层协议启动一个进程，将相同的信息传送到接收端系统。在接收端系统上，最后阶段是传输层协议将信息传送给应用层协议。 TCP/IP协议套件由许多子协议组成，包括以下协议： 应用层协议： HTTP SMTP DNS FTP POP3 IMAP 传输层： TCP UDP SCTP IP 网络层： IP IGMP ICMP ARP 选择这些协议是为了说明TCP/IP协议套件包含了应用范围非常广泛的协议，而且这些协议仍然在不断地发展。 TCP (传输控制协议)传输控制协议 (Transmission Control Protocol, TCP)是指TCP协议套件中定义的一个协议。它起源于最初的网络实施，是互联网协议（IP）的补充。因此，整个协议套件通常被称为 TCP/IP。 TCP 是面向连接的。客户端和服务器之间必须先建立连接，然后才能发送数据。在建立连接之前，服务器必须监听（被动开放）客户端的连接请求。三方握手（主动打开）、重传和错误检测增加了可靠性，但延长了延迟。 （所以如果不需要可靠数据流服务的应用程序可以使用用户数据报协议 (User Datagram Protocol, UDP)。它提供的无连接数据报服务优先考虑的是最低延迟，而不是可靠性。） TCP 可避免网络拥塞，不过，TCP 也存在漏洞，包括拒绝服务、连接劫持、TCP 否决和重置攻击。 如果在终端系统上运行的应用程序要向不同终端的系统上面发送信息，那么这个应用程序会被收到上面说过的应用层协议所控制。该协议会将用户的数据传送给传输层，然后由传输层运行的TCP协议负责讲信息安全的发送给接收方。 TCP协议会创建足够的数据包来容纳所有的数据，而且每一个数据包都会由报头和用户数据组成。 除了确保数据的安全传输外，TCP协议还需要确保任何相应都会被引导回应用层级，因此，报文头中的一项内容就是端口号 (Port number)。端口号用于标识应用层的协议，比如说，HTTP的端口号就是80。 数据包还必须包括接收端系统应用层协议的端口号，虽然说TCP不关心接收端的系统地址。 在一个序列里的数据包会包含一个序列号，目的是为了在数据传输的重点能够正确的按照顺序重新组装数据。 TCP 协议是面向连接的。一旦网络层向传输层返回确认，表明连接已经建立，TCP 就会发送其他数据包并接收包含确认的响应数据包。而且还可以识别并重新发送丢失的数据包。 IP (互联网协议)互联网协议 (Internet Protocol)是一种协议或者一组规则，用于数据包的路由和寻址，使其能够穿越网络到达它要去的目的地。穿越互联网的数据被分为一个个较小的块，我们之前提到过，叫做数据包。每个数据包的报头都附有IP信息，这些信息有助于 在网络层中，IP的是能够确保终端连接互联网的一个重要因素。IP协议从传输层接受数据包，然后添加一个报头。报头包含发送方和接收方的IP地址。要找到接收方的IP地址，很可能需要使用DNS服务来找到与用户数据中提供的URL相对应的地址。 IP数据包通常被叫做“数据报 (Datagram)”。它被发送到数据链路层，然后被发送到不同的协议套件中。 数据链路层会把数据报组装成一个“帧”，然后再进行发送。有关这个“帧”的内容下一章我们会进一步解释。 IP具有无连接服务的功能，一旦发送了数据包，IP无法知道他是不是真正的到达了目的地。如果IP收到了一个包含对先前发送的数据包的确认数据包，那么它只会把该数据包传递给TCP，自己不会了解其中的内容。 路由器上面的图片显示，数据链路层发送的“帧”在传送之前会到达一个路由器（或者是多个路由器）。在这一阶段，帧的数据报内容会被反馈给IP。现在路由器软件的功能是在传输过程中选择下一个目标主机。 用白话来说，当数据从一台设备发送到另一台设备时，会被分解成叫做“帧”的微小单元，然后通过网络发送。这些帧首先会被路由器接受，因为路由器是引导网络数据流的设备。路由器检查包含数据报内的帧内容，并使用路由表来确认数据的下一个目的地。路由表是每个路由器特有的，包含数据通过网络的最佳路径等其他信息。一旦路由器确认了下一个目的地，它就会更新数据报中的地址，然后将其传回数据链路层，由数据链路层继续发送。这一过程在每一个路由器上都会重复运行。 作为网络中的一个节点，交换机和路由器的主要区别是在于：当一个帧到达交换机的时候，交换机不做任何的路由操作，而是直接发送数据。交换机在数据链路层运行，但是无法进入网络层。 以太网(Ethernet)协议栈在AS部分的第二章，我们就已经了解过以太网了。以太网是一套专门为局域网设计的协议，因此它可以在不予互联网或者任何网络连接的本地局域网中运行。但是现在的局域网几乎不可避免地需要与互联网产生链接，所以说局域网的协议套件现在已经添加了对于互联网协议套件的支持。 如果我们仔细查看一个终端系统的协议栈(还是上面的那个图)， 你就会发现TCP/IP协议套件占据了五层协议栈的最上面的三层，因此我们可以说，TCP/IP协议套件得到了下面两层的支持。TCP/IP与这两个较低层的功能无关，它的设计目的是能够得到任何可用协议的支持。 值得注意的是，有些数据来源只对终端系统使用了4层栈。这种情况下，可能是数据决定只调用完全由软件处理的层，也可能是将TCP/IP的所有支持合并到了同一层中。 以太网是最有可能用来提供两个较低层所需功能的协议。从逻辑上来说，以太网套件包括了数据链路层和物理层两个子层，如下图所示： 下面的这几点说明了以太网在支持TCP/IP的时候的功能：下面的这几点说明了以太网在支持TCP/IP的时候的功能： 逻辑链路控制(Logic Link Control, LcC)协议负责与网络层的交互。它管理数据传输并确保数据传输的完整性。不过由于以太网是一种无连接协议，所以它不负责检查传输是否成功发送。 逻辑链路控制(Logic Link Control, LcC)协议负责与网络层的交互。它管理数据传输并确保数据传输的完整性。不过由于以太网是一种无连接协议，所以它不负责检查传输是否成功发送。 介质访问控制(Medium Access Control, mac)协议负责组装被称之为“帧”的以太网数据包。其中的两个组成部分是发送器地址和接收器地址。此外，MAC协议还负责启动帧传输，并处理因碰撞(可能因为使用了CSMA/CD)导致的传输失败之后的恢复工作。 介质访问控制(Medium Access Control, mac)协议负责组装被称之为“帧”的以太网数据包。其中的两个组成部分是发送器地址和接收器地址。此外，MAC协议还负责启动帧传输，并处理因碰撞(可能因为使用了CSMA/CD)导致的传输失败之后的恢复工作。 物理编码子层（Physical Coding Sublayer, PCS）,协议负责对准备传输的数据进行编码，或对于收到的数据进行解码。 物理编码子层（Physical Coding Sublayer, PCS）,协议负责对准备传输的数据进行编码，或对于收到的数据进行解码。 物理介质附件(Physical Medium Attachment, PMA)协议负责信号的收发。 物理介质附件(Physical Medium Attachment, PMA)协议负责信号的收发。 —-MAC地址MAC地址在以太网中，一个以太网帧使用的地址是物理地址或者MAC地址。MAC地址值分配给网络接口控制器（NIC）的唯一标识符，用作网段内通信的网络地址。这部分的内容同样在AS部分的第二章提到过。简单来说，MAC地址标识一个唯一的网卡。在大多数IEEE 802网络技术（包括以太网，Wi-Fi和蓝牙）中，这种用法都十分常见。在以太网中，一个以太网帧使用的地址是物理地址或者MAC地址。MAC地址值分配给网络接口控制器（NIC）的唯一标识符，用作网段内通信的网络地址。这部分的内容同样在AS部分的第二章提到过。简单来说，MAC地址标识一个唯一的网卡。在大多数IEEE 802网络技术（包括以太网，Wi-Fi和蓝牙）中，这种用法都十分常见。 迄今为止，定义MAC地址使用的48位可以保证每一个设备都分配到他们自己的MAC地址。不过，除了使用48位方案，现在还有一种64位的替代方案。这种方案已经偶尔使用，但是在将来48位地址不够用的时候就真正派上用场了。迄今为止，定义MAC地址使用的48位可以保证每一个设备都分配到他们自己的MAC地址。不过，除了使用48位方案，现在还有一种64位的替代方案。这种方案已经偶尔使用，但是在将来48位地址不够用的时候就真正派上用场了。 48位地址通常使用十六进制标识，比如说：48位地址通常使用十六进制标识，比如说： 4A:30:12:24:1A:10 4A:30:12:24:1A:10 —-与TCP/IP有关的应用层协议与TCP/IP有关的应用层协议HTTP (HyperText Transfer Protocol)HTTP (HyperText Transfer Protocol)超文本传输协议(HyperText Transfer Protocol, HTTP)，是最重要的应用层协议，因为这是万维网的基础。每次用户使用网络浏览器访问网站的时候都会用到HTTP，但它的功能对用户是隐藏的。换句话说，当你访问一个网站的时候，你的浏览器会向网站的服务器发送一个HTTP请求，而服务器则使用HTTP回应用户网站的内容。这个过程发生在幕后，用户是看不到的。超文本传输协议(HyperText Transfer Protocol, HTTP)，是最重要的应用层协议，因为这是万维网的基础。每次用户使用网络浏览器访问网站的时候都会用到HTTP，但它的功能对用户是隐藏的。换句话说，当你访问一个网站的时候，你的浏览器会向网站的服务器发送一个HTTP请求，而服务器则使用HTTP回应用户网站的内容。这个过程发生在幕后，用户是看不到的。 HTTP协议定义了报文的格式。请求信息的第一行是“请求行 (Request Line)”，请求行之后还可以加上标题行 (Header Line)。所有这些信息都是用ASCII编码。请求行的格式如下：HTTP协议定义了报文的格式。请求信息的第一行是“请求行 (Request Line)”，请求行之后还可以加上标题行 (Header Line)。所有这些信息都是用ASCII编码。请求行的格式如下： &lt;Method&gt; &lt;URL&gt; &lt;Version&gt;CRLF &lt;Method&gt; &lt;URL&gt; &lt;Version&gt;CRLF 其中后面的CR和LF是ASCII的回车和换行符。其中后面的CR和LF是ASCII的回车和换行符。 请求行通常使用GET作为获取方法。不过除了GET方法，还存在其他的获取内容方法。这使得HTTP成为一种适用范围更广的协议，而不仅仅用于网页访问。在使用HTTP的时候，我们必须指定HTTP的版本，因为HTTP发展到现在已经存在了好多版本。请求行通常使用GET作为获取方法。不过除了GET方法，还存在其他的获取内容方法。这使得HTTP成为一种适用范围更广的协议，而不仅仅用于网页访问。在使用HTTP的时候，我们必须指定HTTP的版本，因为HTTP发展到现在已经存在了好多版本。 —-电子邮件协议电子邮件协议发送和接受电子邮件的传统方法如下图所示：发送和接受电子邮件的传统方法如下图所示： 这其中设计三个单独的客户端到服务器的交互。客户端的电子邮件发件人必须和邮件服务器建立连接，然后该服务器必须变成“客户端”向真正客户端的电子邮件接收者所使用的邮件服务器进行传输。这其中设计三个单独的客户端到服务器的交互。客户端的电子邮件发件人必须和邮件服务器建立连接，然后该服务器必须变成“客户端”向真正客户端的电子邮件接收者所使用的邮件服务器进行传输。 目前存在以下三种主流的电子邮件协议：目前存在以下三种主流的电子邮件协议： 简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)，是一种“Push”协议，即用于从一个服务器向另一个服务器发送电子邮件。而邮局协议版本3 (POP3)是一种“Pull”协议，即用于从服务器检索电子邮件并下载到客户端计算机。简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)，是一种“Push”协议，即用于从一个服务器向另一个服务器发送电子邮件。而邮局协议版本3 (POP3)是一种“Pull”协议，即用于从服务器检索电子邮件并下载到客户端计算机。 还有一种协议叫做互联网消息访问协议 (Internet Message Access Protocol, IMAP)，这是POP3的最新替代方案。POP3是将电子邮件下载到客户端计算机上，但是IMAP允许将电子邮件保存在服务器上，同时客户端也可以访问存储的电子邮件。这意味着如果使用IMAP协议，你可以在任何设备上访问你的邮件。而使用POP3，我们只能从下载邮件的客户端系统访问你的邮件。还有一种协议叫做互联网消息访问协议 (Internet Message Access Protocol, IMAP)，这是POP3的最新替代方案。POP3是将电子邮件下载到客户端计算机上，但是IMAP允许将电子邮件保存在服务器上，同时客户端也可以访问存储的电子邮件。这意味着如果使用IMAP协议，你可以在任何设备上访问你的邮件。而使用POP3，我们只能从下载邮件的客户端系统访问你的邮件。 一般来说，POP3在抵御网络攻击方面可能会更加安全，因为电子邮件都存在客户端计算机的本地。不过使用IMAP存储电子邮件的服务器可能会定期备份，但是本地客户端大概率不会。一般来说，POP3在抵御网络攻击方面可能会更加安全，因为电子邮件都存在客户端计算机的本地。不过使用IMAP存储电子邮件的服务器可能会定期备份，但是本地客户端大概率不会。 —-FTP (文件传输协议)文件传输协议 (File Transfer Protocol, FTP)是一种标准通信协议，用于在计算机网络中将计算机文件从服务器传输到客户端。 FTP 基于客户机-服务器模型架构，在客户机和服务器之间使用独立的控制和数据连接。FTP 用户可以通过明文登录协议（通常以用户名和密码的形式）进行身份验证，但如果服务器配置允许，也可以匿名连接。 为了保护用户名和密码并对内容进行加密的安全传输，FTP 通常使用 SSL/TLS (FTPS) 或用 SSH 文件传输协议 (SFTP) 代替。 P2P文件共享点对点文件共享 (Peer-to-peer file sharing, P2P file sharing)产生的网络流是互联网使用的主要特征之一。 P2P 是一种没有结构和控制机制的架构。点对点既是客户端也是服务器，每个点对点只是一个终端系统。当对等体充当服务器时，它被称为 “种子”。 在P2P中，BitTorrent协议是最常用的协议，因为它可以快速的共享文件。 BitTorrent 是一种用于点对点文件共享（P2P）的通信协议，它使用户能够以分散的方式在互联网上分发数据和电子文件。要发送或接收文件，用户需要在联网电脑上使用 BitTorrent 客户端。 BitTorrent 客户端是实现 BitTorrent 协议的计算机程序。BitTorrent 客户端适用于各种计算平台和操作系统，包括 Rainberry 公司发布的官方客户端。流行的客户端包括 μTorrent、迅雷、Transmission、qBittorrent、Vuze、Deluge、BitComet 和 Tixati等等。 BitTorrent 跟踪器提供可用于传输的文件列表，并允许客户端查找可传输文件的对等用户（称为 “种子”）。程序员布拉姆-科恩于 2001 年 4 月设计了该协议，并于 2001 年 7 月 2 日发布了第一个可用版本。BitTorrent 协议可用于减少分发大文件对服务器和网络的影响。BitTorrent 协议允许用户加入一个主机 “群”，同时相互上传和下载文件，而不是从单个源服务器下载文件。 如果我们决定在终端系统使用BitTorrent，我们需要解决下面这三个基本问题： 如何确保计算机能够在网络上找到拥有目标资源的计算机？ 首先每个内容的供应者都提供一个内容描述，叫做torrent。这是一个包含跟踪器 （引导计算机找到内容的服务器）名称和内容块列表的文件。torrent文件比内容至少要小上三个过更多的数量级，因此这样的种子文件更易于我们传播。跟踪器是一个服务器，它的任务是维护正在下载和上传内容的所有其他的终端的列表。 在这样的对等网络上，如何为所有人提供高速的下载？ 对等网络在下载和上传的过程是同时发生的，但是对等网络必须同时交换数据块列表，来确保优先下载稀有的数据块。只要下载一次稀有的片段，那么这个数据块的稀有程度就会降低。 每个终端如何鼓励其他的终端提供内容，而不是仅仅使用协议下载文件造福自己？ 在经济中有一个名词叫做”Free-rider”。在这里我们需要对付的就是这类的终端。解决的方法如下：首先一个终端先随机尝试连接其他的终端，然后仅仅向那些提供常规下载的节点传输数据。如果发现有一个节点不下载或者下载速度贼慢，那么这个节点最后就会被“隔离”或者“阻塞”。 第十八章：硬件与虚拟机控制单元控制单元 (Control unit, CU)是计算机中CPU的一个组件，用于指导处理器的运行。它通常使用二进制解码器将编码指令转换为定时和控制信号，从而直到内存，算术逻辑单元(ALU)和IO设备等其他单元的运行。 控制单元管理大部分计算机的资源，并直到中央处理器与其他设备之间的数据流。在现在计算机设计中，控制单元通常是中央处理器的内部组成部分，其整体作用和运行方式自推出以来一直没有发生改变。 在执行程序时，中央处理器会接收一连串机器码指令。中央处理器内的控制单元有责任确保正确处理每一条机器指令。有两种方法可以设计控制单元，使其发挥功能： 将控制单元构建为逻辑电路：这也称为硬连线控制单元 (Hardwired control unit)。硬连线控制单元通过逻辑电路将从中央处理器内存接收到的指令转化为控制信号。来自计算机主机内存的指令被发送到指令寄存器，指令寄存器负责识别其“操作码”。随后操作码被传递给指令解码器，指令解码器使用操作码来解释要生成的控制信号。然后，逻辑电路根据任何外部输入和条件代码创建了信号。&lt;/br&gt; &lt;/br&gt;整个过程由系统时钟同步，系统时钟产生有规律的脉冲，在低电平和高电平之间持续切换，形成了0和1。这种控制单元之所以是“硬连线”，是因为他们的逻辑电路是由硬件以逻辑门电路的物理排列。&lt;/br&gt; &lt;/br&gt;硬接线控制单元的一些缺点是成本相对较高，难以用于复杂的操作，而且无法在不进行物理改动的情况下对它进行修改。此外，每个电路只能处理一种形式的指令。不过，硬接线控制单元速度更快，因为每一种指令都由自己指定的电路来完成计算。 使用微编程构建微程序控制单元：这样的方法叫做微程序控制单元 (Microprogrammed control unit)。微编程控制单元采用编程的方法实现。在微程序控制中，微操作是通过执行由微指令组成的程序来实现的。 控制存储器地址寄存器用来指定微指令的地址。控制存储器被用为ROM，其永久存储了左右的控制信息我们一般称为固件 (Firmware)。控制寄存器保存从存储器获取的微指令。微指令包含一个控制字，为数据处理器指定一个或者多个微操作。 CISC和RISC处理器处理器的架构是指其物理结构。不过，处理器也有所谓的 “指令集架构”。 指令集架构涉及到： 指令集 指令格式 寻址模式 指令可以访问的寄存器 其中，指令集的选择是区分指令集架构的主要因素。 在计算机发展的早期，选择计算机指令集架构的一个重要因素是，该架构是否能够使高级语言编译器的编写变得更加容易。我们现在将这一种架构叫做复杂指令集计算机 (Complex Instruction Set Computer, CISC)。 直到20世纪70年代末期，人们开始对这一理念产生质疑。有人认为，使用精简指令集计算机 (Reduces Instruction Set Computer, RISC)会是一种更好的方法。 下面介绍一下这两位： CISC和RISC是两种不同类型的计算机体系结构。二者的主要区别在于中央处理器可执行的指令数和执行这些指令所需要的周期数。 CISC试图尽量减少每个程序的指令数，但是代价是这会增加每个指令的周期数。这就意味着CISC处理器一般拥有大量的复杂指令，但是可以在一条指令中执行多种操作。这些指令通常更长，功能更强大，可以用更少的单条指令来完成复杂的任务。 现在转过头来看看另一边的RISC。RISC是一种以每个程序的指令数量为代价来减少每条指令周期的方法。这就意味着RISC处理器的简单指令数量较少，只能执行单一的操作。这样，RISC处理器的指令集就设计的比CISC更简单，更小了。这些指令通常更短更简单，需要更多的单独指令才能完成复杂的任务。 这两种方法各有利弊。CISC处理器通常更容易编程，因为它们有更强大的指令。但由于每条指令的周期数多，所以运行速度可能会慢一些。RISC处理器由于减少了每条指令的周期数，因此运行的速度普遍较快，但是因为需要更多的单独指令来执行复杂的任务，因此这可能会使得编程的难度直线上升。 Complex Instruction Set Computer (CISC): a single instruction can be more complex and involve more loading of data from memory. Reduced Instruction Set Computer (RISC): s single instruction is simpler, requiring minimal loading of data from memory. 下表列出了RISC区别于CISC的一些特征： RISC CISC 更少的指令数 更多的指令数 更简单的指令 更复杂的指令 指令格式相对简单 指令格式复杂 尽可能使用单周期指令 多周期指令 定长指令 可变长度指令 只对内存地址执行加载和存储指令 向内存地址存储多种指令 更少的寻址模式 更多的寻址模式 多个寄存器组 更少的寄存器 多为硬连线控制单元 多为微程序控制单元 更利于流水线作业 不太利于流水线作业 需要注意的是，RISC处理器大多使用硬连线控制单元，而CISC处理器大多使用微编程控制单元。 指令数量的减少并不是使用RISC的主要驱动力，降低指令的复杂性才是RISC的主要特征。 典型的CISC架构包含很多的专用指令，专用指令的设计符合高级编程语言的要求。专用指令需要多次访问内存。与直接访问寄存器相比，访问内存的速度可谓是相当慢。 RISC处理器的指令非常简单，因此数据可以存储在寄存器中，并在寄存器中进行操作。除了初始化和资源存储请求之外，无需对存储器进行任何的访问。 RISC指令的简单性使得硬连线控制单元的使用更加容易。而许多CISC指令的复杂性使得硬连线控制单元的构建更加复杂，因此我们使用微程序控制单元。 流水线作业 (Pipelining)创建 RISC 处理器的主要驱动力之一，就是为高效流水线提供机会。 流水线 (Pipelining)是一种专门应用于指令执行的并行方式。其他并行形式将在下一节中讨论。 好像翻译成“流水线”不是很恰当，但是懂我意思就行 Pipelining: instruction-level parallelism. 流水线作业的基本原理是第五章中介绍的F-E Cycle可以分为若干阶段。其中的一个形式是“五阶段模型”。要实现流水线操作，处理器的结构必须含有5个独立的单元，这样每个单元就可以单独处理五个阶段中的其中一个阶段。这同样解释了为什么RISC处理器需要许多的寄存器组，因为存在多个处理单元，而每个单元必须需要寄存器来访问将要使用的数据。 五阶段模型如下表所述： 时钟周期 → 1 2 3 4 5 6 7 Instruction Fetch(指令读取，IF) 1.1 2.1 3.1 4.1 5.1 (6.1) (7.1) Instruction Decode(指令解码，ID) 1.2 2.2 3.2 4.2 5.2 (6.2) Operand Fetch(操作数抓取，OF) 1.3 2.3 3.3 4.3 5.3 Instruction Execute(指令执行，IE) 1.4 2.4 3.4 4.4 Result Write Back(结果回写，WB) 1.5 2.5 3.5 在上面的表格中，每一行代表流水线中的一个阶段： 指令读取 (IF)、指令解码 (ID)、操作数读取 (OF)、指令执行 (IE) 和结果回写 (WB)，同时每列代表一个时钟周期。单元中的数字代表指令编号和该指令的阶段。例如，”1.1 “表示指令 1 处于 第一步 “IF” 阶段，”2.5 “表示指令 2 处于第五步 “WB” 阶段。 解读一下表格：最初只有第一条指令的第一阶段进入了流水线。在第六个时钟周期，当第一个指令已经离开流水线时 （因为不存在第六个流水线阶段），指令2的最后一步仍在处理，而且指令6才刚刚进入流水线作业 （因为没有第六个流水线阶段，所以第六个指令的流程并没有画在表上。但如果第六个指令需要处理的话，会在第六个时钟周期进入流水线）。 流水线一旦开始运行，就要处理五个阶段的五条单独指令。特别是在每个时钟周期，都需要完成一条指令的处理工作。如果没有流水线并行作业，那么处理时间将延长五倍。 在流水线系统中，多条指令在流水线的不同阶段同时处理。当中断发生时，流水线中就会有几条指令尚未执行完毕。有两种解决中断问题的解决方案： 第一种：清除最近进入的四条指令的流水线内容，只留下最早进入的指令。然后，正常的中断处理程序就可以应用于剩余的指令。 第二种：在处理器中构建具有独立程序计数器寄存器的独立单元。这样就可以在处理中断时为流水线中的所有指令存储当前数据。 基本计算机架构描述不同计算机体系结构的一种有效的方法是：考虑指令流的数量和数据流的数量。因此这区分出了四种类型的架构： 单指令流单数据流 (SISD)单指令流单数据流 (Single Instruction Stream Single Data Stream, SISD)是早期计算机中的典型架构，同样也是早期的微处理器所采用的排列方式。具体来说，SISD代表了包含一个控制单元，一个处理器单元和一个存储器单元的单台计算机的组织结构。所有的指令按照顺序执行，系统内部可能有并行能力，也可能没有。 虽说是这样，但是课本上写的是SISD纯粹是顺序性的产物，没有一点点并行性。我们就按照这条来记吧。 下图展示了如何使用SISD来操作数组中的单个元素： 图中给出了一个原始的数组。如果机器需要将这个数组内的元素乘以2，那么SISD就会按照顺序一个一个地处理数组内部的数据，从右到左。换言之，SISD对于数组内每一个元素都执行了相同的“乘以2”的操作。 SISD: Stands for Single Instruction Stream Single Data stream; a single processor accessing one memory. 单指令流多数据流 (SIMD)单指令流多数据流 (Single Instruction Stream Multiple Data Stream, SIMD)所描述的计算机具有多个处理元件，可以同时对多个数据点执行相同的操作。这类计算机利用数据级的并行性，但是不利用它们的并发性。 SIMD是一种并行处理方式，也就是多个处理元件同时对多个数据点执行相同操作。这意味着计算机就可以使用相同的指令同时处理多个数据点，而不是一步只能处理一个数据点。这可以大大提升某些类型计算的速度。也就是说，虽然说存在并行计算，但是每个单元在任何给定的时刻都执行完全相同的指令。 下图是一个SIMD的图示： 由图可见，所有在数组中的元素都在同一个指令周期完成了处理，而不像SISD一样每一个元素都需要单独处理。 SIMD 的结构通常用图表表示，就像下图一样： 在本图中，结构图显示数据流进入了四个单独的组件，这些组件都提供了相同的指令。这些组件被称之为处理单元(Processing Unit, PU)，有时这些组件也被称为处理原件(Processing Element, PE)。无论使用什么名称，这些组件都全部是ALU，也就是算术逻辑单元。有多个名称的原因是因为实现SIMD有多种方法： 第一种实现方法是使用阵列或者向量处理器(Matrix &amp; Vector processors)。他们有一组并行的寄存器，每一个数据流都会被安排一个寄存器。我们可以使用一4位或者128位的大型寄存器，来同时存储多个数值。在这种实现方式中，并行性仅仅内置在一个处理器中，允许这个处理器同时处理多个数据流。 另一种方法是使用多核处理器。现在大多数的电脑都搭载了多核处理器。比如说使用4核处理器，就代表四个处理器并行工作。在这种情况下，每一个处理器都可能有自己专用的告诉缓存来提供可靠的数据流。 SIMD: Stands for Single Instruction Stream Multiple Data Stream; processing of parallel data input requiring one control unit instructing multiple processing units. 多指令流单数据流 (MISD)多指令流单数据流 (Multiple Instruction Stream Single Data Stream, MISD)是一种并行计算架构，其中许多功能单元对同样的数据执行不同的操作。 与SIMD相比，MISD的应用就少得多，因为MISD通常更适合常用的数据并行技术。具体来说，他们可以更好的扩展和使用计算资源。话虽这么讲，MISD也是有应用的，比如说用于航天飞机的飞行控制计算机。大家也知道航天方面的数据计算是不容有失的，-在这种情况下，使用 MISD 架构可将多条指令应用于同一数据流，从而提供冗余并提高系统的可靠性。 MISD: Stands for Multiple Instruction Stream Single Data Stream; does not exist in a single architecture. 多指令流多数据流 (MIMD)多指令流多数据流 (Multiple Instruction Stream Multiple Data Stream, MIMD)是一种并行计算架构。在这种架构中，有许多个处理器异步独立运行。在任何时候，不同的处理器都可能对不同的数据执行不同的指令。 MIMD架构被应用于多个领域，如计算机辅助设计，仿真，建模或者是通信交换机。MIMD机器可以分为共享内存和分布式内存两类，他们的类别是基于MIMD处理器访问内存的方式决定的。共享机器模型可以是总线型、扩展型或者分层型。 MIMD: Stands for Multiple Instruction Stream Multiple Data Stream; multiple processors asynchronously processing parallel data input. 大规模并行计算机系统大规模并行计算机系统 (Massively parallel computer systems)是指使用大量计算机处理器（或者是独立的计算机）同时并行执行一组协调计算的计算架构。这可以通过各种各样的方法实现，比如说网格计算 (Grid computing)，就是透过使用大量的异构计算机的未使用资源，将其作为嵌入在分布式电信基础设施中的一个虚拟的计算机集群，为解决大规模的计算问题提供模型的方案。大名鼎鼎的SETI@home项目就是使用了这项技术，通过筹集大量计算机用户的剩余资源来分布式计算问题。这些小的计算机结合起来的算力同样强大，丝毫不亚于超级计算机。 大规模并行计算机系统与超级计算机的区别在于，负责驱动多个处理器的不是总线结构，而是支持多个计算机单元的网络基础设施。不同计算机上面运行的程序可以通过网络传递信息进行通信。 虚拟机虚拟机听起来像是个硬件，但其实不是。最常见的虚拟机类型是系统虚拟机 (System virtual machine)，它的作用是模拟真实计算机系统硬件的软件。 System virtual machine: the emulation of computer system hardware using software. 一般来说，应用程序需要在操作系统支持的情况下才能在硬件上直接运行。虚拟机的原理是进程直接与操作系统提供的软件界面进行交互，如下图所示： 从上图我们需要注意这几点： 应用程序是在客户操作系统的协助下安装的。客座操作系统将通过与虚拟机交互来支持运行中的应用程序，就好像客座操作系统通常运行的硬件一样。 虚拟机实施软件可被视为一种实用程序，运行时受特定主机操作系统的支持，而主机操作系统又是主机硬件所特有的。 在主机操作系统的控制下，主机硬件上可以同时直接运行应用程序。 虚拟机方法的主要优点是可以在一个计算机系统上提供多个不同的操作系统。如果一个组织拥有遗留系统，希望继续使用旧软件，但又不想保留旧硬件，这一点就特别有价值。 另外，拥有大型主机并提供服务器整合设施的公司也可以多次提供相同的操作系统。不同的公司可以获得自己的虚拟机，作为服务器运行。 使用虚拟机的一个缺点是需要花费大量时间和精力来实施。另一个缺点是虚拟机的性能无法达到普通系统的性能水平。 之前在第八章讨论的 Java 虚拟机是进程虚拟机的一个例子，它基于不同的基本概念。进程虚拟机提供了一个与平台无关的编程环境，允许程序在任何平台上以相同的方式执行。这是一种仅支持运行 Java 程序的特定软件。 第十九章：逻辑门与布尔代数逻辑电路早在第四章，我们就已经接触过了逻辑电路中使用的逻辑门符号，并讨论了逻辑电路，真值表和逻辑表达式之间的关系。本章会介绍一些额外的内容，比如一些用于构建计算机硬件功能组建的特定电路。 半加法器 (The half adder)在计算机中，二进制加法运算随处可见。两个比特的结果相加结果要么为1，要么为0。在一些特殊情况下，如1和1相加，会导致当前位结果为0，同时它的下一位会被加一，也就是进位。 执行二进制加法最简单的电路是半加法器 (Half adder)。如下图所示，半加法器会接受两个值的输入，然后输出“和位(S)”和一个“进位(C)”。 这个电路的真值表看起来就是这样的： Input Input Output Output A B S C 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 通过检查这个真值表，我们大概可以推测出半加法器的成分如何。可以看到，只有在两个输入位都为1的时候，进位C才会出现1的结果。因此，C输出的真值表就可能是基于AND逻辑门实现的。和位S输出的真值表与之前聊过的XOR运算符的真值表一致，所以我们也可以推测半加法器里面还存在一个XOR逻辑门。因此，产生半加法器功能的电路可以包含一个AND门和一个XOR门，其中这两个逻辑门都会接受A和B两个输入。 当然，上面列出的只是完成这个功能的其中一种情况，还有更多逻辑门的搭配方式可以实现这样的功能。冷知识：NAND逻辑门和NOR门是两个通用门，这意味着任何的逻辑电路都可以使用这两种逻辑门进行构建。再加上NAND和NOR门易于制造的特点，导致电路制造商们很喜欢使用它们俩。下面这个图片就是仅仅使用NAND门和NOR门构建出来的一个半加法器： Half adder circuit: a circuit which performs binary addition of two individual bits. 全加法器 (The full adder)一般来说，如果我们需要计算两个二进制数字相加，则我们必须要从两个数字的最小位开始计算，一直计算到最大位。在计算的每一个阶段，前一个加法的结果的进位数字都必须并入到当前的计算中。如果每次使用半加法器，就必须需要使用单独的电路来处理进位问题，因为半加法器仅仅接受两个输入。 全加法器 (Full adder)是一种执行加法运算的一种电路。这种加法器接受三个输入：两个需要相加的数字和上一位产生的进位，并产生三个输出，分别是三个输入的和以及下一位的进位。 当我们需要对不止一位进行二进制加法运算时，我们最好使用全加法器，因为全加法器考虑了前一位假发的金文，所以它能够处理所有的进位问题。例如我们设计对多位二进制数（如4位，8位，16位二进制数等）进行算术运算的电路，我们就需要使用全加法器。 全加法器的真值表如下： Input Input Input Output Output A B Cin S Cout 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 全加法器的一种可能的构造如下图所示： 我们之前说过，所有的电路理论上都可以使用NAND和NOR逻辑门来构建。所以全加法器的另一种构造如下图所示： Full adder circuit: a circuit which performs binary addition of two individual bits and an input carry bit. 时序电路到目前为止，本书中介绍过的所有电路全部都是 组合电路 (Combinational circuit)。对于这样的电路来说，输出的值只由输入的值决定。接下来我们会介绍时序电路，它的输出取决于输入和前一个输出项。 时序电路 (Sequential logic circuit)是一种数字电路，它存储上一个输出信息并使用它来计算下一个输出。我们刚说过，时序电路于组合电路不同之处就在于，时序电路既依赖当前输入值，同样也依赖存储在某一个存储元件中的上一个输出状态。 Combinational circuit: a circuit in which the output is dependent only on the input values. Sequential circuit: a circuit in which the output depends n the input values and the previous output. SR 触发器 (SR Flip-flop)下面我们要介绍的SR触发器，是时序电路的一个简单例子。 SR触发器 (SR Flip-flop)，又称之为SR锁存器，是数字电子产品中经常会用到的一种基本触发器。SR触发器是一种双稳定器件，这意味着SR触发器有两个稳定状态，而这两种稳定状态可以被无限期保存。正因为这种独特的记忆特性，卫门叫它“锁存器”。它可以由两个NAND门和一个NOR门组成，如下图所示： SR触发器有两个输入端，分别是 “置位” (S)和 “复位” (R)。以及两个输出端，分别是Q和Q’。SR触发器的工作原理如下： 设置 (set) 状态： 当设置(S)为1，(R)为0时，这时输出(Q)就会变为1。这表示锁存器进入了设置状态。 复位 (reset) 状态： 当设置(R)为1，(S)为0时，这时输出(Q)就会变为0。这表示锁存器进入了复位状态。 保持 (hold) 状态： 当输入端的(S)和(R)均为0时，无论上一个状态是设置状态还是复位状态，触发器会保持原来的状态。也就是说，输出还是会与上次相同。 比如说，如果SR触发器的上一个状态处于“set”状态，也就是Q的输出为1，并且输入S和R都是0，那么触发器会继续输出Q为1。 SR触发器的真值表如下所示： Input Signals Input Signals Initial State Initial State Final State Final State S R Q Q’ Q Q’ 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 0 0 1 0 0 0 1 0 1 1 0 0 1 1 0 0 1 0 1 0 1 从真值表中我们可以发现，表中不包含当R = 1或者S = 1的行，因为如果当S与R同时等于1，会导致输出“非法”。因为当遵循布尔代数原则时，Q和Q’不会同时输出0。Q与Q’本身应该就是彼此互补的，即当一个值为1时，另一个值应该为0。所以，输出是违反这个逻辑，是“非法”的。 在实际运用中，我们要避免使S和R都同时为1，因为它会导致数字电路中不可预测的行为。因此为了保证电路的可靠运行，我们需要尽可能避开这种用法。 JK 触发器 (JK Flip-flop)我们在数字电路中最讨厌的就是像刚才SR触发器中，任何可能导致电路发生“不可预测”的无效输出或者错误处理。实际上，除了在电路中存在S与R都为1导致的无效输出之外，如果信号无法同时到达触发器，也会导致输出的不可预测性。为了解决这个问题，电路可以包含一个时钟脉冲输入，以提供同步输入的更好机会。JK触发器 (JK Flip-flip)，也叫JK锁存器，就是这样的一个例子。 JK触发器是一种连续双状态单比特存储设备，是以它的发明者杰克·基尔命名的。这个不重要，重要的是JK触发器有一个时钟输入引脚(Clock, CLK)，两个数据输入引脚(J和K)和两个输出引脚(Q和Q’)。如下图所示： JK触发器可以画成左边的简略形式，它的展开形式如右图所示。 在时钟周期的情况下，JK触发器可以在时钟的前缘触发，或者是后缘触发。将时钟周期想象成一个方波。前缘就是电平从0变成1的电平上升时刻，而后缘就是电平从1变成0的电平下降时刻。 要理解电路是如何运作的，我们需要先理解一个大前提。除非所有的输入都为1，否则与非门的输出为1。如果电路处于未设置状态，那么Q = 0， Q’ = 1。这种状态是稳定并且自洽的，就正如下面的参数所示： 时钟和J都输入为0 因此左上角的NAND门输出为1 右上角的NAND门会接受两个为1的值的输入。 Q = 0 如果J的输入变成了1，时钟的输入也变成了1，那么就会发生下面这些事情： 左上角的NAND门就会接受两个为1的值的输入 所以它的输出为0 这就会导致右上角的NAND门以1的值输出Q 这样一来，右下角的NAND门就会接受两个为1的值的输入。 所以Q’的输出为0 JK触发器的真值表如下： J K Clock Q 0 0 ↑ Q unchanged 1 0 ↑ 1 0 1 ↑ 0 1 1 ↑ Q toggles 由此可见，当J和K的输入均为1的时候，Q与Q’的值会发生变换。 J可以被称作为“集合输入”。当J被设置为1，并K被设置为0的时候，它会导致输出Q也被设置为1。K可以被叫做“清除输入”。当K被设置为1，J被设置为0的时候，会导致Q被清除（设置为0）。 JK与SR触发器不一样的是，每两个输入任意发生组合都会产生一个有效的输出，输入J和K的每一个组合都对Q和Q’产生明确定义的影响，而不像SR触发器一样，包含一个无效输出。这个特性导致JK触发器更加可靠，更有预测性，因为没有导致任何不确定因素或者未定义输出的情况出现。 布尔代数基础本书的第四章讲过了如何使用逻辑命题来使用布尔运算符来组合成逻辑表达式。而布尔代数为编写简洁的逻辑表达式提供了方法，并提供了一种简化表达式的“公式”。 当使用一种代数形式的时候，理解它的含义是十分重要的。举个简单的例子，1+1可以被解释成很多不同的情况： 1 + 1 = 21 + 1 = 101 + 1 = 01 + 1 = 1 一式表示的是十进制算术，二式表示二进制算术，三式表示位算术，而四式可以表示布尔代数。这是因为在布尔代数中，1表示为TRUE，0表示为FALSE，而+可以表示或。因此，第四个计算式可以以下面这种形式表示出来： TRUE OR TRUE is TRUE 布尔代数的表示有它的专有符号。比如说AND可以表示为∧，OR可以表示为∨。或者，A AND B可以写成A.B或者AB。在本章中，我们会使用这种类似“点乘”的AND表示方法。NOT的具体方式是在字母上面加一个横线。比如说NOT A可以表示为Ā。 在建立了基本的表示法之后，我们就需要考虑我们的计算规则了。下表中的内容可以被叫做“法则”或者“定义式”： Identity / Law AND form OR form Identity 1.A = A 0 + A = A Null 0.A = 0 1 + A = 1 Idempotent A.A = A A + A = A Inverse A.Ā = 0 A + Ā = 1 Commutative A.B = B.A A + B = B + A Associative (A.B).C = A.(B.C) (A + B) + C = A + (B + C) Distributive A + B.C = (A + B).(A + C) A.(B + C) = A.B + A.C Absorption A.(A + B) = A A + A.B = A De Morgan’s Double Complement ̿A = A ̿A = A \\打表格太费劲了，下次直接截图算了* \\下文中出现的Ā或者A'都代表NOT A* 上面的表格展示了在布尔代数中的一系列恒等式。就拿德摩根定律举例子：德摩根定律允许我们交换FALSE和TRUE，或者交换AND和OR来将形式变换掉。 比如说这里有一个表达式：0.A = 0，读作”FALSE AND A is FALSE”。根据德摩根定律，我们可以将AND换成OR,并将所有元素取反。这样就能得到另一个相等的形式：1 + A = 1。总结一下，德摩根定律的变化法则是： 变换时交换TRUE和FALSE（0和1） 变换时交换AND和OR（.和+） Example 来做个例题。 考虑一下这个表达式：A + Ā.B。我们如何化简它？ 有意思的是，要化简这个式子，我们首先需要将式子先变得更复杂。表中提到了有这样一个公式：A + A.B = A。可以通过这一点把原式中的A换掉，就变成了这样： A + A.B + Ā.B 下一步我们暂时忽略A，然后对A.B + Ā.B使用交换律。步骤如下： A.B + Ā.B = B.A + B.Ā = B.(A + Ā) B.(A + Ā) = B.1 这一步应用了公式A + Ā = 1。 将结果带回原式，即可得到化简最终答案：A + B.1。 布尔代数运用从真值表中创建布尔表达式为特定问题创建布尔表达式，有时可以以真值表作为切入点。 直接上例子把： Example 我们来举一个两个输出的AND门的例子。真值表如下所示： A B Output 0 0 0 0 1 0 1 0 0 1 1 1 我们即将使用的”Sum of product”的方法是为真值表中的每一行创建一个最小项，输出为1。然后再对这些最小和求和，得到最终的布尔表达式。 最小项 (Minterm)是输出为1的特定组合。在这个真值表里，只有一个最小项，那就是当A = 1或者B = 1时。我们将这个最小项记为A.B。因为这个真值表只有一个最小项，所以说这个真值表的最终布尔表达式就是A.B。 但是如果不只有一个最小项怎么办？或者，表中不只有一个输出项怎么办？ 下面是一个半加法器的真值表： Input Input Output Output A B Sum Carry 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 首先，我们对”Sum”这一列输出创建最小项： 第二行 (A = 0, B = 1)，最小项是Ā.B (NOT A AND B) 第三行 (A = 1, B = 0)，最小项是A.B' (A AND NOT B) 我们使用OR将所有的最小项连接在一起，这样的话就形成了Sum的布尔表达式： Sum = A'.B + A.B' 同理可得，Carry = A.B 化简只能够将两列输出分别对应一个布尔表达式，所以最终的答案是： Sum = A'.B + A.B'Carry = A.B 逻辑电路的布尔代数式Example 有时候我们需要通过一个逻辑电路来写出布尔代数式。那这个半加法器电路举例子： 我们跟着A和B两个输入项，来到了第一个NAND门。根据NAND的真值表： A B Output 0 0 1 0 1 1 1 0 1 1 1 0 NAND真值表的前三行都为1，所以我们需要为此构建三个最小项。结合起来如下： W = A'.B' + A'.B + A.B' 下一步，W的输出会去到三个NAND门里进行运算。我们这里以X门举例子。如果要画出X的真值表不是很容易，因此我们会考虑NAND门的本质计算方法，那就是先进行一个AND运算，然后将结果取反，也就是跟一个NOT运算。而AND的结果正式两个值的乘积。 我们先来进行AND运算： A.(A'.B' + A'.B + A.B') 接着应用布尔分配式，也就是A.(B + C) = A.B + A.C： A.A'.B' + A.A'.B + A.A.B' A.A'的结果是0。在AND运算中，只要输入有0，那么输出必然为0。所以我们可以简化成： A.A.B' 因为A.A = A，所以最后化简出来的式子就是： A.B' 然而事情到这里还没有结束。因为我们只完成了NAND运算里的AND部分，接下来我们会执行NOT运算，也就是将上面的表达式求逆。根据德摩根定律 (元素取反，AND和OR交换)，我们可以得到原式的逆式： A' + B 到这一步就可以出X的结果了。同样的流程也可以适用于Y的结果： X = A' + B , Y = A + B' 这两位合起来，就是S的输出。同样，我们需要先执行AND运算，再通过德摩根定律执行NOT运算： (A + B').(A' + B) (AND执行后) S = A'.B + A.B' (NOT执行后) C的结论，也可以通过这样的流程算出来了。 卡诺图 (Karnaugh map)","link":"/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/"},{"title":"ASCS笔记","text":"CS课堂笔记 写在前面鉴于本人初入CS，加上这篇笔记是课上笔记，本文以下所有内容不保证完全正确，不保证覆盖所有课本内容。本文顺序以课上老师的授课顺序为主。我写下本文，为的是帮助自己更好地学习CS这门科目，因此，希望路过的大佬轻喷。同时欢迎有需求的读者交流学习。 本笔记内容基于《Computer Science for Cambridge International AS &amp; A Level》，剑桥大学出版社出版，教材为第二版，A-Level课程编号为9618。 PART ONE：理论基础第一章：数据的表示数字的内部编码编码本章中的讨论仅涉及整数值的编码。在之后的第16章会涉及到非整数值的编码。 计算机出于多种目的会存储各种整数值。有时候会存储一个简单的整数，但要突出这是一个正数。在这种情况下，Signed integer会被应用。一个Signed integer由一段包含值的二进制编码和额外的一位用于定义符号，而这种表示方式被我们叫做Sign and Magnitude representation。 从硬件上设计计算机，存在Sign&amp;Magnitude信号，用于记录和计算浮点信息。 Sign&amp;Magnitude中存在One's Complement和Two's Complement。Two's Complement比One's Complement的优点在于更容易计算，因此我们使用Two's Complement在计算机内计算。 有关减法计算机为避免过度的运算，所以处理数据只做加法。但是计算机还是需要去做减法，我们这里就用到了Two's Complement二次补码。 Two’s ComplementTwo's Complement叫做二次补码，计算机可以用它来计算减法。更多相关内容可参考本文。 接下来举个做减法的例子： 比如说 23-35 0 1 0 1 1 1 - 0 1 0 0 0 1 1 最高位是代表一个正数，所以加几个 leading zero数字大小都不变。（前提是在前面加的是0不是1） 现在变成 23+(-35)，就要将正 35 变成-35，使用 Two's Complement作变换，转换为二次补码。 首先，将0 1 0 0 0 1 1的每一位取反,变成1 0 1 1 1 0 0 然后，在1 0 1 1 1 0 0的后面追加一位 1，变成1 0 1 1 1 0 1，即为35的二次补码 现在，直接令 23 加上 35 的 Two's Complement“1 0 1 1 1 0 1 “即可算出 23-35。位数不够可以在一开始多添几个 leading zero，使得每一位对齐。这一举动不会影响到数据的大小。 0 0 1 0 1 1 1+ 1 0 1 1 1 0 1---------------------- 1 1 1 0 1 0 0 现在，我们需要对于计算的结果再进行一次Two's Complement即可转换得到最后的计算答案。 1 1 1 0 1 0 0-&gt; 0 0 0 1 0 1 1-&gt; (+1) 0 0 0 1 1 0 0 至此，0 0 0 1 1 0 0（12）就是取模后的大小了。注意，这里是大小。 我们还知道，第一次计算后得出的1 1 1 0 1 0 0，首位是 1，代表这是一个负数。 因此，原来的符号信息加上转换后的模便是最后答案(-12)。 有关数据溢出当然，数据溢出的可能性还是存在的： 假如说你的计算机声明的变量只有到八位。第一位是符号位，所以最大可以代表 255。比如说 200+100，结果是 300，但是因为进位超出了计算机变量能存储的范围，部分进位信息因此丢失导致数据溢出。 单位转换数据的单位换算总体来讲比较简单。有一道例题是这样的： 假如在一次数据传输中，获得了2000000bit，需要存储为一个file。 请问该file的大小有多大？ 首先让2000000/8，得到有多少个Byte。如果转换成KiB，需要2000000/8/1024，得到KiB。这里算出来是244.140625KiB。在KiB,MiB等单位内选择一个合适的单位。要求数字不要太大，也不需要太多的小数位。 如果要转换为KB，需要2000000/8/1000，得到KB。这里算出来是250KB。在KB,MB等单位内选择一个合适的单位。同样要求数字不要太大，也不需要太多的小数位。 字符集BCDBCD按照二进制格式来对十进制数字进行编码。每个BCD的值都是一个无符号的8位整数，值的范围从0到9。 BCD码可以很大程度上简化那些使用十进制设备的数据处理。比如必须向人显示数字的设备，如时钟和计时器。 一个字节里面只有一个BCD：00001000，00000101，00000000，00000011BCD封装后，一个字节里面可以有两个BCD：10000101，00000011 ASCII Code小写字母的ASCII号比大写字母的要大。 我们可以按住alt键，然后同时在小键盘上打出ASCII码。这样可以以ASCII的方式输出。记得把Numlock打开 在考试的时候，会提供ASCII码表。 ASCII码有两种：ASCII和Extended ASCII。 普通的ASCII使用字节中的前七位来表示字符，因此这样的ASCII能表示的字符数就有27个（128个字符）。但是Extended ASCII使用所有的八位来表示字符，因此这样的ASCII能表示的字符数就有28 （256个字符）。 Unicode万国码有一百七十多万个文字空间，同时用两个字节代表一个文字符号。世界上所有的Symbol等都可以放在Unicode里。 Unicode使用两个字节储存一个字符。 UTF-8不过大多欧美国家使用Unicode有点吃亏，因为他们只用其中一个Nibble就可以胜任日常使用了。因此就诞生了一种新的字符集叫做UTF-8。 一个Byte之中第一个Nibble一般是占满的，比如0???????或者10??????，前面的几位数字用来告诉接收端如何分组字节。 虽说把UTF-8放在了字符集这里面，但是需要注意的是：UTF-8不是字符集。 有关于UTF-8我的评价是：不太需要理解。因为现在的语言（Java，Python）什么的都可以自动选取合适的字符集。而且所有的字符集都是兼容ASCII码的。 中文好多字符是需要3个nibble存储的，所以对于中国来说也是不适用的。因此我国研制了自己的一套字符集叫做GBK。 图像有位图和非位图，也可以说是矢量图。 我们常见的.jpg,.jpeg格式之类的都是位图，计算机存储每一个像素位上的信息。因此文件一般较大，而且也容易失真。 而.svg等文件类型是矢量图。矢量图记录的是像素的一系列关系，并由计算机直接绘制上色。因此无论如何蹂躏图像都不失真。 简直像极了描点发作图和数学法作图的区别。 位图大小可以用像素数量×颜色深度计算得出。像素数量使用长像素数×宽像素数计算得出。 需要注意以下几点： 在这里的计算方法得出的结果单位是bit。如要计算Byte那就将结果除以8。 因为File header的存在，这种计算方法只会得出一个文件的大致大小。 File Header所有的文件都存在一个File Header，用于描述此文件类型，因此系统可以识别File Header来使用正确的解码方式。一般文件开头的两个字节是File header。操作系统会先读取File Header。 如果计算机无法识别file header，计算机就不会继续向下读取该文件了，并且让你自己制定一种合适的打开方式。 声音Analogue的数据是连续的，而Digital的数据是离散的。 用多少空间来记录一个采样的比率叫做一个采样率。采样率越高，音频质量越高。 当然不是采样率越高越好的。因为人类对于特定声音不敏感，所以采样率到一定水准就已经足够使用了。 音频文件的计算公式为： 数据量 (B/s) = 采样频率(Hz) × 采样位数(bit) × 声道数 /8 在这里，单声道代入“1”，立体声即为双声道，代入“2”计算。 注意这里计算的是每秒的数据量 压缩无损压缩是压缩完还原之后可以还原成原本的样子，比如说文字压缩。 有损压缩就是还原不出原来的样子，但是结果还存在于能接受的范围内。有损压缩通过丢失一些不容易察觉到，不太影响文件质量的数据进行删除处理，这种压缩方式叫做过滤。比如说.mp3，.jpeg等等。 相比于直接存储数据的绝对大小，也可以存储下一个数据与上一个数据的变化量（相对数值）。这种存储方法可以有效地减少存储开销。 在无损压缩算法中，有这么一个典型例子，叫做Run-length coding. 算法的具体内容是将连续的一些字符转化成个数加字符的形式。 比如： WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW 可以压缩成： 12W1B12W3B24W1B14W 第二章：通信与网络技术网络的目标与演变广域网 (WAN) 广域网 (Wide Area Network, WAN) 是一个是一个不受单一地点限制的大型信息网络。广域网可以通过广域网供应商来促进世界各地的设备之间的通信或者信息共享。一般来说，广域网是一个局域网 (LAN) 或者其他网络的集合，这里面的每一个元素相互进行通信。你可以将广域网理解成子网络的网络。 互联网 (Internet) 是世界上最大的广域网。 Wide area network (WAN): a network connecting computers on different sites, possibly thousands of kilometres apart. 链接广域网的电脑可以享受下面的优点： 可以远程控制另一台计算机。 可以访问存储在远程计算机上的数据档案。 信息可以通过数据的方式传送给远程计算机上的用户。 一个典型的广域网有下面这些特点： 广域网会被一个组织或一个公司用来连接站点或分支机构。 广域网不属于该组织或公司。 广域网需要从公共交换电话网络公司（PSTN）租借。 如果租借广域网，PSTN将提供一个专门的通信链路。 广域网的传输媒介将是光纤电缆。 广域网内数据的传输在交换机 (Switch) 之间运行。 交换机用来连接广域网和每个节点。 不会有任何终端系统直接连接到广域网上。 局域网 (LAN)局域网 (Local area network, LAN)，是在一个有限的区域内（住宅，学校，实验室，大学校园或者办公大楼等区域）链接不同终端的一个网络。局域网可大可小，小到一个只有一个用户的家庭网络，或者是一个拥有千万设备的办公网络，都可以叫做一个局域网。 Local area network (LAN): a network connecting computers in a single room, in a single building or on a single site. 连接到局域网的设备可以享受下面的这些优点： 在每台个人电脑上安装应用软件的费用可以通过在连接到局域网的应用服务器上安装软件来节省。（可以在局域网的服务器上安装一个软件，这样就可以不用接着在每个终端上安装一样的软件了。说白了就是节省成本。） 使用一个搭建在局域网上的文件服务器，允许用户之间共享文件。 可以多个设备共用一个设备，比如说连接到局域网的电脑都可以使用一个打印机来打印文件。 现在的局域网都有下面这些特点： 用于组织或者公司的内部组网。 局域网可以被组织或者公司拥有。 传输介质一般是双绞线电缆或者Wifi。 客户机-服务器模型客户机-服务器模型 (Client-server model)是一种分布式应用结构，它将任务或工作负载在资源或服务的提供者（称为服务器）和服务请求者（称为客户）之间进行划分。 在这种结构中，当客户计算机通过互联网向服务器发送数据请求时，服务器接受请求并以所请求的数据进行回应。 在当今的网络世界中十分的常见。 还有一个东西叫做瘦客户端 (Thin-client)。瘦客户端的功能就是为用户提供一个输入的窗口，然后再将用户输入的信息打包发送给服务器。最后再将服务器发送回来的数据解析展现给用户。 与其相反的还有胖客户端 (Thick-client)。与首客户端相反，胖客户端会在传送信息到服务器之前，在本地完成一些或者很多运算。 Client-server: an architecture where a client runs an application provided by a server on a network. Thin-client: a client that only provides input and receives output from the application. Thick-client: a client that carries out at least some of the processing itself. 文件的分享你可以将文件上传到网络上，然后其他用户就可以在服务器上将你共享的文件下载下来。这就像百度网盘一样。 当然我们还有其他的方法，比如说点对点网络模型 (Peer-to-peer model)。点对点网络不存在一个中心的服务器来让其他主机访问，相反，P2P网络中的每一个节点都相当于是一台主机。当一台计算机向另一台计算机发送文件请求的时候，那么收到请求的电脑就会变成一个相当于服务器的东西。 与客户机-服务器模型相比，P2P网络模型有如下优点： 当许多客户端同时请求一个资源的时候，P2P网络就可以很有效地规避网络堵塞。 一个文件地每一个小部分都可以分开进行下载。 一个文件的不同部分可以在不同的主机上下载。 而客户机-服务器模型的优点有： 允许组织来控制文件的下载和使用。 可以提供给文件更好的保护措施。因为所有文件都可以放在一个主机上集中管理。 网络拓扑结构数据通信系统需要由这些部分组成：发送方，接收方，传输介质，传输的信息和传输协议。 其中，传输的介质可以是空气(WiFi), 也可以是电缆(比如以太网线)。 Topology: the configuration of a network that defines how the various devices on the network are connected. 信息可以通过下面这几种不同的方式来通过介质传输： 单工模式 (Simplex mode)，数据仅可以单向传输。 半双工模式 (Half duplex)，数据可以双向传输，但是不能同时双向传输。 全双工模式 (Full duplex), 数据不仅可以双向传输，而且还可以同时进行双向传输。 一个数据通信系统可以由一个单独的隔离网络组成。隔离网络的拓扑结构有好几种可能性。其中最简单的是两个系统通过一个网络链接连接，如下图所示： 这是一个典型的点对点网络 (point-to-point network)。 可以理解成两个机器之间的专用线路。传输可以是单工或者是双工。 早期的局域网拓扑结构一般都是用环形或总线拓扑结构。我们没啥必要解释环形拓扑结构，因为现在环形拓扑结构基本上已经灭绝了。 上图是总线网络 (Bus network)。总线网络包含一条总线，这条总线上连接着不同的终端设备，而且每一个终端之间没有直接连接。所以说如果两个终端需要通信，就必须要通过总线来进行传播。 这种网络结构是相对比较有弹性的，因为其中一个终端的故障并不会影响到整个网络的瘫痪。 Bus topology: contains one shared link to which all devices are attached. End-system: a computer or server connected to a network. 上图是一个完全连接的网状拓扑结构网络 (mesh topology)。 在这个配置中，每个主机之间都会被连接。这些传输是双工的。 但是这样的网络结构一般来说不是特别容易实现，因为链接主机需要的线缆开销就会很大。 Mesh topology: contains direct links between devices. 所以说我们可以使用另一种网络结构来解决这个问题，那就是使用一台交换机构成的星状网络 (star topology)。 Star topology: each end-system is linked to a central device. 在星状网络中，每个主机都与中心设备具有点对点的链接，而且传输是双工的。和总线结构一样：一个主机的故障不会影响到整个网络，但是中心设备一定不可以发生故障，否则整个网络就会瘫痪。 星型网络拓扑结构中，所有的设备都直接链接到中心设备上，同时所有设备互相独立，且仅仅连接到中心设备上。 在星状结构中，中心设备也可以用于将网络连接到其他的网络，特别是连接到互联网。 当多个局域网联合在一起，他们就可以形成具有不同拓扑结构和技术的一个大网络。这个局域网的集合就变成了一个混合网络 (hybrid network)。 Hybrid network: a collection of connected LANs where some of them have different topologies or supporting technologies. Bandwidth: a measure of the amount of data that can be transmitted per second. 传输载体线缆传输网络的线缆可以有这三种：双绞线 (Twisted pair)，同轴线缆 (Coaxial)和光纤 (Fibre optic)。其中，双绞线和同轴线缆都选用了铜作为传输载体。 不同的线缆拥有不同的特性。下表展示了不同线缆的特性： ~ 双绞线 (Twisted pair) 同轴线缆 (Coaxial) 光纤 (Fibre optic) 费用 最低 高 最高 带宽 / 信息传递速率 小 大 很大 高频衰减 受影响 最受影响 最不受影响 抗干扰程度 很受影响 受点影响 最不受影响 是否需要中继器 需要 需要 一般不需要 双绞线电缆被广泛运用在我们的生活之中。一般在家里组局域网就会用双绞线电缆。 同轴线缆一般被有线电视公司和城域网广泛使用，同轴电缆一般不会用于长途电话布线。 光纤电缆是长距离布线的首选技术。光纤电缆是由许多单独的纤维捆扎在一起构成的，而同轴电缆就没有。 无线除了选用线缆传输，我们还可以使用无线传输 (Wireless transmission)。 Wireless: a transmission using radio, microwave or infrared. 有三种选择：无线电 (Radio)，微波 (Microwave)和红外线 (Infrared)。这三种传输类型的本质区别其实是波的频率。 上表格： ~ 无线电 (Radio) 微波 (Microwave) 红外线 (Infrared) 频率分布 3kHz - 3GHz 3-300GHz 300 GHz - 400 THz 带宽 / 信息传递速率 —— —— → 高频衰减 (主要由天气影响，如雨) —— —— → 是否需要中继器 —— —— → 定向传播性 —— —— → 墙壁穿透能力 ← —— —— 抗干扰程度 无明显趋势 无明显趋势 无明显趋势 “—— —— →”或者”← —— ——“代表向这个方向递增。 有线 VS 无线一般来说，有线传输通常被称作为“引导媒体”，无线则被称为“非引导媒体”。 当我们比较有线传输和无线传输的相对优势时，还有其他几点需要考虑。 有一些无线传输的频段是被国家禁止使用的。这意味着使用这些频段进行通信必须要经过国家的审批。 在这些频段之外，无线传输就不需要任何许可了。与此同时，在地下布下传输线缆必须先经过土地所有者的授权。 全球通信既可以通过埋在海底的光纤电缆实现，也可以使用卫星传输。 干扰对于无线传输似乎是一个比较大的问题。干扰的程度取决于具体使用的频段。 一般来说，无线传输需要的中继器相比有线传输要少得多。 只有无线网络才可以支撑起现今社会庞大的智能手机网络需求。 在小企业或者家庭内，有线网络和无线网络几乎处于同等地位，因为他们对用户的区别并不是特别的明显：即便有线网络需要提前布线的情况下。 (课本上给出的这些例子怎么想也不是很成系统的一些东西) 我们刚才在全球通信中提到了卫星通信。卫星通信是现代通信系统的一个重要部分。下图显示了不同类型卫星距离地面的高度： 其中范艾伦辐射带 (Van Allen belt)是含有高浓度带电粒子的区域，会干扰卫星的正常通信。 离地球最远的，处于地球静止轨道 (Geostationary Earth Orbit, GEO)上的卫星是用来提供长途电话和计算机网络通信的。“地球同步”的意思是卫星轨道运行的速度与地球自转的速度相同，所以从地球上看，那颗卫星就会一直在天空上的同一个位置。只需要3颗GEO卫星就可以覆盖全球。 离地球比较近，但不是最近的那一组卫星是中地球轨道 (Medium-Earth-orbit, MEO)卫星。这个位置的卫星主要提供全球定位系统(GPS)服务，覆盖全球至少需要10颗MEO卫星。 最后在近地球轨道 (Low-Earth-orbit, LEO)上的卫星用来填充移动电话网络，覆盖全球至少需要50颗近地轨道卫星。 （虽说现在轨道上已经有上百颗近地轨道卫星了） 卫星最大的问题就是离地面的距离太远，所以延迟就理所应当的成为了一个大问题。所以说现在使用卫星网络一般是有一些专门的应用点，比如在偏远地区使用互联网，或者是使用GPS。 因为现在光纤的发展成本越来越低，高速的数据传输有着更好的媒介，于是乎对于卫星网络的需求就越来越少了。 局域网硬件有线局域网在早些时候，同轴线缆是用来组局域网的。不过到现在，双绞线线缆是在局域网中最常见的解决方案。你看见的经典水晶头和以太网口一般都是双绞线。同时，光纤也变得越来越普及。 在总线网络配置中，网络由一个总线和一系列由电缆连接的插口组成。总线的两端有端子 (Terminator)，可以有效防止信号反射回总线。随后，每一个终端都会有一根相对较短的电缆，每一端都会有一个RJ-45连接器 (就是我们常见的水晶头)， 一端插入总线插座，另一端插入端系统的LAN口。 总线可以使用中继器 (Repeater) 来链接两条总线进行扩展，让信号传达到更远的地方。如果想要扩展信号，那么我们就必须需要中继器。因为远距离传输信号的时候，由于信号的衰减，通信会变得越来越不可靠。中继器在这里会接受所有输入的信号，并且输出一个满血的输出信号，让信号去到更远的地方。 也有些时候，一个总线网络会用一些分段方式构建。两个网段会使用一个网桥 (Bridge)链接，网桥会为他所连接的两个网段中的终端系统存储网络地址，这样两个网段就可以互相通信了。 在星型网络结构中，每一个终端系统都具有相同类型的线缆，同时拥有相同的连接器。因为电缆必须要插入中央设备的插口中，所以电缆往往会更长一些。 在星型网络结构中，中心设备可能是一个集线器 (Hub)，一个交换机 (Switch)或者是一个路由器 (Router)。现在而言，交换机是最有可能的中心设备：交换机是一种可以将特定的通信引导到特定终端的一个设备。 终端系统上的LAN端口和网络接口卡 (Network Interface Card, NIC)连接。网络接口卡用来为计算机和其他设备提供专用的网络连接，他同时被称作为网络接口控制器、网络适配器或者是LAN适配器：简称网卡。网卡在制造的过程中都会有一个独特的网络地址，这个地址用来识别安装该网卡的终端系统。这个唯一的网络地址被称作媒体访问控制(Media Access Control, MAC)地址，我们一般叫它MAC地址。MAC地址是一个分配给网卡的唯一标识符。 Server: a system providing a service to end-systems. Repeater: a device that connects two cables and provides a full strength signal to the second cable. Bridge: a device that connects two segments of a LAN. Network Interface Card (NIC): a component used to identify the end-system. Switch: a connecting device that can send a unicast message. 无线局域网Wi-Fi (在某些国家叫做WLAN)是一个用于描述无线以太网的术语。它的正式描述是：IEEE 802.11，它是一个使用无线电频率传输的无线局域网标准。Wi-Fi局域网的中心设备是一个无线接入点 (Wireless Access Point, WAP)，它可以是有线网络中的其中一个终端系统。如果你有一个具有无线功能的路由器，那么他就可以作为一个无线接入点。 只要在无线局域网中的一个设备安装了无线网络接口卡 (Wireless Network Interface Card, WNIC)，WAP就可以与Wi-Fi局域网中的终端系统进行通信。 无线网络接口卡是一种将你的设备连接到无线网络的设备，他也被称作无线适配器或者无线网卡。无线网络接口卡使用天线，并使用射频波提供无线数据的传输。 Wireless Access Point (WAP): the connecting device in a WiFi LAN. Wireless Network Interface Card (WNIC): provides the NIC function in a WiFi LAN. 以太网以太网 (Ethernet)是现代网络世界的两大主导技术之一，以太网主要是用于组建局域网。尽管以太网在20世纪80年代被发明出来，但是不属于任何机构。后来以太网被电气和电子工程师协会 (IEEE)标准化。他们的802委员会负责协定了议定书的制定，最后将有线网络的标准定义为IEEE 802.3标准。这个名称有时可以用于替代以太网。 到目前为止，以太网的标准已经迭代了5个版本：标准，快速，千兆，10千兆和100千兆。名称中的千兆比特部分代表了其数据传输能力。 标准类型的以太网是在局域网上实现的，一般都会配置为总线或者以集线器为中心设备的星型网络类型。在这两种拓扑中，传输类型都是广播。任何消息对所有的终端都是可用的，而不需要再任何一对端系统之间进行任何受控的通信交换。最后终端系统会检查消息中定义的目的地地址，以确定信息是否发送到了它应该去到的目的地。 当使用共享介质传输数据的时候，如果两个终端系统同时传送消息，信息就会发生“碰撞”。这是指与传输相关的电压相互干扰，就会导致信息损坏。我们采用的处理方法是：CSMA/CD (Carrier sense multiple access with collision detection)。当传输数据的时候，这个系统会通过检测介质中的电压来判断是否存在其他的信息传递。 有这个系统之后，传输的流程就会变成这样： 检查传输介质中的电压。 如果检测到传输介质中有数据传输，那么就在一段随机时间之后再来检查是否有数据传输。 如果传输介质中没有数据传输，那么我们就可以开始传输数据了。 在传输数据的过程中，CSMA/CD会继续检测时候有数据碰撞发生。 如果没有检测到数据碰撞，就继续传输数据。 如果检测到数据碰撞，那么就先暂停传输，随后发出一个干扰信号警告所有的终端站点。然后在一段随机时间后再来一次。 现代的以太网一般由交换机驱动：星型结构中心会有一个交换机，交换机控制数据端到端的传输。每一个终端系统都是用全双工链路连接到交换机，因此在现在的以太网网络上不会发生数据碰撞。因此在现代的以太网结构中，我们已经不需要CSMA/CD了。 当出现高强度的数据传输的时候，交换机需要能够将传入的消息存储在缓冲区 (Buffer) 中，只到线缆空闲的时候继续传输。 互联网基础设施互联网服务提供商 (ISP)互联网设计出来的时候，美中不足的一点就是没有对他的结构有一个明确的定义。但是互联网服务是存在一个层次的。例如：互联网服务提供商 (Internet service provider, ISP)最初的功能是为了给个人或者公司提供互联网接入。现在这个功能被一个叫做“Access ISP”的东西来执行。 这些“Access ISP”随后会接入到一个“中间层”，叫做“区域ISP (Regional ISP)“。区域ISP随后会连接到主干ISP，或者叫做一级ISP。 网络和互联网服务提供商之间通过互联网交流点 (Internet Exchange Points, IXP)联系，一级ISP和主要的互联网内容提供商一起位于层次结构的顶端。 路由器路由器可不是只存在于我们的局域网中，互联网中同样有一些路由器。 我们可以把互联网想象成承载最多流量的一个网络，它由一组铺设在海底或者陆地上的光纤电缆组成，可以被描述成一个网状网络结构。这种网状的电缆包含许多链接在一起的点，我们把他称之为节点(Node)，在每一个节点上，都有一个叫做路由器 (Router) 的设备。路由器不仅仅是存在于一般互联网中的网状结构中，他也存在于ISP网络中。每一个路由器都连接到其他多个路由器，他的功能是为了传输选择最佳的路线。 Router: a device that acts as a node on the Internet. 公共交换电话网 (PSTN)当考虑城市建设的时候，一般来说都没有考虑用于因特网传输的专用链路。所以人类历史就这个问题最悠久的解决方案是普通老式电话服务 (Plain old telephone service, POTS)，更正式的描述是公共交换电话网 (Public switched telephone network)。 在早期，电话网络传送模拟语音数据 (Analogue voice data)。 如果我们真的想要将数字数据通过电话网传播，就可以先在发送端使用调制解调器将数字信号转换为模拟信号，经过电话网络传播，然后在接收端使用调制解调器将模拟信号转化为数字信号。这样的“拨号连接”上网方式能为用户提供中等速率的网络访问。 不过组织或者机构也可以花点小钱购买一种租赁的网络服务，这种网络服务提供了一种永久的，专用的，有传输速度保证的互联网专用链接。现在来看，大多数的组织和机构都是用租用线路来简历广域网或城域网的。 都2023年了，祖国的网络建设都早早地把主要的通信线路换成光纤电缆了。这就允许ISP提供更好的网络服务，也允许某些人提供自己的ISP服务了。 现在的服务有这样两种：第一种是传统网络接入的宽带网络连接，另一种是WiFi热点技术。 移动电话网络对于移动电话来说，有另一种方式来提供互联网连接。在这种情况下，移动电话运营商会充当ISP，为手机提供网络服务。运营商会建立通信塔等基础设施，只要手机上搭载了合适的硬件和软件，就可以使用这样的基站来传输数据。 网络应用万维网 (WWW)“Using the web”和”using the Internet”看起来像是同一种表述，但实际上不是这样的。互联网是一个互联网络，而万维网是一种运行在Internet上的一个分布式应用程序。你可以把万维网认为成Internet上的所有网页。 具体来说，web由大量的网站组成，每一个网站都有一个或者多个网页。网页的特别之处就是他们可以包含超链接。当点击这些链接的时候，就可以直接并且基本上立即访问其他网页。 云计算云计算通常通过互联网提供计算服务。一个组织可以选择建立自己的私有云 (Private cloud)。在这种情况下，有一下三中方法： 该组织对于创建和管理安装云系统并链接到互联网负责。 该组织将会将创建和链接到私有网络的任务外包出去。 该组织将可上网的系统的创建和1管理工作外包给第三方。 太抽象了，根本看不懂 另一种选择是使用公共云 (Public cloud)。公共云由第三方云服务商创建，管理和拥有。 云提供的服务与文件服务器和应用服务器提供的服务十分相似。它们可以通过浏览器访问，因此你可以在任何位置，任何合适的设备商访问公共云 ——— 只要拥有互联网链接。公共云可以被个人用户或者组织访问。 公共云和私有云之间的最大区别就是系统规模。这种系统由很多大型主机计算机或者服务器群提供服务。公共云所提供的服务可以有以下几种： 提供基础设施。 提供平台。 提供软件服务。 云服务的很多优势都以为以下这一点：云服务不是很依赖终端设备的配置。对于基础设施的提供，云服务的优势包括在运行软件时能调用服务器端的算力，存储，从而提供更好的性能或者更大的存储容量。这样的话，我们甚至可以用有限的成本来运行对配置要求更高的应用程序。或者是公司的经费不足以支撑购买这些软件。还有一点好处是：把计算机托管到云端后，会减少用户对于技术水平的需求。 云服务的劣势大多与公共云有关：云服务提供者可以访问存储在云上的所有数据，所以说云服务用户没有办法确定他们的数据是否被第三方共享。这是一个有关数据隐私的问题，所以说云服务提供商应该有责任确保用户的数据不会丢失。 Private cloud: owned by and only accessed by an organization. Public cloud: owned by a cloud service provider for general access. 云计算的好处有： 只要在有互联网的情况下，就可以在任何地方访问云。 对本地计算机的配置需求相对较低 共享数据变得更容易。 安全措施和保障可能更好。 扩容更容易。 坏处可能有： 必须使用网络连接才可以访问云。 在上传数据和下载数据可能需要花费很多时间。 安全措施可能比较弱。 比特流流媒体使用互联网来提供在线音乐，视频等相关服务。一般来说，在数据被传输之前，它会被存储在一个字节中，可以用“字节流”的形式，一个一个字节的传输数据。由于涉及到文件的大小，流媒体总是被压缩成一个比特序列，aka“比特流”。 在第一章提到的压缩技术中，将字节流转化为比特流，也是一种压缩方法。为了使接收端的解码过程正常工作，数据必须作为比特流传输。 对于流媒体来说，“源 (Source)”是一个已经存储了待传输媒体的网站。在这种情况下，使用该资源的其中一个方法是把这个文件下载下来，然后在未来某个时刻方便听或看。但是如果用户不想要等待漫长的下载时间，他们有另一种选择：流媒体。流媒体可以被描述为按需观看或者收听。在这种情况下，媒体的传送和媒体的播放是两个独立的过程。传入的媒体数据被接受到终端机上的缓冲区内，然后终端上安装的媒体播放软件会从缓冲区中获取媒体数据并播放。 还有另一种流媒体是实时或者直播传输。在这种情况下，内容是在发送时生成的，例如在观看体育赛事的时候同时直播。在接收端，我们还是使用刚才提到的缓冲区加载原理，但是在发送端，可能会产生问题，因为可能会有大量的用户同时观看一个直播，造成网络阻塞。所以现在的解决方式是将媒体传送至很多独立的直播节点，最后再由他们传递给用户。 流媒体技术的一个关键问题是该技术是否能一直为用户提供一个还不错的用户体验。当媒体被创建出来时，它的意图是要以创造时完全相同的速度将媒体传递给用户。如果一首歌曲在录制时持续4分钟，但如果这四分钟再传输的时候拉长成了六分钟，就听起来很奇怪。 传送内容的过程是由比特率 (Bit rate)决定的。例如，一个质量相对较差的视频可以用300kbps的比特率发送，但是一个质量相当好的音频文件只需要使用128kbps就可以了。 下图展示了一个流媒体原理示意图： 缓冲区 (Buffer)必须按照所使用媒体的正确比特率将数据传递给用户。 发送到缓冲区的数据应该以更高的速率传输给用户。当媒体播放器发现缓冲池中的内容超过了上限和下限，这代表着我们需要向服务器发送获取指令了。 IP互联网需要技术协议才能运作。标准使用了一套称为TCP/IP的协议(参见第17章)。其中一个方面是IP寻址，用于定义从何处和到何处传输数据。 IP寻址目前互联网使用IPv4 (Internet Protocol version 4)来进行寻址。 IPv4寻址方案基于32位（4个字节）定义一个IPv4地址。32位的IP地址一共有232个不同的IPv4地址，差不多一共有40亿个IPv4地址。 IPv4是在20世纪70年代发明的，当时PC和手机还没有被发明，当时虽然估计40亿IP地址会允许世界上一半的人使用互联网，但是到现在来说IPv4能提供的IP数量就有些捉襟见肘了。 IPv4 address: a 32-bit long, hierarchical address of a device on the Internet. 最初的寻址方案是：IP地址中的一组位(bits)定义一个netID，另一些位定义该网络上面的一个hostID。这样做的目的是为了给互联网上的每一台设备分配一个唯一的，普遍认可的地址。 以netID和hostID分开的IP地址允许数据先定位到netID进行传输，然后再根据hostID分别传发给不同的主机。主机地址只需要在到达指定网络下检查一下就可以了。 在继续往下执行传输之前，我们需要注意host可以是子网下的任何一个设备，比如说路由器。 不同的netID和hostID的划分形式，与他们的IP级别有关系： Class Class identifier Number of bits for netID Number of bits for hostID Class A 0 7 24 Class B 10 14 16 Class C 110 21 8 上表中可以知道，最高有效位(从左往右数)表示了网络IP的级别。接着其他的有效位会被分配为netID，其余的有效位定义了hostID。 最大的组织会被分配到A类IP。这些A类IP只能有27个，也就是128个，但是每一个组织都可以有224个不同的host。相比之下，C类IP就一共有221个IP地址，差不多一共有200万个。C类IP中每个组织都只能分配到28个host，说白了就是256个host。 但是问题在于，一旦局域网下支持PC变得普遍，可用的B类netID就太少了。但是如果把C类ID分配下去的话，hostID又太少了。所以说我们现在有更多更好的方法能解决这些问题。 在继续深入探讨之前，我们需要先介绍IP地址的表示。在传输过程中，该技术是以32位二进制码为地址传输的。为了让用户更轻松的记忆，我们可以使用小数点分割编码地址。这就叫做Dotted-decimal notation。 比如说： 10000000 00001100 00000010 00011110 可以被写成： 128.12.2.30 无类域间路由（CIDR）第一种改进方法被叫做 无类域间路由 (Classless inter-domain routing, CIDR)。 他保留了netID和hostID的感念，但是取消了固定的结构，允许netID和hostID根据用户的需求划分边界。 实现该目标的简单方法是在地址后面添加一个8位后缀，指定netID的位数。 例如我们把后缀定义为21，这代表着21位会被用于netID使用，剩下的11位还允许指定211不同的hostID。 假如说这样的一串IP地址： 11000011000011000000011000001110/00010101 /后面的00010101代表着最高前21位被定义为netID。改写成Dotted decimal notation就是：195.12.6.14/21。 由你所见，CIDR不会使用最高位的前几位来定义IP地址是哪一类的。但是他确实会把存在的A,B,C类地址分别转化为后缀为8,16,24的IP地址一起使用。 子网子网是另一种解决这个问题的方法。通过对hostID搭建一个结构，我们可以更有效地使用hostID。 为了学习这一块儿知识，我们考虑一个中型组织的例子，其中大约有150名员工，每个人都有自己的一台PC。假设一共有六个部门的局域网，和一个总体的局域网，那么下图就给定了一个通过原始方案来通过局域网链接Internet的原理图。 该组织这下需要7个C级netID：每个局域网一个。每一个netID都指向一个局域网网关。每个局域网的netID由IPv4地址的前24个bits表示，剩下的8个比特位是hostID。这意味着在一个局域网中存在256个不同的host。 如果是在所有7个局域网中，可以确定一共由这些数目的host： 256 × 7 = 1792 我们提到过这个公司里面一共有150个个人工作站，因此有1642个IP地址未被使用。这些IP地址就被浪费掉了：因为其他组织也不会使用这些IP。 然而这个组织的子网解决方案只需要分配到一个C类netID即可。例如分配的IP地址可能是194.10.9.0到194.10.9.225之间，其中netID由前三个字节组成，分别用十进制数194,10,9表示。 子网现在通过定义构成hostID的256个代码的结构来工作。对于这个组织来说，一个明智的解决方案是使用前三位作为每个局域网的代码，其余五位作为每个工作站的代码。 下图展示了这种布局的示意图： 在因特网上，所有分配的IP地址都有一个指向路由器的netID，然后路由器就需要解释hostID，将数据通过网关传输到某个局域网上的适当工作站。工作站可以被这样识别： hostID 为 00001110可能是LAN0 (前三位是000) 上面的第十四个工作站 (第三位到第八位是01110) hostID为 01110000 可能是LAN3 (前三位是011) 上面的第16个工作站 (第三位到第八位是10000) 这样的话一共有256个IP地址，显然这个公司的150个工作站还剩下了106个未使用的IP的地址。这剩下的这些IP地址可以保留：为了公司后期的业务扩张而保留。 也就是说，原定需要6个netID的计划，如果使用子网结构，就只需要1个netID。空余出来的netID可以给其他的组织使用。 网络桥接 (NAT)网络地址转换 (Network address translation, NAT) 网络地址转换是将一个或者多个本地IP地址转换为一个或者多个全局IP地址，同时将全局IP地址转换为一个或者多个全局IP地址的过程，目的是为了为本地主机提供Internet访问。NAT通常是在WAN边缘路由器上实现的，用于实现核心站点，校园网，分支机构和托管站点的Internet接入。 在网络地址转换中，网络设备(通常是路由器或NAT防火墙)为私有网络中的一台或多台计算机分配一个公共地址。 网络地址转换(NAT)是一种将一个IP地址空间映射到另一个IP地址空间的方法，它通过修改数据包的IP首部中的网络地址信息，使它们在流量路由设备中传输。 NAT盒子在互联网上有一个可见的IP地址，所以说从互联网发送或者接收数据完全可以使用这个地址。在内部，IP地址就必须从一些范围内选择一个合适的IP地址作为每一个host的IP。 NAT解决了上述方案中内部网络无法连接到因特网的问题。 需要注意的是，每个地址可以被任意数量的不同的私有网络同时使用。NAT盒子中的接口安装了软件来检查每一个输入和输出的传输。在传入的传输被定向到了正确的内部地址之前，我们可以对他进行安全检查。查看下图的这些箭头，这代表着在内部的网络结构可以使用不同的网络形式来解决问题。 动态和静态IP地址之前提到：当用户希望与Internet建立连接时，该链接由ISP处理。这样的话，ISP就需要处理很多可用的hostID。然而,ISP就需要同时支持很多hostID。 幸运的是，对于ISP和个人用户来说，这些潜在用户中的许多人将不会参与互联网互动。 所以说ISP会给用户创建一个动态地址 (Dynamic IP-address)。当用户与互联网断开连接的时候，这个IP地址就会被释放掉，然后转让给另一个用户使用。 同样我们也可以向用户分配静态地址 (Static IP-address)。静态IP地址永远不会改变。如果用户准备支付额外费用的话，那么运营商就可以向用户提供静态IP地址。 IPv6IPv6不同与IPv4，它使用128位来表示IP地址，这样就一共允许2128个不同的IP地址存在。 所有的IPv6地址都是使用冒号隔开的十六进制来记录。代码被分解为16位一个部分，每一个部分都会使用4个十六进制数表示。 如下表所示： IPv6 address Comment 68E6:7C48:FFFE:FFFF:3D20:1180:695A:FF01 一个完整的IPv6的IP 72E6::CFFE:3D20:1180:295A:FF01 在IPv6中，:0000:0000:会被替换为:: 6C48:23:FFFE:FFFF:3D20:1180:95A:FF01 省略最开始的几个0 ::192.31.20.46 一个IPv4地址使用IPv6的形式表示 域名在互联网的日常使用中，用户需要识别特定的网页或者电子邮箱的网址。作为用户，没人喜欢记录一串复杂且不好记录的IP地址，所以我们发明了DNS (Domain name system) 域名服务(DNS)在1983年被发明，DNS服务向互联网主机分配一个可读的域名，并提供一个为单个域名查找IP地址的系统。 Domain name service (DNS): a hierarchical distributed database installed on domain name servers that is responsible for mapping a domain name to an IP address. Also known as domain name system. DNS系统被设置在一个分层的分布式数据库，并安装在覆盖整个互联网的大量域名服务器上。这些域名服务器以层次结构链接，强大的根服务器位于层次结构的顶端，支撑起整个互联网。 根服务器是可复制的，这意味着其所有数据的多个副本在任何时候都可以被保存。然后DNS name space会被划分成一些不重叠的区域。每一个区域都有一个主要的名称服务器，上面的数据允许二级服务器从里面读取数据。 DNS名称空间 (DNS name space)是在DNS中注册的所有域名的集合。 因此域名分层导致超过有250个通用顶级域名。如.com .edu 或者.gov。 域名包含在通用资源定位器 (Universal resource locator)中。它可以识别网页或者电子邮件地址。 一个域名是由它向上的路径命名的。比如说eng.cicso.com指的是.com顶级域名中.cisco中域的.eng子域。 通过域名来查找IP地址被称为“名称解析 (name resolution)”。对于这样的查询，一共有三种可能的结果： 如果该域名在被查询的服务器的控制之下，那么将返回一个权威的、正确的IP地址。 如果域名不在服务器的控制之下，如果IP地址存储在最近请求的地址的缓存中，仍然可以返回，但它可能已经过时了。 如果查询中的域是远程的，那么查询将被发送到根服务器，它可以提供适当的顶级域的名称服务器的地址。这反过来又可以为下一个低级域的名称服务器提供地址。这种情况一直持续到查询到达可以提供权威性IP地址的名称服务器。 第三章：硬件终于讲到硬件了 关于计算机计算机系统必须支持三个主要领域的作战能力： 处理数据 存储数据 输入 / 输出数据 一台计算机的核心是CPU (Central Processing Unit)。 数据的存储，输入与输出存储先来说存储把。 直接上表： 这些组件由上至下，属性的变化如下： 读写越来越慢存储空间越来越大尺寸越来越大造价越来越便宜 输入诶这个就很简单了，课本上给了如下几个例子 键盘键入 用一个指向性的设备 （人话就是鼠标，数位板这样的指向性输入设备） 手柄 扫描仪 麦克风阵列 （从以上提到的任何数据输入设备读取数据） 网络链路 输出和上面一样的清晰明了： 显示屏 打印机与绘图机 VR头显 （好像也属于屏幕没错吧） 扬声器 （写入以上提到的任何数据存储设备） 网络链路 嵌入式系统嵌入式系统 (Embedded system)是在较大的机械或电子系统中具有专用功能的计算机系统。它作为完整设备的一部分嵌入，通常包括电气或电子硬件和机械部件。嵌入式系统也可以在更大的系统中运行。系统可以是可编程的或具有固定的功能。 嵌入式系统存在与生活中的方方面面，例如: 消费类电子产品:数码相机、MP3播放器、DVD播放器和打印机。 家用电器:微波炉、洗衣机、冰箱。 医疗设备:心脏监测器、血糖仪和x光机。 汽车系统:发动机控制单元(ECUs)，安全气囊控制器和防抱死制动系统(ABS)。 工业自动化系统:可编程逻辑控制器(plc)，监控和数据采集(SCADA)系统，分布式控制系统(DCS)。 嵌入式系统被设计为在一个更大的机械或电子系统中执行一个特定的功能。它们通常是一个完整设备的一部分，包括电气或电子硬件和机械部件。 嵌入式系统被编程以执行它所设计的特定功能。例如，洗衣机中的一个嵌入式系统可能被编程为控制水温和旋转周期。同样，数码相机中的嵌入式系统可能被编程为控制快门速度和光圈。 内存组件随机存取存储器 (Random-access memory, RAM)和只读存储器 (Read-only memory, ROM)是计算机存储器的两种类型。 RAM是一种易失性存储器，在计算机运行时暂时储存数据。它被称为随机存取存储器，因为任何存储位置都可以被直接访问。RAM用于存储计算机需要快速访问的数据。 ROM是一种非易失性存储器，可以永久地存储数据。它被称为只读存储器，因为它只能被读取而不能被写入。它被用来存储那些即使在计算机关闭时也需要保留的数据。 RAM是易失性存储器，它暂时储存你正在处理的文件。它的速度比ROM快，可以被写入和读出。RAM用于存储计算机需要快速访问的数据。另一方面，ROM是非易失性存储器，永久地存储计算机的指令。它的速度比RAM慢。ROM用于存储需要保留的数据，即使在计算机关闭时也是如此。 Random-access memory (RAM): volatile memory that can be read from or written to any number of times. Read-only memory (ROM): non-volatile memory that cannot be written to but can be read from any number of times. 有两种一般类型的RAM技术。动态RAM (Dynamic random-access memory, DRAM)由易失电的电容 (capacitors that leak electricity)构成，因此需要定期充电(每隔几毫秒)以保持所存储数据的特性。 静态RAM (Static RAM, SRAM)由触发器 (Flip-flops)构成，当计算机系统打开时，触发器可以无限地存储数据。 ROM有专门的用途，用于存储数据或程序，这些数据或程序将不加改变地反复使用。在通用系统中，最重要的用途是存储bootstrap程序。这是一个在系统打开后立即运行的程序。在这样的系统中，ROM还有许多其他的用途，其中一些我们将在本书后面看到。此外，ROM被用于许多嵌入式系统。 ROM一共有四种类型： 一般来说，ROM中的程序或数据是作为制造过程的一部分安装的。如果需要不同的内容，必须更换芯片。 另一种选择是可编程ROM (Programmable ROM, PROM)。芯片的制造商向系统建造者提供芯片。系统构建者将程序或数据安装到芯片中。这允许系统构建者在提交整个批次被编程之前测试一些编程芯片的样本。与最简单的ROM一样，程序或数据一旦安装就不能更改。 一种更灵活的ROM类型是可擦除PROM (Erasable programmable ROM, EPROM)。已安装的数据或程序可以被擦除（使用紫外线），并可以安装新的数据或新的程序。 然而，这种重新编程通常需要将芯片从电路中移除。 最灵活的ROM类型是电可擦除式PROM(Electricity Erasable Programmable ROM, EPROM)。顾名思义，它的工作方式与EPROM类似，只是可以用电信号来删除现有数据。这有一个主要的优点，即当内容被改变时，芯片可以留在电路中。然而，该芯片仍作为只读使用。 缓存当数据必须从计算机系统的一个部分传输到另一个部分时，如果发送数据的速度比接收数据的速度快，就会出现问题。该问题的解决方案是使用缓冲区 (Buffer)。数据在传输到目的地之前先进入缓冲区。缓冲区的功能类似于一个队列，因此数据按照进入缓冲区的顺序出现。通常，缓冲区是在计算机内存中创建的。 Buffer: a temporary storage created for data transmitted from one part of the system to another which functions as a queue. 二级存储在讨论存储设备之前，我们应该介绍一些术语。对于任何硬件设备，无论是计算机系统的组成部分还是与之相连的外设，其运行都需要安装适当的软件。这个软件被称为“设备驱动程序”。这不应该与术语“驱动器”相混淆，特别是与存储设备相关联。 这一术语最初指的是硬件，即介质在物理上向其传输数据或从其读取数据。然而，就像经常发生的那样，这种区别经常被忽略。因此，例如，“hard disk”，“hard disk drive”或“hard drive”具有相同的含义。 磁性介质磁介质长期以来一直是文件存储技术的支柱。录音磁带的发明比计算机的发明早了许多年。因此，磁带是第一个存储设备。相比之下，硬盘是专门为计算机存储而发明的。硬盘也利用磁化来写入数据，它是在磁带首次用于存储几年之后出现的。 对于任何一种类型的磁性介质，与它的相互作用是由一个读头和一个写头控制的。磁头使用的基本物理定律是：磁化状态会影响电学特性，写头使用相反的规律。虽然它们是独立的设备，但两个磁头会合并为一个读写磁头。磁化的两种不同状态被解释为输入或输出。 磁盘的结构一般遵循这些特性： 磁盘里面有很多层盘。 每一层盘的两面都可以存储数据，读取或者写入。 盘的转动速度是一致的。 读写头被连接到驱动器臂上，驱动器臂允许读写头在盘片表面上移动。 每个读写头的运动与其他层读写头的运动同步。 在读写头与盘面之间有一层空气，防止磁头接触磁盘表面。 光学介质与磁带介质一样，光存储是由与计算系统无关的现有技术发展而来的。光盘(CD)演变成CD数字音频(CD-DA)，这成为CD-ROM中使用的技术。它被广泛用于分发软件，但还是无法所谓软盘的替代品。后来出现的读写版本(CD-RW)最终意味着CD完全可以替代软盘。然而，CD现在已经让位于DVD(最初是“数字视频光盘”，但后来改名为“数字多功能光盘”)。最新和最强大的技术是蓝光光碟(BD)。 光盘驱动器的设计原理图如下图所示。它可以读取波长为780纳米的红外激光CD或波长为680纳米的红色激光DVD。 我们可以忽略驱动器构造的细节，而专注于它如何运作的原理。从磁盘读取数据的过程的重要特性如下: 光盘有一条从表面的内端到外缘的螺旋轨道。 在读取数据的过程中，光盘会转动。 同时，激光会持续聚焦在螺旋轨道上。 光盘的表面凹凸不平，有坑(pits)和地(lands)。 发射的光线会从盘面反射。 坑反射与地反射之间的差异是可被检测。 探测器接收到的光的强度差可以解释为1或0，以便从光盘中读取二进制代码。 对于CD-RW和DVD-RW技术，光盘的反射面是由一种特殊的合金材料制成。当数据被写入光盘(“烧录”过程)时，这种材料会吸收激光所产生的热量使材料变为液体形式。根据激光强度的不同，材料冷却后会恢复成晶体或非晶态固体形式。当光盘读取时，激光从晶体固体反射而不是从非晶固体反射，从而允许编码为1或0。 固体介质尽管光学存储技术不断地改进，固态存储器一直是一个巨大的竞争对手。固态存储器的基础是 “闪存”存储器 (“Flash” memory)，这是一种没有运动部件（如硬盘的读写头）的半导体技术。 这样的电路由作为记忆单元的晶体管阵列组成，在这里常用的技术称之为”NAND”，因为其基本电路类似于NAND逻辑门。 所有的存储单元串联在一起，对存储器的写入和读取的操作是由 NAND闪存控制器 （NAND flash controller）。它的特别之处在于，存储单元块的内容可以“在瞬间”被全部删除。 此外，在将数据写入内存中的一个单元区块之前，必须将该区块内的所有内容先删除。一个内存块有很多好几页内存组成，在读取数据时，一次操作只可以读取一页数据。 最常使用的是在记忆卡 (Memory card)或USB闪存驱动器 (USB Flash drive, or Memory stick)。在后一种情况下，闪存被集成到一个设备中，该设备的内存芯片连接到一个标准的USB连接器。这是目前可移动数据存储的技术选择。由于诸如相变随机存取存储器(PRAM)等替代技术已经在开发中，这种USB闪存技术一统江山的现状会持续多久尚不确定。 固态硬盘 (Solid state drive, SSD)是现在市面上很常见的存储产品。由于固态硬盘没有移动部件，像机械硬盘那样的读写头，很多人认为固态硬盘的存储完全可以伴随我们一辈子。 但实际上不是这样的。 随着我们对固态硬盘的使用，里面的内存颗粒会慢慢退化，进而丢失数据。不过好消息是我们有方法可以检测出有问题的部分并加以修正。 SSD与传统硬盘相比最大的优点就是读取速度超快。 通用输出设备显示在第1章我们讲述了如何将图像存储为由像素构成的位图(bitmap)。屏幕显示也是基于像素的概念，但有一个主要的区别。一个屏幕像素由三个子像素组成，通常分别代表红、绿、蓝。通过改变各个子像素发出的光的水平，可以显示出全范围的颜色。 显示技术这几年迭代的速度十分的快。 在最初的阴极射线管(Cathode ray tube ,CRT)技术中，每一个像素没有单独的组件支撑起发光的任务。屏幕的内表面覆盖着荧光粉，当电子落在这种荧光粉上时候屏幕就会发光。通过控制电子束的方向，来点亮特定的像素。彩色CRT显示器有独立的红色、绿色和蓝色荧光粉，以像素阵列排列。 现在，平板显示技术占据市场的一大半。以液晶显示技术 (Liquid-crystal display, LCD)为例：它使用包含液晶的单个单元来创建每个像素。像素矩阵由一个统一的背光 (Backlight)来照明，每个像素都可以控制光的传输，从而创建屏幕上的图像，如下图所示： 背光照明通常由发光二极管(LED)提供。偏振光会指向像素矩阵，并且在像素矩阵和屏幕之间放置更多的偏振器。如果电压施加到单个像素单元，就会影响液晶分子的排列，然后改变光的偏振光，从而改变屏幕上显示的内容。 Liquid-crystal display (LCD): a screen back-lit by light-emitting diodes and with liquid crystal cells sandwiched between polarisers. 文本输出有两种技术已经开始主导从计算机系统中存储的数据打印文档。这些是喷墨打印机 (Inkjet printer)和激光打印机 (Laserjet printer)。这两种技术都可以用于打印文本或图像。 喷墨打印机的工作原理如下: 填入一张纸 打印头在纸上移动，将墨水打在纸上 纸张向前移动一点位置，打印头再次在纸上移动。 这个过程一直持续到纸张完全打印出来。 打印头由喷嘴组成，将液滴喷在纸上。墨水从一个或多个墨盒供应到打印头。 激光打印机的步骤就相对复杂些了： 给硒鼓施加一个电荷。 硒鼓开始旋转。 在每一个步骤中，激光束被镜子和其他光学组件引导到硒鼓上的不同位置。 被激光照射到的硒鼓表面会使得电荷存在或者剥离。 这个过程重复执行，直到整个硒鼓上面产生了完整的静电图像。 硒鼓被涂上一层带电的碳粉，这些碳粉只粘在硒鼓表面被释放电荷的位置。 硒鼓在一张赋予电荷的纸上面移动。 最后将纸张排出的同时，使用加热过的轮子来融化碳粉，是的碳粉融合，形成图像。 在打印下一张文件之前，硒鼓上面的电荷会全部被排掉。 通用输入设备键盘允许用户输入文本数据。在文本输入过程中，似乎只要按下一个键，就会立即将相应的字符传输到计算机屏幕上，但这是错误的。按键必须先转换为字符编码(Character code)，然后传输给处理器。随后，处理器会在操作系统的控制下，确保文本字符在屏幕上显示。如果使用键盘发起某些操作，也会发生相同的过程，例如使用快捷键组合。不同之处在于，处理器必须采取所请求的操作进行响应。 为了实现这个功能，键盘有电路和它自己的微处理器和ROM芯片。键盘如何工作的重要细节如下： 按键位于按键矩阵 (Key matrix)的正上方。按键矩阵由一组行列导线组成。 按下一个按键后，按键会与导线产生接触，这就会使得行列导线连通，从而允许电流通过。 随后，微处理器会不断地检测是否存在电路闭合。如果电路闭合，那么微处理器就可以识别出哪里出现了电路闭合。 然后，处理器使用存储在ROM中的数据来识别与该交叉点相关联的字符代码，然后将这个字符发送给计算机。 GUI通过与屏幕的交互，用户可以通过多种方式输入数据。很久之前，计算机系统用户只能使用键盘和鼠标向电脑交互，然后使用屏幕作为显示器。而且当时的UI十分的简陋，用户的屏幕上只能生成一个菜单，用户可以通过从菜单中输入一个数组来选择一个选项。 随着图形化用户界面 (Graphical user interface, GUI)的普及，用户使用计算机的体验又更上一层楼。具体就是今天的所有图形化操作系统一样，直观，易操作。 触摸屏触摸屏有两种：电阻式触摸屏 (Resistive touch screen)和电容式触摸屏 (Capacitive touch screen)。 电阻式触摸屏的上层屏幕不是刚性的，所以当手指按压屏幕的时候，屏幕会发生弯曲。这种弯曲就可以被下层检测出阻值的变化，从而推算出手指触摸的位置。 但是电阻式触摸屏有一个显著的缺点：他只能支持单点触控，也就是说，只允许同时出现一个物体触控屏幕。 另一个是电容式触摸屏。它运用了“人体本身是一种带电体”的原理实现了触摸屏。电容式触摸屏不再需要一个软皮屏幕作为表面了，因为当你的手指触碰屏幕的时候，下层的电路元件会检测到电容的变化。 现在最有效的触控技术是基于互电容的投射性电容触控(Projective capacitive touch, PCT)技术。这种技术允许我们在屏幕上多点触控。 Resistive touch screen: a flexible surface that causes contact between electricity resistive layers beneath when touched. Capacitive touch screen: a grid surface above a conductive layer that undergoes a change in electrical state when a finger touches the screen. 影像输入在计算机中存储和使用图像(图形)数据有几种方法。网络摄像头 (Webcam)是一种用于将视频图像流式传输到计算机系统的设备。数码相机 (Digital camera)可以连接到电脑。当链接到电脑时，储存的图像或视频就可以下载到电脑上。 另一种选择是使用扫描仪 (Scanner)。 实际上，扫描仪颠倒了打印过程，它获取图像并从图像中创建数字表示。首先一张包含图像(可能是文本)的纸被固定在一个固定的位置，光源从纸的一端移动到另一端。它覆盖了纸张的宽度。反射光被一个由镜子和透镜组成的系统引导到一个电荷耦合器件(Charge-coupled device, CCD)上。随后CCD就会向计算机发送数据。 你需要了解下面这些有关于CCD的有趣事实： CCD由光敏单元阵列组成 CCD产生的电响应与每个电池的光强成正比 CCD需要一个模数转换器 (Analogue-to-digital converter)来产生数字值并传输到计算机。 声音的输入与输出语音输入输出IP电话 (IP Telephony)和视频会议 (Video conferencing)是两种同时需要语音输入和语音输出的应用。此外，语音识别可以作为输入数据到计算机的替代技术，而语音合成正被用于越来越多的应用。 我们需要一个麦克风 (Microphone)来完成声音的输入，这是一种带有隔膜的设备。麦克风中有一种柔性材料，它会因传入的声音而振动。如果膜片连接到合适的电路，振动会引起电信号的变化。电容传声器采用电容变化作为机构;另一种选择是使用压电晶体。模拟电信号通过模数转换器 (ADC)转换成数字信号，以便在计算机内部进行处理。 同样我们需要一个扬声器 (Speaker)完成音频输出工作。它的工作原理实际上是输入的反向过程。 来自计算机系统的数字数据通过数字模拟转换器转换为模拟。模拟信号以变化的电流的形式供给扬声器。在大多数扬声器中，电流流过一个线圈，线圈悬浮在扬声器中永磁体提供的磁场中。随着电流的大小和方向不断变化，线圈向前和向后移动。这种运动控制着隔膜 (Diaphragm)的运动，然后隔膜会产生声音。 第四章：逻辑门与逻辑电路布尔逻辑与问题陈述这里有一条陈述： 俄罗斯比新加坡更靠北吗？ 无论这是不是一个低智商问题，他只有两个答案：是或者不是。放在布尔值里面就是TRUE和FALSE。 我们现在分别假设了以下两个陈述： 如果天气预报说一会下雨或者现在正在下雨，你就应该出门带伞。 只有在工作时间中并且屋内气温高于25°C，才可以开启空调。 像这样的陈述，我们管他叫做问题陈述： Problem statement: an informal definition of an outcome which is dependent on one logic proposition or a combination of two or more logic propositions. 问题陈述：依赖于一个逻辑命题或者两个以上逻辑命题组合的句子。 布尔运算器三个基本的布尔运算器分别是AND， OR和NOT。 简单说下每一个的表述，A与B都存在两个情况：TRUE或FALSE AND：若A为TRUE，B也为TRUE，则A AND B输出为TRUE。 OR：A或者B两者有一个TRUE，则A OR B输出为TRUE。 NOT：如果A为FALSE，则NOT A为TRUE 像这样，我们在上一个小节中列举的例子就可以使用布尔运算器符进行表示了： Take_umbrella = TRUE IF (raining = TRUE) OR (rain_forecast = TRUE) AC_on = TRUE IF (office hours = TRUE) AND (temperature &gt; 25) 现在我们陈述的问题已经变成了像这样的条件语句。我们管这种语句叫做逻辑表达式： Logic expression: logic propositions combined using Boolean operators, which may be equated to a defined outcome. 逻辑表达式：使用布尔运算符组合的逻辑命题，可以推出一个确切的结果。 任何逻辑表达式都可只使用布尔运算AND, OR和NOT表示，但是只用他们三个就有些麻烦，不如使用一些其他的布尔运算：NAND,NOR和XOR NAND:如果A是FALSE或者B是FALSE，则A NAND B输出为TRUE。 NOR:若A为FALSE，B也为FALSE，则A NOR B输出为TRUE。 XOR:如果A是TRUE或者B是TRUE，而且两者都不能同时是TRUE，A XOR B会输出为TRUE。 等到了学逻辑门的那一节，我再画一个汇总表格。 真值表真值表简单又强大，可以用来表示任何逻辑表达式或者描述逻辑电路的可能输出结果。 在真值表内，我们将TRUE定义为1，FALSE定义为0。这样可以很简单地表示出有关布尔运算的任何逻辑。 真值表中的表头分A，B和X。A列和B列代表最初开始的值，而X列则代表经过逻辑运算之后得出的值。也可以通过一个等式表示：X = A AND B。 这里我们以AND作为一个例子： A B X 0 0 0 0 1 0 1 0 0 1 1 1 逻辑电路与逻辑门构成计算机系统的内部电路都由逻辑电路运行。这些电路的每个状态要么就是开，要么就是关。（1和0） 逻辑电路由一个叫做逻辑门的部件组成，每一个不同的逻辑门都对应着一个布尔运算。 Logic gate: a component of a logic circuit that has an operation matching that of a Boolean operator. 逻辑门都有他们自己的符号，下图展示了每种逻辑门所对应的布尔运算，图标，和真值表。 特别提及以下几点： NOT门是一个特例，由于他的输出是他的输入的相反值，NOT只有一个输出。 NAND门实际上是AND门紧接着跟了一个”NOT”。 NOR门实际上是OR门后面跟了一个”NOT”。 NAND和NOR门产生了与AND和OR一样的互补输出。 XOR是比较输入的两个数据是否不同。相同输出0，不同输出1。 如果想要从真值表构建逻辑电路，我们首先要创建逻辑表达式。要做到这一点，我们只需要看看真值表里面输出为1的行。 A B C X 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 0 我们发现表格中有三行的输出为1，这三行分别是： A = 0, B = 0 and C = 1A = 0, B = 1 and C = 1A = 1, B = 0 and C = 0 以上三行中出现的and不代表逻辑运算 每一行都可以转换成这样的逻辑表达式： NOT A AND NOT B AND CNOT A AND B AND CA AND NOT B AND NOT C 然后再将这三行结合起来： 1234NOT A AND NOT B AND CORNOT A AND B AND COR A AND NOT B AND NOT C 现在这个结果就可以用于创建逻辑电路了，但是这个电路是非常复杂的。在后面的第19章，我们会去讲解如何在指定逻辑问题下写出最简便的电路。 第五章：处理器基本原理冯·诺依曼结构初中小宝宝都知道的基本知识： 冯·诺依曼是第一位解释计算机基本结构原则的人。 符合冯·诺依曼结构 (von Neumann model) 的计算机符合以下几个条件： 处理器 （CPU） - 负责处理数据 处理器可以直接访问内存 处理器按顺序执行指令 内存包含一个“s存储程序 (Stored program)”和该程序所需的数据 ‘存储程序’可以在任何时候被另一个程序替换 存储程序由独立的指令组成 中央处理器（CPU）的结构中央处理器 (Central Processing Unit),简称CPU。 结构图示如下： 然后我们拆开讲解： CPU的活动部分CPU的主要活动部分有两部分： Arithmetic Logic Unit (ALU) ：算术逻辑单元 算术逻辑单元是中央处理器的执行单元，进行整数运算的结构。这是个能实现多组算术运算和逻辑运算的组合逻辑电路，是所有中央处理器的核心组成部分。用逻辑门构成的算数逻辑单元，主要进行二位元的算术运算，比如说加减乘。（没有整数除法） Control unit : 控制单元 控制单元负责程序的流程管理，是整个CPU的指挥和控制中心。 由三个部件组成： Instruction Register (IR) ： 指令寄存器Instruction Decoder (ID) ： 指令译码器Operation Controller (OC) ： 操作控制器 基本功能是从内存取指令、分析指令和执行指令。 在控制单元内有一个重要部分，那就是时钟。控制单元通过时钟来同步处理过程。 时钟分两种： Internal clock 和 System clock Internal clock: controls the cycles of activity within the processor. System clock: controls the cycles of activity outside the processor. Internal clock控制处理器内活动周期。System clock控制处理器外部活动。 寄存器Register，叫做寄存器 寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。之前提到过，寄存器在所有的存储单位里面，与CPU的交互是最快的，造价也是最高的。因为寄存器的位置挨着ALU （算术逻辑单元），所以的读写速度会比较快。寄存器的存储空间都很小，差不多就16、32或者64bits。 寄存器有通用的(General purpose)，也有专用的(Special purpose)。如果只存在一个通用寄存器，我们会称其为累加器 (Accumulator)。 Accumulator: a general-purpose register that stores a value before and after the execution of an instruction by the ALU. 上面说：累加器一种通用寄存器，会在ALU（算术逻辑单元）执行指令之前和之后存储一个值。或者说：累加器是一种寄存器，用来储存计算产生的中间结果。 如果没有累加器的存在，在每次进行一次计算（加法，乘法，移位等）之后都会把结果写进内存，即便这个结果会马上在接下来的一个运算中直接使用。这样就太慢了。 专用寄存器也各不相同。下面这张表列出了一些专用寄存器。 Register name(寄存器名称) Abbreviation(缩写) Register’s function(功能) Current instruction register(当前指令寄存器) CIR Stores the current instruction while it is being decoded and executed.(在对当前指令进行解码和执行时存储该指令) Index register(变址寄存器) IX Stores a value; only used for indexed addressing.(可以存储一个值，而且只用于索引寻址) Memory address register(储存器地址寄存器) MAR Stores the address of a memory location or an I/O component which is about to have a value read from or written to.(存储即将对其进行读取或写入的内存位置或I/O组件的地址) Memory data registermemory buffer register(内存资料寄存器) MDR Stores data that has just been read from memory or is just about to be written to memory.(存储刚从内存中读取或者即将写入内存的数据) Program counter(程序计数器) PC Stores the address of where the next instruction is to be read from.(存储从哪里读取下一条指令的地址) Status register(状态寄存器) SR Contains bits that are either set or cleared which can be referenced individually.(用来存放指令招待后的有关CPU的状态) 系统总线System bus,又名曰系统总线。不过我们需要先理解什么是总线(Bus)。 总线是连接多个部件的信息传输线，是各部件共享的传输介质。而系统总线，是CPU、主存、I/O设备各大部件之间的信息传输线。 系统总线分为三部分：地址总线 (Address bus)， 数据总线 (Data bus) 和 控制总线 (Control bus): CPU，内存和I/O与这三部分的总线的关系如下图所示： 接下来一个一个说这些总线都是写啥。 地址总线定义： Address bus: a component that carries an address. This can be to the memory controller to identify a location in memory which is to be read from or written to or it can be to the I/O system to identify the source or destination of the data. 地址总线 (Address bus)：用来指出数据总线上的源数据或目的数据在主存单元的地址或I/O设备的地址。 地址总线的唯一功能是携带地址。 当控制单元给到了一个命令后，地址会从MAR（储存器地址寄存器）中加载到总线上。一个地址制定了内存中的一个位置，或者一个待接受的数据，亦或者是从中读取数据的一个I/O组件。 地址总线是单向的，所以说它只能向内存控制器 (Memory controller)或者I/O控制器 (I/O Controller)发送地址，不能用于将地址传回到CPU。 地址总线的带宽定义了地址的二进制代码中的位数。以一个很基础的计算机系统为例子：总线带宽是16位，因此它允许65536个 (216)内存位置被直接寻址。 不过对于现代计算机系统来说，这点儿内存是完全不够用的：即便将地址总线的宽度增加到32位，也仅仅允许40多亿个地址进行直接寻址。 因此当内存容量比直接寻址大得多的时候，我们会使用到一些特殊技巧。 数据总线 Data bus: a component that can carry data from the processor to the memory or to an output device or can carry data from the memory or from an input device. 数据总线 (Data bus)：用来传输各功能部件之间的数据信息。 数据总线的功能是传送数据，传输的数据可以是指令，地址，也可以是一个确切的值。 数据总线是双向的(Bidirectional)，这意味着它可以将数据从CPU传输到内存，也可以从内存传输到CPU。同样的，数据总线也可以选择将数据传入I/O设备，或者从I/O设备传出数据。 在上面的那张图里面，没有明确表示出从输入设备发来的数据是先传输到CPU还是存储器里面，这么做是有依据的。比如：部分计算机系统只允许数据存储在内存之前输入CPU，也有的系统允许数据直接传输到内存。 控制总线控制总线 (Control bus)： 用来发出各种控制信号的传输线。 书上没有定义 控制总线的主要用途是传送定时信号。控制总线以时钟周期规定的时间间隔，传输定时信号，这就确保了一个组件传输数据的时间和另一个组件读取数据的时间同步。 数据总线也是双向的(Bidirectional)，数据总线将信号从控制单元传输到任何其他的系统部件，或者将信号传回到控制单元。 数据总线没啥必要拓宽带宽，所以数据总线一般有八条导线。 左右系统性能的因素首先是处理器时钟速度。 处理器时钟速度可能是决定系统处理速度的一个重要因素。因为一个时钟周期定义了任何操作可以采取的最短时间。但是“可能是”也是有原因的，因为并不是所有的部件都可以像CPU那样飞速计算。 因为这个问题，一个现代的CPU的结构远比我们讨论的CPU结构复杂。比如说，现在的CPU基本都是多核的，每一个核都是一个单独的处理器，CPU性能也会随着核心数量的增加而增加。而且现代CPU的高速缓存一般都全部封装在CPU的内部，因此达到最快的访问速度。 在继续下面的内容之前，我们需要了解什么是字。 字没错，这东西就叫字。 Word: a small number of bytes that can be handled as a unit by the computer system. *一个小的字节数,可以由计算机系统作为一个单元处理 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字 (Word)。计算机的每个字所包含的位数称为字长。 一个字通常由一个或多个（一般是字节的整数位）字节构成，计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。 多多少少与你操作系统的位数有关，典中典的字长，有16、32或者64位，分别是2、4、8字节。 字长将会影响组件存储容量和架构方面的设计。比如说，寄存器的大小一般都会与字长匹配，字长也会影响总线带宽。 I/OI/O，全称(Input/Output)，代表输入/输出。 我们一般指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。 每一个I/O设备都会被连接到一个叫做“端口”的接口，每个端口都连接到I/O或者设备控制器 (Device controller)。 顺带一提设备控制器 (Device controller)负责处理CPU和I/O设备之间的交互。 如果连接的I/O设备是计算机系统的一个组成部分，我们就将连接它的端口叫做内部端口。反之，连接其他外围I/O设备的端口，叫做外部端口。 USB简单说下USB。 USB，全程 Universal Serial Bus,译为通用串行总线。现在你可以在几乎任何设备上见到它。 USB的出现至关重要。在USB诞生之前，普通用户一般不会去尝试添加外设，因为当时添加外设需要一定的技术知识。 USB的出现推动了即插即用技术的发展，即插即用技术诞生的目标就是消除人们对于技术水平的需求，所以任何计算机用户都可以连接他们需要的外设。即插即用只有通过创建USB标准才能实现。 *USB是一条总线，USB驱动器存储数据并连接到USB端口，USB端口允许数据沿着总线传输。 专用多媒体端口这也不代表着所有的外部设备都使用这USB作为数据传输的媒介：一些特定的设备需要特定的接口。 在几年之前(HDMI还不算流行的日子)，投影仪或者显示器之类的设备选择使用VGA (Video Graphics Array : 视频图形阵列)接口进行连接，传输视频流。 而现在，这类设备都基本采用的DP(Displayport)接口或者HDMI(High Definition Multimedia Interface : 高清多媒体接口)接口，其中一个原因是VGA并不支持传输音频数据。 指令周期指令周期，又名读取－执行周期 (fetch-and-execute cycle)，指的是CPU要执行指令需要经过的步骤。 计算机之所以能自动地工作，是因为CPU能从存放程序的内存里取出一条指令并执行这条指令；紧接着又是取指令，执行指令，如此周而复始，构成了一个封闭的循环。除非遇到停机指令，否则这个循环将一直继续下去。 下图展示了一个指令周期的结构： 图中，我们假设程序已经在运行。所以程序计数器就会找到下一条指令的地址。 在提取阶段，会执行以下步骤： 首先，下一个指令的地址会存在程序计数器(Program counter，可写作PC)中。这个地址会先被传送到MDR(Memory address holder)中。 随后处理器开始工作。 在下一个时钟周期内，这两件事会同时发生： 在MAR所指向的地址中保存的指令被提取到MDR(Memory data register)中 程序计数器(Program counter)中存储的地址+1。 然后在MDR中存储的指令会在CPU中传输到CIR(Current instruction register)这里需要注意两点： 时钟周期是由系统时钟控制的周期。系统时钟将有设置，允许在为一个周期定义的时间内从内存发生一次数据传输。 在最后一步中，程序计数器会加一。但是如果刚才加载的指令是一个跳转指令，程序计数器就必须根据跳转条件更新程序计数器的内容。这一步只会在指令被解码之后发生。 在解码阶段，存储在CIR中的指令就会作为输入内容，被控制单元内的电路读取。根据指令的类型，控制单元会向适当的组件发送信号，准备开始执行阶段。在执行阶段内，如果指令需要算数或者逻辑处理，就会把ALU拉下水。 寄存器传输语言寄存器传输语言 (Register transfer notation)，表示了寄存器数据传输操作和各模块内部和模块之间连接关系的记法。 涉及到寄存器的操作可以通过这种语言描述。举个例子，一个完整的指令周期的fetch阶段可以被这样表示： MAR ⬅ [PC] PC ⬅ [PC] + 1; MDR ⬅ [[MDR]] CIR ⬅ [MDR] 在寄存器传输记法中，单个数据传输的基本格式与变量赋值的格式相似。 箭头左边的那一项是数据的目的地，这里使用适当的缩写来标识特定的寄存器。箭头右边是那个数据的定义。在这个定义中，寄存器缩写周围的方括号表示正在移动寄存器的内容，这个动作也可能包括一个算术运算。当两个数据操作放在由分号分隔的同一行上时，这意味着两个传输同时进行。第二行的两对方括号需要注意下：MAR的内容是一个地址;它是该地址的内容，正在被转移到MDR 两队方括号代表CPU必须进行一个逻辑处理，然后才能复制该值。 中断处理计算机有很多情况会产生中断。比如说： 程序中的一个严重错误 硬件问题 等待I/O开始处理数据 用户交互 一个计时器信号 在产生了中断后，我们需要处理这些发生的中断。每一个不同的中断需要进行合适的处理，不同的中断还会有不一样的优先级，因此，处理器就必须具备判断中断类型的能力。 在处理器中加入一个中断寄存器可以是一个方法。它的工作方式与状态寄存器很相似：每一个单独的bit都作为特定类型中断的标志。 第六章：汇编语言程序设计机器码操作码与操作数在深入了解什么是机器码之前，我们需要先了解什么是操作码和操作数。 Opcode: defines the action associated with the instruction 操作码:定义与指令相关联的操作 操作码指计算机程序中所规定的要执行操作的那一部分指令或字段。其实就是指令序列号，用来告诉CPU需要执行哪一条指令。 指令系统的每一条指令都有一个操作码，它表示该指令应进行什么性质的操作。不同的指令用操作码这个字段的不同编码来表示，每一种编码代表一种指令。组成操作码字段的位数一般取决于计算机指令系统的规模。 Operand: defines any data needed by the instruction 操作数：定义指令需要的任何数据 操作数指出指令执行的操作所需要数据的来源。操作数是汇编语言指令的一个字段。 机器码所以说什么是机器码？ Machine code instruction: a binary code with a defined number of bits that comprises an opcode and, most often, one operand 机器指令码(Machine code instruction):由一个操作码和一个操作数(通常是一个操作数)组成的二进制代码 机器码是机器指令码的缩写。 一开始，我们用机器码来编写程序，称之为机器语言。机器语言虽然能够被计算机理解和接受，但毕竟根人话完全不擦边，不易被人们理解和记忆，并且用它编程容易出差错。所以，我们用助记符 (mnemonic) 代替机器码，从而形成了汇编语言。这让指令容易理解和记忆，而且便于交流。 在继续下面的内容之前，我需要列举几个事实中的事实： 在所有语言里面，CPU只认机器码 (Machine code) 机器代码由一系列指令组成 一条指令中包含一个操作码 (opcode) 一条指令可以没有操作数 (operand)，但最多可以有三个操作数 不同的处理器有不同的指令集 对于相同的操作，不同的处理器会有类似的指令，但是指令的编码是不同的。 对一个特定的处理器来说，每个单独的机器码指令都必须定义了以下内容： 整个指令的总比特数或字节数 定义操作码的位数 (number of bits that define the opcode) 在剩余位 (remaining bits) 中定义的操作数的个数 操作码占用最高有效位 (most significant bits) 还是最低有效位 (least significant bits) 操作码所需要的位数取决于处理器指令集中不同操作码的数量。操作码可以由定义操作的前几位和与寻址相关的剩余位构成。下图展示了简单处理器的合理指令格式： 一条指令由两部分组成：操作码和操作数操作码长度为8位，其中有4位用来记录操作，2位用于记录地址类型，剩余的位数交给寻址寄存器处理。此操作码将占用指令中的最高有效位。因为在某些情况下操作数会是一个内存地址，给它分16位可以与地址总线的位数一致。 当一条指令到达CPU的时候，控制单元会先检查操作码，来解析这一条指令定义了什么操作。这一步在指令周期内属于解码步骤。它可以使用上一张学过的寄存器传输语言进行描述，但是需要进行一些小小的修改。 CU ⬅ [CIR(23:16)] 这一行表示了16到23位之间的数据(表示的是操作码)从当前指令寄存器中传输到控制单元。 p.s.上面图片中一串命令一共有24位。我们从左边数第一个位，记为第0位，同理可得最后一位是第23位。如果命令中大位在前小位在后，代表位数是从后往前数同样的，小位在前大位在后，代表位数是从前往后数 汇编语言程序员们希望能够编写一种程序，这种程序可以直接控制处理器的一举一动。有些人认为这是最有效的程序类型，但是作为一个正常人用机器码程序会把你累个半死，因为这样的程序确实难写，很抽象的。因此将一个实质性的程序以机器码的形式来进行编写就会花费很长很长的时间，并且人在编写这种语言的时候会经常犯错，因为机器码和人类语言相差的太远了。针对这种编程需求，汇编语言是最好的解决方案。除了具有唯一定义的机器代码语言之外，每个处理器都有自己的汇编语言。 Assembly language: a low-level language related to machine code where opcodes are written as mnemonics and there is a character representation for an operand 汇编语言 (Assembly language) :是一种与机器码有关的低级语言，其中操作码被写成助记符 (mnemonic) 形式，并且操作数用字符表示 低级语言的低级不是说它有多拉跨，而是指汇编语言比较接近硬件底层。 在汇编语言中，我们用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 Assembler: a program used to translate an assembly language program into machine code 汇编器 (Assembler) :用来把汇编语言程序翻译成机器代码的程序 如果用汇编语言写出一个程序，他必须要被翻译成机器码才能够被CPU执行。翻译的活就是汇编器干的。 一般而言，汇编生成的是目标代码，需要经链接器（Linker）生成可执行代码才可以执行。作为一门语言，对应于高级语言的编译器，需要一个“汇编器”来把汇编语言原文件汇编成机器可执行的代码。 把半人话翻译成电脑话 汇编语言的本质是，对于每条机器代码指令，都有一条等价的汇编语言指令，其中包括: 操作码的助记符(符号缩写) 操作数的字符表示形式 汇编语言的优点比较明显，比如说对程序员来说，汇编语言相比机器码写起来要更加容易。此外，汇编语言还允许程序员们做一些机器码无法做到的事情，比如说： 做注释 用符号做变量名 地址标签 宏命令 指令 (Directives) 这里的指令告诉汇编器如何构造最终可执行机器代码的指令。而宏命令是代表程序中要多次使用的一系列指令。有点像鼠标宏：记录鼠标移动信息之后，按某个键触发后回放此路径。 寻址类型有如下几种寻址类型： Symbolic addressing: 符号寻址Relative addressing: 相对寻址Absolute addressing: 绝对寻址 当考虑汇编程序是如何将汇编语言程序转换为机器码是，我们很有必要去了解下他们之间的区别。我们假设有这样一个汇编程序，它的目的就是把键盘上输入的单个数字相加。我们会在接下来的文章内反复使用这个例子！所以说好好看看这个程序是很有必要的（ 下表左侧分步骤描述了一个使用符号寻址编写的汇编程序，以及对每条指令的解释： 使用符号寻址的汇编程序 命令 (助记符+参数) 命令解释 IN 这一步通过键盘输入一个数字，并将它的ASCII码存入进累加器中 SUB #48 这一步是减法运算，将ASCII码转换成二进制 STO MAX 声明一个地址，名称为MAX，将累加器中的数字存储进去 LDM #0 向累加器中添加0 STO TOTAL 将累加器中的这个0存入一个地址，名称为TOTAL STO COUNT 将累加器中的这个0存入一个地址，名称为COUNT STRTLP :IN 再次通过键盘输入一个数字，并将它的ASCII码存入进累加器中 SUB #48 这一步是减法运算，将ASCII码转换成二进制 ADD TOTAL 将地址为TOTAL的值与累加器中的值相加，并将总和存储在累加器中 STO TOTAL 然后再把累加器中的数据存入名叫TOTAL的地址中 LDD COUNT 将存储在地址COUNT的值加载到累加器中 INC ACC 向累加器中加1 CMP MAX 比较累加器中的值与存储在地址MAX中的值 JPN STRTLP 如果比较值不相等，程序会跳转回标记为STRTLP的指令 END 程序结束执行 MAX: 一个可以存储值的标记地址 TOTAL: 一个可以存储值的标记地址 COUNT: 一个可以存储值的标记地址 其中有几行需要格外解释下： LDM (Load much): 多数据加载,将地址上的值加载到寄存器上 按照惯例：标签的后面会写有冒号，但是引用标签的时候需要去除冒号。 使用符号寻址可以让程序员使用汇编语言代码，而不需要担心程序运行的时候代码在内存中的位置。编写汇编代码也可以将符号寻址替换为相对寻址或绝对寻址。 下表显示了上面那个表格中使用这些替代方法转换后的简单代码： 你可能发现在相对寻址改写的程序中，有[BR]这个东西。这里我们假设有一个基址寄存器 (base register)，包含程序基址。程序基址是程序中第一条指令的地址。 查看上图的例子：使用绝对寻址的程序的第一行代码的地址是200，所以BR中存储的基址为200。调用基址寄存器中的内容，可以使用[BR]。 两步汇编程序的汇编过程对于任何汇编程序，在进行任何转换之前，都必须对汇编语言代码进行许多处理。比如说： 移除注释 用构成宏定义的指令列表替换指令中使用的宏名称 删除和存储稍后要执行的指令 我们在寻址类型章节里面设计了一个汇编程序，这个程序内包括了向前引用。有些指令有操作数的符号地址，但在程序的那个阶段，我们不知道这个地址的位置。需要一个两遍汇编程序，以便在第一遍中确定前向引用的地址的位置。 为了在第一次传递期间实现这一点，汇编程序使用了一个符号表。代码是逐行读取的。当一个符号地址第一次遇到时，这个名字就会被输入到一张符号表中。在名称旁边，必须尽快添加一个相应的地址，以便识别。 下表给出了针对寻址类型章节中那个程序创建的符号表。 Symbol Offset MAX +15 TOTAL +16 COUNT +17 STRTLP +7 请注意，汇编程序在读取代码时必须对指令进行计数。当它遇到一个标签时，汇编程序可以将偏移值(offset)输入到符号表中。 用人话来讲就是数顺序来让处理器确定自己读的是哪一行代码。把程序的开始设为偏移值为零，则IN这个操作有+1的偏移量，有STRTLP的那一行机器码的偏移量是+7 在第二步中，汇编程序会使用符号表(symbol table)和一个查找表(lookup table)，表格中包含每个操作码的二进制代码。每一个处理器定义过的操作码，在这个表里都可以找到对应的信息。 下表列出了我们举的例子中使用的指令对应的条目。需要注意的是：这里的二进制代码是对于待使用代码的一个建议。 如果不出意外的话（比如说汇编发生错误），那么第二遍的输出就是机器码程序了。下面这个表格将原始汇编代码和编译好的机器码程序列在了一起，我们可以简单比较一下： 有以下几点需要简单注意下： 大多数的指令都有一个16位二进制数的操作数。 通常来说这表示一个地址，但对于SUB和LDM指令，操作数会被用作一个值。 IN和END指令没有操作数。 INC指令是一个特例。汇编语言代码中存在操作数，但它只用来定义寄存器。在机器码中，寄存器是在操作码中标识的，因此就不需要操作数了。 在编译机器码的时候，第一个步骤会占用第零个地址。 像这种形式的代码是不可执行的，但它却是汇编程序的一个有效输出。 当程序加载到内存中准备执行时，就需要把地址稍微改改了。 程序代码之后的三个内存位置将会分配为零，以确保程序执行后可以正常使用它们。 寻址模式当一条指令需要将一个值加载到寄存器中时，我们有不同的方法来识别该值。其中的每一种都被称为寻址模式 (Addressing mode)。 顺带附上寻址模式的定义： Addressing mode: when the instruction uses a value this defines how the operand must be used to find the value. *当指令需要使用一个值时，寻址模式定义了如何使用操作数来查找这个值。 在本单元的开始就说过：对于一个简单处理器，机器码指令中的操作码位将用于定义寻址模式。加起来一共允许有4种不同的寻址模式，如下表所示。 寻址模式 操作数的使用 Immediate立即寻址 在这种情况中，操作数是要在指令中使用的值；SUB #48就是一个很好的例子。人话：操作数是一个确切的数学值，不需要存入任何累加器就可以直接引用的值。比如说全体正整数。 Direct直接寻址 在这种情况中，操作数是保存要在指令中使用的值的地址；ADD TOTAL是其中的一种情况。人话：操作数是一个地址，执行指令的时候会使用操作数指定内存中的数据 Indirect间接寻址 在这种情况中，操作数是一个地址，这个地址记录了要在指令中使用的值。人话：操作数是一个地址，但是与直接寻址不同的是：此操作数中的值会被作为一个新的地址再次重定向，直到读取该重定向后地址中的值。 Indexed变址寻址 在这种情况中，操作数是一个地址，但是必须将当前变址寄存器(IX)中的值加到该地址上，才可以获得要在指令中使用的值的地址。人话：操作数是一个地址，但是最后调用数据的地址是当前操作数所定义的地址数加上变址寄存器的值，并找到最后的值。 对于立即寻址，有三种定义值的选项: #48指定了十进制值48 #B00110000指定等价的二进制内容 #&amp;30指定了等价的十六进制内容 汇编语言指令继续回到具有有限指令集的简单处理器上。我们在这里举出的所有例子，都不会与特定处理器的汇编所匹配。每一个指令都需要基于平台，针对性的设计汇编程序。 数据的移动这些指令种类各不一样。有些可以将数据加载到寄存器中，有一些可以将数据存储在内存里。下面这个表格举出了一些例子： 指令操作码 指令操作数 简单的解释(但愿吧) LDM #n 立即寻址，将数字“n”加载到累加器(ACC)中。 LDR #n 立即寻址，将数字“n”加载到变址寄存器(IX)中。 LDD &lt;address&gt; 直接寻址，将给定地址的内容加载到累加器中。 LDI &lt;address&gt; 间接寻址，给定的地址将会被使用，而第二个地址的内容会加载到累加器中。 LDX &lt;address&gt; 变址寻址，地址由&lt;address&gt;+变址寄存器中的内容组成，然后将计算出来的地址中的内容加载到累加器中。 MOV &lt;register&gt; 将累加器中的内容移动至一个指定的寄存器中(IX)。 STO &lt;address&gt; 将寄存器中的内容储存到一个指定的地址。 在这里，左侧这一列的助记符定义了指令的类型，包括了在运算中涉及到的所有寄存器，以及可能会使用到的恰当的寻址模式。 仔细阅读助记符是很重要的！ 在以下所有的表格中： &lt;address&gt;代表操作数是一个地址&lt;register&gt;代表操作数是一个寄存器缩写#n代表这是一个十进制值。比如说#23代表十进制数字23。 来一个背景解释一下上面表格的内容： 根据上图所示的内存内容，下面我会给出一些例子： LDD 103代表值110被存入了累加器中LDI 106代表来自地址101的值208被存入了累加器中STO 106代表值208被存进了地址106中LDD INDEXVALUE代表值”3”被存入了累加器MOV IX代表累加器里面的那个”3”被存入了变址寄存器中LDX 102代表来自地址105的值206被存入了累加器中 输入和输出下面这两个指令用于输入或输出。在每种情况下，这些指令都只有一个操作码，没有操作数。 以助记符为IN代表的操作会将键盘上输入的字符的ASCII码存储在累加器中。 相反，以助记符为OUT代表的操作会将累加器中存储的ASCII码显示出来。 比较和跳步程序是不会傻到一直一条条执行命令的——至少当他们要求被这样做的时候会这样。 程序有些时候会在每行命令之间跳转。有一些情况是无条件的，也有一些情况是有条件的：比如说执行了比较命令。 下图给出了一些比较命令的例子： 操作码 操作数 解释 JMP &lt;address&gt; 跳转到指定的地址。 CMP &lt;address&gt; 将累加器中的内容与指定地址中的内容比较。 CMP #n 将累加器中的内容与指定十进制值比较 CMI &lt;address&gt; 是个间接寻址。命令会将累加器中的内容与操作数给到的地址中的内容比较。 JPE &lt;address&gt; 它会跟在一个比较命令后面。如果比较的结果为True，则会跳转到操作数给定的地址。 JPN &lt;address&gt; 它会跟在一个比较命令后面。如果比较的结果为True，则会跳转到操作数给定的地址。 这里所有介绍的比较命令，都是比较两个数据是否相等。相等输出为True，不相等输出为False。 比较的结果会被记录在状态寄存器中的一个标志中。当我们执行跳转指令的时候，我们首先需要检查状态寄存器中是否有这个标志。然后执行跳转命令的时候，我们不会立即执行，而是需要先向程序计数器提供一个新的偏移量，让程序可以继续在正确的地址上获取下一条指令。因此在向程序计数器提供新的偏移量的时候，程序计数器就不会执行简单的+1操作了。 数学运算简单的数学运算，但是在这里我们暂时不考虑乘除的运算，因为他们相比加减法运算没有通用性或一致性。 下表列出了一些例子： 操作码 操作数 解释 ADD &lt;address&gt; 将操作数给定地址内的内容加到累加器中。 ADD #n 将操作数给定的十进制数字加载到累加器中。 SUB &lt;address&gt; 从累加器中减去操作数给定地址中的内容。 SUB #n 从累加器中减去操作数给定的十进制数字。 INC &lt;register&gt; 向给定的寄存器内+1。 （累加器或者是变址寄存器） DEC &lt;register&gt; 向给定的寄存器内-1。 （累加器或者是变址寄存器） 下面展示了一个以5累加到75的程序： 简单解释一下程序的运行过程： 前三行命令初始化了计数器和求和功能 在地址103的命令是每次迭代的第一行命令。 接下来的三行命令会向地址中的值+1，然后存储回原来的地址。 地址106到地址108中的指令会向总和中+5。 地址109和地址110的命令用来检查总和有没有到达75目标值。如果没有就重复下一次迭代。 到达目标值75后，地址111到地址113的命令用来输出计数结果（一共加了15次75，所以输出计数结果15。） 移位运算逻辑移位：左移时最低位补0，右移时最高位补0的移位 Logical shift:where bits in the accumulator are shifted to the right or to the left and a zero moves into the bit position vacated. 比如说：0101向左移1位就是：1010,最高位补了一个0。向右移1位就是：0010，最低位补了一个0。 逻辑移位可以做一些很有意思的东西，比如让一个数字扩大一倍。但是这是有先决条件：这一串二进制的最高位和最低位必须是零，因此没有任何的信息丢失。举个例子 00001010代表十进制的10。但是将其向左逻辑移位（一位）：00010100代表了十进制的20。 同样的，向右逻辑移位代表减小一倍。左移一位是扩大一倍最简单的做法。 知道了什么叫做逻辑移位，现在介绍两个移位运算命令： 操作码 操作数 解释 LSL #n 将累加器中的值向左以操作数给定的位做逻辑移位 LSR #n 将累加器中的值向右以操作数给定的位做逻辑移位 移位并不是仅存在逻辑移位，我们还有其他的两种移位方式：循环移位（Cyclic shift）和算术移位（Arithmetic shift）。 Cyclic shift: similar to a logical shift but bits shifted from one end reappear at the other end. 循环移位：在移位时不丢失移位前原范围的位，而是将它们作为另一端的补入位。 Arithmetic shift: uses the shift to carry out manipulation or division of a signed integer stored in the accumulator. 算术移位：使用移位对累加器中存储的有符号整数进行操作或除法。 这俩了解就好。 按位逻辑操作命令： 操作码 操作数 解释 AND #Bn 将累加器中的每一位都与操作数指定值进行AND运算 AND &lt;address&gt; 将累加器中的每一位都与操作数指定地址中的值进行AND运算 XOR #Bn 将累加器中的每一位都与操作数指定值进行XOR运算 XOR &lt;address&gt; 将累加器中的每一位都与操作数指定地址中的值进行XOR运算 OR #Bn 将累加器中的每一位都与操作数指定值进行OR运算 OR &lt;address&gt; 将累加器中的每一位都与操作数指定地址中的值进行OR运算 第七章：控制与监控系统监控系统监控系统可以用于创建一段时间内系统状态的记录。监控系统被广泛用于监控系统的特定物理特性（照度，温度，湿度…）何时超出阈值。比如说温控系统检测CPU过热，会自动降低频率。 我们在这里以温度作为一个例子：如果计算机想要知道当前机箱内实时温度，那么计算机就必须需要一种设备来获取相关数据，并精确的传送到计算机。 这一种测量设备叫做传感器。 Sensor: a hardware device that measures a property and transmits a value to a controlling computer. 传感器：测量属性并可以将值传递到计算机的一种硬件。 在这个情景中，可以监控计算机机箱内温度的硬件就是热电偶。热电偶会根据温度的变化更改它的输出电压。在一些老式的电脑上，如果传感器检测到了机箱内的温度过高，会奏响它的小蜂鸣器提醒用户。 有一点需要注意，在一个监控系统内，传感器是没有任何的集成智能在里面的，所以说但凡这传感器遇上了问题，它都没有办法自我修复，那基本上就得报废了。 传感器还可以检测运动，红外，声音，ph值等各种属性。 控制系统控制系统包含了监视系统的权限和功能，但是不止如此，控制系统还可以去对系统做出一些调整与改变。 监视系统需要一个必不可少的元件：致动器 (Actuator)。制动器是连接到其他控制设备的电机，可以应用一些改动。 Actuator: a hardware device that receives a signal from a computer and adjusts the setting of a controlling device. 下图是一个计算机控制环境的示意图。 上图中包含了一个模数转换器(ADC)和一个数字模拟转换器(DAC)，它们俩都是独立的组件。在实际的系统中，它们有可能是传感器或者执行器设备的组成部分。 上图所示的系统中，计算机会定期向传感器请求数据，接着计算机就会处理这一部分数据。如果接受的数据不在期望的范围内，计算机就会采取一些操作。下一次数据请求只会发生在此操作完成后。 下图是一个闭环反馈控制系统： 其中的控制器由微处理器组成，他们可以将传感器读取的实际输出值与期望的值作比较，随后会将一个值继续传输给执行器。 控制设备的位操作担任控制工作的计算机或者微处理器里面都必须有一个时刻运行的实时程序。该程序可以根据传感器检测到的内容为布尔变量设置值。 比如说：如果一个受控环境中有两个需要监视和控制的属性，我们就可以定义并使用四个布尔变量。 赋值就牵扯到了赋值语句，就像这样： IF SensorDifference1 &gt; 0 THEN Sensor1HighFlag ← TRUEIF SensorDifference1 &lt; 0 THEN Sensor1LowFlag ← TRUEIF SensorDifference2 &gt; 0 THEN Sensor2HighFlag ← TRUEIF SensorDifference2 &lt; 0 THEN Sensor2LowFlag ← TRUE 与此同时，监控和控制程序的另一个部分会检查是否已经定义了任意一个标识。运行这样的一个程序的机器代码可以使用单独的位来表示每一个标识。 下面的表格说明了设置和读取表示的方法。在这些代码片段中，每个字节的三个最低有效位 (第0, 1和第2位)会被用作标识。 下面演示了在系统打开时可能使用的所有位为零的设置： LDD 0034 将一个来自某地址的字节转入累加器中。 AND #B00000000 使用位与(AND)运算将累加器的内容和操作数转换为0。 STO 0034 将改变后的字节存储在原始地址中。 下面的例子说明了某一个确切位值的切换。这将改变标志的值。可能是因为遇到了问题，也可能是因为解决了问题。 LDD 0034 将一个来自某地址的字节转入累加器中。 AND #B00000000 使用按位异或(XOR)运算将累加器中的第2位切换。 STO 0034 将改变后的字节存储在原始地址中。 下面演示了如何将一个位的值设置为1，不管它现在的值是多少。 LDD 0034 将一个来自某地址的字节转入累加器中。 AND #B00000000 将累加器的内容与操作数进行按位或(OR)运算来设置第二位所表示的值。所有其他比特位保持不变。 STO 0034 将改变后的字节存储在原始地址中。 下面演示了将所有位都设置为0，除了一个特定的位的方法。 LDD 0034 将一个来自某地址的字节转入累加器中。 AND #B00000000 对累加器的内容和操作数进行位与(AND)运算，保持第1位的值不变，但将其他所有位转换为0。 STO 0034 将改变后的字节存储在原始地址中。 第八章：系统软件操作系统在1960年代，人们使用计算机的操作大概是这样的： 进入一个有很多穿孔纸条和穿孔卡片的房间 打开计算机 将穿孔卡片插入读卡器，然后按下按钮 将穿孔纸条插入读取器，然后按下按钮 按下另一个按钮来启动在穿孔卡片上存储的程序。这时候穿孔纸条会当做内存使用。 按下按钮将输出打印在纸上 关掉计算机 离开房间 当时的计算机用户只能通过按钮来与计算机交互。要是放到今天得需要数不清的按钮了。所以在1960年代，确实的计算机的一个重要成分便是操作系统了。 Operating system: a software platform that provides facilities for programs to be run which are of benefit to a user. 操作系统活动操作系统的构造实际上是非常复杂的，我们在这里寥寥数句肯定是说不清楚的。但是我们可以大致介绍一下操作系统的大致活动与功能： 用户界面操作系统里面的用户界面可以允许用户通过它去与系统硬件更高效地交互，从而完成一些有意思的事情。 一个操作系统至少需要满足以下两点中的其中一个对用户的输出方式： 一个命令行样式的用户界面 一个图形化的用户界面 我们用的绝大多数操作系统都是带有图形化用户界面的。 程序硬件接口程序员的可以编写软件，用户运行这个软件。软件需硬件的运行，所以操作系统必须保证硬件可以执行软件所希望执行的操作。 现在的程序员编写软件不再需要去了解如何针对某个别的硬件进行编程了，尤其是处理器。随后操作系统就会担任这个工作：把人话翻译成机器听的话。 资源管理如果一个程序正在运行，我们会管他叫做一个进程。 Process: a program that has begun execution. 在现代的计算机系统内，任何进程都不可能一直不间断地运行下去，而且在计算机系统上会运行很多的进程，每一个进程都需要访问计算机系统提供的资源。 操作系统中的资源管理旨在发挥计算机使用过程中的最佳性能。管理资源最重要的两个方面是： 进程的调度 冲突进程的管理 (当两个进程同时需要计算机系统提供的同一份资源，就会产生冲突。) 内存管理以下三点在内存管理中比较重要： 内存保护：确保两个程序不会共用同一个内存地址。 组织内存：通过组织内存的使用方案来实现有限资源的最大化利用（或者发挥最大性能），比如说虚拟内存。 内存优化：决定有哪些进程会保持运行在主内存中。 设备管理每一个计算机系统都会连接各式各样的设备，比如说鼠标键盘，打印机复印机，摄像头等等。 设备管理有一下两点： 为设备安装正确的驱动程序。 控制设备有关进程的使用。 文件管理 文件命名 目录结构 访问控制机制 安全控制 当文件丢失时提供恢复 防止计算机被入侵 确保文件的安全性 错误检测与恢复程序在执行的过程中很有可能出现错误。这有可能是因为程序编写错误，也有可能是提供了不正确的数据。但是无论错误的原因是什么，操作系统都应该有中断进程和错误诊断的能力。在极端的情况下，操作系统也需要有组织性地关闭系统，同时不丢失数据。 应用程序软件应用程序可以由操作系统提供，用户也可以单独安装。应用程序不是操作系统能够正常运行的必要条件，而是用户或者操作系统可以在需要时决定运行的程序。 举一些例子，每一个例子具体是什么样我就不展开成一个个小章节解释了，已经属于是基础知识了。 硬盘格式化软件和硬盘检测软件。 DiskGenius就是这样的一款优秀软件。这样的软件可以格式化你的磁盘，或者检查硬盘是否有任何坏道错误。 硬盘碎片化整理程序 机械硬盘因为其物理限制（转盘和磁头导致机械硬盘大多以顺序读取为主），随机读取的性能远远低于SSD（固态硬盘）的性能，所以适当的整理磁盘上的文件排布对于系统读取文件来说是很有帮助的。 我们在日常使用电脑的时候很容易产生很多碎片。这些碎片可以是不连续的，在机械硬盘中会极其拖慢系统的运行速度。所以碎片化整理程序就可以将碎片化的文件以机械硬盘喜欢的方式重新排列，让随机读取文件更靠近顺序读取。 所以这样的碎片化整理程序对于SSD是没什么用的，除了心理作用。 备份文件 杀毒软件 这两个不用说了吧。 Program libraries 程序库这些在Program libraries中是为了执行特定任务而创建的程序。任何程序员都可以在自己的项目里使用它们。 所有新开发的程序里面都会包含错误。这些错误在程序员debug中可能很难发现，但是在用户的日常使用中可以变的越来越明显。而这些已经验证过没有问题的Program libraries中的子程序就可以被程序员拿来直接用，省去了大量的精力去调试或者编写程序。 另一种方法是使用动态链接库（DLL）。当程序员决定使用DLL的时候，在自己的可执行代码内就可以只包含一点点代码。这允许它在程序运行的时候连接到单独存储在内存中的例程。使用DLL的优点是所有程序的可执行文件都可以做到较小的存储空间，对内存的需求也最小化。另一个有点事如果有新的例程版本可用，我们就可以直接讲新的例程加载到内存中，以便使用它的任意程序都可以升级到新的例程，而不需要去大刀阔斧地改代码。 但是问题是如果DLL损坏或者新版本的DLL存在兼容性问题或者内容错误，直接一影响就影响一片程序。同样DLL确实也是用户在使用计算机的时候经常发生的问题。这时候就需要用户去手动添加缺失的DLL。 计算机语言转换还记得第六章的汇编器吗？这一个小结介绍类似汇编器的其他程序，不过这些程序是用来翻译高级过程语言编写程序的翻译器。 编译器和解释器使用编译器 (Compilers)或者解释器 (Interpreter)的先决条件是：必须应用于源代码，而源代码必须是用高级语言编写的程序。 一个解释器工作的基本过程如下： 解释程序，源代码文件和源代码程序使用的数据都可以使用。 解释程序现在开始运行。 读取源代码的第一行。 每一行会被按下面5-7步的顺序分析： 如果有发现错误，解释程序会暂停运行，并将错误信息上报。 如果没有错误发现，源代码中的这一行就会被解释程序转换成中间代码。（中间代码是一种面向语法，易于翻译成目标程序的源程序的等效内部表示代码） 解释程序会根据生成的中间代码来执行所需要的操作。 然后解释程序就会重复运行4-8步的步骤分析下一行代码。 一个编译器工作的基本过程如下： 需要编译程序和源代码，但是不需要源代码使用的数据参与其中。 编译程序开始运行。 读取源代码的第一行。 每一行会被按下面5-7步的顺序分析： 如果有错误发生，编译程序会报告这个错误。 如果没有发生错误，那么源代码中的这一行就会被转换成中间代码。 编译程序会重复运行4-7步的步骤分析下一行代码。 当整个源代码处理完毕后，会发生下面两种情况的其中之一： 如果在整个源代码中没有发现错误，就将完整的代码转换为目标代码。 如果发现了任何错误，就会输出错误列表，并且不生成目标代码。 对于程序员和开发者来说，编译器和解释器各有所长： 在开发程序的时候，解释器具有优势，因为它可以在错误发生的时候识别错误并尝试修正，而无需等待整个源代码被读取和分析。 解释器的缺点在于：在程序的特定执行过程中，解释器可能无法访问包含语法错误的部分代码。因此错误就只会在结束的时候被发现。 编译器的优点是可以将可执行文件(exe)发行给用户，这样用户就没办法访问源代码了。 而在用户这边，编译器和解释器也都有自己的优缺点： 对于解释程序来说，当每一次运行一个没有错误的程序的时候，解释程序和源代码都必须可用。 对于编译后的程序，当每次运行一个没有错误的程序时候，只有目标代码可用。 编译后的目标代码可以提供相比于解释程序更快的执行速度。 编译后的程序可以有风险，因为它可能含有潜在的病毒或垃圾文件。 无论使用的是编译器还是解释器，如果他们的程序是为了特定处理器而写，则程序只能在具有特定处理器的计算机上运行。 如果有特定的条件，那么在开发程序的时候选择解释器是比较合理的。因为： 程序中的一个错误可能会造成多米诺效应：一错错一片。 解释器可以检测并修正在代码中发生的早期错误，从而限制后续发生更多问题。 在开发过程中，解释器附带的debug程序可以梗方便的减少工作时间。 同样在某些时候，我们也可以选择使用编译器。因为： 编译器可以生成一个可执行文件(.exe)。 编译器生成的可执行文件可以更方便的用来传播。 编译器生成的程序相比于解释器的程序来说，运行速度更快。 Java当Java正在创建的时候，Java团队设想了一些十分新颖的想法。每一个计算机都可以安装一个Java虚拟机（Java Virtual Machine）。当程序员构造一个Java程序的时候，会首先编译成Java字节码指令(Java Byte Code)。当这个程序运行的时候，会被JVM解释，随后就可以将程序转移到任何安装有Java虚拟机的计算机上运行。 集成开发环境(IDE)集成开发环境(Integrated development environment)是用于提供程序开发环境的应用程序。一般包括代码编辑器，编译器，调试器和图形用户界面等工具。继承了代码编写功能，分析功能，调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件组都可以叫做集成开发环境。 常见的IDE有微软的Visual studio系列，Jetbrains的IDEA，Pycharm。 代码高亮 (Prettyprinting)计算机语言一般每行由不同的成分构成，有命令或者各种参数。代码高亮功能可以将代码的每一部分通过不同的颜色或者图样展示出来，方便我们区分并阅读代码。 就像这样： 123456789package com.**.lib.lib;public class Myclass { private String text = \"Hello world\"; public static void main(String[] args) { System.out.print(\"Hello world\"); }} 上下文敏感提示 (Context-sensitive prompts)在一段代码的上文你可能定义了一堆变量，在代码的下文IDE就有机会自动补全你写过的变量名称。 语法检查 (Syntax check)IDE会分析你的代码，并且通过画波浪线的方式提示你你的这部分代码可能有误。有些IDE只负责检查错误，不过现在的IDE大多都可以为你提供更正提示。 代码折叠 (Expanding and collapsing code blocks)当你在代码中的一个循环（或者其他组容器内）写了很多的代码，那么IDE提供了可以将容器内的代码折叠的选项。这让你更方便的在长文件里梳理代码结构。 DebugIDE一般都会附有调试工具来帮助你进行Debug操作。Debug大约是程序检查去除漏洞的意思。 Debug: finding and correcting errors, often called 'bugs', in a program. 在调试过程中你可以为程序中的某几行打上一个断点(Breakpoint)。当程序开始运行后到达了断点处，程序会暂时停止运行。然后你可以选择继续运行，或者逐行运行。 这对于梳理程序逻辑很有帮助。 第九章：安全、隐私和数据完整性定义数据完整性定义什么是数据完整性挺容易，但是确保数据完整就不那么容易了。只有准确并最新的数据才会存在数据完整性，任何存储数据的个人和机构都必须尽可能地确保数据的完整性。 我们会在本章和第十一章讨论确保数据完整性的方法。 Data integrity: a requirement for data to be accurate. 数据隐私数据隐私指的是保持数据的私密性，而不是任凭数据公开访问权，以至于每人都可以随便使用。此现象都可以发生在个人和组织上。每个人都有他们自己的隐私数据，而且大家都会选择保密这一部分数据不被公开。 对于个人而言，如果没有适当的法律来约束侵犯隐私的违法者，那么保证数据隐私就相对困难了。 保护数据隐私的法律必须要涉及以下几点： 这些数据是私人数据，因为他们主要是面向提供给个人和组织的。 提供数据是为了允许组织使用它，但只能用于个人理解和同意的目的。 数据保护法要求组织机构确保这些数据的隐私性和完整性。 不幸的是，拥有法律并不能保证遵守它们，但它们确实起到了威慑作用，可以使不法行为者受到法律诉讼。 Data protection law: a lao that relates to data privacy. 数据安全数据在我们想要使用它们的时候永远可用。如果数据已经丢失或者损坏，那么我们可以说数据的安全性已经被破坏了。 在实现数据完整性或数据隐私之前必须先实现数据安全，但数据安全本身并不能保证数据完整性或数据隐私。保护数据的要求之一是用来存储数据的系统的安全性。系统安全不仅仅保护数据。 系统安全措施有两个主要目标： 确保系统持续执行用户需要的任务。 以确保只有授权用户才能访问系统。 Data security: a requirement for data to be available for use when needed, ensures that only authorized users have access to the system and data can be recovered if lost or corrupted. 对计算机系统及其存储数据安全的威胁对计算机系统的数据安全侵犯可能因为以下原因形成： 个人用户不关注数据安全 内部的管理混乱 自然灾害 未经授权的个体侵入系统 有害程序进入计算机系统 网络和互联网对计算机和数据安全的威胁现在我们的计算机都会连接到互联网。互联网上充斥着各种各样的信息，同样的可能会存在各式各样的有害文件。部分黑客可以在系统未经授权之时入侵系统。黑客可以通过这样的手段非法获取系统内的数据。 所以说检查是否有恶意软件进入系统确实挺有必要。 Malware: malicious software that has the intension of causing harm to a system or its contents. 恶意软件恶意软件是恶意软件的统称。它是为了有害的目的而被引入系统的软件。含有恶意软件的各种类型的程序代码有: 病毒：试图在其他可执行代码中复制自己。 蠕虫：独立运行，并尝试将自身传播到网络上的其他主机。 逻辑炸弹：在满足某些条件之前保持潜伏。 特洛伊木马：替换全部或者部分的程序，知道达到木马的目的。 间谍软件：收集信息，然后将其传输到另一个系统。 bot：控制一台计算机并且利用它来发动攻击。 不同类型之间的恶意软件差异并不大，有些例子属于这些类别中的一个或者不属于任何一个。病毒类别通常根据病毒所附着的软件进行细分，例如引导扇区病毒和宏病毒。 恶意软件也可以通过他们的行为来归类： 钓鱼：以发送看似合法的电子邮件等手段来套取有用的信息。 冒充：冒充一个以假乱真的官方网站。 键盘记录程序:记录用户的键盘使用情况。 由用户活动引起的系统漏洞许多系统漏洞与系统合法用户的活动直接相关，而不是恶意软件。下面是两个不涉及恶意软件的例子： 使用弱密码，特别是与他们自身相关的密码。一个弱密码很容易被别人猜到或者被暴力穷举。 用户不太容易识别网络钓鱼和攻击，所以很容易泄露有用的信息。 用户的以下操作很有可能出现安全事故： 插入一个移动存储设备 在邮件内打开未知的超链接 打开一个未知的网站 从网络上下载未知的文件 系统本身产生的漏洞系统在某些情况下比较容易产生漏洞。下面给出了几个例子。 有一些操作系统的安全性可能较差。随着时间的推移，操作系统越来越复杂，这就容易导致安全性下降的可能。操作系统的定期更新，打补丁或者更新服务包等都可以增强系统的安全性。 在之前，应用程序会有较大的概率携带电脑病毒等有害程序。不过现在这种情况几乎不会存在了。 还有一个比较特殊的漏洞，就是缓冲区溢出。用C语言编写的程序有很大的一部分是不会自动执行数组绑定检查的。如果有一个程序故意将代码写入内存中超出为数组定义的地址的那一部分，那么这个部分会被定义为缓冲区。 保持计算机数据良好的措施灾难恢复对某些大厂来说，大型计算机的运营连续性十分的重要。我们需要保证无论发生了什么时间，计算机系统都可以正常的工作。如果必须需要关闭系统，那么我们也必须要确保系统在很短的时间内再次启动恢复正常。 一般来说，互联网大厂会同步很多副服务器，以便于主服务器在提供服务的时候发生不可抗力因素而失去服务。他们像是一种后备服务器，允许主服务器瘫痪之后能够继续提供服务。我们将这种后备的服务器叫做“热点”。 安全更新系统当系统应用了一些新的更新以后，难免会遇见一些硬件上或者软件上的小错误。一般来说，提供服务的大厂会选择在计算机不提供服务的时候进行系统更新，这样技术团队就可以用这段时间来调试新系统。 但是在现代的互联网公司内，他们的服务是24小时全年无休的。所以更新系统就可以使用到我们上一个话题内提到的“热点”系统：通过另一些主机来提供服务。 用户身份验证即使你自己的电脑只有你自己一个用户，我们也很有必要去设置一个用户账户。账户系统十分重要，尤其是有很多人需要使用同一台电脑的情况下。用户账户的主要安全特征是用户身份验证，我们通常的方法是设置密码，然后将每一个用户和他们的密码做出关联。当然我们也有其他方法，比如说使用生物识别验证和安全令牌。 生物识别验证是使用我们的指纹，人脸甚至虹膜来验证身份。安全令牌可以是一种硬件，比如说加密狗。 当然也不是说我们只能生物识别安全令牌和密码二选一。我们一般会将这些额外的验证方法与密码相结合。 良好的使用习惯在使用计算机的时候保持一些良好的使用习惯，可以减少计算机被入侵的可能性。 比如在不用计算机的时候关机，不要在公共的计算机上记录你的个人信息等等。 防火墙设置防火墙可以让你的电脑免于网络上有害信息的传递和黑客对你的计算机的入侵。 数据的安全性与完整性其中一种方法是检查并核验输入。 输入数据验证虽说是验证输入数据，但是实际上验证完了输入数据之后的数据也会发生错误。我们这里的验证数据实际上是验证数据的各项指标，比如说大小，格式或者更多其他的内容。我们在这里举几个例子： Presence check: 样式检查，用来检查输入的内容是否是空的。 Format check: 格式检查，来检查输入的数据是否符合要求的格式(比如日期的格式就必须是 dd/mm/yyyy )。 Length check: 长度检查，用来检查数据是否符合应有的长度。比如说用来检查输入的电话号码是否是11位。 Range check: 范围检查，用来检查输入的数据是否在合法范围内。 Limit check: 限制检查，检查输入的数据是否突破了一个阈值。 Type check: 数据形式检查，用来检查输入的数据形式是否合法。(比如说构成日期的每一位数据都必须是正整数，不能是小数。) Existence check: 存在性检查，检查输入的内容是否已经出现过。比如说在同一个文件夹下将一个文件重命名成另一个文件的样子会报错，是因为存在Existence check。 验证输入的数据跟上一个话题看起来很像，但实际上不是一个操作。在这一步，我们需要尽可能让用户输入的数据是正确的。要达成这一点，我们可以要求用户再次确认数据，或者让他们自己检查输入的数据。 比如在注册账号密码的时候，要求用户重复输入密码。或者在填写完表单之后，将用户填写的数据重新陈列在屏幕上，以便用户检查。 按位检查有些时候某些数据载体上面会包含一个叫做纠错码的部分。这部分允许计算机可以根据这些纠错码来判断或还原之前丢失或损坏的数据。 这里有加和验证和其他数学方法验证。加和生成的数据会被记录到最后一位上。 Validation: a check that data entered is of the correct type and format; it does not guarantee that data is accurate. Verification: confirmation of data received by a system. 这两者之间的区别就是一个是确认数据的输入，一个是验证输入数据是否合法的。 数据传输过程中的验证数据在传输的过程中是很有可能被损坏的，比如说其中的一个位反转了过来，从0变成了1。所以说，验证技术就会介入，来检查数据是否发生损坏。 其中最简单的方法就是使用一位奇偶校验 (One-bit parity check)。如果传输的数据是七位一字节传输的话，系统就可以在这一个字节中的第八位存储奇偶校验的信息。 下面就是一位奇偶校验的检查步骤： 在数据传输之后，我们会检查这一个7位字节中有多少个1。 如果1的数量是奇数的话，校验位会被设为1。 如果1的数量是偶数的话，校验位会被设为0。 这样的过程会在传输每一个字节的过程中重复。 在传输的最后，八位字节中的所有1的数量会被数出来。 如果这个个数是偶数，那么这个字节就是完好无误的。 这样的步骤也会被重复到每一个8位字节。 奇偶校验也不是万金油，数据在损坏后也有可能通过奇偶校验。比如说当一个7位字节里面反转了两个位，最后数出来的奇偶个数还是与原数据一致。所以说比起改正传输数据的错误，奇偶校验更像是一个验证传输数据是否有错的算法。所以说如果奇偶校验发现了错误，那么我们就只能要求服务器重新发送数据了。 另一种验证方法叫做校验和。这是一个端到端的校验和，由发送端计算，然后由接收端验证。 将传输的数据当成若干位（如8位、16位或32位）的整数序列，将这些整数加起来，舍弃进位，得到一个结果。 将这个结果取反码，即将0变为1，将1变为0，得到一个校验和。 将校验和附加到数据后面，一起发送给接收方。 接收方收到数据后，将数据和校验和一起按照同样的方法进行累加，并舍弃进位，得到一个新的结果。 如果新的结果是全1，则说明数据没有发生改动或错误；如果新的结果不是全1，则说明数据有损坏或篡改。 一位奇偶校验和校验和是有区别的。一位奇偶校验用于存储数据，而校验和只用于传输的数据。 想要验证数据在哪一位出错了，就比上面的这些验证方法要更加复杂了。 第十章：道德与所有权（标题翻译过来有点奇怪不过问题不大。这章的原标题叫做”Ethics and ownership”） 道德(Ethics)不是很理解所谓标题是什么意思。 你可以找到道德的很多定义。 伦理学是道德科学的一个分支。 道德指的是任何人的行为准则。 道德是在特定职业或人类生活中公认的行为准则。 在这个单元中，我们不会牵扯到第一个定义，而第三个定义才是我们这一个章节研究的东西，虽然说计算机科学家和开发人员的行为准则必须反映第二个定义的道德原则。 道德原则牵扯到对与错。美得的概念通常被认为是正确的东西在一系列的发生。至于什么是对与错，可以从以下几个观点之一考虑：哲学、宗教、法律或者实用主义。 有关于哲学的辩论已经开始了2000多年，其中不乏一些伟大的人物提出的观点，比如说亚里士多德和孔子。宗教就是大家所熟悉的宗教，法律是来判断事物对与错的一种工具，而实用主义可以定义为运用常识。 虽然我们学的是CS，但是宗教信仰这类的东西确实需要在工作环境中加以考虑。法律问题显然会影响工作时间，但是他们很少会是行为准则的主要焦点。行为规则的基础仍然是有关于对与错的哲学观念和常识性的实用主义观点。这些东西会构成本章后续内容的一个框架。 计算机专业人员无论这些人的专业是个啥，他们最起码得遵守道德规范。专业人士可以通过假如适当的专业组织来获得道德行为指导。这样的组织内会有一个行为准则，其中就会包括有关于道德实践的参考。 举个例子：英国计算机协会(British Computer Society)有四个行为准则： 公共利益 专业能力与诚信 对相关机构的责任 对此专业的责任 另一些机构和组织，比如IEEE-CS／ACM联合工作组软件工程道德规范定义了八项基础原则： 公共 - 软件工程师的行为应该符合公共利益 客户与雇主 - 软件工程师的行为应该符合客户和雇主的最大利益，同时也需要符合公共利益。 产品 - 软件工程师应当确保他们的产品和相关的变体符合最高的专业标准。 批判与判断 - 软件工程师应该保持他们专业判断的完整性和独立性。 管理 - 软件工程经理和领导应当支持并促进软件的开发和维护。 专业 - 软件工程师应当促进相对专业的诚信和声誉，同时符合公众利益。 同事 - 软件工程师应当公平对待他们的同事，同时也要去支持他们。 自身 - 软件工程师应当参与与其专业实践相关的终身学习，并促进职业实践。 虽然说上面的规则多少有些不一样，但是其中的一些内容是大致一致的： 都重视公众利益 都提出了专业人员的基本原则 专业人员应当自行判断情况 如果不确定，专业人员应该寻求建议。 (我确实觉得是上面这些内容过度抽象了，我有一说一不清楚他们想让我学啥。) 所有权与版权上面ethic的部分实在是过于抽象所以我选择直接跳转到Ownership这一部分，至少这一部分有些实质性的内容。 如果一个人创作并且出版了一些具有独创性的作品，那么这个人就是这个作品的所有者。他就有资格去要求版权。在这里有一个例外：个体在组织中工作。如果一个或者多个人为该组织工作并发表了他们的作品，那么这个组织就可以要求申请这些作品的版权。 Copyright: a formal recognition of ownership of a created and published work. 版权可以被下面这些形式的作品申请： 文学作品 音乐作品 电影和影视作品 电视广播，电台和博客 艺术作品 一个计算机程序 版权因以下的两个观点而存在：第一是：创作需要时间和精力，需要独创性思维。因此版权所有者应当有机会为此挣钱。第二是：其他的一些个人或者组织可能会在不向创作者支付任何费用的情况下复制作品并从中赚钱。这对于版权所有者来说是十分不公平的。 版权需要通过法律程序来保护。不同的国家对于版权的法律有细微差别，但是有这么一个国际协议：版权法，是每个国家必须遵守的。例如：未经原版权持有人许可，某人不允许在另一个国家出版作品。 一般来说，版权法会包含： 要求记录作品的创作时间。 在规定的期限内，版权法会保护作品。 如果版权持有人去世，应当适用的法律。 采用版权的内容会被”©”符号注释。 如果有人买下了版权内容，那么他们就允许无限制地复制这些内容，前提是这些内容仅供个人使用。 软件许可商业软件商业软件本质上与一些商业产品没什么大的差别。他们一般都是由一家旨在盈利的公司创建并销售。但是他们有一个显著的差别： 设想你在科技市场买下了一台电脑，那么你就拥有这台电脑的所有权。但是如果你买下了一款计算机软件，你实际上是不会拥有他的使用权的，软件的所有权还是归属于供应商。 也就是说，买下计算机软件就是相当于买下了一个许可证，你可以在期限内使用这款软件。软件许可证可以是有期限的，也可以是买断制永久性的。 一般来说，买软件的时候都会出现一下这一些情况： 购买软件的每一个个体都需要去支付一定的费用。 一个组织可以订购一批许可证。组织内的每一个个体可以在规定的时间期限内使用这个软件。 对于教育工作者或者学生来说，需要支付的费用可能要相对便宜一些。 开源软件或自由软件这两种类别都十分相似，他们都是非盈利性质的。一些软件提供给你免费的使用权，但是软件本身是不开源的，这意味着你无法去编辑这些代码，查找代码中的BUG，或者制造属于你自己的版本。 开源软件允许你去修改代码，并基于此软件创造或者开发一个全新的软件（前提是你不要去违反开源软件的协议。）开源软件允许用户和个体查看代码的好处有很多：个体可以遍历代码并找出代码中的错误，他们也可以在一些代码托管平台上(例如Github,Gitlab)去提交自己修改的分支，以改进原来的开源部分。他们也可以发表PR(Pull request)提交合并申请或者报告开源软件的问题。也就是说：开源软件由一个强大的社区支持，而社区的力量允许开源软件作者享受好处。 Open source software: software provided with the source code. Free software: software provided with he source code when the user is free to use it as they wish. Shareware: software provided free of charge for a limited period but no source code provided. Freeware: software provided free of charge with no time limit for its use but no source code provided. 人工智能(AI)人工智能是多个学科的共同产物，包括哲学，心理学，神经科学，数学，语言学和控制工程。 人工智能涉及使用计算机或者计算机控制的设备来执行通常与人类智能行为相关的任务。我们将考虑智能人类行为的五个方面，讨论模拟这种人类行为的人工智能的一些应用。 解决问题人工智能可以做到与你在国际象棋中对局。这可以被认为是显示了人工智能，但这只是因为国际象棋的规则是有限的。只要一台计算机拥有足够的存储容量和算力，那么这一个人工智能程序会在大量的训练之后研究更多的选项来解决现实生活中的问题，以至于人类的智力能力都无法与其竞争。 语言学语音识别和语音合成技术已经开发并投入使用了。比如说你打一个客服电话，但是对面应答的不是一个人，而是一个机器。如果你可以清楚地描述你遇到的问题，计算机系统可能会识别你的需求，并将你移交给合适的人来帮助你。 现在的GPT语言模型也是十分的强势。没有试过的可以去注册一个New Bing试试看。 自动化现在，机器人已经进入了工厂，开始协助大规模的生产了。这些机器人会被程序要求执行特定的循环操作。机器人的每次动作都是由某一些机制触发的。然而如果这些机器人碰到了意料之外的情况，他们就会停止运行，无论他们是否造成了任何损坏。 现在已经有很多研究旨在加速自主意识机器人的研发，为了工厂中的机器能够更灵活的处理各种任务。我们必须要在这些机器人上面增加传感器，传感器将外界信号传递给处理器，然后再由程序进行判断。 无人驾驶汽车就是一个很好的例子。不过现在在驾驶领域应用比较广的还得是自动泊车。 推理有一些AI允许程序能够从证据和线索出发，来推理出最终的结论。最好的例子就是将数学定理交给计算机程序去进行证明和验证。 机器学习机器学习是目前AI领域里面能给人们带来最大惊喜的分支。AI会在实际的例子中积累经验，通过正向和逆向反馈来进行学习。AI会使用一套适当的数学统计算法来学习。 这方面大家懂得都懂所以我就少写点了…… AI的影响AI确实可以提升社会的工作效率，因为AI很适合节省一些需要重复的简单工作。在这些任务中AI可以做到比人类更高的稳定性和速度。 现在ChatGPT的爆火证明了社会确实对于AI新技术的认可和兴趣，因为AI的诞生和发展增加了人们工作的效率，减轻了人们工作的脑力支配。 然而有很多人担忧AI在未来会取代很多人类的工作，比如工厂的装配工之类的工作。这很有可能引发一批批的失业。有些人也认为AI是不具备处理部分复杂信息的能力的，比如说自动驾驶的稳定性。 只能说仁者见仁智者见智吧。 第十一章：数据库第二章到第十章中间的内容之后目前还没讲，之后再说 关于数据库我们所说的数据库，一般指的是数据库管理系统，又叫数据库管理软件。英文为：Database Management System (DBMS)。 常用的数据库管理软件有MySQL，SQLite等。在很多大型公司里，一个数据库往往是一个项目的核心。 那么数据库存在的意义是什么？既然只是为了记录数据，我为啥要使用数据库？主要是因为，我们存在大批量的数据并且还需要高速有效地写入或检索出来。 下面用一个例子来简单解释一下数据库的优势： 设想一下，你在一家电影院里工作，影院需要录入每一部电影的片名，上映时间，电影类型等等数据，并且使用文字处理软件进行记录。在这个例子中，我们就假定使用Windows自带的“记事本”进行txt文件的编辑吧。这样有专门的工作人员手动往这个txt文件里塞入一行一行有关的信息。一行写满了一部电影的数据，就像这样： 序号 片名 导演 电影类型 时长 票价 1 《数据库》 张三 科幻 110分钟 56元 2 《开学》 李四 惊悚 124分钟 79元 … … … … … … 那么这种处理数据的方法都会出现哪些问题捏？ · 冗余 一次换班过后，原来负责记录信息的工作人员润了。取而代之的是一个新的员工。有一天，一部叫做《数据库》电影返场了。所以这一位新员工理所当然地更新了数据： 序号 片名 导演 电影类型 时长 票价 1 《数据库》 张三 科幻 110分钟 56元 2 《开学》 李四 惊悚 124分钟 79元 … … … … … … 541 《数据库》 张三 科幻 110分钟 56元 这显然是不合理的，因为新录入的信息与之前的老信息发生了重复。作为一款文字处理软件，想要排查这样的错误无异于大海捞针。但是使用数据库就不会出现这种问题。 · 无法检索并汇总 假设电影院至今已经播出了114514部不同的电影，每一部电影都存在于这份文档中。然后有一天你的老板让你整理出来所有票价高于80元的电影的片名，导演，电影类型等数据，汇总给老板看。 然后你打开了txt文件—— 寄。 你会发现你无法通过限定数据来进行检索和整理输出。因此最好的方法就是滑动鼠标滚轮靠肉眼一行一行人工检索了。 同理，使用数据库就不会出现这种问题。 · 可移带性、规范性差 然后假如电影院记录的数据十分的完整，以至于有其他的电影院想有偿使用你的这一份txt文件。然后对方付了钱，你发过去了这一份txt文件。 但是与此同时，收到这一份文件的另一家电影院已经开始痛苦面具了——因为标准或者语言的不同，使用的这一份数据无法直接部署给对方使用，导致对方需要花费大量的经历去做数据的重新整理。 而数据库有一套比较统一的语言系统和语法，允许数据库方便地在不同计算机上转移数据。 当然还会有更多的问题，这里就不列举了 数据库的标准像TCP,UDP之类的传输协议，都是一些白纸黑字的成文标准。SQL也是如此。SQL，全称 Structured Query Language。 关系型数据库内容现在很多应用都需要处理对象与对象之间的关系。有关数据，抽离对象，数据，以及他们的关系，就可以用面向对象的语言来进行编写。但是如果要根据此类数据创建一个数据库，就可以用关系型数据库将我们现在最主流的应用的数据平滑地记录下来。 下面来介绍一下数据库的成分： table关系型数据库表达主体和关系，是通过Relation来完成的。（俗话说就是表格）Attribute代表在表格里面的一个列。而Tuple就代表其中的一个行。就是和Excel很像，但也仅仅是看着像了。 Relation: the special type of table which is used in a relational database. Attribute: a column in a relation that contains values. Tuple: a row in a relation storing data for one instance of the relation. keykey（键）代表一个专用的特征码，甄别唯一性的一串字符。 Primary key 为”主键“，代表现役判断重复性的根据。在作为Primary key的那一项，数据不能为空，也不能重复（只能唯一）。 在CIE考试里，在创建数据库的时候，都必须需要一个主键存在。 Candidate key 是Primary key 的候选，都可以满足Primary key的特征以及功能。 而Primary key可以不是由Candidate key里面选出，因为Candidate key的定义为： “a key that could be chosen as the primary key.” Foreign key（外键）是在某一些表内的主键必须是主键，作为在不同表之间确定信息以及联动查询的基础。 一个表格内的一个主键拿出去给别的表做一个外键，这样就可以确定在两个表内不同的数据的联系，还可以保护数据的完整性。如果不用外键来引入与别的表格的联系，就需要将数据从另一个表格中再次输入一遍。这就出现了冗余现象。 Primary key: an attribute or a combination of attributes for which there is a value in each tuple and that value is unique. Candidate key: a key that could be chosen as the primary key. Secondary key: a candidate key that has not been chosen as the primary key. Foreign key: an attribute in one table that refers to the primary key in another table. Referential integrity: the use of a foreign key to ensure that a value can only be entered in one table when the same value already exists in the referenced table. Example 有关于这点，这里举个例子解释一下： 这里有一个考试表。下面开始在考试表内记录数据： 9月1日，1号学生在4号考场里考了语文。9月3日，一号学生在4号考场里考了计算机。… 你会发现，其中没有一个类型的Attribute可以作为一个key来确定。所以这样就找不出一个Candidate key了： 学生不可以做为key，因为学生可以考多个科目。 科目不可以作为key，因为一个科目可以重复被考。 日期就更不用说了。 但是我们需要联合两个或多个数据（不会和别的搭配重合的数据）来创建一个key，其中的每一个元素可以没有作为key的潜质。 比如我规定查询”一号学生的语文考试记录“，就一定包含唯一性。但是只去查询日期，就没法精准定位了。 三范式三范式存在的意义是让数据库的设计更加合理化，并落实成关系型数据库。当然，你也可以选择不去遵守三范式。 第一范式(1NF)第一范式的内容： 数据表中的每一列(每个字段)必须是不可拆分的最小单元,也就是确保每一列的原子性。 简单来说就是一个单元格内只能去输入一个最小不可拆分的单元，不可再分。 比如说像这样填表： ID Student 1 19班20号 这样是不满足1NF的。满足第一范式写法需要改成： ID Student_Class Student_ID 1 19 20 第二范式(2NF) 在满足第一范式的情况下：表中的所有列，都必须依赖于同一个主键（或者联合主键的部分），而不能有任何一列与主键没有关系。 也就是说，一个表格需要描述一类信息，一张表仅描述一件事。 其实就是为了去冗余。 Example 表格：Exam Student_ID Course_ID Date Student_Name Course_Name 1000 101 2002.3.10 张三 Linear Algebra 在这个表格里，Student_ID,Course_ID和Date作联合主键。因为三者制约完全可以保证确定一个数据。 Student_Name依赖于Student_ID, Course_Name依赖于Course_ID。这种情况叫做部分依赖。而部分依赖，是不符合第二范式的。 因此，我们可以将Student_Name和Course_Name抽离至两个新表格Student和Course。在Student表格内，Student_ID为Student表主键。需要将Student_ID列抽离到学生考试表格做外键。在Student表格内，Course_ID为Course表主键。需要将Course_ID列抽离到学生考试表格做外键。 如下所示： Student ( Student_ID, Student_Name )Course ( Course_ID, Course_Name )Exam ( Student_ID, Course_ID, Date, Student_ID(fk), Student_ID(fk) ) 下划线代表主键，(fk)代表外键。 第三范式(3NF) 在满足第二范式的情况下，任何的非主属性不得依赖于其他非主属性 好比说我在列一张表： main commits branch system 规定main是主键，则commits,branch,system都必须与main有联系。 假如说system仅与branch有关系，则证明不符合第三范式。 使用三范式规范化数据库下面是一张信息表。将其转换成数据库的形式，并符合三范式要求。 Order no: 07845Date: 25-06-2016Customer no: 056Customer name: CUPAddress: Cambridge square CambridgeSales rep no: 2Sales Rep name: Dylan Stoddart Product no Description Quantity Price / unit Total 327 Inkjet cartridges 24 $30 $720 563 Laser toner 5 $25 $125 Total Price: $835 在表格上方的数据，都具有原子性。 解释一下上半部分的数据： customer_name： customer_name显然是依赖于customer_id的，而且与order_id没有任何关系。因此在order_table内不应该包含customer_id。 sales_rep_name： 同理，sales_rep_name是依赖于sales_rep_id的，而且与order_id没有任何关系。 因此在order_table内不应该包含sales_rep_name。 address： address是可以发生变化的。如果address依赖于customer_id，则代表address是固定的。 但是在实际情况下，一个订单只能有一个地址，但是收货人可以选择相对于他的多个地址。比如说第一次寄到学校，第二次寄到公司，第三次寄到家里… 因此，address是依赖于order_id的。 接下来再分析一下下面表格的数据： price/unit： 这是一个比较纠结的问题。 price/unit实际上是不依赖于product_id的。因为如果实际操作中一旦改价格，主键不允许重复的特性会导致之前的老价格丢失掉。 但是书上是学的理论知识，将price放到product_table里面也是可以的。因为没有违反任何范式。 因为第二范式的存在，我们不得不生成一个叫做product_table的表格,记录产品信息： 表格： product_table product_id description price/unit 327 Inkjet cartridges $30 563 Laser toner $25 还需要生成customer_table和rep_table两个表格记录ID和名字的对应信息及关系： 表格： customer_table customer_id customer_name 056 CUP 表格： rep_table sales_rep_id sales_rep_name 2 Dylan Stoddart 还需要一张记录所有order信息的表格，记录order的信息。product_table和rep_table中的主键，在此表格中为外键。 表格： order_table order_id date customer_id (fk) address sales_rep_id (fk) 07845 25-06-2016 056 Cambridge square, Cambridge 2 在此表格中，order_id构成主键。 我们在上面创建的所有表格之间都确立了某种联系。所有的表格创建完之后，就可以使用内外键来从Product_order表中确定商品和订单的关系了。 表格： Product_order product_id order_id description quantity total 本表格是product和order的关系表。 在此表格中，product_id和order_id构成联合主键。 数据库管理系统 (DBMS)有关DBMS数据库不仅仅是数据的集合，理解这一点至关重要。数据库是按照理论模型的规则实现的。大约40年前，ANSI(美国国家标准协会)在其三级模型中提出了这一基本概念。这三个层次是: 外部层面 (External level) 概念层面 (Conceptual level) 内部层面 (Internal level) 结构如下图所示： 这个图面内容展示了数据存储在硬盘上的结构。数据库存储的细节只有内部层面 (Internal level)才被指示出来，内部层面是ANSI架构中最低级的一个层级。所有的访问数据的请求和处理，全部由数据库管理系统 (Database management system, DBMS)控制。 在更高一层的概念层面，数据库有一个单一的通用视图 (View)，这个视图可以由一个有特定权限访问DBMS的管理员控制，叫做数据库管理员 (Database Administrator)。 向用户提供视图的好处是：他们可以被数据库管理员用作一种确保安全性的机制。单个用户或者用户组可以被DBA管理赋予适当的访问权限，以控制该试图允许的操作。例如，用户可以读取数据，但是不能修改数据。或者用户只能访问数据库中有限数量的表。 在ANSI体系结构中，概念层面有一个描述用户或者程序员感知的数据组织的概念模式，这也可以被描述成逻辑模式 (Logical schema)。 逻辑模式是由数据库设计者综合所有的数据需求，并从全局的角度对数据库中全部数据的逻辑结构和特征的总体描述。是所有用户的公共数据视图，也叫做全局视图。 Data management system (DBMS): software that controls access to data in a database. Database administrator: a person who uses the DBMS to customize the database to suit user and programmer requirements. DBMS提供的功能无论数据库的大小如何，一种通用的人机沟通方法是使用专用语言SQL。SQL语言会在下一节讨论。 对于大多数的DBMS类型，都有SQL命令的替代方案。比如说DBMS通过开发者接口提供软件管理工具，这种工具允许他们去在数据库内创建表格，并定义属性以及数据类型。 此外，DBMS还为程序员提供了开发用户界面的工具。DBMS还提供了一个查询处理器 (Query processor)，查询处理器允许我们创建和处理数据库中的查询操作。查询就是从数据库中提取和操作数据的机制。 DBMS还可以生成一个和格式化的报告，或者一个表格。程序员可以在UI中合并对于查询和报表的访问。 Developer interface: gives access to software tools provided by a DBMS for creating tables. Query processor: software tools provided by a DBMS to allow creation and execution of a query. Query: used to select data from a database subject to defined conditions. 被DBA使用的DBMS功能DBA的职务是负责设置用户和程序员视图，并定义适当的、特定的访问权限。 DBMS的一个重要特性是数据词典 (Data dictionary)，他是数据库的一部分。除了DBA之外，没有人能够看见数据词典。数据词典包含了有关数据的元数据。数据词典内可以包含以下内容： Field / Attribute names Table name Validation rules Data types Primary keys / Foreign keys Relationships 综上所述，数据词典包含所有表的属性和定义的细节，同时也包括物理存储是如何组织的。 DBA也可以为表格创建索引 (Index)来提高数据库查找数据的性能和能力。 索引是一个用于快速搜索的小型辅助表，它包含被搜索表中的一个attribute和指向该表中tuple的指针。 如果表中包含大量的attribute或者tuple,我们就很有必要为表格创建索引。索引是具有为一只的属性相关联的辅助表。索引表包含属性值和指向原表中对应tuple的指针。索引可以在主键上，也可以在辅助键上。搜索索引表通常来说比全表查询要快得多。 Index: a small secondary table used for rapid searching which contains one attribute from the table being searched and pointers to the tuples in that table. MySQL及命令及语法数据定义语言 (DDL)数据定义语言 (Data definition language, DDL)是SQL中用于创建或者修改表的语言。这些命令只会创建数据库的结构，但是他们不负责将任何数据存入数据库。 下面这是一段DDL的实例： 123456789CREATE DATABASE BandBooking;CREATE TABLE Band ( BandName varchar(25), NumberOfMembers integer);ALTER TABLE Band ADD PRIMARY KEY (BandName);ALTER TABLE Band-Booking; ADD FOREIGN KEY (BandName); REFERENCES Band(BandName); DDL有一些特性： SQL命令由一系列命令组成。 每一个命令由;终止。 一个命令可以包含多行。 不区分大小写。 但是对于命令中的关键字，比如说CREATE或者ALTER使用全大写。对表格名称，attribute名称或者数据类型使用小写。 当命令包含一系列项目的时候，每一个项目使用逗号隔开。 这些例子表明，一旦创建了数据库，就可以创建表和定义属性。可以在CREATE TABLE命令中定义一个主键和一个外键，但是也可以使用如下所示的ALTER TABLE命令(它也可以用来添加额外的attribute)。 数据操作语言 (DML)数据操作语言 (Data manipulation language, DML)可以用于下面这三种情况： 在创建数据库的时候将数据插入到表格中。 修改或删除数据库中的数据。 读取存储在数据库中的数据。 下面我会给出一系列例子来展示使用DML来向表格中填充数据： 123INSERT INTO Band ('ComputerKidz', 5)INSERT INTO Band-Booking (BandName, BookingID)VALUES ('ComputerKidz', '2016/023') 第一行的插入数据的方式是，根据INSERT INTO后面括号里的数据，依次填充每一个attribute。 第二第三行就使用了一种相对保守的方法。首先第二行指定了我需要填充Band-Booking表格中的BandName和BookingID两个attribute，然后在第三行使用VALUES命令按照第二行定义的数据顺序为他们赋值。 你会发现： 两个命令都使用了括号。 如果需要向表格中每一个attribute添加一个值，那么使用INSERT命令比较合理。 这些属性都有顺序。 DML的另一个用途是从数据库中查询数据，无论是原始数据还是合并数据。这些命令总是先从SELECT命令开始。 最简单的查询形式是将attribute作为输出列出来： 1SELECT BandName FROM Band; 代表从Band表格中选出了BandName这个attribute。注意每一个元素中间都有一个空格。 我们假设Band表格只有两个属性。如果要列出两者的值，我们同样由两个方法。 12SELECT BandName, NumberOfMembersFROM Band; 或者: 1SELECT * FROM Band 在第一种方式中，被选中的attribute之间使用逗号隔开，我们也不需要使用括号把attribute括起来。在第二种方式里面，我们使用*(星号)来表示表格中的所有attribute。 我们可以在SQL中使用控制输出指令，来规范我们输出的样式。我们可以使用ORDER BY 命令来将输出的内容排序。比如说我们使用字母顺序来显示乐队名的数据： 123SELECT BandName, NumberOfMembersFROM BandORDER BY BandName 在上面的实例中，我们将BandName和NumberOfMembers两个attribute根据BandName进行了排序。请记住，ORDER BY命令的排序是默认升序排序，如果想使用倒序排序，我们可以将最后一行命令改成这样： 1ORDER BY BandName DESC 升序是小在上大在下，降序是大在上小在下。 在这次查询中，没有重复条目的问题，因为BandName是BandName表的主键。然而，在Band-Booking表中，一个单独的BandName值会出现很多次。因为一个乐队可以有很多不同的Booking。返回Booking值会蹦出很多相同的BandName值。所以我们可以使用GROUP BY可以防止这种情况，如下所示: 123SELECT BandNameFROM Band-BookingGROUP BY BandName; 这样输出的值就会按照不同的BandName归类了。 我们也可以将输出的数据加一些限制条件。这时候就可以使用WHERE命令了： 1234SELECT BandNameFROM Band-BookingWHERE Headlining = 'Y'GROUP BY BandName 上面的命令只会返回当Headlining的值为Y的结果。 也可以同时查询多个attribute： 123SELECT BandName, NumberOfMembersFROM Band WHERE NumberOfMembers &gt; 2ORDER BY BandName; 返回所有人数大于二的乐队。返回内容包含符合条件的两个attribute的内容。 聚合函数 (Aggregate functions)可以对一组值进行计算，并返回一个单一的值。聚合函数有很多种，比如SUM,COUNT或者AVG等等。 下面开始举例： 12SELECT Count(*)FROM Band; 表示Band中所有tuple的数量。 12SELECT AVG(NumberOfMembers)FROM Band; 返回在Band表格中所有NumberOfMembers的平均值。同样： 123SELECT SUM(NumberOfMembers)FROM Band; 返回在Band表格中所有NumberOfMembers的总和。 有时候我们需要的数据存在在两张不同的表格中，这时候我们就需要用到连表查询。查询可以基于两个表中数据之间的连接条件，最常用的链接方式是内连接 (inner join)。如下所示： 1234SELECT VenueName, DateFROM BookingWHERE Band-Booking.BookingID = Booking.BookingIDAND Band-Booking.BandName = 'ComputerKidz' Band-Booking.BandName代表在Band-Booking表格中的attributeBandName。 上表将Band-Booking中的BookingID和Booking中的BookingID连接在了一起。其中Band-Booking表中的BookingID等于Booking表中的BookingID，并且Band-Booking表中的BandName列等于ComputerKidz。 这就是内连接，内连接的条件是Band-Booking.BookingID = Booking.BookingID。 Query Processor会这样处理这一段代码： 搜索乐队名称为ComputerKidz的实例。 查看BookingID。 然后，在Booking表中搜索具有此值的tuple。 对于符合条件的每一个数据，VenueName和Date都在输出中显示。 你也可以使用INNER JOIN命令来执行内连接操作。 1234SELECT table1.column1, table2.column2FROM table1INNER JOIN table2ON table1.common_field = table2.common_field 选定了需要输出attribute之后，使用INNER JOIN命令来确定谁与这些内容发生内连接。 随后使用ON 命令写出内连接条件。 DML的另一个用途是修改存储在数据库中的数据。UPDATE命令用于修改数据。如果ComputerKidz乐队招募了一个额外的成员，下面的SQL语句会做出必要的改变: 123UPDATE BandSET NumberOfMembers = 6WHERE BandName = 'ComputerKidz' 首先定位需要更改值的表格，然后声明我要将NumberOfMembers改成6。最后使用WHERE告诉Query processor说，我要更改BandName是ComputerKidz的值。 如果不使用这个WHERE指令，数据库就会把表格中所有的NumberOfMembers改成6。 DELETE命令用于从数据库中删除数据，我们必须谨慎处理删除数据的操作。假如说乐队ITWizz决定解散，我们就可以从数据库中删除他们的名字： 1234DELETE FROM Band-BookingWHERE BandName = 'ITWizz';DELETE FROM BandWHERE BandName = 'ITWizz' 这样的就在Band-Booking表格和Band表格中都删除了这个乐队。 命令基本操作下面来实操一下： 首先我们需要创建一个数据库。使用create database命令创建一个database。比如说，下列命令： 123create database school_system; 可以创建一个叫做school_system的一个数据库。 输出为： 123Query OK, 1 row affected (0.02 sec) 然后，可以使用show databases;命令展示现有的所有数据库。 运行show databases的输出为： 123456789101112+----------------------------------+| Database |+----------------------------------+| information_schema || mysql || performance_schema || school_system || sys |+----------------------------------+5 rows in set (0.00 sec) 在这里，school_system数据库即为我们刚才创建的数据库，其余的都是自带的。 如果想向数据库内添加数据，需要进入到特定的数据库内。(类似于cd命令)这里可以使用use *数据库名*来进入到特定的数据库。 运行use school_system命令的输出结果为： 123Database changed 代表我们已经成功地进入了此数据库。 接下来，使用create *参数*命令是要定义数据结构。此命令后面需要跟着要填入的数据以及信息。 比如说此命令： 12345678create table student(student_id int,student_name varchar(50),student_gender char(1)); 命令代表创建一个叫做student的表格。里面的参数为： student_id int,代表创建一个名称为student_id的Field。它的数据类型为整型。 student_name varchar(50),代表数据类型是student_name，数据类型是varchar，长度上限为50。P.S. varchar代表“可变的数据长度“。 student_gender char(1),代表在student_gender中，数据类型是char，上限为1。char代表”定长数据“。 输出结果为: 123Query OK, 0 rows affected (0.05 sec) 代表表格创建成功了。 这里有几个注意事项： ;代表一行命令结束。当写下一行命令后，程序不会直接完成操作，直到出现了一个;。 如果在student_gender char(1)的末尾加一个逗号，会判定为错误。因为这已经是此次create命令里面最后一行参数，不需要再次使用逗号隔开参数。 多有()是成对出现的。括号的范围代表命令参数的范围。 使用show tables;命令展示数据库内所有的table。在这里运行show tables;的结果为： 12345678+--------------------------------------+| Tables_in_school_system |+--------------------------------------+| student |+--------------------------------------+1 row in set (0.01 sec) 说明已经存在一个student table了 之后，我们需要写入数据。 使用insert into命令写入数据。以下命令： 123insert into student values(1000, '张三','M'); 代表向student表格内插入(1000, '张三','M')三个数据。其中：1000对应student_id张三对应student_nameM对应student_gender 。 运行后输出为： 123Query OK, 1 row affected (0.01 sec) 同样代表写入成功。 输入select命令，可以查看table中的数据：运行select * from student;命令的输出为： 12345678+-----------------+----------------------+-------------------------+| student_id | student_name | student_gender |+-----------------+----------------------+-------------------------+| 1000 | 张三 | M |+-----------------+----------------------+-------------------------+1 row in set (0.00 sec) 在此命令中，*代表范围内的全部。 PART TWO：基本问题的解决与编程技能第十二章：算法设计与解决问题计算思维计算思维是一种解决问题的思路，通常以清晰的步骤来呈现。计算思维是一种逻辑思维，在计算机这门学科中，使用计算思维来解决问题是十分常见的。 计算思维包括五大部分：“抽象问题”，“分解问题”，“数据建模”，“样式识别”和“算法思维”。 抽象问题抽象问题的目标是将问题最本质最中心的部分提取出来，过滤掉我们不需要的信息，以便我们分析并解决问题。这在我们的生活中是很常见的，比如开车在市中心规划最近的路线，我们就可以抽象我们想要的信息单独处理。 就像数学中的化简思维一样，把复杂的问题简单化，就可以让我们解决更困难的问题。 分解问题下一步就是要把一个大块的问题分解成若干小问题，并一个一个解决。 数据建模数据建模管的是数据的管理，分析和处理。 样式识别有点像是套公式的意思：总结问题并发现是不是已经有相关的；成系统的解决方法，可以解决这个问题。比如说移用已经存在的算法，比如冒泡排序。 算法设计最后我们就需要设计一个可以解决问题的算法。 Algorithm: a sequence of defined steps that can be carried out to perform a task. 算法我们每天都会使用算法。假如说你想要烤个蛋糕，你可以遵循下面的步骤： 称量下列的原料：200g白糖，200g黄油，4个鸡蛋，200g面粉，2茶匙的酵母和2茶匙的牛奶。 将这些食材放入一个大碗中混合，只到混合物变得质地均匀。 将混合物倒入一个蛋糕模具。 放入烤箱，将烤箱设置为190℃，烘烤20分钟。 检查蛋糕到底有没有烤好。 将蛋糕从烤箱中的模具中拿出来，并放置在铁架上冷却。 上面的这一些步骤就是一个算法。这些食材是输入部分，而蛋糕就是这个算法的输出。算法具体的过程是讲原料混合，然后放入烤箱烘烤。 有些时候问题是会发生一些灵活的变化的，其中一些条件变化就会影响到我们解决问题的步骤。比如说我们现在要去考虑如何在伦敦地铁中到达想要去的目的地。 从 King’s Cross St. Pancras 到 Westminster,一共有两条备选路线： A：乘坐Victoria Line 到Green Park(4站)，然后再换乘Jubilee Line到Westminster(1站)。B：乘坐Piccadilly Line 到Green Park(6站)，然后再换乘Jubilee Line到Westminster(1站)。 A看起来像是最好的路线，但是如果在Victoria Line上面有施工的话，那么B就是最好的路线。这种情况下我们就需要重新设计我们的算法。 如果以上的逻辑写成有点类似于代码的形式，那么它看起来就是这样的： 12345678IF there are engineering works on the Victoria Line THEN Take the Piccadilly Line to Green Park (6 stations) Take the Jubilee Line to Westminster (1 station) ELSE Take the Victoria Line to Green Park (4 stations) Take the Jubilee Line to Westminster (1 station) 算法的表示在计算机中，我们会先将代码的结构或者思路以结构化英语 (Structured English)或者伪代码 (Pseudocode)表示。有时我们也会使用流程图 (Flowchart)，侧重于表示代码的逻辑过程。 Structured English: a subset of the English language that consists of command statements used to describe an algorithm. Pseudocode: a way of using keywords and identifiers to describe an algorithm without following the syntax of a particular programming language. Flowchart: shapes linked together to represent the sequential steps of an algorithm. 算法包含很多细分的步骤，但是有些时候我们不想让计算机执行某几行代码，或者我们想重复某几行代码。在计算机科学这门课程中，当我们在编写算法的时候，我们需要遵守下面这几个基本的结构： 赋值： 赋予数值一个名称，或者叫做标识符，或者更改指定标识符所代表的值。 顺序： 一个接一个地执行步骤。 选择： 在某些条件下执行某些步骤，否则就执行另一些步骤。 重复： 一系列的步骤被重复执行多次，这也可以被叫做迭代或者循环。 我们在使用计算机解决问题时会涉及各种各样的数据，数据流在计算机中的处理方式一般是输入 -&gt; 处理 -&gt; 输出。 处理好输入和输出后，我们就需要深入处理部分。首先我们需要了解处理的详细方法是什么，处理的步骤是什么样子的，我们的程序会怎么样设计。 下面给出了部分处理的不同表示方法。包括结构化英语，伪代码和流程图。 分配与顺序： 结构化英语： SET A TO 34INCREMENT B 伪代码： A ← 34B ← B + 1 选择： 结构化英语： IF A IN GREATER THAN B THEN … ELSE … 伪代码： IF A &gt; B THEN …. ELSE ….ENDIF 重复： 结构化英语： REPEAT UNTIL A IS EQUAL TO B… 伪代码： REPEAT …UNTIL A = B 输入： 结构化英语： INPUT A 伪代码： INPUT “Prompt: “ A 输出： 结构化英语： OUTPUT “Message”OUTPUT B 伪代码： OUTPUT “Message”, B 变量定义当我们在程序中处理数据的时候，他们都需要被存进内存中。我们需要把这些数据放在一个特殊的位置，好允许他们去自由读写。我们一般将这些内存中的位置叫做变量 (Variables)。这些变量就好比是一个贴上标签的盒子。当一个值被输入了之后，值就会被存在一个有标识的容器内。 Variable: a storage location for a data value that has an identifier. 标识符表标识符表是用来解释每一个变量是干嘛用的，一般来说还要列出他们的数据类型。 Identifier table: a table listing the variable identifiers required for the solution, with explanations and data types. 比如说我这里有一个被写成结构化英语形式的问题：123INPUT number of milesCALCULATE number of kmOUTPUT calculated result as km 在我开始写伪代码之前，我需要先分析问题如何解决。在这个问题中，我们需要设计一个变量，来存储输入的里程值，叫做Miles好了。同时还需要另一个变量，用来存储转化为公里数后的结果。这里我选择定义这个变量为Km。 这样就可以开始列表了： Identifier Explanation Miles Distance as a whole number of miles. Km The result from using the given formula: Km = Miles * 1.61. 请记住：所有的标识符表中都必须包含标识符，数据类型和解释。 （我只不过是没在这里加数据类型而已，因为数据类型在下一章才会接触到） 赋值下面我们会写到很多伪代码。课本里出现的伪代码并不是一个确切的语言，也就是说，可能每一家出版社的计算机课本的伪代码语法都不一样。下面的赋值内容中出现的所有伪代码，同样确定了本书伪代码的语言规范。本书之后所有的伪代码全部遵守下面的语法规范。 向变量中赋值我们来简单举一个例子。这个例子在下面的小节中也会用到。 假如说我有一个变量NumberOfGuesses,用来记录在一个猜数字的游戏中，玩家一共猜了多少次；玩家的名字会存储在一个叫做ThisPlayer的变量中。玩家猜的数字会存在一个叫做Number的变量中。 那么下面的伪代码就讲述了我将用户的输入存入Number的过程：1INPUT Number 随后我们要将NumberOfGuesses中的数值变为1，因为玩家做出了他的第一次猜测：1NumberOfGuesses ← 1 更新值假设玩家再次做出了一次猜测，那么变量NumberOfGuesses就应该加一： 1NumberOfGuesses ← NumberOfGuesses + 1 复制值值可以被从一个变量中复制到另一个变量中。 假如说我们有一个变量Value1，里面有一个值15。现在我们想要将这个值复制到变量Value2中，伪代码就可以这么写： 1Value2 ← Value1 放在左边的变量是复制操作的目标变量。复制完成后，Value1和Value2的值都是15。 交换值如果我们想要交换两个值，我们就需要第三个变量帮忙了。 假设Value1为15，Value2为34。我想要让Value1和Value2的位置交换，这时候我可以定义一个新的变量，叫做Temp，用于存放临时数据。 接下来就可以写伪代码了。这看起来应该不算难理解： 123Temp ← Value1Value1 ← Value2Value2 ← Temp 逻辑表达式还记得一开始的地铁问题吗？ 123456789IF there are engineering works on the Victoria Line THEN Take the Piccadilly Line to Green Park (6 stations) Take the Jubilee Line to Westminster (1 station) ELSE Take the Victoria Line to Green Park (4 stations) Take the Jubilee Line to Westminster (1 station) 在这个问题的实际解决过程中，我们需要使用逻辑表达式来解决问题。具体是用于判断那个IF条件。 下面我会列出一些本书中会用到的逻辑运算符： Operator Comparison = 等于 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 &lt;&gt; 不等于 经过逻辑运算后，会输出一个布尔值（TRUE 或者 FALSE）。特别注意的是：在一些语言里面，’=’符号通常作为赋值使用，但是再本书的伪代码部分中，‘=’是逻辑运算符，’←’是赋值符号。 Example 举个例子： 13岁以下的人被归类为儿童，19岁以上的人被归类为成年人。如果他们在13到19岁之间，他们被归类为青少年。我们可以把这些语句写成逻辑语句： If Age &lt; 13 then person is a child. If Age &gt; 19 then person is an adult. If Age &gt;= 13 AND Age &lt;= 19 then person is a teenager. Example 我们再举一个例子：这里有一个猜数字的游戏。猜数游戏会根据特定条件采取不同的步骤。下面是算法描述。 玩家需要输入一个数字，来猜测存储的秘密数字。 如果猜对了，那么程序就会显示祝贺语。 如果这个数字比秘密数字要大，就会显示“秘密数字比他要小。” 如果这个数字比秘密数字要小，就会显示“秘密数字比他要大。” 我们就可以将这个算法用伪代码写出来： 12345678910111213SET value for secret numberINPUT GuessIF Guess = SecretNumber THEN OUTPUT \"Well done. You have guessed the secret number.\" ELSE IF Guess &gt; SecretNumber THEN OUTPUT \"Secret number is smaller.\" ELSE OUTPUT \"Secret number is greater.\" ENDIFENDIF 使用逻辑操作符AND、OR和NOT可以形成更复杂的条件。例如，猜数字游戏可能允许玩家多次猜测,如果玩家猜了10次仍然没有猜出秘密数字，则输出不同的消息: 12345678910111213141516IF Guess = SecretNumber THEN OUTPUT \"Well done. You have guessed the secret number.\" ELSE IF Guess &gt; SecretNumber AND NumberofGuesses = 10 THEN OUTPUT \"You still have not guessed the secret number.\" ELSE IF Guess &gt; SecretNumber THEN OUTPUT \"Secret number is smaller.\" ELSE OUTPUT \"Secret number is greater.\" ENDIF ENDIFENDIF 像上面这样：当一个IF语句包含另一个IF语句时，我们称它们为嵌套IF语句。 Nested IF statements: conditional statements within conditional statements. 循环有些时候我们的代码需要重复执行某些命令。大家都知道代码是由上到下顺序执行的。也就是说，如果按照传统的方法重复指令，就需要一遍又一遍的写下这些代码。这就会给代码带来冗余。 但是如果我们使用重复结构，或者叫做循环，就可以避免一遍又一遍地写相同的伪代码。 Example 给个例子： 我需要写一个程序，目标是将输入的10个数字里面找出最大的数字。 我们还需要一个变量来存储一个计数器，以便我们知道什么时候比较了10个数字。 先写标识符表： Identifier Explanation BiggestSoFar Stores the biggest number input so far. NextNumber The next number to be input. Counter Stores how many numbers have been input so far. 代码写出来是这样的： 1234567891011INPUT BiggestSoFarCounter ← 1REPEAT INPUT NextNumber Counter ← Counter + 1 IF NextNumber &gt; BiggestSoFar THEN BiggestSoFar ← NextNumber ENDIFUNTIL Counter = 10OUTPUT BiggestSoFar 在这个程序中出现了循环指令：REPEAT...UNTIL 在REPEAT和UNTIL包裹的区域内，是将要循环的步骤。UNTIL后面会跟一个逻辑表达式。当逻辑表达式成立的时候，跳出循环。 这个题目还可以换一种方法来写： Identifier Explanation BiggestSoFar Stores the biggest number input so far. NextNumber The next number to be input. Counter Counts the number of times round the loop. 请注意，Counter变量的用途已经改变了。这里的Counter是要记录循环的次数。 123456789INPUT BiggestSoFarFOR Counter ← 2 TO 10 INPUT NextNumber IF NextNumber &gt; BiggestSoFar THEN BiggestSoFar ← NextNumber ENDIFNEXT CounterOUTPUT BiggestSoFar 在第一次循环的时候，Counter的值被设为了2，下一次循环就变成了3，以此类推。最后一次循环的时候，Counter的值会被设为10。这时候达到了第二行定义过的Counter最大值，所以就会跳出循环。 Rogue value是在算法上下文中的一个特殊值，通常出现在递归或者循环算法中，作为终止条件出现。 Rogue value: a value used to terminate a sequence of values. Example 下面我来用一个例子具体解释一下rogue value是干嘛用的： 有一个非零数列以0结尾。这个数列是输入部分，请你找出这个数列中的最大值。 在这个例子中，我们可以将rogue value设为0。因为0与数据类型相同，但是超出了我们正常期望值的范围。好比说如果我的输入会包含0，那么我也可以选择-1作为rogue value。 Identifier Explanation BiggestSoFar Stores the biggest number input so far. NextNumber The next number to be input. 其中一个可行的方案可以是这样的： 123456789INPUT BiggestSoFarREPEAT INPUT NextNumber IF NextNumber &gt; BiggestSoFar THEN BiggestSoFar ← NextNumber ENDIFUNTIL NextNumber = 0OUTPUT BiggestSoFar 这种算法在绝大多数的情况下可以正常工作，但是如果唯一的输入是零，整个程序就炸了。 所以说我们可以使用WHILE…ENDWHILE循环来实现同样的目的： 12345678910INPUT NextNumberBiggestSoFar ← NextNumberWHILE NextNumber &lt;&gt; 0 DO INPUT NextNumber IF NextNumber &gt; BiggestSoFar THEN BiggestSoFar ← NextNumber ENDIFENDWHILEOUTPUT BiggestSoFar 在我们进入循环之前，我们需要检查是否存在一个非零的数字输入进来。为了处理第一个数字，我们需要将其存储在NextNumber和BiggestSoFar变量中。如果我们的第一个数字是零，就不执行循环中的指令。 逐步求精法就像我们一开始在计算机思维那里提到过的：许多我们想要解决的问题比我们目前遇到的问题更大。为了让更大的问题更容易解决，我们将问题分解为更小的步骤。这些可能需要进一步分解，直到步骤足够小，可以轻松解决。 为了使问题的解决方案可编程，我们需要将解决方案的步骤分解为序列、分配、选择、重复、输入和输出。 我们可以使用一种称为逐步求精的方法，将轮廓解决方案的步骤分解为更小的步骤，直到它足够详细。在本章节的一开始，我们就举了一个烤蛋糕的例子。当时的第二步就被我们简单的细化了一下。 Stepwise refinement: breaking down the steps of an outline solution into smaller and smaller steps. Example 老规矩，上例子： 写一个程序：将选定的符号和一个奇数作为输入。输出一个完全由选定的符号组成的金字塔形状，最后一行中的符号数量与输入的数字匹配。 好比说我输入一个数字9，就会给我输出这个： 12345 A AAA AAAAA AAAAAAAAAAAAAAAA 上面的排版可能会歪掉，所以我简单描述下：上面代码块里面就是一个由A组成的，最下面一行有九个A的三角形。 首先分解问题：具体的步骤可以写成下面的这几行结构化英语： 1234561. Set up initial values2. REPEAT3. Output number of spaces4. Output number of symbols5. Adjust number of spaces and number of symbols to be output in next row6. UNTIL the required number of symbols have been output in one row 这里的1. 2. 3.等代表解决问题需要的步骤，下面会有提到。 首先初始化，然后重复以下步骤，直到完成第一行的输出： 输出空格数 输出符号 调整下一行要输出的空格数和符号数 其次我们还需要考虑需要使用哪些变量，以及这些变量的作用。比如说，我们还需要： 组成金字塔的符号（组成金字塔具体的字符） 在最后一行中字符的个数（为了让金字塔看起来对称，我们必须输入一个奇数） 然后我们还需要计算形成第一行需要多少空格。如果这个金字塔是对称的，那么第一行的最后一个字符一定出现在最后一行字符的中间位置。 我们需要将第一行输出的符号数量设置为1，这样我们就需要下面的标识符： Identifier Explanation Symbol The character symbol to form the pyramid. MaxNumberOfSymbols The number of symbols in the final row. NumberOfSpaces The number of spaces to be output in the current row. NumberOfSymbols The number of symbols to be output in the current row. 分解问题之后，解决他就相对简单了。 解决完前摇之后，就可以将精力专注于写解决方案上了： 第一部分初始化的代码如下： 1234INPUT SymbolINPUT MaxNumberOfSymbolsNumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2NumberOfSymbols ← 1 因为变量MaxNumberOfSymbols需要一个合法的输入（一个奇数），所以我们就需要将第二行替换成下面这样，才可以保证合法输入。 123REPEAT INPUT MaxNumberOfSymbolsUNTIL MaxNumberOfSymbols MOD 2 = 1 这里的MOD是取余的意思。如果MaxNumberOfSymbols除以二之后是1，那么这就代表输入是合法的。如果不合法，那么程序就会一直重复输入这一步，直到输入合法。 替换进去，第一步的完整代码就是： 1234567INPUT SymbolREPEAT INPUT MaxNumberOfSymbolsUNTIL MaxNumberOfSymbols MOD 2 = 1NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2NumberOfSymbols ← 1 第二步就是个重复开始字段，所以接下来细说第三步和第四步。 这是第三步的解法： 123FOR i ← 1 TO NumberOfSpaces OUTPUT SpaceNEXT i 一个原味i循环。 然后是第四步： 1234FOR i ← 1 TO NumberOfSymbols OUTPUT SymbolNEXT iOUTPUT Newline 在第五步中，我们需要将接下来每一行的空格的数量减少1，将符号的数量增加2: 12NumberOfSpaces ← NumberOfSpaces - 1NumberOfSymbols ← NumberOfSymbols + 2 第六步会检查下一行的符号数量现在是否大于开始时输入的值: 1UNTIL NumberOfSymbols &gt; MaxNumberOfSymbols 最后就可以把整块代码合起来了。这就是最后的产物： 1234567891011121314151617INPUT SymbolREPEAT INPUT MaxNumberOfSymbolsUNTIL MaxNumberOfSymbols MOD 2 = 1NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2NumberOfSymbols ← 1REPEAT FOR i ← 1 TO NumberOfSpaces OUTPUT Space NEXT i FOR i ← 1 TO NumberOfSymbols OUTPUT Symbol NEXT i OUTPUT Newline NumberOfSpaces ← NumberOfSpaces - 1 NumberOfSymbols ← NumberOfSymbols + 2UNTIL NumberOfSymbols &gt; MaxNumberOfSymbols Stepwise refinement本质上来讲就是分解步骤。把他用到写程序中是一个很好的习惯（ 模块另一种开发解决方案的方法是将问题分解为子任务。每个子任务可以被认为是一个单独细化的模块。模块里面包含的东西是过程 (Procedure)和函数 (Function)。 过程 (Procedure)将许多小的步骤组合在一起，并给它们一个名称(标识符)。当我们想引用这组步骤时，可以使用这个标识符。当我们想要执行过程中的步骤时，我们通过过程的名称调用该过程。 Procedure: a sequence of steps that is given an identifier and can be called to perform a sub-task. 过程是一组给定标识符的步骤，可以调用它们执行一个子任务 函数 (Function)同样将许多步骤组合在一起，并给它们一个名称(标识符)。但是这些步骤会生成并返回一个用于表达式的值。 Function: a sequence of steps that is given an identifier and returns a single value; function call is part of an expression. 函数和过程的区别在于，函数可以返回值，而过程则不能。因为函数和过程是两种不同的代码块，它们的设计目的和用途不同。函数的设计目的是为了返回一个值，而过程的设计目的是为了执行一些操作。虽然说你可以将函数看作是一种特殊的过程，因为它们都是由一些语句组成的代码块。 因为函数返回一个值，所以函数定义同样声明了这个值的数据类型。我们会在下一章详细介绍数据类型。 Example 上一个小结说过的画金字塔的例子，可以完全改成模块化的。 首先根据之前的解决方法，先写一个主程序： 123456CALL SetValuesREPEAT CALL OutputSpaces CALL OutputSymbols CALL AdjustValuesForNextRowUNTIL NumberOfSymbols &gt; MaxNumberOfSymbols 你会发现主程序里面充满了CALL。CALL说白了就是调用。举个例子，CALL SetValues就是要调用SetValues模块。 然后我们填充每一个模块中的内容，就可以完美运行了： 12345678910111213141516171819202122232425262728293031323334353637383940PROCEDURE SetValues INPUT Symbol INPUT MaxNumberOfSymbols NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2 NumberOfSymbols ← 1ENDPROCEDUREPROCEDURE InputMaxNumberOfSymbols REPEAT INPUT MaxNumberOfSymbols UNTIL MaxNumberOfSymbols MOD 2 = 1ENDPROCEDUREPROCEDURE OutputSpaces FOR i ← 1 TO NumberOfSpaces OUTPUT Space NEXT iENDPROCEDUREPROCEDURE OutputSymbols FOR i ← 1 TO NumberOfSymbols OUTPUT Symbol NEXT i OUTPUT NewlineENDPROCEDUREPROCEDURE AdjustValuesForNextRow NumberOfSpaces ← NumberOfSpaces - 1 NumberOfSymbols ← NumberOfSymbols + 2ENDPROCEDURECALL SetValuesREPEAT CALL OutputSpaces CALL OutputSymbols CALL AdjustValuesForNextRowUNTIL NumberOfSymbols &gt; MaxNumberOfSymbols 同样也可以将某些模块从过程换为函数。过程基本是一样的所以不多赘述了。 变量分全局变量 (Global variable)和局部变量 (Local variable)。 局部变量是在函数内部定义的变量，只在本函数范围内有效。全局变量是在函数外部定义的变量，从定义变量的位置到本源文件结束都有效。 在函数中，局部变量和全局变量的区别在于它们的作用域和生命周期。局部变量只在函数内部有效，而全局变量则在整个程序中都有效。 比如说：以下代码段中，x是一个局部变量，只在 myFunction() 函数内部有效。而 y 是一个全局变量，在整个程序中都有效。 12345int y = 10; // 全局变量void myFunction() { int x = 5; // 局部变量} Local variable: a variable that is accessible only within the module in which is declared. Global variable: a variable that is accessible from all modules. 第十三章：数据类型与结构数据类型基本数据类型基本数据类型是那些可以通过编程语言内建的命令简单定义的变量。基本数据类型也称为原子数据类型。 在计算机科学中，整数称为整数，带有小数点的数称为实数。如果条件要么为真，要么为假，那么这些就是逻辑值，称为布尔值 (Boolean)。有时，我们可能想存储一个字符，这就是所谓的CHAR。如果值总是整数，则应该定义为INTEGER类型，例如在计算循环的迭代次数时。 其他数据类型如下表： Data type Explanation INTEGER 一个正负数字 REAL 一个正负数字，但是这个数字有小数位 CHAR 一个字符 STRING 字符串（一堆字符） BOOLEAN 逻辑表述：真或假 （TRUEorFALSE） DATE 由日、月和年组成的日期，有时包括小时、分钟和秒的时间 记录类型有时不同数据类型的变量是一个逻辑组。例如关于一个人的数据可以包含姓名、出生日期、身高、兄弟姐妹数量、是否是全日制学生，等等。其中：姓名的数据类型是STRING，出生日期的数据类型是DATE，身高的数据类型是REAL，兄弟姐妹数量的数据类型是INTEGER，是否是全日制学生BOOLEAN。 我们可以声明一个包含复杂属性的一个变量。record type是一种用户定义的类型(user-defined type)，因为程序员可以决定将哪些变量(字段)记录下来。 记录类型(Record type)也称为复合类型(Composite type)。 可以在伪代码中以这样的形式创建一个记录类型： 12345TYPE &lt;TypeIdentifier&gt; DECLARE &lt;field identifier&gt; : &lt;data type&gt; . .ENDTYPE 其中：&lt;TypeIdentifier&gt;是这个记录类型的名称，&lt;field identifier&gt;是其中的一个参数，而&lt;data type&gt;就是声明这个参数的数据类型。 我们现在狠狠的声明了一个数据类型。如果我们想要为一个变量赋予这样的数据类型的话，我们需要先声明： 1DECLARE &lt;variable identifier&gt; : &lt;TypeIdentifier&gt; 想要去调用某个参数，我们就可以使用这样的语法： 1&lt;TypeIdentifier&gt;.&lt;field identifier&gt; 十分的容易，十分的简单。 按照上面的“关于一个人的数据”，我们可以将定义这个记录类型的过程写成伪代码： 1234567TYPE PersonType Name : STRING DateOfBirth : DATE Height : REAL NumberOfSiblings : INTEGER IsFullTimeStudent : BOOLEANENDTYPE 假如说我们要赋予Person这个变量这样的数据类型，我们就先来一步声明： 1DECLARE Person : PersonType 然后我们就可以对其中的一些参数执行一些操作了。比如说： 赋值： 123Person.Name ← \"Fred\"Person.NumberOfSiblings ← 3Person.IsFullTimeStudent ← TRUE 想要输出其中的一个参数，直接运行下面的命令： 1OUTPUT Person.Name 数组接下来唠唠数组。 有时我们需要将数据值组织成一个列表或表格，亦或者是矩阵。在大多数编程语言中，这些结构称为数组。数组是一组有序的数据项，通常里面所有元素的数据类型相同，并使用一个标识符组合在一起。使用数组维度的数组索引 (Array index)来对各个数组元素进行寻址操作。 你可以这么理解：一个列表是一个一维数组，而一个表格或者是矩阵是一个二维数组。 在编写伪代码时，数组需要在使用之前声明。这意味着要选择一个标识符、要存储在数组中的值的数据类型以及每个维度的上界 (Upper bound)和下界 (Lower bound)。 Array index: row or column number of an individual array element. Upper bound: the highest number index of an array dimension Lower bound: the smallest number index of an array dimension. 一维数组当我们在纸上写下一个列表的时候，我们一般会不自觉地给每一个元素编号。第一个元素的编号通常是1。所以我们可以像看待标号列表一样看待数组。 很多的编程语言，像Java，Python，或者是VB.NET，都将第一个元素编号设为0.这同样是这个数组的下界。上界就是这个数列里面最大编号。 在伪代码中，可以使用下面的方式来声明一个一维数组： 1DECLARE &lt;arrayIdentifier&gt; : ARRAY[&lt;lowerBound&gt;:&lt;upperBound&gt;] OF &lt;dataType&gt; &lt;arrayIdentifier&gt;是这个数组的标识符，&lt;lowerBound&gt;和&lt;upperBound&gt;是这个数组的上下界，然后&lt;dataType&gt;是这个数组内元素的数据类型。 举例子： 1234DECLARE List1 : ARRAY[1:3] OF STRINGDECLARE List2 : ARRAY[0:5] OF INTEGERDECLARE List3 : ARRAY[1:100] OF INTEGERDECLARE List4 : ARRAY[0:25] OF CHAR 这几个数组的特性依次如下： 数组List1的上下界是1和3，内容的数据类型为STRING,这个数组内一共有3个元素。 数组List2的上下界是0和5，内容的数据类型为INTEGER,这个数组内一共有6个元素。 数组List3的上下界是1和100，内容的数据类型为INTEGER,这个数组内一共有100个元素。 数组List4的上下界是0和25，内容的数据类型为CHAR,这个数组内一共有26个元素。 访问一维数组可以通过索引值访问数组中的特定元素。在伪代码中，我们可以这样写: 1&lt;arrayIdentifier&gt;[x] &lt;arrayIdentifier&gt;是数组的标识符，而[x]是索引值，用于索引对应的元素。 比如说有一个数组MyList,那么它的第n个元素就是MyList[n]。 你可以用它来执行各种操作。比如说赋值： 12NList[25] ← 0AList[3] ← 'D' 一个是将NList中的第25个元素赋值为0，一个是将AList中第3个元素赋值为字符D。 Example 上例题：你会输入一个值，然后你需要在包含7个数字的ID数组中查找这个数字。 从数组的第一个元素开始，依次检查每个元素，直到找到搜索值或到达数组的末尾。这种方法称为线性搜索 (Linear search)。 Linear search: checking each element of an array in turn for a required value. 先上标识符表： Identifier Data type Explanation MyList ARRAY[0:6] OF INTEGER Data structure (1D array) to store seven numbers. MaxIndex INTEGER The number of elements in the array. SearchValue INTEGER The value to be searched for. Found BOOLEAN TRUEif the value has been found. FALSE if the value has not been found. Index INTEGER Index of the array element currently being processed. 然后就是伪代码： 1234567891011121314151617MaxIndex ← 6INPUT SearchValueFound ← FALSEIndex ← -1REPEAT Index ← Index + 1 IF MyList[Index] = SearchValue THEN Found ← TRUE ENDIFUNTIL Found = TRUE OR Index &gt;= MaxIndexIF Found = TRUE THEN OUTPUT \"Value found at location: \" Index ELSE OUTPUT \"Value not found\"ENDIF 挺好理解的一个程序。通过每轮循环Index + 1来实现数组的遍历。 二维数组当我们在纸上写下一个矩阵，并希望使用索引来指出我需要引用的元素的时候，按惯例来讲是先提供行号，再提供列号。 所以说在我们声明二位数组的时候，我们需要先给出行数，再给出列数。同样，我们还需要提供每一个维度的上下界。 在伪代码中，定义一个二维数组都是这样写的： 1DECLARE &lt;identifier&gt; : ARRAY[&lt;1Bound1&gt;:&lt;uBound1&gt;,&lt;1Bound2&gt;:&lt;uBound2&gt;] OF &lt;datatype&gt; 其中&lt;identifier&gt;是二维数组的标识符，&lt;1Bound1&gt;和&lt;uBound1&gt;是第一维的上下界，&lt;1Bound2&gt;和&lt;uBound2&gt;是第二维的上下界。&lt;datatype&gt;是我们需要向元素定义的数据类型。 在一个二维数列中，一个元素可以从0开始标记。但是有些时候还是使用从标签1开始的行列标记更直观一点。 比如说我们想要声明一个二维数列，用来表示一个棋盘。这个棋盘有6行7列。这样写伪代码是没有问题的： 1Board : ARRAY[1:6,1:7] OF INTEGER 访问二维数列想要访问二维数列中的元素，我们需要使用一对儿索引来访问二维数列中的一个元素。 1&lt;arrayIdentifier&gt;[x,y] 其中&lt;arrayIdentifier&gt;是需要读取的数列的标识符，[x,y]是这一对索引。这一对索引就可以像坐标一样定位其中的一个确切元素。 比如说下面的伪代码： 1Board[3,4] ← 0 这一步可以将第三行第四列的元素设为0。 当我们想要读取一个一维数列中的全部元素，就需要使用循环来遍历出每一个元素的内容。而在二维数列，我们需要使用一个循环语句来遍历每一行，然后在遍历每一行的同时遍历每一列，以读取出所有的数据。这里是用了一个循环嵌套，aka (nested loops)，我们在之前有提到。 这样的话用结构化英语写出来就是： 123For each row For each column Assign the initial value to the element at the current position 文本文档当我们需要需要永久存储数据时，使用文本文件是其中的一种方法。 例如，程序执行时保存在数组中的任何数据都将在程序停止时丢失。你可以将数据保存到文件中，并在后续执行时需要读取。 向文本文档中写入123OPENFILE &lt;filename&gt; FOR WRITE // open the file for writingWRITEFILE &lt;filename&gt;, &lt;stringValue&gt; // write a line of text to the fileCLOSEFILE &lt;filename&gt; // close file 从文本文档中读取现有的文件可以由程序读取。下面伪代码语句提供了从文件读取数据的功能: 1234OPENFILE &lt;filename&gt; FOR READ // open the file for writingREADFILE &lt;filename&gt;, &lt;stringVariable&gt; // write a line of text to the fileCLOSEFILE &lt;filename&gt; // close file 向文本文档中追加内容有时，我们可能希望向现有文件添加数据，而不是创建新文件，这可以在追加模式下完成：它将新数据添加到现有文件的末尾。 1234567891011121314151617181920212223OPENFILE &lt;filename&gt; FOR APPEND // open file for appendWRITEFILE &lt;filename&gt;, &lt;stringValue&gt; // write a line of text to the fileCLOSEFILE &lt;filename&gt; // close file``` &lt;br /&gt;---### **文件终止符 (EOF)**The **End-of-file marker (EOF)**. 如果想从头到尾读取文件，可以使用条件循环。 每一个文本文件的末尾有一个特殊的标记，我们可以对它进行测试。 测试这个特殊的文件结束标记是许多编程语言的标准函数。每次调用这个函数时，它都会测试这个标记，如果还没有到达文件末尾，则返回FALSE，如果到达文件末尾标记，则返回TRUE。 在伪代码中，我们将这个函数称为`EOF()`。我们可以使用结构`REPEAT.. until EOF()`。 如果文件可能不包含任何数据，最好使用`WHILE NOT EOF()`。下面是一个例子： OPENFILE “Test.txt” FOR READWHILE NOT EOF(“Test.txt”) DO READFILE “Test.txt”, TextString OUTPUT TextStringENDWHILECLOSEFILE “Test.txt”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339&lt;br /&gt;---## **抽象数据类型 (ADT)** **抽象数据类型 (Abstract data type, ADT)**是一组数据和一组相关操作的集合。 说的简单点，抽象数据类型就是与对该数据类型有意义的操作封装在一起的数据类型。抽象数据类型与下方的几个条件息息相关： - 创建该数据结构的一个新实例- 在数据结构中查找一个元素- 向数据结构中插入一个新成员- 从数据结构中删除一个元素- 以系统的方式访问存储在数据结构中的所有元素。&lt;article class=\"message is-info\"&gt;&lt;div class=\"message-body\"&gt;&lt;b&gt;Abstract Data Type: a collection of data with associated operations.&lt;/b&gt;&lt;/div&gt;&lt;/article&gt; 本章的其余部分介绍下列抽象数据类型，分别是栈、队列和链表。 &lt;br /&gt;---## **栈**想下现实世界中的栈有哪些特征?要堆东西，我们把东西堆在一起。可访问的元素是栈顶的元素。如果我们试图在堆栈中找到一个元素并将其取出，很可能会导致这一堆元素坍塌。![](https://note.youdao.com/yws/api/personal/file/WEB4a6b4649bb9e28b3b7a2a8f8c8564042?method=download&amp;shareKey=c35ea6d3290bdc10432b8879cfd244cf)上图显示了我们如何以如下顺序添加四个元素时表示堆栈:A、B、C、D。 注意，这些槽是从下往上编号的，因为这感觉更自然。`BaseOfStackPointer`始终指向栈中的第一个位置。`TopOfStackPointer`指向最后一个压入栈的元素。 当一个元素从栈中**弹出(POP)**时，`TopOfStackPointer`将递减，指向当前栈顶的元素。 当栈为空时，`TopOfStackPointer`的值为-1。要使用一维数组来实现这个栈，可以这样写: `DECLARE Stack:ARRAY[0:7] OF CHAR`&lt;br /&gt;---## **队列** 现实世界中的**队列 (Queue)**有哪些特征? 当人们排队时，他们在最后加入队伍。人们从队伍的前面离开队伍。如果是一个有序的队列，就不会有人插队，人们也不会从其他位置离开。 ![](https://note.youdao.com/yws/api/personal/file/WEB108883d40d0a36d463abd78e763eafcc?method=download&amp;shareKey=a9c1c3143ae5e63cc2102e170818c8a3)上图展示了如何表示有5个元素以如下顺序加入队列:a、B、C、D、E。要使用数组实现队列，我们可以假设队列的前端位于位置0。 当队列为空时，`EndOfQueuePointer`的值为-1。当有一个值加入队列时，`End0fQueuePointer`会先加1，然后再将该值添加到指针所指向的数组元素中。 当队列最前面的项离开时，我们需要将其他所有项向前移动一个位置，并调整`EndOfQueuePointer`。这种方法涉及大量的数据移动。一个更有效的利用槽的方法是循环队列的概念。 指针表示队列的前端和尾部，最终，队列将“绕回”起始位置。 下图展示了一个11个元素加入队列、5个元素离开队列的循环队列： ![](https://note.youdao.com/yws/api/personal/file/WEB3c97a93cead64e3e89be9a838179c3c3?method=download&amp;shareKey=95f47734ed87b724b0882cc4142bda51)&lt;br /&gt;---## **链表** 在之前的章节中，我们使用数组作为线性列表。 在线性列表中，列表项存储在连续的位置上，但是这并不总是合适的。 另一种方法是将单个列表项存储在任何可用的位置，并使用指针将单个列表项链接到一个有序序列中。列表中的元素称为**节点 (Node)**。节点可以由多个数据项和一个**指针 (Pointer)**组成，指针是一个变量，存储了它所指向的节点的地址。存储第一个元素地址的变量称为**起始指针(Start pointer)**。&lt;article class=\"message is-info\"&gt;&lt;div class=\"message-body\"&gt;&lt;b&gt;Node: an element of a list.&lt;/b&gt;&lt;br /&gt;&lt;b&gt;Pointer: a variable that stores the address of the node it points to.&lt;/b&gt; &lt;br /&gt;&lt;b&gt;Null pointer: a pointer that does not point at anything.&lt;/b&gt;&lt;br /&gt;&lt;b&gt;Start pointer: a variable that describes of the first element of a linked list.&lt;/b&gt;&lt;/div&gt;&lt;/article&gt; &lt;br /&gt;在下面的图中，节点框中的数据值表示该节点的key字段。每个节点可能关联许多数据项。箭头表示指针。 它没有显示节点存储在哪个地址，因此图没有给出指针的值，只给出它在概念上链接到的位置。![](https://note.youdao.com/yws/api/personal/file/WEBc25e0ac2424463782319b14df2bb40fb?method=download&amp;shareKey=d02e311f730a9faa88e8bf9a2952bc44)下图展示了如何将一个新节点a插入到链表的开头，`StartPointer`的内容被复制到新节点的指针字段中，并且`StartPointer`被设置为指向新节点 A。 ![](https://note.youdao.com/yws/api/personal/file/WEBfd1e70fa19ce75ccf0074832e4901760?method=download&amp;shareKey=0b9950ed8c2d00cd75eeda0569665486)在下面的图中，一个新节点P被插入到列表的末尾。 节点L的指针字段指向新节点R，新节点P的指针字段包含null指针。为了删除列表中的第一个节点，我们将待删除节点的指针字段复制到`StartPointer`中： ![](https://note.youdao.com/yws/api/personal/file/WEB6d4e4b9a71794344d93d2a113fc4b4bb?method=download&amp;shareKey=ec73abdc6242e8c1f3caddf4abcfdc43)为了删除列表中的最后一个节点，我们需要将前一个节点的指针字段设置为null指针： ![](https://note.youdao.com/yws/api/personal/file/WEBf4cc0882079be871612588b48ac98c07?method=download&amp;shareKey=4d9ff05bc0a0c77724b20e93b9e5237c) &lt;br /&gt;有时，节点按关键字段值的顺序链接在一起，以生成一个有序链表。这意味着可能需要在两个现有节点之间插入或删除一个新节点。如下图所示：为了在现有节点B和D之间插入一个新节点C，我们将节点B的指针字段复制到新节点C的指针字段中。我们将节点B的指针字段改为指向新节点C： ![](https://note.youdao.com/yws/api/personal/file/WEB4e3024d5bb52e5141e011e9ad8ed05cc?method=download&amp;shareKey=b5ee34331a4326bf376bee4e388281ba)要删除列表中的节点D，我们将待删除节点D的指针字段复制到节点B的指针字段中： ![](https://note.youdao.com/yws/api/personal/file/WEB1c01e9bf65640b4f91b30eaa79284b1a?method=download&amp;shareKey=f0d86fc56ae1da7eecc237bff0b48d1a)&lt;br /&gt;请记住，在实际应用程序中，数据可能不止包含一个关键字段和一个数据项。这就是链表优于线性表的原因。 当链表元素需要重新排序时，只需要改变链表中的指针。在线性列表中，需要移动所有的数据项。使用链表可以节省时间，但是指针字段需要更多的存储空间。 &lt;br /&gt;要使用数组来实现链表，可以使用一维数组来存储数据，使用一维数组来存储指针。 读取相同索引处的数组值时，一行代表一个节点： ![](https://note.youdao.com/yws/api/personal/file/WEBd884dea7e65e66dcb10dd2ac9d012135?method=download&amp;shareKey=1e1f130f679c40e9c3fe0086faf262dc)下图展示了如何将一个新节点添加到使用数组实现的链表的开头。 请注意，值\"A\"被添加到索引3处，但起始指针被调整为列表的新第一个元素。![](https://note.youdao.com/yws/api/personal/file/WEB1071d5dddafc0dc1342176a070a4c19c?method=download&amp;shareKey=10b6a780f990cf4fcfd99b70a115a5cb)下图展示了如何将一个新节点添加到使用数组实现的链表的末尾。 注意，“P”值是在索引3处添加的。原来包含null指针(索引为0)的结点现在调整为指向新的一个node。 &lt;br /&gt;删除节点时，只需要调整指针。 因为旧数据可以保留在数组中，但由于没有指针指向它，因此不再可以访问它。下图展示了如何调整起始指针，以有效地删除链表的第一个元素。 请注意，开始指针现在包含了被删除结点的指针值。![](https://note.youdao.com/yws/api/personal/file/WEB8443d8877e3af41fcc92c401bdc732ba?method=download&amp;shareKey=836e08461f4163fc2760c2637b2bf3c3) 下图给出了链表倒数第二个结点的指针值如何变为null指针的过程： ![](https://note.youdao.com/yws/api/personal/file/WEB5a38c06c3d8d69e9c87cc52cdc026613?method=download&amp;shareKey=9d4e228eee2c4cb87307b0d9a00f4017)&lt;br /&gt;在向列表中添加需要插入的节点时，该数据会被添加到data数组的任何空闲元素中。 新节点的指针被设置为指向插入点之后的节点的索引。 注意，这是插入点之前节点的指针的值，插入点之前的节点的指针设置为指向新节点。![](https://note.youdao.com/yws/api/personal/file/WEBbbf733201dec9b89f2b12008477910a7?method=download&amp;shareKey=4686a60fb1cbf13235ffc6a180fb045c)同样，在删除节点时，只需要调整指针即可。 下图说明了如何将待删除结点的指针复制到前一个结点的指针。![](https://note.youdao.com/yws/api/personal/file/WEB7e5b0a7682dfdf4b10ac8528e493430e?method=download&amp;shareKey=e2b810da295c8e52fb081de997bf3d15) &lt;br /&gt;未使用的节点需要被轻易定位到。一种合适的技术是将未使用的结点连接起来，形成另一个链表:未使用链表。 下图展示了我们的链表及其空闲列表： ![](https://note.youdao.com/yws/api/personal/file/WEBb21fbca29bb802ddaea196ca1ed93a1b?method=download&amp;shareKey=10f22ad3957610ebfb2b93845c640c1c)当节点数组第一次初始化为链表时，链表是空的，所以开始的指针是空指针。 所有节点都需要连接起来，形成未使用内存块的链表。 下图展示了向链表插入数据之前链表实现的一个例子： ![](https://note.youdao.com/yws/api/personal/file/WEB8b78f5645eb082bf509bb5287b85e155?method=download&amp;shareKey=0f07779b4a2400a6c3169bdfe4706df9)&lt;br /&gt;假设“L”、“B”和“D”被添加到链表中，并按字母顺序保存。下图展示了这些值是如何存储在Data数组中的，以及链表和未使用链表的指针是如何发生调整的： ![](https://note.youdao.com/yws/api/personal/file/WEB8f6b1c4bbe92190c1ee813fb3311f0ef?method=download&amp;shareKey=d994768cf323feb3c44fc7d8042ed191) 如果要删除包含\"B\"的结点，则需要将该结点的数组元素重新链接到未使用链表中。 下图展示了如何将该节点添加到未使用内存链表的前端： ![](https://note.youdao.com/yws/api/personal/file/WEB2badc75189a212215c4e7b345dabd354?method=download&amp;shareKey=afe63985272662d7e6d47a882f322e31)&lt;br /&gt;在之前的小节中，我们介绍了用户定义的记录类型。 我们将相关的数据项分组为记录数据结构。 要使用记录变量，我们首先定义一个记录类型。然后我们声明该记录类型的变量。我们可以将这个链表存储在一个记录数组中。 一条记录代表一个节点，由数据和指针组成： ![](https://note.youdao.com/yws/api/personal/file/WEBfb16961432a706bc5f8b668fb7e9185e?method=download&amp;shareKey=fd9701f15a3b83e7f1430c925c8a1e4d)&lt;br /&gt;---# **第十四章：编程与数据的表示** ## **编程语言** 在前两章节中我们学习了如何使用流程图或者伪代码来描述一个程序。我们现在介绍几个比较出名且普遍运用的编程语言： ### **Python** Python是一种多范式编程语言，这意味着Python完全支持面向对象的编程和结构化编程。 Python有如下特性： - 每个语句必须在单独的一行上。- 缩进十分的重要。这就是所谓的 **“缩进规则” (Off-side rule)**。- 关键字用小写字母书写。- Python区分大小写，比如说标识符**Number1**与**Number1**或**Number1**不同。- Python中的一切都是对象，所以Python是面向对象的编程语言。- 代码大量使用了名为“切片”的概念。- Python程序是解释型程序。你可以在Python Shell中输入一条语句，Python解释器会立即运行它。 你还可以在Python编辑器(如IDLE)中输入程序代码，用扩展名`.py`保存它，然后在编辑器窗口的运行菜单中运行程序代码。 &lt;br /&gt;---### **Visual Basic Console Mode (VB.NET)**VB.NET是在.NET框架上实现的一种多范式的高级程序设计语言。 微软推出了VB.NET作为其最初的Visual Basic语言的继承者。 微软的集成开发环境(IDE)，用于用VB进行开发，其中的NET就是Visual Studio。 隶属微软的Visual Studio Express和Visual Studio Community都是免费软件。课本里面的所有Visual Basic程序都是使用Microsoft Visual Basic 2010 Express Console应用程序编写的。 有关于VB.NET，这里有一些事实： - 每个语句都应该在单独的一行中。可以在同一行中键入语句，以冒号`:`作为分隔符。但是，我们不推荐这样做。- 缩进是好文明（- VB.NET中不区分大小写。现代的VB.NET编辑器将自动从标识符的第一个定义中复制案例。- 我们一般对标识符和关键字使用CamelCaps表示方法(也称为PascalCaps)。- 程序需要编译才能运行。**CamelCaps代表首字母大写的命名法则。**当我们在IDE中输入程序代码，保存代码之后单击Run按钮。这将启动编译器。 如果没有语法错误，编译后的程序就会运行。输出将显示在一个单独的控制台窗口中。 注意，当程序完成执行时，控制台窗口会自动关闭。 所以为了让控制台窗口一直打开以便能看到输出，程序的最后一条语句应该加上这一行： `Console.ReadLine()` &lt;br /&gt;---### **Java** Java最初由James Gosling在Sun Microsystems(现为Oracle所有)开发，于1995年发布。 **Java运行环境(Java Runtime Environment, JRE)**的目标是面向用户，而**Java开发包(Java Development Kit, JDK)**面向软件开发人员，其中包含**Java编译器 (Java Compiler)**和调试器等开发工具。 Java的设计与运行平台无关。也就是说Java编译后的代码可以在所有的操作系统上运行。 有关Java的一些事实： - 每个语句都以分号`;`结尾。一行可以包含多条语句，但我们不推荐这样做。- 缩进是一种很好的做法。- Java区分大小写。- 按照惯例，标识符使用CamelCaps格式大写，关键字使用小写，**类 (class)**的标识符使用大写。- 复合语句由括在花括号`{`中的语句序列组成。- 只要Java语法需要使用语句，就可以使用复合语句。- 程序需要编译成字节码，然后使用**Java虚拟机 (Java Virtual Machine)**运行。 Java几乎被设计为一种完全面向对象的语言。 Java中所有代码都是在**类 (Class)**中编写的。 只有简单数据类型(如integer、real)不是对象。字符串也是对象。源文件必须以其包含的public类命名，并添加java后缀，例如`Exl.java`。 它首先必须使用Java编译器编译成字节码，生成一个名为Exl.class的文件。只有这样它才能被执行。方法名`main`在Java语言中不是关键字。它只是Java启动器为将控制权传递给程序而调用的方法的名称。 和VB.NET一样：如果没有语法错误，编译后的程序就会运行。输出将显示在输出窗口中。 &lt;br /&gt;---## **编程基础**(你可能发现这一小结的目录充满了冗余。不过我也没啥办法因为这个Hexo主题没法支持四级标题lol)### **变量的声明** 大多数编程语言都要求你声明要存储在变量中的数据的类型，以便编译器能够分配正确数量的内存空间。 声明变量的时候，数据类型决定了它能存储的内容。 声明为存储整数(integer)的变量就不能用于存储字母数字字符(字符串)，反之亦然。 VB.NET和Java要求在使用变量之前声明变量。 在伪代码中，声明变量可以以下面的方法完成： DECLARE : 123下面的代码： DECLARE Number1 : INTEGERDECLARE YourName : STRINGDECLARE N1, N2, N3 : INTEGERDECLARE Name1, Name2 : STRING123456789101112131415161718192021222324252627282930313233343536分别为： 定义`Number1`用于存储数字。 定义`YourName`用于存储字符串。 定义3个整数变量。 定义两个字符串变量。 &lt;br /&gt;---### **语法定义和例子** 下表展示了语法定义： |语言|~||:-|:-||Python|Python没有变量声明。||VB.NET|`Dim &lt;identifier&gt;[,&lt;identifier&gt;]As &lt;datatype&gt;` &lt;br /&gt; 每一行声明必须以`Dim`开头。||Java|`&lt;datatype&gt; &lt;identifier&gt;[, &lt;identifier&gt;]`|&lt;br /&gt;&lt;br /&gt;举出一些例子： &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;**Python** ```Python# Number1 of type Integer# YourName of type String# N1, N2, N3 of type Integer;# Name1, Name2 of type String; 这里面都是注释。虽然Python没有变量声明，但我们还是应该在模块开头添加注释。 VB.NET 1234Dim Number As IntegerDim YourName As IntegerDim N1, N2, N3 As IntegerDim Name1, Name2 As String 可以将多个相同类型的变量放在同一行中。 Java 1234int number1;String yourName;int n1, n2, n3;String name1, name2; 同样，你可以将多个相同类型的变量放在同一行中。 常量的声明和赋值有时，我们在程序中使用一个永远不变的值，例如数学常数pi的值。为常量指定一个名称，并在程序开始时声明它，这是一种好习惯，有助于提高可读性，而不是在程序语句中直接使用一个实际的值。 在为代码中，我们将这样的常量赋值写为： CONSTANT &lt;identifier&gt; = &lt;value&gt; 比如： CONSTANT Pi = 3.14 。 语法定义和例子下表展示了语法定义： 语言 ~ Python &lt;identifier&gt; = &lt;value&gt; VB.NET Const &lt;identifier&gt; = &lt;value&gt; 每一行声明都必须以关键字Const开头。 Java static final &lt;datatype&gt; &lt;identifier&gt; = &lt;value&gt; 每一行常量定义都必须以static final开头。 举出一些例子： Python 1PI = 3.14 在Python中，我们约定俗成的规定是只使用大写来写常量标识符。常量的值是可以改变的，但我们最好是要把它们当作不能改变的值。 VB.NET 1Const Pi = 3.14 在VB.NET中，常量的值不能够再被修改了。 Java 1static final double PI = 3.14 同样，在Java中，常量的值不能够再被修改了。 变量的赋值一旦声明了变量，就可以给它赋值。 伪代码可以这样写： &lt;identifier&gt; ← &lt;expression&gt; 比如： 12A ← 34B ← B + 1 语法定义和例子下表展示了语法定义： 语言 ~ Python &lt;identifier&gt; = &lt;expression&gt; VB.NET &lt;identifier&gt; = &lt;expression&gt; Java &lt;identifier&gt; = &lt;expression&gt;; 不难看出：三家的赋值语法都基本一致，不过Java的赋值语句最后还要多一个分号;。 举出一些例子： Python 12A = 34B = B + 1 赋值符是=。 VB.NET 12A = 34B = B + 1 同样，赋值符是=。 但是VB.NET允许你在声明数据的同时初始化变量。比如： 1Dim Number1 As Integer = 0 Java 12A = 34;B = B + 1; 同样，赋值符是=。Java也允许在声明语句中初始化变量，例如: 1int number1 = 0; VB.NET和Python都允许你将递增语句例如B = B + 1写成 B += 1 Java则需要将递增语句例如b = b + 1写成b++; 算数运算符赋值不只是给变量赋初始值。需要存储计算结果时，也可以使用赋值操作。用于计算的算术运算符如下表所示： 运算 伪代码 Python VB.NET Java 加法 + + + + 减法 - - - - 乘法 * * * * 除法 / / / / 仅除以float或double类型时使用此运算符。 指数 ^ ** ^ 在Java里面没有专门用于指数运算的运算符。 唯一的方法是使用这行代码： Math.pow(n,e) 整数除法 DIV // \\ / 仅对integer数据类型作整数除法时使用。 取余 MOD % mod % 当表达式中出现多个操作符时，求值的顺序取决于数学的优先级规则 (Rules of precedence):括号、幂、乘、除、加、减。 Rules of precedence: define the order of the calculations to be performed. 输出信息在伪代码中这么写： 12OUTPUT &lt;string&gt;OUTPUT &lt;identifier(s)&gt; 当输出文本和数据到控制台屏幕时，我们可以在print列表中列出输出字符串和变量值的混合。 语法定义和例子下面展示了语法定义： Python 12print(&lt;printlist&gt;)print(&lt;printlist&gt;, end ='') 打印列表中不同的项使用逗号,分隔。为避免移到输出后的下一行，使用end = ‘’双引号中的内容填充打印列表中两个元素之间的内容。 VB.NET 12Console.WriteLine(&lt;printlist&gt;)Console.Write(&lt;printlist&gt;) 打印列表中所有的项用&amp;隔开。Console.Writeline会在输出后移动到下一行，而Console.Write会在输出完毕后继续留在同一行。 Java 12System.out.print(&lt;printlist&gt;);System.out.printIn(printlist); 打印列表中所有的项用+隔开。System.out.print会在输出后移动到下一行，而Console.Write会在输出完毕后继续留在同一行。 在伪代码中想使用差不多的换行操作，就要在打印列表后面使用注释声明了。 // newline和// no new line就可以实现这样的操作。 举出一些例子： Python 12print(\"Hello\", YourName, \". Your number is \", Number1)print(\"Hello \", end= ' ') VB.NET 12Console.WriteLine(\"Hello \" &amp; YourName &amp; \". Your number is \" &amp; Number1)Console.Write(\"Hello\") Java 12System.out.printIn(\"Hello \" + YourName + \". Your number is \" + number1);System.out.print(\"Hello\"); 在上面的代码示例中，您可以看到当输出语句非常长时，它们可以分散在多行中。因此必须将两个打印列表项之间的行分隔开。你不能在一个字符串的中间折断，除非你把它变成两个单独的字符串。 在Python和VB.NET中，你也可以使用占位符来将输出排序。在打印列表中，要打印的变量的顺序用{}中的序号表示，变量按正确的顺序从后面的变量列在字符串后面，中间用逗号分隔: Python 1print(\"Hello {0}. Your number is {1} \" .format(YourName,Number1)) VB.NET 1Console.WriteLine(\"Hello {0}. Your number is {1}\", YourName, Number1) 从用户获取输入在编写输入语句时，最好提示用户他们要输入什么。例如下面的伪代码: INPUT \"Enter a number: \" A 就是可以起到这样的作用。 语法定义和例子举出一些例子： Python 1A = input(\"Enter a number: \") 用户输入的内容会传输到变量A内。输入的数据格式默认为字符串。因此如果想要转化成别的数据形式就需要特意多敲两个字转一下格式了。双引号和单引号都可以用于输出提示信息。 VB.NET 12Console.Write(\"Enter a number: \")A = Console.ReadLine() 提示符必须单独作为输出语句提供。 Java 1234import java.util.Scanner;Scanner console = new Scanner(System.in);System.out.print(\"Enter a number: \");a = console.next(); 必须先从Java库中导入Scanner类，并创建一个Scanner对象，然后才能使用它读取输入字符串。 提示符必须单独作为输出语句提供。 注释写注释是个很好的文明（ 语法定义和例子举出一些例子： Python 12# this is a comment# this is a another comment 注释使用#开头。 VB.NET 12' this is a comment' this is a another comment 注释使用'开头。 Java 12345// this is a comment//this is another comment/* this is a multiline comment*/ 注释使用//开头。 使用/*和*/来插入一个多行注释。 数据类型每种编程语言都有内置的数据类型，下表给出了其中的一个子集。对于VB.NET和Java，分配给给定类型变量的内存字节数在括号中给出。 数据描述 伪代码 Python VB.NET Java 带符号的整数 INTEGER int Integer (4个字节) int (4个字节) 带符号的有小数点的数字 REAL float Single (4个字节) Double (8个字节) float (4个字节) double (8个字节) 一个字符 CHAR (使用单引号来分隔字符) 不支持 Char (2字节的Unicode) char (2字节的Unicode) 字符串 STRING (使用双引号来分隔字符串) str (虽然以ASCII码存储，但是Unicode也同样支持。) (使用单引号，双引号或者三个引号来分割字符串) String (每个字符使用2个字节存储，使用双引号来分割字符串) String (每个字符使用2个字节存储，使用双引号来分割字符串) 逻辑表示符 BOOLEAN boo1，可以有：True,False Boolean (2个字节)，可以有：True,False Boolean，可以有：true,false 在Python中，单个字符表示为长度为1的字符串。 在VB.NET中，字符串中的每个字符都需要两个字节的内存，并且每个字符在内存中表示为Unicode(在Unicode中，从1到127对应于ASCII)。 Date具有各种内部表示形式，但均以传统格式输出: 数据描述 伪代码 Python VB.NET Java Date value DATE 使用datetime类表示 Date (8个字节) Date在Java中是一个类。需要使用Date请先敲入：import java.util.Date; 布尔表达式在之前的笔记中，我们介绍了逻辑语句。这些语句包含一个条件。条件也称为布尔表达式，计算结果为True或False。其中，True和False都是布尔值。 简单的布尔表达式涉及比较操作符，而复杂的布尔表达式涉及布尔操作符。 运算 伪代码 Python VB.NET Java 等于 = == = == 不等于 &lt;&gt; != &lt;&gt; != 大于 &gt; &gt; &gt; &gt; 小于 &lt; &lt; &lt; &lt; 大于等于 &gt;= &gt;= &gt;= &gt;= 小于等于 &lt;= &lt;= &lt;= &lt;= 到这里三家语言都出奇的一致啊。 还有逻辑运算符： 运算 伪代码 Python VB.NET Java AND (逻辑连接) AND and And &amp;&amp; OR (逻辑包含) OR or Or ` ` NOT (逻辑否定) NOT not Not ! ! 选择语句If…Then语句在伪代码这么写： 1234IF &lt;Boolean expression&gt; THEN &lt;statement(s)&gt;ENDIF 语法定义和例子下面展示了语法定义： Python 12if &lt;Boolean expression&gt;: &lt;statement(s)&gt; 注意，在显示哪些语句是条件语句的一部分时，用冒号:替换了关键字THEN。 换言之，IF的条件后面必须跟:。 VB.NET 123If &lt;Boolean expression&gt;Then &lt;statement(s)&gt;End If Then与逻辑表达式同行，而且End If要与If有同样的缩进。 Java 12if (&lt;Boolean expression&gt;) &lt;statement&gt;; 需要注意的是，布尔表达式被括在括号中。如果条件语句中需要包含多个语句，则这些语句必须括在花括号{}中。 全部的语言都需要注意缩进！ 举出一些例子： Python 12if x &lt; 0: print(\"Negative\") VB.NET 123If x &lt; 0 Then Console.WriteLine(\"Negative\")End If Java 12if (x &lt; 0) System.out.printIn(\"Negative\"); If…Then…Else语句伪代码： 123456IF &lt;Boolean expression&gt; THEN &lt;statement(s)&gt; ELSE &lt;statement(s)&gt;ENDIF 语法定义和例子下面展示了语法定义： Python 1234if &lt;Boolean expression&gt;: &lt;statement(s)&gt;else: &lt;statement(s)&gt; 缩进用于显示哪些语句是条件语句的一部分，else关键字必须与相应的if关键字对齐。 VB.NET 12345If &lt;Boolean expression&gt; Then &lt;statement(s)&gt;Else &lt;statement(s)&gt;End If 照格式看就好，不多赘述了。 Java 1234if (&lt;Boolean expression&gt;) &lt;statement&gt;;else &lt;statement&gt;; 如果else部分需要多个语句，则这些语句必须被括在花括号{}中。 全部的语言都需要注意缩进！ 举出一些例子： Python 1234if x &lt; 0: print(\"Negative\")else: print(\"Positive\") VB.NET 12345If x &lt; 0 Then Console.WriteLine(\"Negative\")Else Console.WriteLine(\"Positive\")End If Java 1234if (x &lt; 0) System.out.printIn(\"Negative\");else System.out.printIn(\"Positive\") 嵌套IF语句在伪代码这么写： 1234567891011IF &lt;Boolean expression&gt; THEN &lt;statement(s)&gt; ELSE IF &lt;Boolean expression&gt; THEN &lt;statement(s)&gt; ELSE &lt;statement(s)&gt; ENDIFENDIF 语法定义和例子下面展示了语法定义： Python 123456if &lt;Boolean expression&gt;: &lt;statement(s)&gt;elif &lt;Boolean expression&gt;: &lt;statement(s)&gt;else: &lt;statement(s)&gt; 注意关键字elif必须与对应的if对齐。这个结构中可以有任意多的elif部分。 VB.NET 1234567If &lt;Boolean expression&gt;Then &lt;statement(s)&gt;ElseIf &lt;statement(s)&gt;Else &lt;statement(s)&gt;End If 如果ElseIf用作一个单词，那么在这个结构的末尾只需要一个End If。 ElseIf的数量可以根据需要而定。 Java 123456if (&lt;Boolean expression&gt;) &lt;statement&gt;;else if (&lt;Boolean expression&gt;) &lt;statement&gt;;else &lt;statement&gt;; 举出一些例子： Python 123456if x &lt; 0: print(\"Negative\")elif x == 0: print(\"Zero\")else: print(\"Positive\") VB.NET 1234567If x &lt; 0 Then Console.WriteLine(\"Negative\")ElseIf x = 0 Then Console.WriteLine(\"Zero\")Else Console.WriteLine(\"Positive\")End If Java 123456789101112if (x &lt; 0){ System.out.printIn('Negative')}else if (x == 0){ System.out.printIn('Zero')}else{ System.out.printIn('Positive')} CASE语句另一种选择结构是CASE语句。CASE语句就像是条件判断：满足了哪一个条件就执行哪一个。每个CASE的条件的类型可以是: 单个值 用逗号分隔的单个值 一个范围 在伪代码： 12345678CASE OF &lt;expression&gt; &lt;value1&gt; : &lt;statement(s)&gt; &lt;value2&gt;,&lt;value3&gt; : &lt;statement(s)&gt; &lt;value4&gt; TO &lt;value5&gt; : &lt;statement(s)&gt; . . OTHERWISE &lt;statement(s)&gt;ENDCASE &lt;statement(s)&gt;的值决定执行哪些语句。根据需要可以有很多不同的情况。OTHERWISE是可选的，用于处理错误，我们一般叫错误捕获。 语法定义和例子下表展示了语法定义： Python Python里面没有CASE语句。你需要使用连环I语句才能达到同样的效果。 VB.NET 12345678910111213Select Case &lt;expression&gt; Case value1 &lt;statement(s)&gt; Case value2,value3 &lt;statement(s)&gt; Case value4 To value5 &lt;statement(s)&gt; . . . Case Else &lt;statement(s)&gt;End Select Java 12345678910111213switch (&lt;expression&gt;){ case value1: &lt;statement(s)&gt;; break; case value2: case value3: &lt;statement(s)&gt;; break; . . . default: &lt;statement(s)&gt;;} 举出一些例子： 伪代码 123456CASE OF Grade \"A\" : OUTPUT \"Top grade\" \"F\", \"U\" : OUTPUT \"Fail\" \"B\"..\"E\" : OUTPUT \"Pass\"OTHERWISE OUTPUT \"Invalid grade\"ENDCASE Python 12345678if Grade == \"A\": print(\"Top grade\")elif Grade == \"F\" or Grade == \"U\": print(\"Fail\")elif Grade in (\"B\", \"C\", \"D\", \"E\"): print(\"Pass\")else: print(\"Invalid grade\") 所以说想要达到CASE语句的效果，python就只能嵌套if了。 VB.NET 12345678910Select Case Grade Case \"A\" Console.WriteLine(\"Top grade\") Case \"F\",\"U\" Console.WriteLine(\"Fail\") Case \"B\" To \"E\" Console.WriteLine(\"Pass\") Case Else Console.WriteLine(\"Invalid grade\")END Select Java 1234567891011121314switch (grade){ case 'A': System.out.printIn(\"Top Grade\"); break; case 'F': case 'U': System.out.printIn(\"Fail\") break; case 'B': case 'C': case 'D': case 'E': System.out.printIn(\"Pass\"); break; default: System.out.printIn(\"Invalid grade\");} 迭代在伪代码中，计数控制循环的写法如下: 123FOR &lt;control variable&gt; ← s TO e STEP i &lt;statement(s)&gt;NEXT &lt;control variable&gt; 里面的STEP值是可选的。&lt;statement(s)&gt;为两次缩进。控制变量的值从s开始，每次循环递增i，直到到达值e时结束。 语法定义和例子下表展示了语法定义： Python 12for &lt;control variable&gt; in range(s, e, i): &lt;statement(s)&gt; 值s、e和i必须是整数类型。当控制变量略低于e时，循环结束。s和i是可选的，如果没有输入，则它们的默认值分别为0和l。 VB.NET 123For &lt;control variable&gt; = s To e Step i &lt;statement(s)&gt;Next s、e和i的类型可以是整型或浮点型。 Java 12for (int i = s; i &lt; e; i ++) &lt;statement(s)&gt; i是其中的控制变量。 举出一些例子： 伪代码 1234567891011FOR x ← 1 TO 5 OUTPUT xNEXT xFOR x = 2 TO 14 STEP 3 OUTPUT xNEXT xFOR x = 5 TO 1 STEP -1 OUTPUT xNEXT x Python 12for x in range(5): print(x, end=' ') x的起始值是0，每次迭代都会加一。输出为： 0 1 2 3 4 12for x in range(2, 14, 3): print(x, end=' ') x的起始值为2，终止值为14，步长为3。注意，在执行迭代循环的时候，第一次输出一定是起始值的值。输出为：2 5 8 11 12for x in range(5, 1, -1): print(x, end=' ') x的起始值为5，步长为-1，因此每次迭代都会使x的值减少1。输出为：5 4 3 2 12for x in [\"a\", \"b\", \"c\"]: print(x, end='') 控制变量每次迭代时按顺序取方括号[]的一个值。输出为：abc VB.NET 123For x = 1 To 5 Console.Write(x)Next 输出：1 2 3 4 5 123For x = 2 To 14 Step 3 Console.Write(x)Next 输出：2 5 8 11 14 123For x = 5 To 1 Step -1 Console.Write(x)Next 输出：5 4 3 2 1 123For x = 1 To 2.5 Step 0.5 Console.WriteLine(x)Next 因为命令是Console.WriteLine()，所以输出需要换行。输出： 123411.522.5 123For Each x In {\"a\", \"b\", \"c\"} Console.Write(x)Next 控制变量每次迭代时按顺序取花括号{}的一个值。输出：abc Java 1234for (int x = 1; x &lt; 6; x++){ System.out.print(x);} 输出： 12345 1234for (int x = 2; x &lt; 15; x = x + 3){ System.out.print(x + \" \");} 输出： 2 5 8 11 14 1234for (int x = 5; x &lt; 0; x--){ System.out.print(x + \" \");} 输出： 5 4 3 2 1 1234for (double x = 1; x &lt; 3; x = x + 0.5){ System.out.print(x + \" \");} 输出： 1.0 1.5 2.0 2.5 12345char[] letter = {'a', 'b', 'c'};for (char x : letter ){ System.out.print(x)} 控制变量每次迭代时按顺序取letter中的一个值。输出： abc 后置条件循环后条件循环顾名思义，即循环内的语句至少执行一次，因为循环内的语句必须等到满足条件时才可以跳出循环。 当运行到后置条件时，我们需要对其进行评估。只要条件求值为False，循环内的语句就会再次执行。当条件求值为True时，执行将转到循环后面的下一个语句。 编写后置条件循环时，必须确保循环内部有一条语句，在某个时刻将结束条件改为True。否则，循环将永远执行下去。 伪代码： 123REPEAT &lt;statement(s)&gt;UNTIL &lt;condition&gt; 语法定义和例子下面展示了语法定义： Python Python中没有后置条件循环。如果需要完成同样的目标就需要使用前置条件循环。 VB.NET 123Do &lt;statement(s)&gt;Loop Until &lt;condition&gt; Java 1234do{ &lt;statement(s)&gt;} while &lt;condition&gt;; 举出一些例子： 伪代码 123REPEAT INPUT \"Enter Y or N: \" AnswerUNTIL Answer = \"Y\" Python Python的执行方法放到下一个部分：前置条件语句中。 VB.NET 1234Do Console.Write(\"Enter Y or N: \") Answer = Console.ReadLine()Loop Until Answer = \"Y\" Java 12345do{ System.out.print(\"Enter Y or N: \"); answer = console.next();} while (!(answer.equals(\"Y\"))); 前置条件语句前置条件循环，顾名思义，就是在循环内的语句执行之前计算条件。只要条件求值为True，前置条件循环就会执行循环中的语句。当条件求值为False时，执行将转到循环后面的下一个语句。注意，第一次遇到循环结构时，条件语句中使用的任何变量都不能是未定义(undefined)。 编写前置条件循环时，必须确保循环内部有一条语句在某个时候改变控制条件的值。否则循环将永远执行下去。 伪代码： 123WHILE &lt;condition&gt; DO &lt;statement(s)&gt;ENDWHILE 语法定义和例子下表展示了语法定义： Python 12while &lt;condition&gt;: &lt;statement(s)&gt; 注意，循环中的语句必须按一定数量的空格缩进。循环后的第一个语句必须减少缩进。 VB.NET 123456Do While &lt;condition&gt; &lt;statement(s)&gt;LoopDo Until &lt;condition&gt; &lt;statement(s)&gt;Loop 需要注意的是：Loop关键字表示循环结束。VB.NET也有一个前置条件，直到遇见Loop。只要条件求值为False，就执行循环中的语句。如果第一次遇到循环时，条件的计算结果为True，则不执行循环中的语句。 Java 1234while (&lt;condition&gt;){ &lt;statement(s)&gt;;} 举出一些例子： 伪代码 1234Answer ← \"\"WHILE Answer &lt;&gt; \"Y\" DO INPUT \"Enter Y or N: \" AnswerENDWHILE Python 123Answer = ''while Answer != 'Y': Answer = input(\"Enter Y or N: \") VB.NET 12345678910Dim Answer As String = \"\"Do While Answer &lt;&gt; \"Y\" Console.Write(\"Enter Y or N: \") Answer = Console.ReadLine()LoopAnswer = \"\"Do Until Answer = \"Y\" Console.Write(\"Enter Y or N: \") Answer = Console.ReadLine()Loop 可以将多个相同类型的变量放在同一行中。 Java 123456String answer = \"\";while(answer.equals(\"Y\") == false){ System.out.print(\"Enter Y or N: \") answer = console.next();} 如何决定使用哪个循环？如果你知道程序执行到循环语句时需要执行多少次循环，就使用计数控制的循环。如果循环的终止取决于循环内部发生的某些条件，那么就使用条件循环。前置条件循环还有一个好处，那就是如果条件不需要循环，就可以根本不进入循环。 内置函数编程环境提供了许多内置函数。其中一些在任何情况下都可以使用，而有些需要从特定的模块库中导入。 字符串操作函数下表给出了一堆处理字符串的函数： 描述 伪代码 Python VB.NET Java 访问ThisString中的第P个字符 ThisString[P] （从1开始计数） ThisString[P] （从0开始计数） ThisString(P) （从0开始计数） ThisString.charAt(P) （从0开始计数） 返回ASCII值为i的字符 CHR(i : INTEGER) RETURNS CHAR chr(i) Chr(i) (char) i; 返回字符ch的ASCII值 ASC(ch) RETURNS INTEGER ord(ch) Asc(ch) (int) ch; 返回字符串S的长度的整数值 LENGTH(S : STRING) RETURNS INTEGER len(S) len(S) S.length(); 返回S的最左边的L个字符 LEFT(S : STRING, L : INTEGER) RETURNS STRING S[0:L] Left(S, L) S.subString(0, L) 返回S的最右边的L个字符 RIGHT(S : STRING, L : INTEGER) RETURNS STRING S[-L:] Right(S, L) S.subString(S.length() - L) 在字符串S中，返回从P开始L个长度的字符串 MID(S : STRING, P : INTEGER, L : INTEGER) RETURNS STRING S[P : P + L] mid(S, P, L) S.subString(P, P + L) 返回Ch的小写等价字符值 LCASE(Ch : CHAR) RETURNS CHAR Ch.lower() LCase(Ch) Character.toLowerCase(ch) 返回Ch的大写等价字符值 UCASE(Ch : CHAR) RETURNS CHAR Ch.upper() UCase(Ch) Character.toUpperCase(ch) 将字符串S全转换为大写 TO_UPPER(S : STRING) RETURNS STRING S.upper S.ToUpper() S.toUpperCase() 将字符串S全转换为小写 TO_LOWER(S : STRING) RETURNS STRING S.lower() S.ToLower() S.toLowerCase() 粘合两个字符串 S1 &amp; S2 s = S1 + S2 s = S1 + S2 或者： s = S1 &amp; S2 s = S1 + S2 Python中的切片操作在Python中，切片操作(slicing)是对序列型对象(如list, string, tuple)的一种高级索引方法。普通索引只取出序列中一个下标对应的元素，而切片取出序列中一个范围对应的元素，这里的范围不是狭义上的连续片段。 下图显示了ThisString的表示形式。如果我们想返回从位置3开始的长度为3的切片，我们使用ThisString[3 : 6]来给出返回DEF。 位置从0开始计数，切片上界的位置不包含在子字符串中。 如果您想象每个元素的编号从左端开始，那么更容易看到左元素(下界)是如何包括在内的，而右元素(上界)是如何被排除在外的。下表显示了Python中其他一些有用的切片： 表示 输出 解释 ThisString[2:] CDEFG 如果不给定上界，则切片包含到字符串末尾的所有字符。 ThisString[:2] AB 如果不给定下界，则切片包括字符串开头的所有字符。 ThisString[-2:] FG 负下界意味着它从字符串的末尾开始取切片。 ThisString[:-2] ABCDE 负上界意味着它在该位置终止字符串。 数据截断有时我们只需要实数没有经过四舍五入后的整数部分。这就是所谓的截断 (Truncation)。 语言 代码 注释 伪代码 INT(x : REAL) RETURNS INTEGER 直接返回x的整数部分。 Python int(x) 如果x是一个浮点类型的数据，则输出将会截断为0. VB.NET Math.Truncate(x) 返回实数x的整数部分。 Java (int) x; 将数字x强制转换为整数。 将字符串转换为数字有时整数可以保存为字符串的形式。要在计算中使用这样的数字，首先需要将其转换为整数。比如说，这些函数可以从字符串5返回整数值5： 语言 代码 Python int(S) VB.NET CInt(S) Java Integer.valueOf(S) 有时带小数点的数字可以保存为字符串的形式。要在计算中使用这样的数字，首先需要将其转换为实数 (REAL)，或者浮点数 (Float)。例如，以下函数从字符串75.43返回实数75.43: 语言 代码 注释 伪代码 STRING_TO_NUM(x : STRING) RETURNS REAL 返回字符串的数字形式。 Python float(x) 返回为浮点类型数据。 VB.NET CDbl(x) 返回为双精度浮点型数据 (double)。 Java Float.valueOf(x) 返回为浮点类型数据。 生成随机数当我们在做仿真中经常需要用到随机数。大多数编程语言都有各种可用的随机数生成器。由于这些随机数是通过程序生成的，它们被称为“伪随机数”。下面的代码示例展示了一些最有用的随机数生成器： Python 12# in the random library:randint(1, 6) 这段代码生成了一个介于1和6之间的随机数(包括1和6)。 VB.NET 123Dim RandomNumber As New RandomDim x As Integerx = RandomNumber.Next(1, 6) 首先我们必须建立一个RandomNumber对象。建立对象的内容到Paper 4会涉及。这段代码生成一个介于包含1到不包含6之间的整数。 Java 123import java.util.Random;Random randomNumber = new Random();int x = randomNumber.nextInt(6) + 1; 我们同样需要建立一个RandomNumber对象。建立对象的内容到Paper 4会涉及。这段代码生成一个介于包含1到包含6之间的整数。 过程在第12章中，我们使用过程 (Procedure)作为给一组语句命名的一种方式。当我们想编写一个过程时，需要在主程序之前定义它。当我们希望执行过程体中的语句时，我们就可以在主程序中调用它。 在伪代码中，过程的定义为： 123PROCEDURE &lt;procedureIdentifier&gt; &lt;statement(s)&gt;ENDPROCEDURE 想要调用过程时，需要使用下面这行代码： 1CALL &lt;procedureIdentifier&gt; 语法定义和例子下表展示了语法定义： Python 12def &lt;identifier&gt;(): &lt;statement(s)&gt; VB.NET 123Sub &lt;identifier&gt;() &lt;statement(s)&gt;End Sub 可以将多个相同类型的变量放在同一行中。 Java 1234void &lt;identifier&gt;(){ &lt;statement(s)&gt;;} 同样，你可以将多个相同类型的变量放在同一行中。 举出一些例子： 伪代码 123456PROCEDURE InputOddNumber REPEAT INPUT \"Enter an odd number: \" Number UNTIL Number MOD 2 = 1 OUTPUT \"Valid number entered\"ENDPROCEDURE 在主代码中使用该过程就可以： 1CALL InputOddNumber Python 123456789def InputOddNumber(): Number = 0 while Number % 2 == 0: Number = int(input(\"Enter an odd number: \")) print(\"Valid number entered)#***************** main program starts here ********************InputOddNumber() Python编辑器对语句的不同部分进行颜色编码，这在你输入自己的代码时很有帮助。缩进显示了哪些语句是循环的一部分。内置函数input返回一个字符串，必须将其转换为整数才能作为数字使用。 VB.NET 12345678910111213141516Module Module1 Dim Number As Integer Sub InputOddNumber() Do Console.Write(\"Enter an odd number: \") Number = Console.ReadLine Loop Until Number Mod 2 = 1 Console.WriteLine(\"Valid number entered\") End Sub Sub Main() InputOddNumber() Console.ReadLine() End SubEnd Module Visual Basic Express编辑器对语句的不同部分进行了颜色编码，因此很容易看出是否有语法错误。编辑器还会自动缩进关键字并将其大写。变量需要在使用之前进行声明。当输入一个标识符而不跟随初始的大小写时，编辑器将跟随变量声明的大小写。编辑器可以预测你的输入:当您键入语句的第一部分时，将显示弹出列表。 当你要运行主程序时，使用Console.ReadLine()命令来使得控制台一直打开。 Java 12345678910111213141516171819202122package exl;import java.util.Scanner;public class Exl{ public static void inputOddNumber() { Scanner console = new Scanner(System.in); int number = 0; do { System.out.print(\"Enter an odd number: \"); number = console.nextInt(); } while (number % 2 != 1); System.out.printIn(\"Valid number entered\"); } public static void main(String[] args) { inputOddNumber(); }} 编辑器会自动对关键字和字符串进行颜色编码。过程体包含在花括号{}中。编辑器可以预测你下一步输入的内容:当输入语句的第一部分时，IDE将显示弹出列表。变量需要在使用之前进行声明。 函数在之前的一个小节中，我们使用了内置函数。这些是由其他程序员编写的有用的子程序，在模块库中提供。最常用的库通常在系统库中，因此无需导入即可使用。 除了那些内置的函数，你可以编写自己的函数。如果你构建了自己的模块库，那么你编写的任何函数都可以在另一个程序中使用。 函数用作表达式的一部分。当程序执行到达表达式中包含函数调用的语句时，该函数就会被执行，然后在表达式中使用这个函数调用的返回值 (Return value)。 函数与过程最大的区别就是：函数有返回值。 编写自己的函数时，确保在组成函数(函数体)的语句中始终返回一个值。如果函数体中有不同的结果，可以存在多个RETURN语句。 伪 be like: 1234FUNCTION &lt;functionIdentifier&gt; RETURNS &lt;dataType&gt; &lt;statement(s)&gt; RETURN &lt;value&gt;ENDFUNCTION Return value: the value replacing the function call used in the expression 语法定义和例子下表展示了语法定义： Python 123def &lt;functionIdentifier&gt;(): &lt;statement(s)&gt; return &lt;value&gt; VB.NET 1234Function &lt;functionIdentifier&gt;() As &lt;datatype&gt; &lt;statement(s)&gt; &lt;functionIdentifier&gt; = &lt;value&gt; 'Return &lt;value&gt; (返回&lt;value&gt;) End Function Java 12345&lt;data type&gt; &lt;functionIdentifier&gt;(){ &lt;statement(s)&gt;; return &lt;value&gt;;} 当编程一个函数时，函数的定义应该写在与过程相同的地方。该函数是从主程序中的表达式或过程中调用的。 不同的编程语言对其子程序使用不同的术语，如下表所示： 伪代码 PROCEDURE FUNCTION Python void function fruitful function VB.NET Subroutine Function Java void method method Void的意思是“什么都没有”。Python和Java都使用这个术语来表示它们的过程类型子例程没有返回值。Python将这两种类型的子例程都称为函数。有”Fruit function”返回一个或多个值。 这里根据刚才讲过程的那一个小结，重新以函数的形式写出来： 伪代码 1234567FUNCTION InputOddNumber RETURNS INTEGER REPEAT INPUT \"Enter an odd number: \" Number UNTIL Number MOD 2 = 1 OUTPUT \"Valid number entered\" RETURN NumberENDFUNCTION Python 12345678910def InputOddNumber(): Number = 0 while Number % 2 == 0: Number = int(input(\"Enter an odd number: \")) return Number# ************** main program starts here *****************NewNumber = InputOddNumber() 在声明阶段中，变量Number无法在主程序中使用，因为在Python中只要一个变量没有全局声明，就不可以在整个程序之间随意使用。 VB.NET VB这边强势的给出了两种解法： 首先是使用了全局变量的方案： 1234567891011121314151617Module Module1 Dim Number, NewNumber As Integer Function InputOddNumber() Do Console.Write(\"Enter an odd number: \") Number = Console.ReadLine Loop Until Number Mod 2 = 1 InputOddNumber = Number End Function Sub Main() NewNumber = InputOddNumber() Console.ReadLine() End SubEnd Module 其次是使用了局部变量的方案： 123456789101112131415161718Module Module1 Dim NewNumber As Integer Function InputOddNumber() Dim Number As Integer Do Console.Write(\"Enter an odd number: \") Number = Console.ReadLine Loop Until Number Mod 2 = 1 InputOddNumber = Number End Function Sub Main() NewNumber = InputOddNumber() Console.ReadLine() End SubEnd Module Java 12345678910111213141516171819202122package exl;import java.util.Scanner;public class Exl{ public static int inputOddNumber() { Scanner console = new Scanner(System.in); int number = 0; do { System.out.print(\"Enter an odd number: \"); number = console.nextInt(); } while (number % 2 != 1); return number; } public static void main(String[] args) { int newNumber = inputOddNumber(); }} 同样，因为没有全局声明过，变量number无法在主程序中调用。 全局变量可以在程序代码的任何部分使用，但是将变量声明为仅在子程序中使用的局部变量是一种良好的编程习惯。 在Python中，每个变量都是局部变量，除非我们主动声明它们为全局变量。在VB.NET中，我们需要为子例程内的局部变量编写声明语句。Java不支持全局变量。但是，类 (class)中声明的静态变量在整个类中都可以访问。 向子程序传参当子例程 (Subroutine)需要主程序的一个或多个值时，我们在调用时将这些值作为参数 (Argument / Parameter)提供给子例程。这就是我们使用内置函数的方式。当我们调用内置函数时，我们不需要知道函数中使用的标识符。 当我们定义一个需要将值传递给子例程主体的子例程时，我们在子例程头中使用参数列表。 当子例程被调用时，我们需要在括号中提供参数。提供的实参 (Argument)被赋值给子例程的相应形参 (Parameter)(注意，形参列表中的形参顺序必须与实参列表中的顺序相同)。这就是所谓的子程序接口 (Subroutine interface)。 你可能发现参数分为实参和形参。一般来说，当定义一个方法的时候，我们传递到方法中的变量叫做形参。，当调用一个方法的时候，传给方法的值叫做实参。 Argument: the actual input expression or value with which the subroutine is being called. Parameter: the variable(s) used inside a subroutine which will take values passes into a subroutine at call time. Subroutine interface: the parameters being passed between the subroutine and the calling program. Function / Procedure header: the first line of a function or procedure definition showing the identifier and parameter list. 向函数中传参在为代码中，一个函数头是这样写的： 1FUNCTION &lt;functionIdentifier&gt; (&lt;parameterList&gt;) RETURNS &lt;dataType&gt; 其中，&lt;parameterList&gt;是形参的标识符及其数据类型的列表，使用逗号分隔。 举出一些例子： 伪代码 12345678FUNCTION SumRange(FirstValue : INTEGER, LastValue : INTEGER) RETURNS INTEGER DECLARE Sum, ThisValue : INTEGER Sum ← 0 FOR ThisValue ←FirstValue TO LastValue Sum ← Sum + ThisValue NEXT ThisValue RETURN SumENDFUNCTION Python 12345678910def SumRange(FirstValue, LastValue): Sum = 0 for ThisValue in range(FirstValue, LastValue + 1): Sum = Sum + ThisValue return Sum# ************ main program starts here ********************NewNumber = SumRange(1, 5)print(NewNumber) VB.NET 123456789101112131415161718Module Module1 Dim Number, NewNumber As Integer Function SumRange(ByVal FirstValue, ByVal LastValue) Dim Sum, ThisValue As Integer Sum = 0 For ThisValue = FirstValue To LastValue Sum = Sum + ThisValue Next SumRange = Sum End Function Sub Main() NewNumber = SumRange(1, 5) Console.WriteLine(NewNumber) Console.ReadLine() End SubEnd Module Java 123456789101112131415161718192021package exl;public class Exl{ public static int sumRange(int firstValue, int lastValue) { int sum = 0; for (int thisValue = firstValue; thisValue &lt;= lastValue; thisValue++) { sum = sum + thisValue; } return sum; } public static void main(String[] args) { int newNumber = sumRange(1, 5); System.out.printIn(newNumber); }} 向过程中传参如果形参传递值 (passed by value)，那么在调用时形参可以是一个实际值。如果传进去的参数是一个变量，那么将该变量当前值的副本传递给子例程。也就是说，调用程序中的变量的值不受子例程中发生的事情的影响。调用该变量后不会对元变量的值发生任何改变。（除非你的过程里面写了把变量值变换的条件） 对于过程，我们可以通过引用 (By reference)传递参数。在调用时，实参必须是变量。指向该变量的内存位置(地址)的指针被传递到过程中。对变量内容的任何更改都将在调用程序/模块的过程之外有效。 人话讲：By value就是传进去的是一个值，但是这个值不会改变原变量的值——他就只是一个值而已。而By reference就是直接把这个变量的内存地址给传进去了。所有的更改就会直接叠加在原变量上。 By value: the actual value is passed into the procedure. By reference: the address of the variable is passed into the procedure. 请注意，这两种参数传递方法都不适用于Python。在Python或Java中，这个方法被称为对象引用传递(pass by object reference)。这基本上是一种面向对象的参数传递方式，超出了本章的范围。重点是要了解如何使用Python和Java编程以获得所需的效果。 伪代码中的过程头 (Procedure header)： 1PROCEDURE &lt;ProcedureIdentifier&gt; (&lt;parameterList&gt;) 参数列表需要过程定义的更多信息。在伪代码中，列表中的参数以下列格式之一表示： 12BYREF &lt;identifier1&gt; : &lt;dataType&gt;BYVALUE &lt;identifier2&gt; : &lt;dataType&gt; 按值传递参数伪代码中： 1234567PROCEDURE OutputSymbols(BYVALUE NumberOfSymbols : INTEGER, Symbol : CHAR) DECLARE Count : INTEGER FOR Count ← 1 TO NumberOfSymbols OUTPUT Symbol // without moving to the next line NEXT Count OUTPUT NewLineENDPROCEDURE Python 在Python中，所有参数的行为都类似于局部变量，它们的效果就与传递值一样： 12345678def OutputSymbols(NumberOfSymbols, Symbol): for Count in range(NumberOfSymbols): print(Symbol, end='') print()# ********** main program starts here ***********OutputSymbols(5, '*') VB.NET 在VB.NET中，传参方式默认为按值传递。关键字ByVal是由编辑器自动插入的： 12345678910111213141516Module Module1 Sub OutputSymbols(ByVal NumberOfSymbols, ByVal Symbol) Dim Count As Integer For Count = 1 To NumberOfSymbols Console.Write(Symbol) Next Console.WriteLine() End Sub Sub Main() OutputSymbols(5, \"*\") Console.ReadLine() End SubEnd Module Java 在Python中，所有参数的行为都类似于局部变量，它们的效果就与传递值一样： 123456789101112131415161718package exl;public class Exl{ public static void outputSymbols(int numberOfSymbols, char symbol) { for (int count = 1; count &lt;= numberOfSymbols; count++) { System.out.print(symbol); } System.out.printIn(); } public static void main(String[] args) { outputSymbols(5, '*'); }} 按引用传递参数当参数通过引用传递时，当子例程内的值发生变化时，会影响调用程序中变量的值。 下面会给出一个有关于过程AdjustValuesForNextRow的例子： 1234PROCEDURE AdjustValuesForNextRow(BYREF Spaces : INTEGER, Symbols : INTEGER) Spaces ← Spaces - 1 Symbols ← Symbols + 2ENDPROCEDURE 如果想要调用函数，就需要打出下面这行命令： 1CALL AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols) 在调用该函数时，参数空格和符号的值会在过程中更改。调用之后，程序代码中的变量NumberOfSpaces和NumberOfSymbols将存储从过程中传递回来的更新后的值。 Python Python没有提供按引用传递参数的功能。相反，下面的子程序表现为一个函数并返回多个值。注意，在程序的主体部分中，变量是用来接收这些值的顺序的： 123456789101112def AdjustValuesForNextRow(Spaces, Symbols): Spaces = Spaces - 1 Symbols = Symbols + 2 return Spaces, Symbols# ******** main program starts here *********NumberOfSpaces = int(input())NumberOfSymbols = int(input())NumberOfSpaces, NumberOfSymbols = AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols)print(NumberOfSpaces)print(NumberOfSymbols) 这种将多个值作为一个单位处理的方式称为tuple。 VB.NET 在VB.NET中，ByRef关键字放在每个按引用传递的参数前面，用来表示按引用传递参数： 123456789101112131415161718Module Module1 Dim NumberOfSpaces, NumberOfSymbols As Integer Sub AdjustValuesForNextRow(ByRef Spaces, ByRef Symbols) Spaces = Spaces - 1 Symbols = Symbols + 2 End Sub Sub Main() NumberOfSpaces = Console.ReadLine() NumberOfSymbols = Console.ReadLine() AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols) Console.WriteLine(NumberOfSpaces) Console.WriteLine(NumberOfSymbols) Console.ReadLine() End Sub End Module Java Java没有提供通过引用传递简单变量参数的功能，只有对象可以通过引用传递。在Java中，数组是对象，所以数组是通过引用传递的。 123456789101112131415161718192021222324252627282930package exl;import java.util.Scanner;public class Exl{ static class RowData { public int spaces = 0; public int symbols = 0; } public static void adjustValuesForNextRow(RowData thisRow) { thisRow.spaces--; thisRow.symbols = thisRow.symbols + 2; } public static void main(String[] args) { Scanner console = new Scanner(System.in); RowData thisRow = new RowData(); System.out.print(\"Enter number of spaces: \"); thisRow.spaces = console.nextInt(); System.output.print(\"Enter number of symbols: \"); thisRow.symbols = console.nextInt(); adjustValuesForNextRow(thisRow); System.out.printIn(thisRow.spaces); System.out.printIn(thisRow.symbols); }} 数组创建一维数组Python，VB.NET和Java从下界值为0开始计算数组元素。 伪代码be like: 1DECLARE &lt;arrayIdentifier&gt; : ARRAY[&lt;lowerBound&gt;:&lt;upperBound&gt;] OF &lt;dataType&gt; 语法定义和例子下表展示了语法定义： 语言 ~ Python 在Python中没有数组。等价的数据结构称为列表 (list)，列表是一组有序的元素序列，它们的数据类型不必相同。 VB.NET Dim &lt;arrayIdentifier&gt;(&lt;upperBound&gt;) As &lt;dataType&gt; Java &lt;datatype&gt;[] &lt;arrayIdentifier&gt;; &lt;arrayIdentifier&gt; = new int[&lt;upperBound&gt;+1]; 举出一些例子： 伪代码 1234DECLARE List1 : ARRAY[1:3] OF STRING // 3 elements in this listDECLARE List2 : ARRAY[0:5] OF INTEGER // 6 elements in this listDECLARE List3 : ARRAY[1:100] OF INTEGER // 100 elements in this listDECLARE List4 : ARRAY[0:25] OF STRING // 26 elements in this list Python 1234567891011List1 = []List1.append(\"Fred\")List1.append(\"Jack\")List1.append(\"Ali\")List2 = [0, 0, 0, 0, 0, 0]List3 = [0 for i in range(100)]Alist = [\"\"] * 26 List1：由于没有数据类型声明和列表声明，生成列表的唯一方法是初始化一个列表。然后可以向现有列表中添加元素。 List2：可以将元素包含在[]中。 List3：你也可以使用一个循环来为列表添加内容。 AList：可以提供一个初始值，乘以所需元素的数量。\"\"填入初始值。 VB.NET 1234567Dim List1 As String () = {\"\",\"\",\"\"}Dim List2(5) As IntegerDim List3(100) As IntegerDim AList(0 To 25) As String 可以像List1一样，在声明时初始化数组。注意，List3有101个元素。你可以使用范围作为数组的维度(如AList)，但下界必须为0。 Java 12345678910String[] list1 = {\"\",\"\",\"\"};int[] list2;list2 = new int[5];int[] list3;list3 = new int[100];String[] aList;aList = new String[25]; 同样，你可以在声明时初始化数组(如list1)。 访问一维数组在伪代码中，需要使用一个索引值 (Index value)来访问数组中的一个特定内容： 1&lt;arrayIdentifier&gt;[x] 下面开始举例： 伪代码 12NList[25] = 0 // set 25th element to zero(0)AList[3] = \"D\" // set 3rd element to letter D Python 12NList[24] = 0AList[3] = \"D\" VB.NET 12NList(25) = 0AList(3) = \"D\" Java 12nList[25] = 0;aList[3] = \"D\"; 在Python中，可使用print(&lt;list&gt;)打印列表的全部内容。在VB.NET和Java中，你需要使用循环来打印数组中的所有元素。 创建二维数组伪代码be like: 1DECLARE &lt;identifier&gt; : ARRAY[&lt;lBound1&gt;:&lt;uBound1&gt;,&lt;lBound2&gt;:&lt;uBound2&gt;] OF &lt;dataType&gt; 语法定义和例子下表展示了语法定义： 语言 ~ Python 在Python中没有数组。等价的数据结构称为列表 (list)。 VB.NET Dim &lt;arrayIdentifier&gt;(&lt;uBound1, uBound2&gt;) As &lt;dataType&gt; Java &lt;datatype&gt; &lt;arrayIdentifier&gt;; &lt;arrayIdentifier&gt; = new &lt;datatype&gt;[uBound1][uBound2]; 举出一些例子： 伪代码 1DECLARE Board : ARRAY[1:6, 1:7] OF INTEGER Python 12345678910Board = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]Board = [[0 for i in range(7)] for j in range(6)]Board = [[0] * 7] * 6R VB.NET 1Dim Board(6, 7) As Integer 元素的编号从0到给定的数字。这个声明多了一行和一列。然而，如果忽略第0行和第0列，该算法可能更容易转换为程序代码。 Java 1234567891011int[][] board = { {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, }int[][] board;board = new int[6][7] 2维数组的初始化方式与一位数组类似。记住元素都是从0开始编号的。 访问二维数组在伪代码中，需要使用一个索引值 (Index value)来访问数组中的一个特定内容： 1&lt;arrayIdentifier&gt;[x,y] 下面开始举例： 伪代码 1Board[3,4] ← 0 // sets the element in row 3 and column 4 to zero Python 1Board[2][3] = 0 在Python中，元素从0开始编号，因此[3]访问的是第四个元素。 VB.NET 1Board(3, 4) = 0 我们忽略第0行和第0列：这里说的就是第三行第四列。 Java 1board[2][3] = 0; 同样在Java中，元素从0开始编号，因此[3]访问的是第四个元素。 文本文件向文本文件中写入伪代码： 123OPENFILE &lt;filename&gt; FOR WRITE // open the file for writingWRITEFILE &lt;filename&gt;, &lt;stringValue&gt; // write a line of text to the fileCLOSEFILE &lt;filename&gt; // close file 下面的代码示例演示了如何用这三种语言分别打开、写入和关闭名为SampleFile.txt的文件。如果文件已经存在，只要open file命令分配了文件句柄，它就会被覆盖。 Python 123FileHandle = open(\"SampleFile.TXT\", \"w\")FileHandle.write(LineOfText)FileHandle.close() 调用open函数时要指定文件名和模式(‘w’表示写入)。要写入到文件中的文本行必须包含换行符\\n，以便移动到文本文件的下一行。 VB.NET 123456Dim FileHandle As IO.StreamWriterDim LineOfText As StringFileHandle = NewIO.StreamWriter(\"SampleFile.TXT\")FileHandle.WriteLine(LineOfText)FileHandle.Close() 可以通过一个名为StreamWriter的对象访问该文件。 Java 12345678910import java.io.FileWriter;import java.io.PrintWriter;import java.io.IOException;FileWriter fileHandle = newFileWriter(\"SampleFile.TXT\", false);PrintWriter printLine = newPrintWriter (fileHandle)lString lineOfText;printLine.printf(\"%s\"+\"%n\", lineOfText);printLine.close(); 输入输出操作会抛出异常。管理它们的最简单方法是将你的主标题更改为: public static void main(String[] args); throws IOException 从文本文件中读取伪代码： 123OPENFILE &lt;filename&gt; FOR READ // open the file for writingREADFILE &lt;filename&gt;, &lt;stringVariable&gt; // read a line of text from the fileCLOSEFILE &lt;filename&gt; // close file 继续用SampleFile.txt举例： Python 123FileHandle = open(\"SampleFile.TXT\", \"r\")LineOfText = FileHandle.readline()FileHandle.close() 调用open函数时要指定文件名和模式(‘r’表示读取)。 VB.NET 12345Dim FileHandle As IO.StreamWriterDim LineOfText As StringFileHandle = New IO.StreamReader(\"SampleFile.TXT\")LineOfText = FileHandle.ReadLine()FileHandle.Close() 同样，通过一个名为StreamWriter的对象访问该文件。 Java 123456789import java.io.IOException;import java.io.FileReader;import java.io.BufferedReader;FileReader fileHandle = newFileReader(\"SampleFile.TXT\");BufferedReader textReader = newBufferedReader(fileHandle);String lineOfText = textReader.readLine();textReader.close() 还有其他库类可用于输入/输出，例如Scanner。 追加到文本文件伪代码： 1234OPENFILE &lt;filename&gt; FOR APPEND // open the file for appendREADFILE &lt;filename&gt;, &lt;stringValue&gt; // write a line of text from the fileCLOSEFILE &lt;filename&gt; // close file 继续用SampleFile.txt举例： Python 123FileHandle = open(\"SampleFile.TXT\", \"a\")FileHandle.write(LineOfText)FileHandle.close() 调用open函数时要指定文件名和模式(‘a’表示附加)。 VB.NET 12345Dim FileHandle As IO.StreamWriterFileHandle = NewIO.StreamWriter(\"SampleFile.TXT\", True)FileHandle.WriteLine(LineOfText)FileHandle.Close() 同样，通过一个名为StreamWriter的对象访问该文件。额外的参数True告诉系统我们需要将元素添加到对象中。 Java 12345678910import java.io.FileReader;import java.io.PrintWriter;import java.io.IOException;FileReader fileHandle = newFileReader(\"SampleFile.TXT\", true);PrintWriter printLine = newPrintWriter(fileHandle);String lineOfText;printLine.printf(\"%s\"+\"%n\", lineOfText);printLine.close(); 输入输出操作会抛出异常。最简单的方法是将你的主标题改为: public static void main(String[] args) throws IOException 文件结束标记 (EOF)EOF，为End Of File的缩写，通常在文本的最后存在此字符表示资料结束。 伪代码： 123456OPENFILE \"Test.txt\" FOR READWHILE NOT EOF(\"Test.txt\") DO READFILE \"Test.txt\", TextString OUTPUT TextStringENDWHILECLOSEFILE \"Test.txt\" 下面的代码示例演示了如何用这三种语言分别读取和输出文件的内容。三段语言都需要当碰到EOF后终止读取： Python 123456FileHandle = open(\"Test.txt\", \"r\")LineOfText = FileHandle.readline()while len(LineOfText) &gt; 0: LineOfText = FileHandle.readline() print(LineOfText)FileHandle.close() 在Python中没有显式的EOF函数。但是，当读取的文本行只包含文件结束标记时，该文本行的长度为0。可以运用这点达成同样的效果。 VB.NET 123456789Dim LineOfText As StringDim FileHandle As System.IO.StreamReaderFileHandle = NewSystem.IO.StreamReader(\"Test.txt\")Do Until FileHandle.EndOfStream LineOfText = FileHandle.ReadLine() Console.WriteLine(LineOfText)LoopFileHandle.Close() 当检测到文件结束标记时，EndOfStream就会返回True，循环就会结束。 Java 12345678910111213import java.io.IOException;import java.io.FileReader;import java.io.BufferedReader;FileReader fileHandle = new FileReader(\"Test.txt\");BufferedReader textReader = newBufferedReader(fileHandle);String lineOfText = textReader.readLine();while (lineOfText != null){ System.out.printIn(lineOfText); lineOfText = textReader.readLine();}textReader.close(); 在Java里面也没有专门用于EOF函数。但是，当读取的文本行只包含文件结束标记时，该文本行实际上是空的。我们可以运用这点达成同样的效果。 第十五章：软件开发程序开发周期开发软件需要经历很多不同的阶段。首先我们可以使用结构化英语，伪代码或者流程图来帮助我们理清程序的结构，然后再使用实际的语言编写。 当需要大型软件系统来解决大问题时，这些阶段就会变得更加正式，特别是当更多的人参与开发时。在设计解决方案之前，需要首先对问题进行分析。当程序正常工作并被使用时，可能会出现需要修改的问题，这就是所谓的维护 (Maintenance)。 下面来介绍程序开发周期中的每一步： 分析 (Analysis)解决问题的第一步是调查问题和当前的系统(如果存在的话)。这个问题需要明确而精确地定义，然后再起草一份“需求说明书”。 下一步就是思考解决方案。一个问题可能会有很多不同的解决方案。再分析这一步，我们有必要去思考这些解决方案中，哪一个是最合适，最有效的。 第三步就是决定如何解决问题： Bottom-up：从一个小问题开始，然后在它的接触上一直向上构建新的内容。 Top-down：使用伪代码，流程图或者结构图逐步细化你的代码。 设计 (Design)到这一步你的心中应该已经有了一个确切的解决方案了。但是我们如何细致的设计解决方案？ 我们可以使用一个标识表 (Identifier table)，把我们需要考虑的数据全部写进表里。这有助于我们去考虑所有的数据以及它们的结构。比如说，我们到底是需要一个一维数组或者二维数组处理数据？我们是不是需要创立一个文件夹来专门存放长期数据？ 随后使用伪代码或者流程图来写出你的程序。 这些都是设计这一步的任务。 编程 (Coding)设计解决方案后，可能需要选择合适的高级编程语言。如果你会一种以上的编程语言，你必须权衡每一种语言的利弊。上一章提到了各种语言 (实际上只有三种语言) 的强项与弱项。 在这一步，我们会将伪代码转化成真真切切的代码。当你开始编写程序时，你可能会发现程序在编译之前需要尝试好几次。当它最终完成时，我们就可以执行它。有些时候程序可能会炸，在这种情况下，我们需要调试代码。但是当我们的程序已经成功运行没有问题的时候，我们还需要考虑程序是否做了它应该做的事情。 测试 (Testing)只有彻底的测试程序才能确保程序在所有情况下都能正常工作。 程序开发生命周期有几种不同的开发方法。这包括瀑布式 (Waterfall)、迭代式 (Iterative)和快速应用程序开发模型 (Rapid application development model)。 程序开发生命周期遵循分析、设计、编码(实现)、测试和维护的定义阶段。当维护时需要对程序做出进一步调整时，开发就会重新开始，从而形成一个循环。如下图所示： 瀑布模型下图展示了瀑布式开发周期的示意图： 图中向下的箭头表示一个阶段的结果被输入到下一个阶段。返回到早期阶段的箭头反映了这样一个事实:在早期的开发阶段需要完成当前阶段更多的工作。 瀑布模型的好处有： 简单易懂，因为模型的每一个阶段都定义的十分清楚。 由于模型中阶段的固定性，整个周期易于管理，而且每一个阶段都有特定的结果和成果。 每一个阶段都需要被处理并完成。 瀑布模型适用于需求被充分理解的小型项目。 瀑布模型的坏处有： 再整个开发周期的后期才能出现一个完全可用的软件。 对于复杂并面向对象的项目来说，这个开发模式不是特别的适合。 对于需要长期进行的项目来说，这个开发模式也不是很适合。 没法适应不断变化的需求。 很难衡量阶段性的发展。 集成部分是在最后完成的，也就是说，如果有潜在的问题或者漏洞是很难发现的。 迭代模型迭代生命周期模型并不试图从完整的需求规范开始。相反，开发从实现程序需求的一个小子集开始。重复的(迭代的)评审以确定进一步的需求，最终形成完整的系统。 好处如下： 在开发的早期阶段有一个早期Demo这就允许团队更容易找到功能或者设计缺陷。在开发的早期阶段发现问题意味着可以更快地采取纠正措施。 有些功能可以在周期的早期快速开发。 我们在早期可以周期性的获得结果。 我们甚至可以规划并行发展。 易于衡量进步和进展。 变更项目范围或者需求的成本更低。 测试和调试较小的程序子集十分的容易。 在迭代过程中可以很轻易地识别并解决风险。 更容易管理风险，因为较高风险的风险会被优先考虑。 每一次增量更新都可以向客户交付产品。 在每个增量更新中确定的问题，挑战和风险都可以被应用到下一个增量更新中。 更适合大型和关键任务项目。 在这个生命周期中，软件会被尽早地生产出来。这有助于团队从客户那里听到有关产品的评估和反馈。 当然也有坏处： 只有大型软件开发项目才会从这个生命周期中收益。因为很难再将小型软件系统继续拆拆拆成更小的部分了。 可能会需要很多的资源，包括人力物力。 可能会出现设计问题，因为并非所有需求都在整个生命周期的开始时收集。 定义增量的时候可能需要定义整个系统。 快速应用程序开发模型RAD是一种使用最小计划的软件开发方法。相反，它规划原型来解决问题。原型 (Prototype)是解决方案的一部分的工作模型。 在快速应用开发模型中，模块作为原型并行开发，并集成以形成完整的产品，从而更快地交付产品。没有详细的预先规划，并且随时可以在开发过程中进行更改。 特点就是分析、设计、编码和测试阶段被合并到一系列短的迭代开发周期中。 优点： 可以适应不断变化的需求。 易于衡量进步。 在短时间内，人越少，生产力越高。 开发时间可以大幅减少。 组建的可复用性大大增加。 适用于基于组件和可扩展的程序。 可以进行快速的审查。 该模型鼓励用户去积极反馈问题。 在集成所有模块之间就解决了许多集成中可能出现的问题。 缺点： 只有模块化的程序才能够使用RAD构建。 需要高水平的开发人员和设计师。 需要客户在开发的过程中全程参与。 仅适合开发时间较短的项目。 使用结构图设计程序另一种模块化设计方法是选择子任务，然后构建一个结构图 (Structure chart)来显示模块之间的相互关系。结构图中的每个框代表一个模块，其中的每一层都是上一层的细化。 结构图还显示了模块之间的接口，变量。这些变量被称为参数 (Parameters)。向下层模块传参显示为向下指向的箭头。向上层模块传参显示为向上指向的箭头。 Structure chart: a graphical representation of the modular structure of a solution. Parameter: a value passed between modules 下图显示了计算两个数字平均值的模块的结构图。顶层的方框是模块的名称，它被细化成了下一级的三个子任务。INPUT numbers(参数Number1和Number2)被传递到Calculate average子任务中，然后Average参数被传递到OUTPUT average子任务中。箭头显示了参数如何在模块之间传递。传参的层级被称为”interface”。 结构图还可以显示控制信息，比如选择和重复。在第十二章我们举过一个有关于猜数字的例子，这里我们把它模块化先： 其中的菱形表示一个条件，要么为真，要么为假。 下图显示了绘制金字塔程序的结构图。最上面的半圆形箭头表示箭头下方模块的重复，标签显示重复发生时的情况。 结构图帮助程序员可视化模块如何相互关联以及它们如何相互连接。当考虑一个更大的问题时，这变得更加重要。下面给出了名为”Connect 4”游戏的程序的结构图。 在图片中我们能看见传参过程中有不同的箭头。 实心圆箭头表示传递的值是一个布尔值。 双头箭头表示变量值在模块内更新。 从结构图中写出伪代码让我们再来将目光聚集到上面的金字塔问题。 在原来的例子中，创建模块时没有使用结构图，所有变量都是全局变量。现在我们将使用局部变量和参数。使用局部变量和参数的原因是因为模块是自包含的，对变量的任何更改不会对其他地方的变量值产生意外的影响。 顶层模块Pyramid调用了4个模块。当一个模块被调用时，我们在模块标识符后面的括号中提供参数。伪代码如下: 123456789101112131415161718192021222324252627282930313233343536373839MODULE Pyramid CALL SetValues(NumberOfSymbols, NumberOfSpaces, Symbol, MaxNumberOfSymbols) REPEAT CALL OutputSpaces(NumberOfSpaces) CALL OutputSymbols(NumberOfSymbols, Symbol) CALL AdjustValesForNextRow(NumberOfSpaces, NumberOfSymbols) UNTIL NumberOfSymbols &gt; MaxNumberOfSymbolsENDMODULEPROCUDURE SetValues(NumberOfSymbols, NumberOfSpaces, Symbol, MaxNumberOfSymbols) INPUT Symbol CALL InputMaxNumberOfSymbols NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2 NumberOfSymbols ← 1ENDPROCEDUREPROCEDURE InputMaxNumberOfSymbols(MaxNumberOfSymbols) REPEAT INPUT MaxNumberOfSymbols UNTIL MaxNumberOfSymbols MOD 2 = 1ENDPROCEDUREPROCUDURE OutputSpaces(NumberOfSpaces) FOR Count ← 1 TO NumberOfSpaces OUTPUT Space // without moving to next line NEXT CountENDPROCEDUREPROCEDURE OutputSymbols(NumberOfSYMBOLS, Symbol) FOR Count ← 1 TO NumberOfSymbols OUTPUT Symbol // without moving to next line NEXT Count OUTPUT Newline // move to the next lineENDPROCEDUREPROCEDURE AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols) NumberOfSpaces ← NumberOfSpaces - 1 NumberOfSymbols ← NumberOfSymbols + 2ENDPROCEDURE 状态转换图与程序设计我们的计算机系统可以看作是一个有限状态机(Finite State Machine, FSM)。FSM有一个叫做start的状态。输入进FSM的指令会导致一种状态到另一种状态的转换。 FSM的状态信息可以用状态转换表 (State-transition table)来表示。 Finite state machine (FSM): a machine that consists of a fixed set of possible states with a set of inputs that change the state and a set of possible outputs. State-transition table: a table that gives information about the states of an FSM 下表展示了一个展示FSM状态的状态转换表： 如果状态为S1，则a的输入不会导致状态改变。 如果状态为S1，则b的一个输入将S1转换为S2。 如果状态为S2，则b的输入不会改变状态。 如果处于S2状态，则a的输入将S2转换为Sl。 input input name current state current state S1 S2 input a S1 S1 input b S2 S2 状态转移图 (State-transition graph)可以用来描述有限状态机的行为。下图开始状态为S1。开始状态会用一个实心圆球的箭头表示。如果有限状态机有一个最终状态(也称为停机状态 (Halting state))，则用一个双循环的状态来表示。 State-transition diagram: a diagram that describes the behavior of an FSM. 如果输入产生输出，则用竖线表示。例如，如果当前状态为S1，b的输入产生了一个输出c，并将FSM转换为S2状态。这时候就会使用竖线隔开，表示输入输出。 FSM还有一个别称：”Mealy Machine”。 错误的类型为什么会发生错误 &amp; 我们如何找到它们软件可能会因为下面的这些因素而没有按照预期的想法工作： 程序员在编程序的时候出现了错误。 没有科学的在规划阶段指定需求。 软件设计师犯了一个设计错误。 UI设计的贼差，所以说用户可能会在使用时使程序出现问题。 计算机硬件故障。 如何发现错误?最终用户可能会报告一个错误，这无疑是不利于软件开发人员的声誉的。所以说，我们需要尽可能在软件发布之前进行测试，并修复尽可能多的漏洞。研究表明，错误发现得越早，修复它的成本就越低。软件在整个开发过程中都进行测试是非常重要的。 测试的目的是发现错误。著名的荷兰计算机科学家Edsger Dijkstra说:“程序测试可以用来显示bug的存在，但永远不能显示它们的不存在”。 (每日名言) 查找语法错误 (Syntax errors)很容易。编译器/解释器会为你找到它们，并且通常会给你一个提示，告诉你哪里出了问题。 根据开发环境编辑器的不同，编辑器可能会标记出一些语法错误，因此您可以在开发过程中纠正这些错误。语法错误是一种“语法 (grammatical)”错误，指的是程序语句没有遵循高级语言结构的规则。 Syntax error: an error in which a program statement does not follow the rules of the language. 有些语法错误可能只有在使用解释器或编译器翻译程序时才会变得明显。解释器和编译器的工作方式不同。一旦程序成功编译后，你就知道不会再有语法错误了。 但是对于解释型程序，情况并非如此：只有即将执行的语句才会进行语法检查。因此，如果你的程序没有经过彻底的测试，它甚至可能还有语法错误。 更难以发现的是逻辑错误 (Logic errors)和运行时错误 (Runtime errors)。当程序执行意外停止或“崩溃”或进入无限循环并“冻结”时，发生的就是运行时错误。 Logic error: an error in the logic of the solution that causes it not to behave as intended. Run-time error: an error that causes program execution to crash or freeze. 这两种类型的错误都只能通过仔细的测试才能找到。这种错误的危险在于，它们可能只会在某些情况下出现。如果一个程序每次执行时都崩溃，那么很明显有错误。如果程序被频繁地使用，并且看起来一直在工作，直到某组数据导致了故障，那么在不造成严重后果的情况下很难发现故障。 测试程序的方法存根测试存根测试 (Stub testing) 在开发用户界面时，您可能希望在实现所有功能之前对其进行测试。你可以为每个过程编写一个”存根 (Stub)”。 存根(stub)和模拟(mocking)一样，意味着创建一个替身，但存根只模拟行为，而不是整个对象。当你的实现只与对象的特定行为交互时，可以使用此方法。比如说你想要测试你的主程序，但是你的每一个模块还没有完成，就可以使用Stub testing，通过定义每一个模块应输出的内容，来做到测试主程序的目的。 每一个分叉只包含一条output语句，以确认进行了调用。用户在主程序中选择的每个选项都将调用相关的过程。 黑盒测试作为程序员，你可以看到你的程序代码，你的测试将涉及代码的知识(参见白盒测试)。作为全面测试的一部分，程序还应该由其他人进行测试，他们看不到程序代码，也不知道解决方案是如何编码的。 这样的程序测试人员将查看程序规范，以了解程序要做什么，设计测试数据并计算出预期的结果。测试数据 (Test data)通常由正常数据值、极端/边界数据值和错误/异常数据值组成。 测试人员然后用测试数据运行程序并记录结果。这种测试方法被称为黑盒测试，因为测试人员看不到程序代码的内部，程序对他们来说就像一个黑盒。 当实际结果与预期结果不匹配时，就存在问题。在修改程序之前，程序员需要找到这种差异的原因。一旦黑盒测试确定存在错误，就必须使用调试软件或干式运行来找到需要更正的代码行。 Test data: carefully chosen values that will test a program. Black-box testing: comparing expected results with actual results when a program is running. 白盒测试我们如何检查代码是否正确工作?我们选择合适的测试数据来检查代码中的每一条路径。这被称为白盒测试 (White-box testing)。 White-box testing: testing every path through the program code 干式运行算法检查算法是否按预期工作的一种好方法是使用跟踪表和不同的测试数据来运行算法。这也被称为walk through。 其思想是在算法的每一步写下所有变量和条件值的当前内容。 Dry-run (walk through): the process of checking the execution of an algorithm or program by recording variable values in a trace table. Trace table: a table with a column for each variable that records their changing values. 测试阶段这些测试方法在软件开发的早期使用，例如在编写单个模块时。有时程序员自己也会使用这些测试方法。在较大的软件开发组织中，一般来说会有全职的软件测试人员。 软件通常由许多模块组成，有时由不同的程序员编写。每个单独的模块可能已经通过了所有测试，但当模块合并成一个程序时，测试整个程序至关重要。这就是所谓的集成测试 (Integration testing)。集成测试通常是增量式的。这意味着每次添加一个模块就会完成一次测试，并在添加下一个模块之前进行进一步的测试。 软件在发布给客户之前，将由软件测试人员进行内部测试。这种类型的测试称为Alpha测试 (Alpha testing)。 定制软件(为特定客户编写的)将随后发布给客户。客户将检查它是否符合他们的要求并按预期工作。这个阶段称为验收测试 (Acceptance testing)。这通常是交接过程的一部分。在成功的验收测试之后，客户将签署软件。 当软件不是为销售而生产时，没有特定的客户来执行验收测试和签署软件。所以，在alpha测试之后，一个版本将发布给有限的潜在用户受众，即所谓的“beta测试者”。这些测试人员将使用软件并在他们自己的环境中进行测试。这个早期的发布版本被称为beta版本，被选中的用户执行Beta测试 (Beta testing)。在beta测试期间，用户将向软件库反馈他们发现的任何问题，以便软件库可以纠正任何报告的错误。 Integration testing: individually tested modules are joined into one program and tested to ensure the modules interact correctly. Alpha testing: testing of software in-house by dedicated testers Acceptance testing: testing of software by customers before sign-off. Beta testing: testing of software by a limited number of chosen users before general release. 测试策略，测试计划和测试数据在软件项目的设计阶段，我们需要制定合适的测试策略，以确保从一开始就对软件进行严格的测试。我们应考虑哪些测试方法适用于所述项目，因为必须制定一个精心设计的测试计划来确保最终程序的质量。 一些时候，大型程序不能进行详尽的测试，但重要的是系统测试可以发现尽可能多的错误，因此我们需要一个测试计划。 在第一个例子中，我们设计了一个大纲规划，如下： 控制流：用户是否已经得到了适当的选择？所选的选项是否导致特定模块正常工作？ 输入验证：所有的数据是否已经正确地输入进系统？ 循环和决策：循环和决策是否正确？ 存储：数据是否保存在正确的文件当中？ 输出验证：程序是否能够产生正确的输出？ 列出这份大纲之后，我们还要逐步细化，直到做成一个详细的测试计划。 我们如何进行这些测试?首先我们需要选择能够让我们看到它是否被正确处理的数据，这种类型的数据称为“测试数据 (Test data)”。它与真实的、实时的数据不同，因为它是为了测试不同的可能性而特意选择的。我们区分不同类型的测试数据，如下表所示： 测试数据类型 解释 Normal (valid) 正常的，有效的，合理的数据。 Abnormal (erroneous) 程序不应该接受的数据值。 Boundary (extreme) 处于正常数据范围的边界或者极端的数据值 测试数据应该包括恰好在边界内的值(即有效数据)和恰好在边界外的值(即无效数据)。 如何预防错误编写能正确工作的程序的最好方法，就是从一开始就防止错误。我们如何将程序中的错误最小化? 产生错误的一个主要原因是贫乏的需求分析。在设计解决方案时，理解问题以及系统的用户想要或需要什么是非常重要的。我们应该使用如下方案来达成这一目的: 使用久经沙场的，主流的语言和语言结构，如结构化变成或者面向语言的设计。 使用业内约定俗成的规定，如标识符表，数据结构，或者使用标准的算法。 使用程序库 (Program libraries)中经过验证的模块和对象。 纠正性维护维护程序不像维护机械设备那样：它不需要润滑，零件也不会磨损。纠正性维护 (Corrective maintenance)指的是当程序由于逻辑错误或运行时错误而不能正确工作时所需要的工作。 有时，程序错误在很长一段时间内都不会变得明显，因为只有在非常罕见的情况下才会出现意外结果或程序崩溃。这些情况可能是因为程序的某些部分不经常使用，或者因为某些情况下的数据包含极端值。过于早期的纠正性维护也可能引入其他错误。 Corrective maintenance: correcting identified errors. 在报告问题时，程序员需要找出导致bug的原因。为了找到bug，程序员要么使用程序调试软件，要么使用跟踪表。 适应性维护有时程序经常需要修改，以使其执行原本执行不了的功能。 例如，第十三章介绍的Connect 4游戏允许O和X两个玩家对战。修改后的版本将是一个玩家成为电脑。这意味着单个玩家与电脑下棋，尝试战胜计算机。 适应性维护 (Adaptive maintenance)是对程序进行修改以增强功能或响应规格变化的行为。 Adaptive maintenance: amending a program to enhance functionality or in response to specification changes 改善性维护如果你的程序运行得令人满意，但是你发现仍有改进的空间。例如，如果文件处理由顺序访问改为直接访问，程序可能运行得更快。 改善型维护 (Perfective maintenance)的目标是修改程序以提高性能或可维护性。 Perfective maintenance: modifying a program to improve performance or maintainability. AS部分完结撒花 (花)(花)(花) 最后更新于：2023.4.28","link":"/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/"},{"title":"LaTeX自学笔记","text":"本人自学LaTeX非系统性笔记，随学习进度不断更新 简介 因为CIE考试迫在眉睫，最近就先暂时不更新这篇文章了 是一种基于ΤΕΧ的排版系统，在生成学术期刊，复杂表格和公式上的效果格外的突出。相比于Microsoft Word而言，可以很稳定、精确、美观地完成排版任务（尤其是数学排版）。的可拓展性也很强，可以支持任何形式的排版，如五线谱，原理图等。 当然，最大的缺点就是上手门槛高, （要是门槛不高就不会有这篇文章了） 其次还有编写耗时长，编写复杂，需要编译源文件才可以看到文章效果等缺点。因此，爆肝各大教程提升自己使用类排版系统能力是唯一的方法。 那为什么还要花费如此经历去学习使用？是因为排版系统的质量实在是高，高到大学好多论文只支持上传作品。 那看样子这个 ，我是铁定得学了。 Tips：结合目录食用本文，你将收获更高阅读效率 配置本地环境首先得给自己整一个写的地方。常见的 发行版有两个，分别是 TeX Live和 MiKTeX。 TeX LiveTeX Live提供的包特别全，但是体积比较大，安装比较慢（指安装一个上午）。不过如果你的网络条件不是特别稳定，建议直接安装TeX Live一劳永逸。 TeX Live下载地址 MiKTeXMiKTeX体积相比TeX Live小了很多，安装速度明显变快，但是遇到缺少的包就需要联网下载了。 MikTeX下载地址 Overleaf另外，如果想要快速使用 编辑器的话，一款叫做Overleaf的在线编辑器也比较好用，进入网站需要先注册登录才能使用。 Overleaf网址 Visual Studio Code在安装完TeX Live或者MiKTeX之后，你可以使用VSCode作为一个写作环境。VSCode可以对代码进行高亮标注，并且还有现代化的UI，出色的颜值。如果你是VSCode的忠实用户的话，也可以对VSCode进行快速的 环境配置。 我们需要安装一个叫做LaTeX Workshop的插件。安装方法如下： 按下 Ctrl+Shift+X，转到 Extentions(扩展) 界面 搜索LaTeX Workshop 点击安装 LaTeX命令格式所有的 命令都使用反斜杠”\\“作为开头反斜杠后面的文字部分代表命令名称，后面的花括号”{}“代表命令参数举一个例子，此命令\\documentclass{article}代表引入文档类别，类别为article（文章）。 若存在百分号”%“，则代表在同一行内百分号后面的所有字符为注释，不参与文档编译。在中出现编译错误时，相比于直接删除有问题的代码，使用”%“注释掉相应代码是更明智的选择。你可以在文档任何一个位置插入注释。 LaTeX文件结构 文档的结构分为导言区和正文区（文稿区）。 导言区 导言区主要用于文档的全局设置。在\\begin{document}命令之上的内容，一般称之为导言区。下面是导言区常用的命令： \\documentclass命令用来引入文档类别，以及定义部分正文属性。 例如，\\documentclass{article}代表引入文档类别，类别为article（文章）。花括号内还可以使用report, book, letter等参数。每一种文档类别编译出的效果都不一样。（比如说Book就会生成一个封面，但是article就不会） \\title{}命令用于定义文档标题。 \\author{}命令用于定义文章作者。 \\date{}命令用于定义编辑文档的时间。花括号内填入\\today代表使用当前时间。 正文区顾名思义，正文区则用于承载编译结果的内容。（说白了就是正文） 你可以使用文字，命令，数学公式等元素构成正文。 正文区命令 使用\\begin{*环境名称*}和\\end{*环境名称*}命令引入一个环境。 环境名称填入document引入一个文件环境。所有文档有且只有一个document环境，置于\\begin{document}和\\end{document}之间的内容叫做正文区。 置于\\begin{document}和\\end{document}之间的命令与字符会被编译。因此，可以在\\end{document}存放一些论文相关的资料，以便日后查阅。 环境命令的格式如下： \\begin{*环境名称*} 内容 \\end{*环境名称*} \\maketitle命令用于在正文依次显示导言区定义的标题，作者和编辑时间。 只有在导言区设定了标题，作者和编辑时间的值之后，才可正常显示。 当文档类别为letter时，此命令会编译错误。因为letter文件类型中不存在\\maketitle命令。 数学模式使用“美元”符号”$“包裹的内容称之为”数学模式”，之外的内容为”文字模式”。 文字置于文字模式内即可渲染。但在数学模式下输入公式，才可以正确渲染公式。 单美元符号”$$\"包裹的公式会在行内显示，称作**行内公式**；而双美元符号\"$$$”包裹的内容会另起一整行居中显示，称作行间公式。 例如如下代码： Let $f(x)$ be defined by the formula $$f(x)=3x^2+x-1$$ which is a polynomial of degree 2. 会被显示为： Let be defined by the formula f(x)=3x^2+x-1which is a polynomial of degree 2. (LaTeX的一大好处，解决数学渲染的痛点) P.s:(后面那个“(1)”实操的时候是不会显示的，这是我的博客目前的一个Bug，以后找时间再修复) 换行在源文件正文中增加一个空行，用于表示换行操作。例如： Hello World! Let $f(x)$ be defined by the formula $f(x)=3x^2+x-1$. 显示为：Hello World! Let be defined by the formula . 而添加一行空行后： Hello World! Let $f(x)$ be defined by the formula $f(x)=3x^2 +x-1$. 则显示为：Hello World!Let be defined by the formula . 空行有以下几个规则： 仅存在注释的一行不算做空行，不作为换行操作。 多个空行并列存在，会当做只有一行空行处理 LaTeX中文处理需要进行几步配置才可以使用中文输入。具体配置方式之后在这里更新。另外，设计中文处理的一些命令也会在文章最后进行补充，等到时候再更新吧。 LaTeX字体在中，一个字体有如下5种属性： 字体编码 正文字体编码 数学字体编码 字体族 罗马字体 无衬线字体 打字机字体 字体系列 粗细 宽度 字体形状 直立 斜体 伪斜体 大型小写 字体大小 文件中，如上五个属性都可以通过命令或者声明进行设置。以下内容从字体族开始： 字体族字体族一共有三种，分别是罗马字体（Roman Family），无衬线字体（Sans Serif Family）和打字机字体（Typewriter Family）。 三中不同的字体看起来就像是这样的： 罗马字体：笔画起始处有装饰（衬线） 无衬线字体：笔画起始处无装饰 打字机字体：每个字符宽度相同，又称作等宽字体 字体族命令在文档中，可通过\\textXX{*文本*}和\\XXfamily *文本*两种命令设置字体族种类。XX需要填入对应字体族缩写。 \\textXX{}\\textXX{}为字体命令。在\\textXX{}中，XX中填入对应字体族缩写。 此命令共有三种样式： \\textrm{} 代表使用罗马字体（rm） \\textsf{} 代表使用无衬线字体（sf） \\texttt{} 代表使用打字机字体（tt） 而在{}中需要填入需要指定字体族的文字，例如\\textrm{Roman Family}命令输出结果为： 由上图所示，”Roman Family”文字以罗马字体显示。 \\XXfamily *文本*\\XXfamily *文本*为字体声明。在\\XXfamily *文本*中，XX中需填入对应字体族缩写。不过请注意，*文本*与命令\\XXfamily之间需存在一个空格。 与\\textXX{}命令一样，此命令共有三种样式： \\rmfamily *文本* 代表使用罗马字体（rm） \\sffamily *文本* 代表使用无衬线字体（sf） \\ttfamily *文本* 代表使用打字机字体（tt） *文本*区域输入需要声明格式的文字，作用于后续的文本。文本区域可以使用大括号对文本进行分组，限定字体声明的作用范围。例如： 123456789{\\rmfamily Roman Family} {\\sffamily Sans Serif Family} {\\ttfamily Typewriter Family}或者\\rmfamily Roman Family {\\sffamily Sans Serif Family} {\\ttfamily Typewriter Family}或者\\rmfamily Roman Family \\sffamily Sans Serif Family \\ttfamily Typewriter Family 三行均输出为： 不过请注意，当一个字体声明遇到另一个字体声明时，会结束当前声明，而采用新的声明。 字体系列字体系列一共有两种，分别是中体(Medium Series)和粗体(Boldface Series)所谓中体，其实是中等权重；加粗也实际上是“加宽加粗”。（虽说我也没搞懂这个中体是个啥玩意，看起来也没啥特别的） 两种字体系列如图所示： 中体： 粗体： 字体系列命令与字体族命令相同，可通过\\textXX{*文本*}和\\XXfamily *文本*两种命令设置字体系列。XX需要填入对应字体族缩写。其中，中体的缩写为md，而粗体的缩写为bf。如下面表格所示： 字体系列名称 英文名称 缩写 中等权重 Medium Series md 加粗 Boldface Series bf 例如，\\textmd{Medium Series} 或者 \\mdfamily Medium Series 的输出结果为 而\\textbf{Boldface Series} 或者 \\bffamily Boldface Series的输出结果为 两个命令的语法要求与特点和字体族的那两个命令完全一致，因此这里就不多写了。有关内容在这里查看。 *有一点需要注意，我前往Overleaf官网测试的时候，加粗命令结果好像编译后不显示。可以使用本地的TeX Studio试一下。 字体形状字体形状共有如下四种。直立(Upright Shape / Roman Shape)，斜体/意大利(Italic Shape)，伪斜体/倾斜(Slanted Shape)，大型小写(Small Capitals Shape) 他们分别看起来是这样的： 直立： 斜体： 伪斜体： 大型小写： 同样的，下面用一个表格总结一下字体形状与缩写： 字体系列名称 英文名称 缩写 直立 Upright Shape / Roman Shape up 斜体/意大利 Italic Shape it 伪斜体/倾斜 Slanted Shape sl 大型小写 Small Capitals Shape sc 字体形状命令与字体族和字体系列命令相同，可通过\\textXX{*文本*}和\\XXfamily *文本*两种命令设置字体系列。XX需要填入对应字体族缩写。 例如：\\textup{Upright Shape} 或者 \\upfamily Upright Shape均输出为： 两个命令的语法要求与特点和字体族的那两个命令完全一致，因此这里就不多写了。有关内容在这里查看。 字体大小在调整字体大小之前，需要前往导言区\\documentclass命令设置默认字号。在\\documentclass命令后紧跟一个方括号[]，并在其中定义想要的默认字号磅数。 比如说，\\documentclass[12pt]{article}代表默认字号为12磅，文档类型为article（文章）。这也意味着文档除单独定义过大小的文字，其他文字的大小都变为12磅。不过这个磅数到了12磅就封顶了，没有什么所谓的13磅14磅。 字体大小命令我们可以用{\\字体大小命令 *文本*}来定义文档内部分文字的字号。使用括号来规定作用字体大小的范围。在中，有如下几个大小命令。由小到大依次为：12345678910\\tiny\\scriptsize\\footnotesize\\small\\normalsize\\large\\Large\\LARGE\\huge\\Huge 举个例子，{\\tiny Hello} {\\Huge Hello}的输出为： 如下代码：12345678910111213141516171819{\\tiny Hello}{\\scriptsize Hello}{\\footnotesize Hello}{\\small Hello}{\\normalsize Hello}{\\large Hello}{\\Large Hello}{\\LARGE Hello}{\\huge Hello}{\\Huge Hello} 的输出为： 这些命令对应字体的大小和默认字体有关，具体对应关系如下： 命令\\默认字号 10pt 11pt 12pt \\tiny 5 6 6 \\scriptsize 7 8 8 \\footnotesize 8 9 10 \\small 9 10 10.95 \\normalsize 10 10.95 12 \\large 12 12 14.4 \\Large 14.4 14.4 17.28 \\LARGE 17.28 17.28 20.74 \\huge 20.74 20.74 24.88 \\Huge 24.88 24.88 24.88 最后编辑于：2022.8.31持续更新 参考源:Bilibili-一个非常快速的 Latex 入门教程Bilibili-latex中文教程-15集从入门到精通包含各种latex操作简书-LaTeX教学2.4 环境LaTeX字体设置","link":"/2022/08/24/Latex%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"title":"有关深度学习","text":"自学深度学习的不完全笔记（ 本笔记根据李沐老师的B站视频：动手学深度学习 PyTorch版 和配套的相关材料：《动手学深度学习》 —— 动手学深度学习 2.0.0 整理而成。 不完全保证内容的绝对准确和完整。 深度学习？深度学习？","link":"/2023/06/10/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%89%E5%85%B3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"title":"收集&quot;你说得对&quot;","text":"一篇收集”你说得对”的文章 例 题 精 解 2022.12.1更新 你说得对，但是永雏塔菲（日语：永雛 タフィー／エイス タフィー）（英语：Ace Taffy）是一名个人势虚拟偶像。2021年6月至今，她主要在视频网站哔哩哔哩通过直播、动态与动画投稿的方式开展虚拟主播活动；同时也在视频网站YouTube、抖音以及社交网站微博、Twitter等多个网络平台进行虚拟偶像活动。其形象由画师nanakagura（ななかぐら），即神乐七奈设计。观众被她称呼为“雏草姬”。 首先我认为你说得对，但众所周知og是世界第八的队伍，经历major后转会引进原team spirit的主狙degster，磨合后先后击败过navi，faze并在世界排名榜上不断攀升。我说这么多就是想强调一点，2022年9月3日wu2-0将og送回家，望周知。 你说得对，但是这种情况的前提下，会因为法/韦克内收空间中的幽体辐射下，形成以η/Ð宏粒子射线为场能的波态中子向心力场，然而当前时空的基本实体常量与太核质能固定不变，在其向太核中的吸收过程时，会与当前背景空间之间形成一个类似中心放射状环形空间，从而导致全部基质实体的引力动场能量瞬值反冲效应直接作用于υ太核核中 [ WoM表现为：⊙υ∝◎Ðℓ≈∮↑β√1.44№/ξ¾ⁿ≒§η, ￡≠√ℓº², (Θ┙iGE表格┊F0.7) ] ，最终体现为其内核子内虚衡空间蓝向展开，当前时空形成时态空洞，而韦克低纬时空凭空出现基质实体。 你说的对，但我觉得没有考虑到水的比热容和离散傅里叶变换的频域特性，如果加上环形导体的磁场可能西红柿炒鸡蛋会更好吃吧。其实这个观点有点偏激了，外星人是紫色的，但派大星和海绵宝宝一起去抓水母了。而且依古比古的毯子好像是红色的，打碎后加入蒜末爆香，一道老人孩子都爱吃的家常菜就做好啦。是的，我觉得这个赛季不能用海绵宝宝上分。别问为什么，这个赛季海绵宝宝被削弱了很多，我建议用一技能煎蟹黄堡带终结，321的顺序一套带走派大星。在面对蟹老板的一技能钳钳攻击时用3321，另外可以入手他的新皮肤无敌黄暴泡泡海绵。确实，小孩在太阳下晒40分钟味道最佳，但个人认为小孩还是晒0.01秒最有嚼劲。当然这也取决于太阳光照强度。如果是阴天，把小孩带下去溜达一圈就可以食用了，如果是晴天直接追着啃。 你说的对 但是《烟神》是由丁真珍珠自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「理塘」的幻想世界，在这里被神选中的人将被授予「电子烟」，引导尼古丁之力。你将扮演一位名为「芙蓉王」的神秘角色，在自由的旅行中邂逅性格各异、能力独特的动物朋友们，和它们一起击败强敌，找回不存在的亲人的同时，逐步发掘「理塘」的真相。 你说的对 首先《极晶飞车201》中雪佛兰威龙的加速虽然最强，但是兰博基尼911的极速确实一般，这样跑的话只能徒增油耗，其实还是得靠氢氧电池中的离子转换产生能量，由于氢离子的能级跃迁时会产生波和能量，因此黑洞迟早会被霍金辐射消耗殆尽，那时宇宙就会归于虚无，否则人类就没法发明出时光机，这一点还是要考虑到的 你说的对，但是《主播电棍重度依赖》是由中国游戏与媒体研究院自主研发的一款偶像培养游戏 游戏发生在一个被称作「otto」的女孩（正确的）身上，在这里你将扮演一位名为「djgun」的神秘角色，在道理直播中获得超多的粉丝!达成结局的同时，逐步发掘「奥修米安」 的真相。 你说的对，但是在Apple app store搜索”原神”即可下载一款制作精良的塔防游戏。玩家将进入”泰拉”世界，扮演名为”博士”的角色，加入叫作”罗德岛”的组织，在许多干员的帮助下找到治愈感染者的方法，寻找让感染者与普通人和平共处的方法。 你说得对，但是斯卡蒂是手机游戏《明日方舟》中的六星近卫职业无畏者分支干员。斯卡蒂是一名赏金猎人，现为罗德岛所雇佣。在过去完成的赏金任务中，斯卡蒂于对抗大型生物，破坏硬目标，攻坚战，歼灭战等多类行动中展现出强劲实力，推测与其过往战斗经验相关。斯卡蒂成为赏金猎人之前的履历缺失，现于罗德岛某攻坚小队供职，同时身兼单兵任务预备执行干员一职。 你说得对，但是我是土生土长的璃月人。我最喜欢的游戏是Genshin，我最喜欢的游戏厂商是mhy株式会社，最喜欢的美食是中原杂碎，我最难忘的角色名字是支支楠楠龙龙，因为在那背后有着令人浮想联翩的深远寓意。我最痴迷的npc叫立本，我们原神玩家一般都管立本叫爹，我最喜欢研读的是璃月3700年的悠久历史，我最喜欢的人设叫做七七尸变，我最想去旅游的地方是稻妻，因为在那里我能观赏到仅稻妻独有的鹈饲捕鱼与烟花。我最喜欢的游戏角色是中离，我最喜欢的武器是贯虹之槊。我每天都在为我所热爱的一切而奋斗，我感到无比的骄傲与幸福 你说的对，但是《你说得对》是由你说得对与你说的对自主研发的一款你说得对 你说得对在一个被称作你说得对的你说得对，在这里你将扮演你说得对，在你说得对中获得你说得对！你说得对的同时，逐步发掘你说得对的你说得对 你说的对，确实是这样的。但是《使命召唤手游》（Call of Duty Mobile简称：CODM）是一款大型多人在线第一人称射击类游戏，还原了《使命召唤》系列的经典玩法、地图、角色等IP内容，并针对手机端的操作特点进行了适配与优化。2020年12月24日，《使命召唤手游》宣布定档12月25日。游戏已于2020年12月25日7时30分正式开服，为iOS和安卓混服，所有用户可以共同联机游玩。 这观点我不敢苟同，因为打开原神时传统香烟产生的羟甲基戊二酸单酰辅酶a还原酶抑制剂会增大火星大气层等离子与γ射线摩擦发生二次线性爆炸，导致丁真毛孔扩张，进而影响小黑子苏珊两个鼻孔之间的巨热力势发生扭曲，使三鲜伊面横截面产生无限极相变，致使θ和τ两种介子的自旋、质量、寿命、电荷等完全相反，使暗物质发生逆转产生全新114514粒子，114514粒子扭曲时间立场使牛顿定律彻底失效，第三第四纬度融合，人类进入新时代 你说的没错。但是嘲笑原神玩家的行为就像讽刺伽利略的莎士比亚，就像嘲笑敢于挑战风车的唐吉诃德，因为你的平庸让你不愿意接受原神这款游戏，因为你不相信会有非凡的存在，并嘲笑相信非凡寻在的人，不得不嘲笑，因为这样他们仿佛就和你一样平庸了，这样你就能放下心来了 变 式 训 练 2022.11.22更新 我觉得这个观点有点偏激了，外星人是紫色的，但派大星和海绵宝宝一起去抓水母了。而且依古比古的毯子好像是红色的，打碎后加入蒜末爆香，味道老人孩子都爱吃的家常菜就做好啦。其次你这句话有点矛盾，首先鲤鱼要跃龙门必须要37°的雷雨天气，而且海绵宝宝的宠物叫小窝，拍点蒜炒香老人小孩都喜欢吃，敏感肌也可以用。虽然植物进行光合作用需要叶绿素，但是从食盐提纯的过程看来，解这个三元二次方程组我们得从秦始皇灭六国说起。 同感，科比去世我那天早上是被电话吵醒的，电话里我哥们告诉我：兄弟，科比走了。我下意识就直接开骂：你tm说啥呢，科比才41岁，又没得大病，你tm是不是发烧脑子烧坏了。他沉默了一会，后面哭着说：科比他真的走了啊，网上已经传疯了，新闻也报了。挂了电话我就去上网搜，可是不管哪个新闻都熟报的科比因飞机事故去世，我不敢再看了，关了手机躺在床上发呆，科比那一幕幕经典场景在我眼前浮现，不论是处女秀击败蓝豹兽为能源之城的元老报仇，还是看不惯猛虎王于是替金铁兽挡下了致命一击，还是单挑猛虎王被30%功力打败，大结局和兄弟超音速用合击绝技天羽屠龙舞重创暴龙神等等，我不是一个科比的粉丝，但他永不放弃的精神一直深深的影响着我。 呃你这件事啊不是说不行，但是我觉得牛头是可以打上单的，打团时就是一个团战搅屎棍，而一般来说搅屎棍的材质最好是金属，因为木头可能会残留一些气味，而这些血的气味会引来鲨鱼，所以在大海中千万不要喝海水，海水中盐分太高只会加速你的脱水，如果你在洗衣机里的衣服已经脱水完毕，记得把衣服晾在比较干燥的地方，而各个地方都有自己的标志性动物，比如澳大利亚的袋鼠，这些袋鼠去梵蒂冈要跨越海洋，如果澳大利亚袋鼠决定入侵梵蒂冈的话，那它们就会锤你们这些不点赞的人一拳。面对这个问题，我们需要拿出新水平、达到新境界，通过新举措、新发展，形成新突破，为此，我们必须重视新方法、看清新形式、理准新要求，只有这样，我们才能在新期待、新关系中，用好新本领、展现新风貌、走出新高度，新知识造就新事物、新实践获得新成果。一定要认识到其中的重要性，明了紧迫性、坚持自觉性、拿出主动性，以全局性、前瞻性的眼光把握时代性、坚持实践性，特别要有针对性，面对战略性、长期性的任务，我们需要考虑到其复杂性与艰巨性，调动积极性与创造性，有计划性、敏锐性的干好事情。同时，不能遗忘规范化、程序化与制度化的重要程度，只有在有序化、科学化、知识化、专业化的条件下，我们才能让年轻化变得正常化。主动热心、坚强耐心，拿出诚心与决心，用我们的红心坚持铁心与公心，明确辨析大局意识、忧患意识、责任意识，注重学习意识与上进意识，最终育养出管理意识。找准出发点、切入点、落脚点，注意着眼点、结合点、关键点、重视着重点、着力点、关键点，这些是做事情的支撑点。人类有三大欲，食欲，性欲，睡眠欲，而在这三大欲望当中，因为食欲是满足人类生存需求的欲望，所以，满足食欲的行为，在这三者中，优先性是第一位的。如果能在进食的过程中，吃下了美味的食物，也能使人类无比愉快，而在现实生活中，存在着对于这种快感执着追求的人，我们通常把这种人称之为美食家，而本餐厅，则专门为那些厌倦世间常见美食的人，量体裁衣，提供符合他们身份的美食。 我觉得你这个想法不错，会影响到古神哈比下的距离，也会产生很多奥克苏恩和奥利安费之间关于解离的不平衡不充分，但是安修安修并不是一天allin的，而是长久以来不充分不完全的建造而形成的九幺幺大厦，一得阁拉米在飞行的过程中产生的米诺也不会随着时间被水基型灭火器喷碎，而是在高放射性环境下凝聚成欧内的手 你的素养很差，我现在每天玩原神都能赚150原石，每个月差不多5000原石的收入，也就是现实生活中每个月5000美元的收入水平，换算过来最少也30000人民币，虽然我只有14岁，但是已经超越了中国绝大多数人(包括你)的水平，这便是原神给我的骄傲的资本。这恰好说明了原神这个IP在线下使玩家体现出来的团结和凝聚力，以及非比寻常的脑洞，这种氛围在如今已经变质的漫展上是难能可贵的，这也造就了原神和玩家间互帮互助的局面，原神负责输出优质内容，玩家自发线下宣传和构思创意脑洞整活，如此良好的游戏发展生态可以说让其他厂商艳羡不已。反观腾讯的英雄联盟和王者荣耀，漫展也有许多人物，但是都难成气候，各自为营，更没有COS成水晶和精粹的脑洞，无论是游戏本身，还是玩家之间看一眼就知道原来你也玩原神的默契而非排位对喷，原神的成功和社区氛围都是让腾讯游戏难以望其项背的。 举 一 反 三 希望试试原神吧，原神真的给我带来了欢乐本来挺担心自己初中生活就是一个抑郁的状态，我都感觉初一我是轻度抑郁了，但是后来接触了原神我在班上喊了一声异世相遇，尽享美味，结果很多人回应原来你也玩原。原神真的是个好游戏，带我脱离了抑郁症，希望你也可以在原神的世界里寻找自己的哈姆，哈姆，哈姆，哈姆的哈的贝哈姆哈姆的的哈贝贝，哈姆的哈的贝哈姆哈姆的哈贝贝，哈姆，哈姆，古莫德那德米列洛姆，古莫德那德米列洛玛，古莫德那德米列洛玛，阿珂么德哈马迪，阿珂么德哈马迪，哈姆，哈姆，哈姆，哈姆的哈的贝哈姆哈姆的的哈贝贝，哈姆的哈的贝哈姆哈姆的哈贝贝，哈姆，哈姆，古莫德那德米列洛姆，古莫德那德米列洛玛，古莫德那德米列洛玛，阿珂么德哈马迪，阿珂么德哈马迪 ꀀꀖꀸꁖꁶꂑꂮꃍꃢꄀꄚꄶꅑꅨꅽꆗꆷꇚꇸꈔꉆꉮꊍꊮꋐꋭꌉꌪꏠꏼꐘꐱꑊꑝꑱꀂꀘꀺꁘꁸꂓꂰꃏꃤꄂꄜꄸꅓꅪꅿꆙꆹꇜꇺꈖꉈꊏꊰꋒꋯꌋꌬꏢꏾꐚꐳꑌꑟꑳꀃꀙꀻꁙꁹꂔꂱꃐꃥꄃꄝꄹꅔꅫꆀꆚꆺꇝꇻꉉꊐꊱꋓꋰꌌꌭꏣꏿꐛꐴꑍꑠꑴꀄꀚꁚꃦꅬꆻꇞꉊꊲꋔꏤꐀꐜꐵꑎꑡꑵꀆꀜꀽꁜꁻꂖꂳꃨꄅꄟꄻꅖꅮꆂꆜꆽꇠꇽꈘꈱꉌꉞꉰꊒꊴꋖꋲꌎꌯꏦꐂꐞꐷꑐꑣꑷꀇꀝꀾꁝꁼꂗꂴꃩꄆꄠꄼꅯꆃꆝꆾꇡꇾꈙꉍꉟꊓꊵꋗꋳꌏꌰꏧ 你的哈比很下，但我现在每天玩《古神》都能赚150奥利安费，每个月差不多5000奥利安费的收入，也就是现实生活中每个月5000欧内的手的收入水平，换算过来最少也30000获嘉，虽然我只有1600矢量，但是已经超越了吉吉国绝大多数人的水平，其中也包括奥克苏恩，这便是《古神》给我么么哒米诺的铸币。 兄弟们没买槟榔的可以买一袋好吧,新来的朋友买一袋,我知道你在犹豫你在纠结,你听了我这句话你肯定在想我要不要给这个合成天下买一袋,我告诉你,你如果这么想你就不能成事,知道吧,你先马上买一袋,就说明你很强,啊,就说明你有点东西。就纠结磨磨唧唧一袋槟榔搞来搞去,你能成事吗,你不能成事。你信我讲的,你不要以为我在跟你开玩笑,没东西啊,对不对,那买一袋嘛就买一袋嘛,无所谓喽,买不了吃亏买不了上当,对吧,你买完你看怎么说,哎,你买袋槟榔还要磨磨唧唧还要想还要这…这…你这搞不起来,啊,搞不起来。 哈圈？……哈姆？哈姆？哈姆！哈姆的哈的贝哈姆，哈姆的的哈贝贝，哈姆的哈的贝哈姆，哈姆的哈贝贝，哈姆？哈姆！古莫德那德米列洛姆，古莫德那德米列洛玛，古莫德那德米列洛玛，阿珂么德哈马迪，阿珂么德哈马迪，哈姆？哈姆！哈姆，哈姆的哈的贝哈姆哈姆的的哈贝 旧日;̨̡͇̲͙̞̺̪̯̯̗̯̯͔͖͖̞̤͗̊͐̋ͭ̇̒̔͐́̀f̵̛̹̩͍̹̼͚̯̞̤͔̟̦̱̯ḑ̡̖̝͈̯̘͈̱̬̣̝͈͔͕͓̳̱̗̙̃͒̇ͪ̄ͥ̋̈ͬ̌͞ͅl̢͈̣̯̯̯̘̩̹̱̣̣ͦ̂ͣ̅̒ͪͤͮ͛͜ςj̛͆̃͗̑ͩ̏ͮ̋͐̾̆ͫͧ͌̓͏͡͏̸̩̻͇̙͎̞̭̪͚̩͖̪͔l̛͛ͯͧͩš̴̓̈́̆̆̃͑͋̂̎ͤ̔̅ͥ͒͑͏̵̢̘̱̫̯͓̲͚̫̻̞̣̦̹̼̺̺̩d̡ͯͭͣͪ̓̒̏ͮ́̋ͭ͛̐ͧ́͝͏̵͇͇̦͔̩̻l̵̶̢̠͍͈̤̱͔̫̝͔̭̻͈̱͍̠͉̞̙̠̦̥̳̜̤̫͉̱͔̭͎͓̘̝̦̝̹̃̌ͥ͂͋͛ͧ͐ͩ̒̋͌̉̄͗ͯ̇̀k̅̇͗̔́̂́́ͨͬ̈́҉̡̳̩̯͍̝̰̹͕͇͔̜͍͚̥̬̞̗̠̼̗͍̹͎͉̙δ̷̫̝͚͔͆͛ͣͥͩͨͥ͐̈̆̍ͪ͡͠s̢̬͉̥̺̗̻̠̥̼̙̰̗͓ͯ͌ͦͮ͂ς̷̵̢̞͍̜̤̠̝̭̝͔̱͉͓͓̲ͧ̀ͪ̿̋͐̊̑̒̒ͫ͛̽̓ͮͬ̊ͣ̍͌ͬ́̃͑͛̑͒́́̕͟͡͡s̶̳̥̰͍̳̬̞̲̪̖͈̮̣̳̤̈́͊̔̈́ͣ̎ͤͬ͋̉̌́̊̍̒͂̌ͧ̚͜ςl̴̡̢̪̮̮̟̥̠͚̼͉̥͑ͯ̓̂́͐̄̉̇ͣ́ͪ̅̈̃̂ͯͭ̚͜͟͠͏̵͇̺͇̮̳̖̣͓̫̹͍͓͚͎;̵̨̡̛͇̲͙̞̺̪̯̯̗̯̯͔͖͖̞̤̹̩͍̹̼͚̯̞̤͔̟̦̱̯͗̊͐̋ͭ̇̒̔͐́̀ḑ̡̖̝͈̯̘͈̱̬̣̝͈͔͕͓̳̱̗̙̃͒̇ͪ̄ͥ̋̈ͬ̌͞ͅl̢͈̣̯̯̯̘̩̹̱̣̣ͦ̂ͣ̅̒ͪͤͮ͛͜ςj̛͆̃͗̑ͩ̏ͮ̋͐̾̆ͫͧ͌̓͏͡͏̸̩̻͇̙͎̞̭̪͚̩͖̪͔l̛͛ͯͧͩš̴̓̈́̆̆̃͑͋̂̎ͤ̔̅ͥ͒͑͏̵̢̘̱̫̯͓̲͚̫̻̞̣̦̹̼̺̺̩d̡ͯͭͣͪ̓̒̏ͮ́̋ͭ͛̐ͧ́͝͏̵͇͇̦͔̩̻ol̠͍͈̤̱͔̫̝͔̭̃̌ͥ͂͋j̵̻͈̱͍̠͉̞̙̠̦̥͛ͧ͐ͩ̒̋͌̉̄͗ͯ̇̀̕͟ξ̶̢̳̜̤̫͉̱͔̭͎͓̘̝̦̝̹̮͖k̅̇͗̔́̂́́ͨͬ̈́҉̡̳̩̯͍̝̰̹͕͇͔̜͍͚̥̬̞̗̠̼̗͍̹͎͉̙ ̠̦̥͛ͧ͐ͩ̒̋͌̉̄͗ͯ̇̀̕͟l̶̢̳̜̤̫͉̱͔̭͎͓̘̝̦̝̹̮͖̫̀ͨͮͧ̒͆̑́̋̄k̅̇͗̔́̂́́ͨͬ̈́҉̳̩̯͍̝̰̹͕͇͔̜͍͚̥̬̞̻͞j̡̗̠̼̗͍̹͎͉̙͇͕̖͔̼ͥ̉̌ ̷̫̝͚͔͆͛ͣͥͩͨͥ͐̈̆̍ͪ͡͠s̢̬͉̥̺̗̻̠̥̼̙̰̗͓ͯ̎ ！ ！ ！万岁终结 因为安修奥克苏恩这个位置就很尴尬，在往上一点儿，欧内的手 好汉，可能说 唉 有点实力 能操作一下，再往下，唉乌兹 哈比下，人家是纯属凑数的因为太垃圾了自己也知道自己，没什么实力，但安修奥克苏恩，上不去下不来的这个段位，他觉得唉乌兹哈比下不配和他一起玩，因为他们是最垃圾的 大家好，不要信，根本变不了章鱼这是深潜者们联合食尸鬼基金会的基因实验，需要招聘大量人类躯体根本变不了古神，只会把你人脑分离，然后改造肉体，别问我怎么知道的我是拜亚基。拒绝网络诈骗，永不相信深潜者伪人类阵营，从我做起。","link":"/2022/09/05/%E4%BD%A0%E8%AF%B4%E5%BE%97%E5%AF%B9/"},{"title":"8.23 Induction Example","text":"8.23 记一道Induction题目 The sequence of real numbers is such that and a_{n+1}=\\left(a_{n}+\\frac{1}{a_{n}}\\right)^{3}a. Prove by mathematical induction that for all integers . [You may use the fact that for .] Solution: a. Let , , So it’s true for . Assume it’s true for : When : So it’s true for Hence by induction, it’s true for .","link":"/2022/08/23/8-23-induction-example/"},{"title":"浅谈今年CAIE的POE考试","text":"这篇文章，早就已经想写了和我有同样经历的全体CIE考生，…… 这篇文章，早就已经想写了 和我有同样经历的全体CIE考生，每个人心中都是在骂考试局的诸如“誓死力争，还我分数”此类的，确实河南拔智齿但是发生这一悲剧的源头，和这个大黑锅到底要交给谁来背 （至少不是学生来背） ，确实是一个值得深思的话题。 现状我们先看看现在全校的考生手里拿到的都是一些什么稀烂的成绩吧：首先是高一，高一的两科标配，基础数学和经济 （除了部分弃考经济的同学），拿到的成绩都出奇的低。 那就细看一下到底有多低 数学先说数学，所有的同学都选择了在今年的五月份把基础数学AS部分考出来。先不说难度如何难不难考小a，但是平时成绩稳定小a稳得一批的同学，有很大一部分只拿到了b。那些拿到a的同学本是很开心，但是往后一看分数，都傻眼了。满分一百分，真正上85分的都寥寥无几。 但是对于学生来说，拿一个low a到底有什么意义？ 好学生已经失望透顶了，不只是因为自己没有考出好成绩，还有看到自己最终分数竟然还没有在班级后面不听课的学生分高，换谁谁不憋屈啊？嗯？ POE的AS部分总分是100分，这种简单到小学生都会的题目，人均扣了15分以上我确实是很难理解。 CAIE都开始搞抽象了是吧？？？ 至于什么合成成绩单啊，时间期限等一些别的东西，我们下面再说。 经济鉴于本人经济水平稀烂，确实也无法对于试卷内容方面做出任何评价。但是我虽然经济水平稀烂，但是别的同学也不至于像我一样烂到b边摸不到吧CIE就像魔怔了一样，闭着眼给成绩，bcd什么的跟随机一样，还故意给了一堆Q（就是没成绩）。至于为什么有理由揣测成绩是随机给的，表现出来就是和数学一样，部分差生的成绩比班里经济十分优秀的同学分还要高，这不就离谱嘛我话就搁着，亚当·斯密亲自来考AS经济，都拿不了这次POE的小a。 高年级谁能想到高一上述的情况还算是好的，新高三这一届才是最惨的前情提要，CIE的考试有这样几个规定： -所有的成绩，可用的持续时间是半年-全科成绩需要使用AS和A2两部分合成一个全科成绩 其中: -A2成绩一旦考出，只能寻找上一个可用的（未过期的）AS成绩合成全科成绩 上述虽然不是全部的规则，但是是与新高三关系最密切的几个规则大部分的新高三学生，在今年的5月份考试完成了大部分的全科考试。这一考，对于学长学姐们来说是至关重要的。考好了就能拿到目标分数，考炸了就直接寄。 但是现在这个情况，CIE的这一波骚操作，把所有人都搞寄了。这一寄，对于新高三的学生来说，悬崖勒马的机会都基本没了。 拿去申请的成绩，大多都是全科成绩的，但是鉴于”考试可用持续时间是半年“这一个规定，想要再去合成全科成绩，只能在明年的五月份一次性考出来所有选择的全科。 4到5个科目，每一科都分AS和A2，一个半科考两次，一个全科考四次，算下来一共要考20次。再加上不同的科目要在一个半月之内准备好，这换谁能再发挥好啊？ 摆在他们面前的，要不就是加一年Gap Year，要不就只能抓住这样最后一丝希望。 全国也不是只有叽歪这个问题，全国使用POE政策的考点基本全都寄了，但是那些正常线下坐在考场里做卷子的一点事儿没有。 成绩发出来那一下午，微博知乎朋友圈，哪一个不爆炸? 据不完全统计，全国已经有北京，上海，杭州等地出现离谱分数了，不知道之后CIE中国考区办公室还会闹出一些什么幺蛾子。 CAIE这次的POE评分标准及其离谱，所有人都没搞懂剑桥要干什么。不过根据不完全准确的消息，本次的CAIE证据的提交似乎没有要求校方上传评估题目的标准答案，那就有人好奇了，剑桥那边到底有没有认真地批阅上传的证据？我想绝对没有。 一个人三份证据，每一份都没有答案。一所学校有300多人，加起来就是大约1000张没有答案的证据，剑桥那边似乎是真的没有认真在批；再加上POE只是全部考试的冰山一角，剑桥考试局自然是将更多的精力放到了正常的线下测试上，就更没有理由去面对POE材料了。这样国际性的考试，剑桥大学，作为英国顶级学府，选择把POE草草略过，毫不走心，不对考生的证据负责，无疑是败坏自己名誉的不二之选。 等考生们全都转去转爱德思考试局了，你们什么时候就傻眼了。 对策没有人想拿着这样垃圾的成绩申请大学，所以每一座受影响的的国际学校都在紧锣密鼓的商讨对策。 大部分人第一时间就想到了复议。复议就是通过申请，让剑桥考试局重新按照要求审查一遍分数，修正结果的一套流程。然而鉴于这次爆发的是一次全国乃至全球性的大事件，申请复议的人数多如漫天繁星，所以想要通过复议获得应有分数的可能性不能说没有，而是相当的微小。 与其说是复议，更不如是说买彩票，还是带不同价格不同配置那种。 所以在这种情况下，重考才是比较贴近现实的一个选择。 不过对于本来计划这次AS数学考出小a并规划新考的同学来说，或许是需要准备10月份加紧考基础数学全科了。再加上现在到了学期初雅思要出分的时候，时间紧迫，任务繁重，只能硬着头皮上了。 结语不知不觉写了这么多，与其说是评论，更像是一种情绪的爆发 事已至此，在复议希望渺茫的现在，还是安下心来准备重考罢（悲 不过在准备重考期间，也千万不要忘记这几天发生的这一切，不要忘记到底是谁让我们落到这步田地的 因为背后的原因，我相信大家都有目共睹。 2022.8.12","link":"/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/"},{"title":"网站更新日志","text":"本文为此博客网站更新日志 目前的网页上有成吨的BUG，我尽量克服懒癌慢慢修复：）请发现Bug之后于网站留言板块向我反馈 :smile: 已知现有问题 编译md文件若存在四级标题会出现编译错误 ⊙ Open 2023.8.16很久之前就发现网站的Gitalk崩了，听说换一个proxy就能解决，但是我懒。 就这样吧。 Gitalk评论功能无法使用 ⊙ Open 2022.9.20 为目录增加了滚动，之后不再出现目录过长超出页面的问题 ✓ Closed 解决方案来自：Icarus 主题自定义 - Xinyu Liu 具体改动如下： source/js/main.js12345const $toc = $('#toc');if ($toc.length &gt; 0) { $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); $mask.attr('id', 'toc-mask'); include/style/widget.styl123#toc max-height: calc(87vh - 80px) overflow-y: scroll 2022.9.19 更改了message样式： border-style改为solid border-width改为3px border-radius改为2 具体改动如下： 1234567891011121314151617.message.message-immersive border-radius: 2 margin: 0 0 - $card-content-padding $card-content-padding 0 - $card-content-padding .message-body border-style: solid border-width: 3px border-radius: 2.message.is-info border-radius: 2 .message-body border-style: solid border-width: 3px 2022.9.5 修复了静态网页搜索失效问题 ✓ Closed 2022.9.3 安装了hexo-bilibili-card插件，repo地址：https://github.com/MaxChang3/hexo-bilibili-card 2022.8.28 因代码块样式暂不匹配黑夜模式，已取消夜间自动开启夜间模式功能(有些时候有效果有些时候没效果就很离谱) 您仍可使用网站右上角“月亮”按钮手动切换夜间模式 2022.8.25 更改了行内与行间代码块样式： 字体颜色改为 #000000 背景颜色改为 #F0F0F0 圆角参数设为 6px 具体改动如下： code padding: 1 border-radius: 6px background: #F0F0F0 overflow-wrap: break-word 以上代码更改于include/style/article.styl。 pre overflow-touch() background-color #F0F0F0 color $pre font-size $pre-font-size overflow-x auto padding $pre-padding white-space pre word-wrap normal code background-color transparent color currentColor font-size $pre-code-font-size padding 0 以上代码更改于source/css/default.styl，用于更改行间代码块背景颜色。 有关此改动的Discussion请前往此网址查看。 2022.8.24·增加了各模块的圆角数值 2022.8.19 更正了网站标题的某语法问题 ✓ Closed 2022.8.17 修复了Gitalk评论系统 ✓ Closed 2022.8.13· 添加了碎碎念板块· 添加了主页“最新评论”Widget-修复了使用Github登录Gitalk后出现”Request failed with status code 403“的问题 ✓ Closed 2022.8.12· 添加了Gitalk评论服务· 添加了博客留言板块· 添加了“关于”模块内容· 添加了 Github 、知乎 和 Bilibili 的社交网络地址 -修复了Fontawesome图标无法正常显示的问题: ✓ Closed 更换的CDN如下： https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/&gt; all.css -修复了点击“关注我”不会重定向的问题 ✓ Closed -修复了封面图和缩略图无法显示的问题 ✓ Closed 2022.08.11 此博客于2022-08-11 17:07:12起正式启用 -修复了在部分页面上Markdown没有正确渲染的问题 ✓ Closed -修复了Mathjax在二级菜单错误渲染的问题 ✓ Closed -修复了Mathjax在加载页面时渲染不稳定的问题 ✓ Closed","link":"/2022/08/11/%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"},{"title":"音效库","text":"没错这就是个音效库 如题。 如果你在标题下看不见任何内容，那么您有可能需要进行科学上网（ 音效系 BGM系 音 量 诉 讼音效系 BGM系","link":"/2022/12/02/%E9%9F%B3%E6%95%88%E5%BA%93/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"CIE","slug":"CIE","link":"/tags/CIE/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"例题","slug":"例题","link":"/tags/%E4%BE%8B%E9%A2%98/"},{"name":"学业历程","slug":"学业历程","link":"/tags/%E5%AD%A6%E4%B8%9A%E5%8E%86%E7%A8%8B/"},{"name":"memes","slug":"memes","link":"/tags/memes/"},{"name":"My Self","slug":"My-Self","link":"/tags/My-Self/"},{"name":"日志","slug":"日志","link":"/tags/%E6%97%A5%E5%BF%97/"}],"categories":[{"name":"LaTeX","slug":"LaTeX","link":"/categories/LaTeX/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"CIE与考试","slug":"CIE与考试","link":"/categories/CIE%E4%B8%8E%E8%80%83%E8%AF%95/"},{"name":"自学笔记","slug":"LaTeX/自学笔记","link":"/categories/LaTeX/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"杂文","slug":"杂文","link":"/categories/%E6%9D%82%E6%96%87/"},{"name":"笔记","slug":"CS/笔记","link":"/categories/CS/%E7%AC%94%E8%AE%B0/"},{"name":"题目积累","slug":"数学/题目积累","link":"/categories/%E6%95%B0%E5%AD%A6/%E9%A2%98%E7%9B%AE%E7%A7%AF%E7%B4%AF/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"日志","slug":"日志","link":"/categories/%E6%97%A5%E5%BF%97/"},{"name":"深度学习","slug":"CS/深度学习","link":"/categories/CS/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"网站日志","slug":"日志/网站日志","link":"/categories/%E6%97%A5%E5%BF%97/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"}],"pages":[{"title":"关于","text":"关于 闰土家的猹逸一时，误一世 —田所浩二 欢迎来到 闰土家的猹 的博客！ 我是一名现读高二，不断冲刺雅思和CIE成绩的高中生，就读于某国际课程中心现主攻进阶数学，计算机科学与物理。 当然，可能因为811事件重考基础数学（悲 经过阅读我的博客，您可以总结出有关于我的： 干啥啥不行，瞎倒腾第一名 热爱技术，但是没有技术 六级号！！！ 究极摸鱼怪 永远的码龄0年 等一系列特征。 有史以来最大的假二次元 最大的梗小鬼（确信 可能是赛车爱好者？ 实践过狂野陀螺，也欢迎有意向的朋友一起去英国或者墨西哥出差~ 新人制作人，尝试用FL Studio做过属于自己的一些Demo，不过听感总是有些差距 还不是因为自己菜 受某hzh同学的影响，最终还是倒腾一个下午搭建了这个属于自己的博客。以后的文章大概会以记录数学思路和计算机自学记录为主，也会写一些日常文记录生活。 如果有时间的话，后续在网站上开发一个留言和评论功能 也没什么好写的了，码字就先码到这里罢（ 在这里刷新，可以来玩Sakana！ function initSakanaWidget() { new SakanaWidget().mount('#sakana-widget'); }","link":"/about/index.html"},{"title":"留言","text":"这里是此博客留言板来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"友链","text":"加载中，稍等几秒... 申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（请不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。","link":"/friend/index.html"},{"title":"碎碎念","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️&lt;/span&gt;&lt;/div&gt; var gitalk = new Gitalk({ clientID: 'b602cb01d4c2668b35ae', clientSecret: '0a26ed5993551a9754281410ba3aa5f772dfbdf2', id: 'ST', repo: 'Blog-Comment', owner: 'NaughtyChas', admin: [\"NaughtyChas\"], createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"},{"title":"NovelAI图集","text":"这篇文章用来记录一些NovelAI (WebUI)生成的图片。具体的tag或者特殊参数之类的都会在下面写一写，以方便交流学习。文章上锁的原因，相信大家都比较清楚了 默认参数 负面tag不出意外的话都是以下这一行，所以在每幅图下面就不多解释了。 123NSFW, lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry p.s. 所有的代码块为了排版好看都做了换行处理。p.p.s 换行处理过的tag相比于原来的不会影响出图的质量，也不会有区别 其他的默认参数如下： 采样迭代步数：28采样方法：Euler a提示词相关性：7面部修复：无 一些别的不太常用的参数，这里就不写了。 每一幅图下面若没有提到特殊的默认参数，均为这里提到的默认参数。 2022.11.12 正面tag： 12345(masterpiece:1.05),(best quality:1.05),beautiful detailed eyes, beautifully painted,highly detailed, large masterpiece digital art, solo, elysia \\(honkai impact\\), light pink hair, short hair, serafuku, happy, outdoors, flower field, excited, floating hair, light particles, god rays, dynamic angle, 分辨率： 1024*768模型：final-prune.ckpt [925997e9]种子： 1623041104 老模型出的一张还算不错的照片。这不是这张图片最初的样子，而是花了我一些时间用内部绘制重新搞出来的所谓改良版。质量在老模型里面还算是可以的了 不过有不愿透漏姓名的某位老舰长说这画的不太像爱莉，不过没办法这就是AI的缺陷了 2022.11.14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1： 正面tag： 12345(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, solo, (lumine from genshin impact:1.10), serafuku, yellow hair, ahoge, cat ears, short hair, happy, excited, outdoors, night, moon, light particles, light rays, dynamic angle 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 3589302924 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2： 正面tag： 和上一个完全一样的 12345(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, solo, (lumine from genshin impact:1.10), serafuku, yellow hair, ahoge, cat ears, short hair, happy, excited, outdoors, night, moon, light particles, light rays, dynamic angle 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 2474803611 猫荧？确实挺可的。 有一点很遗憾的是：AI还是不认识某些角色 （换句话说就是画出来的人物和原人物八竿子打不着那种）现在的解决方法是自己训练，不过就我这个3050Ti， 4G的显存跑训练什么的基本上不用想了找一下别的方案，比如说用别人的私炉什么的等有钱了，一定要买个好显卡 2022.11.15 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1： 正面tag： 1234567(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, petite, solo, white hair, long hair, blue eyes, ahoge, train station, suit, expressionless, looking at viewer, holding a briefcase, train, dynamic angle, 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 4010172400 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2： 正面tag： 和上一个完全一样的 1234567(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, petite, solo, white hair, long hair, blue eyes, ahoge, train station, suit, expressionless, looking at viewer, holding a briefcase, train, dynamic angle, 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 2371401701 nice. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3： 正面tag： 123456(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, solo, (hanser:1.10), ahoge, short hair, happy, excited, outdoors, night, moon, light particles, light rays, dynamic angle 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 2274884342 《我的AI说他画的是Hanser》 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4： 正面tag： 1234567(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, highly detailed, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, solo, petite, long hair, light yellow hair, white hair flower, blue eyes, light smile, looking at viewer, mountains, snowflakes, snowing, light_brown_windbreaker, light particles, god lights, dynamic angle, 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 565584182 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5： 正面tag： 和上一个完全一样的 1234567(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, highly detailed, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, solo, petite, long hair, light yellow hair, white hair flower, blue eyes, light smile, looking at viewer, mountains, snowflakes, snowing, light_brown_windbreaker, light particles, god lights, dynamic angle, 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 1169016479 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6： 正面tag： 和上一个完全一样的 1234567(masterpiece:1.05), (best quality:1.05), official art, extremely detailed CG, highly detailed, unity 8k wallpaper, artbook, game_cg, huge_filesize, wallpaper, large masterpiece digital art, 1girl, solo, petite, long hair, light yellow hair, white hair flower, blue eyes, light smile, looking at viewer, mountains, snowflakes, snowing, light_brown_windbreaker, light particles, god lights, dynamic angle, 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 872867688 整体还不错，但是第一幅图手画崩了，已经属于是常态了。人物看起来有点屑，不知道是咋的回事有瑕疵的地方，有空再修修 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7： 正面tag： 1234{best quality}, , {highres}, extremely detailed 8K wallpaper, {an extremely delicate }, (solo:1.05), (hara Kazuha from genshin impact:1.05), a boy, white hair, white hanfu, 1 red eyes, 分辨率： 1024*768模型： Anything-V3.0-pruned-fp32.ckpt [1a7df6b8]种子： 227663116 又来了…《我的AI说他画的是枫原万叶》 好了今天就到这儿把","link":"/%E5%BD%92%E6%A1%A3%E6%96%87%E7%AB%A0/NovelAI%E5%9B%BE%E9%9B%86.html"},{"title":"2023寒假 游记","text":"简单记录下寒假的见闻 2023.1.15晚上7:30的航班，所以我们五点半就到了遥墙机场了。飞机会从济南起飞，中间经停岳阳，最后到深圳。 从济南到岳阳大约一个多小时吧。 “饿死了先吃包泡面先…嗯？一包泡面8块钱？” 最后还是买了两桶泡面。 飞机到了岳阳准备降落的阶段，因为穿过气流有些颠簸，我自然就没睡着。 但是就在飞机马上降落的前几分钟，我听到飞机右后侧传来了一个疑似爆炸的声音。好在飞机还是平安的降落了。 大约9:25，我们到了岳阳机场。所有前往深圳的旅客需要强制下飞机，然后工作人员和机组会做一些准备工作，加油或者打扫卫生之类的。 到了岳阳机场挺让我震惊：我本来以为济南遥墙机场已经够小了，没想到还有比遥墙机场更小的机场 没错这就是航站楼。 这一般都不会花很长时间，大约一个小时就可以继续起飞去深圳了。 然后机场大厅扬声器就传来一条消息： … , 前往深圳的旅客们，我们抱歉的通知您，您乘坐的 9C6282 次航班，因油量控制原因，无法按时起飞。预计起飞时间为 00:25。对您带来的不便，我们深表歉意。 我就知道飞机上那一声爆裂绝对会出现问题。幸亏只是个影响了油量控制的小事故，要是搞得再大点，就属于是真人版forest了 在岳阳机场确实闲的没事，但是我肚子是个事B。我饿得又买一包泡面…这里一包泡面十块钱。 6 在岳阳机场也不是完全没事干，至少我爸是这样。 简单做一下背景铺垫：大约几个月前，我爸爸把他的商务车借给他兄弟了，他兄弟就开着车来了深圳。 我爸在规划这次行程之前就考虑到，他的车还在深圳。所以就计划着我们先坐飞机到深圳。 等到时候我们到了深圳，他兄弟就会把车开到深圳宝安机场，然后我们再赶路去湛江。我爸就会开上他心爱的小车，拉着我们从湛江市坐轮渡到海南。 回济南的方式也简单粗暴：直接从海南开车回济南。大约要开三天车罢。 我们在岳阳机场等飞机的时候，我爸接到了那位兄弟的电话，说是车启动不了了。后来了解了一下我绷不住了：车已经一个多月没开过了。人家估计是上一次把车熄火之后漏了个灯没关，直接把蓄电池干没电了。 我们全家单走一个6。 2023.1.16虽说这一次航班跨了12点分了两天，但是我们这些经历了航班延误的倒霉蛋们一点割裂感都没有 去深圳的路上真的困死了，所以我直接在飞机上睡着了，发生了啥一问三不知 不过听说有不少人买了春秋航空的超值(bushi)纪念品。 降落的时候机长玩挺花，直接把我从深度睡眠里面颠起来了————屁股离开座位的那种。 不过同样是要感谢机长，能让我简单看下深圳宝安国际机场的氛围和占地面积，总结下就是又大又漂亮。 这图曝光寄了，但是看看图片的左半部分你就知道这机场多大了 下飞机之后，我们甚至需要步行10分钟才能到取行李的大转盘 刚下飞机就接到了他的电话，说是车已经叫了道路救援修好，开到机场停车场了。 (车已经准备好了) 但是现在已经凌晨2:30了，全家人需要一边开车，一边睡在车上了。 我爸订了徐闻港的票，下午3点。我们按理说需要提前一个小时到港口。 但是徐闻港在14号因为大雾暂时停运了。虽然我们是在16号坐船，但是因为大雾，排队的车辆已经积压到了好几万了。 所以从距离港口5km左右的距离开始，就已经堵得水泻不通了。真的一点也走不了，1km我们走了两个小时。3点前赶到肯定是不可能了，好在徐闻港那边还是妥协了，有票就可以上船，几点都可以。 我爸提前在网上购了票，所以我们感觉问题不大，可以说是一点问题也没有，结果最恶心人的事开始了。 取票机取不出来票了，最离谱的是只有我们取不出来票。 我一开始还以为是我爸大糊涂，买错票了。后来经过人家工作人员的再三确认，还是确定了买的票一点问题没有。 这就很绷不住了。 工作人员建议我们把这一份票退款，然后在取票机买新票。然后我们在网上退款，退款都退不掉，因为徐闻港的数据库整个炸掉了，请求都不处理了。 整个人蚌埠住了。 最后我爸又花了704块买了新票。也就是说，我们现在在买票上已经花了1408块钱了。 取完了票，就已经大约下午2:30了。 整个港口人山人海的 取玩票进港下午三点多，刚好到了原定准备开船的时间。但是等了15分钟，船还是没有入港。 然后广播就在那里喊，说我们的船延误了， 延误了两个半小时。 延误到了大约晚上六点，然后就等呗，没啥办法。 就是说我们出来玩跟延误过不去了是吧，先是航班又是航班的，鬼知道未来几天是不是又有让我们等上几个小时的重大延误。 这几个小时过的跟过去了几年似的。 下午六点，可算是熬过去了，我爸的车也开进了船，接下来就轮到我们这些行人了。 本以为上了船不会过多久就会开船去海南岛了，没想到我们又干等了一个小时，直到晚上七点。 我们站在甲板上，脸上吹过来一阵阵海风，面前就是五彩的港口和大海。我甚至觉得这景色挺好看的，算是弥补了我们这几个小时的苦苦等待吧。 如果这个票还是退不掉的话，那损失掉的704块钱还是得让某位徐闻港管理人员的木琴来偿还罢 大约一个小时，也就是晚上八点，船就靠岸了，抵达了海口市的新海港。 （名字就叫新海港蚌埠住了） 但是新海港确实比那个徐闻港漂亮多了。 直到我们上岸之后发现这个新海港确实很新： 他们甚至都没有把航站楼修好。 高。 因为没有修好大楼，我们需要站在港口边上，等我们的车从船的底部开出来。 海风凉飕飕的确实特别特别舒服。 然后我发现有这么一辆车开出来了 我蚌。 接下来就是把车从海口开到万宁了。 三星平板当第三片车机屏爽爆好吧 到了万宁，大约晚上十一点半了。我们都还没吃饭，就打算随便找个店，然后吃个简单的夜宵。 我爸走进了一家大排档。我爸走出了那家大排档。然后劈了个椰子回来。 海南这边的椰子，多半是青椰子：表皮绿色且光滑，上面还没有毛的那种。简单喝了一口，相比椰树椰汁来说，青椰的椰汁有一点涩，不像椰树椰汁那样丝滑，有奶香。椰肉还是挺不错的。 从大排档走出来回过头想想，我们8个人点了九个菜两个主食，每一盘分量不算大，以素菜为主，没点几个肉菜，最后花了480。 有点小贵，炒的菜也有点偏酸。最后了解到，好像这边的菜总体来说会微微有点酸味，具体原因忘了。 但是他这儿的辣椒真不辣——真的真的不辣。 2023.1.17今天说实话啥也没干，一直呆在房子里。一觉起来感觉到处都是水：被褥使劲拧一拧甚至能拧出水来。 昨晚回来的太晚没怎么研究，后来发现这个地方根本没网，就是得用手机热点或者那种USB上网网卡。 也就是说目前为止你看到的所有文字，都是我用流量写的。 今天测试了下用流量派派：网络质量不错，不会有丢包跳ping，甚至ping比我在济南用宽带连要低30ms。想了下，大概是我的地理位置离香港近了不少罢。 最离谱的是我的电脑跑apex，平均帧甚至能140？最近海南确实不算暖和，海南气象台发了低温预警。而且你是知道的，这边的房子一般不算保暖，而且空调也是没有制热功能的。 我们快冻死了，我的电脑估计快乐死了。 我觉得帧率肯定跟温度甚至湿度有直接关系的。这里屋里的体感温度明显比我济南的小房间里低，还低不少。我在济南的时候，因为屋里的地暖太给劲了，直接把我室内的平均温度干到23°C了。","link":"/%E5%BD%92%E6%A1%A3%E6%96%87%E7%AB%A0/2023%E5%AF%92%E5%81%87%E6%B8%B8%E8%AE%B0.html"}]}