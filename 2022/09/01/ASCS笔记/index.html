<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>ASCS笔记 - ntcs&#039; blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ntcs&#039; blog"><meta name="msapplication-TileImage" content="img/icon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ntcs&#039; blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="CS课堂笔记"><meta property="og:type" content="article"><meta property="og:title" content="ASCS笔记"><meta property="og:url" content="http://naughtychas.github.io/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="ntcs&#039; blog"><meta property="og:description" content="CS课堂笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><meta property="article:published_time" content="2022-09-01T13:33:28.000Z"><meta property="article:modified_time" content="2024-05-14T13:01:21.570Z"><meta property="article:author" content="MXK"><meta property="article:tag" content="CIE"><meta property="article:tag" content="笔记"><meta property="article:tag" content="计算机"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naughtychas.github.io/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/"},"headline":"ntcs' blog","image":["http://naughtychas.github.io/%5Cthumbnails%5CCS.jpg"],"datePublished":"2022-09-01T13:33:28.000Z","dateModified":"2024-05-14T13:01:21.570Z","author":{"@type":"Person","name":"MXK"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"CS课堂笔记"}</script><link rel="canonical" href="http://naughtychas.github.io/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/icon.ico"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.2/css/&gt; all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="ntcs' blog" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/thumbnails/CS.jpg" alt="ASCS笔记"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-09-01  <a class="commentCountImg" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">cd3959d276fa3caf2a7f842749b93dc0</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="cd3959d276fa3caf2a7f842749b93dc0">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>9 小时  <i class="fas fa-pencil-alt"> </i>84.6 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">ASCS笔记</h1><div class="content"><blockquote>
<p>CS课堂笔记<br><span id="more"></span></p>
</blockquote>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h1><p>鉴于本人初入CS，加上这篇笔记是课上笔记，本文以下所有内容<strong>不保证完全正确</strong>，<strong>不保证覆盖所有课本内容</strong>。<br>本文顺序以课上老师的授课顺序为主。<br>我写下本文，为的是帮助自己更好地学习CS这门科目，因此，希望路过的大佬轻喷。<br>同时欢迎有需求的读者交流学习。  </p>
<hr>
<p>本笔记内容基于《Computer Science for Cambridge International AS &amp; A Level》，剑桥大学出版社出版，教材为第二版，A-Level课程编号为<code>9618</code>。  </p>
<hr>
<h1 id="PART-ONE：理论基础"><a href="#PART-ONE：理论基础" class="headerlink" title="PART ONE：理论基础"></a><strong>PART ONE：理论基础</strong></h1><h1 id="第一章：数据的表示"><a href="#第一章：数据的表示" class="headerlink" title="第一章：数据的表示"></a><strong>第一章：数据的表示</strong></h1><h2 id="数字的内部编码"><a href="#数字的内部编码" class="headerlink" title="数字的内部编码"></a><strong>数字的内部编码</strong></h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a><strong>编码</strong></h3><p>本章中的讨论仅涉及整数值的编码。在之后的第16章会涉及到非整数值的编码。  </p>
<p>计算机出于多种目的会存储各种整数值。有时候会存储一个简单的整数，但要突出这是一个正数。<br>在这种情况下，<code>Signed integer</code>会被应用。<br>一个<code>Signed integer</code>由一段包含值的二进制编码和额外的一位用于定义符号，而这种表示方式被我们叫做<code>Sign and Magnitude representation</code>。</p>
<p>从硬件上设计计算机，存在<code>Sign&amp;Magnitude</code>信号，用于记录和计算浮点信息。  </p>
<p><code>Sign&amp;Magnitude</code>中存在<code>One's Complement</code>和<code>Two's Complement</code>。<br><code>Two's Complement</code>比<code>One's Complement</code>的优点在于更容易计算，因此我们使用<code>Two's Complement</code>在计算机内计算。  </p>
<hr>
<h3 id="有关减法"><a href="#有关减法" class="headerlink" title="有关减法"></a><strong>有关减法</strong></h3><p>计算机为避免过度的运算，所以处理数据只做加法。但是计算机还是需要去做减法，我们这里就用到了<code>Two's Complement</code>二次补码。  </p>
<h3 id="Two’s-Complement"><a href="#Two’s-Complement" class="headerlink" title="Two’s Complement"></a><strong>Two’s Complement</strong></h3><p><code>Two's Complement</code>叫做二次补码，计算机可以用它来计算减法。<br>更多相关内容可参考<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1719849343054359798&amp;wfr=spider&amp;for=pc">本文</a>。  </p>
<hr>
<p>接下来举个做减法的例子：  </p>
<p>比如说 23-35</p>
<p>0 1 0 1 1 1 - 0 1 0 0 0 1 1</p>
<p>最高位是代表一个正数，所以加几个 leading zero数字大小都不变。（<del>前提是在前面加的是0不是1</del>）</p>
<p>现在变成 23+(-35)，就要将正 35 变成-35，使用 <code>Two's Complement</code>作变换，转换为二次补码。</p>
<ol>
<li>首先，将<code>0 1 0 0 0 1 1</code>的每一位取反,变成<code>1 0 1 1 1 0 0</code>  </li>
<li>然后，在<code>1 0 1 1 1 0 0</code>的后面追加一位 1，变成<code>1 0 1 1 1 0 1</code>，即为35的二次补码</li>
</ol>
<p>现在，直接令 23 加上 35 的 <code>Two's Complement</code>“<code>1 0 1 1 1 0 1</code> “即可算出 23-35。<br>位数不够可以在一开始多添几个 leading zero，使得每一位对齐。<br>这一举动不会影响到数据的大小。</p>
<p>   0 0 1 0 1 1 1<br>+ 1 0 1 1 1 0 1<br>----------------------<br>   1 1 1 0 1 0 0</p>
<p>现在，我们需要对于计算的结果再进行一次<code>Two's Complement</code>即可转换得到最后的计算答案。</p>
<p><code>1 1 1 0 1 0 0</code>-&gt; <code>0 0 0 1 0 1 1</code>-&gt; (+1) <code>0 0 0 1 1 0 0</code></p>
<p>至此，<code>0 0 0 1 1 0 0</code>（12）就是取模后的大小了。注意，<strong>这里是大小</strong>。</p>
<p>我们还知道，第一次计算后得出的<code>1 1 1 0 1 0 0</code>，首位是 1，代表这是一个负数。 因此，原来的符号信息加上转换后的模便是最后答案(-12)。  </p>
<hr>
<h3 id="有关数据溢出"><a href="#有关数据溢出" class="headerlink" title="有关数据溢出"></a><strong>有关数据溢出</strong></h3><p>当然，数据溢出的可能性还是存在的：</p>
<p>假如说你的计算机声明的变量只有到八位。第一位是符号位，所以最大可以代表 255。<br>比如说 200+100，结果是 300，但是因为进位超出了计算机变量能存储的范围，部分进位信息因此丢失导致数据溢出。  </p>
<hr>
<h3 id="单位转换"><a href="#单位转换" class="headerlink" title="单位转换"></a><strong>单位转换</strong></h3><p>数据的单位换算总体来讲比较简单。<br>有一道例题是这样的：  </p>
<blockquote>
<p>假如在一次数据传输中，获得了2000000bit，需要存储为一个file。<br>  请问该file的大小有多大？</p>
</blockquote>
<p>首先让2000000/8，得到有多少个Byte。<br>如果转换成KiB，需要2000000/8/<strong>1024</strong>，得到KiB。<br>这里算出来是244.140625KiB。<br>在KiB,MiB等单位内选择一个合适的单位。要求数字不要太大，也不需要太多的小数位。  </p>
<p>如果要转换为KB，需要2000000/8/<strong>1000</strong>，得到KB。<br>这里算出来是250KB。<br>在KB,MB等单位内选择一个合适的单位。同样要求数字不要太大，也不需要太多的小数位。  </p>
<hr>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a><strong>字符集</strong></h2><h3 id="BCD"><a href="#BCD" class="headerlink" title="BCD"></a><strong>BCD</strong></h3><p>BCD按照二进制格式来对十进制数字进行编码。<br>每个BCD的值都是一个无符号的8位整数，值的范围从0到9。  </p>
<p>BCD码可以很大程度上简化那些使用十进制设备的数据处理。<br>比如必须向人显示数字的设备，如时钟和计时器。  </p>
<p>一个字节里面只有一个BCD：<code>00001000</code>，<code>00000101</code>，<code>00000000</code>，<code>00000011</code><br>BCD封装后，一个字节里面可以有两个BCD：<code>10000101</code>，<code>00000011</code></p>
<h3 id="ASCII-Code"><a href="#ASCII-Code" class="headerlink" title="ASCII Code"></a><strong>ASCII Code</strong></h3><p>小写字母的ASCII号比大写字母的要大。  </p>
<p>我们可以按住alt键，然后同时在小键盘上打出ASCII码。这样可以以ASCII的方式输出。记得把Numlock打开  </p>
<p>在考试的时候，会提供ASCII码表。  </p>
<p>ASCII码有两种：<strong>ASCII</strong>和<strong>Extended ASCII</strong>。  </p>
<p>普通的ASCII使用字节中的前七位来表示字符，因此这样的ASCII能表示的字符数就有2<sup>7</sup>个（128个字符）。<br>但是Extended ASCII使用所有的八位来表示字符，因此这样的ASCII能表示的字符数就有2<sup>8</sup> （256个字符）。  </p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h3><p>万国码有一百七十多万个文字空间，同时用两个字节代表一个文字符号。世界上所有的Symbol等都可以放在Unicode里。  </p>
<p>Unicode使用<strong>两个字节</strong>储存一个字符。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><strong>UTF-8</strong></h3><p>不过大多欧美国家使用Unicode有点吃亏，因为他们只用其中一个Nibble就可以胜任日常使用了。<br>因此就诞生了一种新的字符集叫做UTF-8。</p>
<p>一个Byte之中第一个Nibble一般是占满的，<br>比如<code>0???????</code>或者<code>10??????</code>，前面的几位数字用来告诉接收端如何分组字节。    </p>
<p>虽说把UTF-8放在了字符集这里面，但是需要注意的是：<strong>UTF-8不是字符集</strong>。  </p>
<p><br><br>有关于UTF-8我的评价是：不太需要理解。<br>因为现在的语言（Java，Python）什么的都可以自动选取合适的字符集。<br>而且所有的字符集都是兼容ASCII码的。  </p>
<p>中文好多字符是需要3个nibble存储的，所以对于中国来说也是不适用的。因此我国研制了自己的一套字符集叫做GBK。</p>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a><strong>图像</strong></h3><p>有位图和非位图，也可以说是矢量图。  </p>
<p>我们常见的<code>.jpg</code>,<code>.jpeg</code>格式之类的都是位图，计算机存储每一个像素位上的信息。因此文件一般较大，而且也容易失真。  </p>
<p>而<code>.svg</code>等文件类型是矢量图。矢量图记录的是像素的一系列关系，并由计算机直接绘制上色。因此无论如何蹂躏图像都不失真。  </p>
<p><em>简直像极了描点发作图和数学法作图的区别。</em>  </p>
<p>位图大小可以用<strong>像素数量×颜色深度</strong>计算得出。像素数量使用<strong>长像素数×宽像素数</strong>计算得出。  </p>
<p><br></p>
<p>需要注意以下几点：  </p>
<ul>
<li>在这里的计算方法得出的结果单位是bit。如要计算Byte那就将结果除以8。  </li>
<li>因为File header的存在，这种计算方法只会得出一个文件的大致大小。  </li>
</ul>
<h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a><strong>File Header</strong></h3><p>所有的文件都存在一个File Header，用于描述此文件类型，因此系统可以识别File Header来使用正确的解码方式。<br>一般文件开头的两个字节是File header。<br>操作系统会先读取File Header。 如果计算机无法识别file header，计算机就不会继续向下读取该文件了，并且让你自己制定一种合适的打开方式。</p>
<h3 id="声音"><a href="#声音" class="headerlink" title="声音"></a><strong>声音</strong></h3><p>Analogue的数据是连续的，而Digital的数据是离散的。  </p>
<p>用多少空间来记录一个采样的比率叫做一个采样率。采样率越高，音频质量越高。  </p>
<p>当然不是采样率越高越好的。因为人类对于特定声音不敏感，所以采样率到一定水准就已经足够使用了。  </p>
<p><br></p>
<p>音频文件的计算公式为：  <strong>数据量 (B/s)  = 采样频率(Hz) × 采样位数(bit) × 声道数 /8</strong>   </p>
<p>在这里，单声道代入“1”，立体声即为双声道，代入“2”计算。  </p>
<p><em>注意这里计算的是每秒的数据量</em>   </p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a><strong>压缩</strong></h3><p>无损压缩是压缩完还原之后可以还原成原本的样子，比如说文字压缩。</p>
<p>有损压缩就是还原不出原来的样子，但是结果还存在于能接受的范围内。<br>有损压缩通过丢失一些不容易察觉到，不太影响文件质量的数据进行删除处理，这种压缩方式叫做过滤。比如说<code>.mp3</code>，<code>.jpeg</code>等等。  </p>
<p>相比于直接存储数据的绝对大小，也可以存储下一个数据与上一个数据的变化量（相对数值）。这种存储方法可以有效地减少存储开销。</p>
<p><br></p>
<p>在无损压缩算法中，有这么一个典型例子，叫做<strong>Run-length coding.</strong>  </p>
<p>算法的具体内容是将连续的一些字符转化成个数加字符的形式。  </p>
<p>比如：</p>
<p><code>WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW</code></p>
<p>可以压缩成：</p>
<p><code>12W1B12W3B24W1B14W</code></p>
<p><br></p>
<hr>
<h1 id="第二章：通信与网络技术"><a href="#第二章：通信与网络技术" class="headerlink" title="第二章：通信与网络技术"></a><strong>第二章：通信与网络技术</strong></h1><h2 id="网络的目标与演变"><a href="#网络的目标与演变" class="headerlink" title="网络的目标与演变"></a><strong>网络的目标与演变</strong></h2><h3 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网 (WAN) "></a><strong>广域网 (WAN) </strong></h3><p>广域网 (Wide Area Network, WAN) 是一个是一个不受单一地点限制的大型信息网络。<br>广域网可以通过广域网供应商来促进世界各地的设备之间的通信或者信息共享。<br>一般来说，广域网是一个局域网 (LAN) 或者其他网络的集合，这里面的每一个元素相互进行通信。你可以将广域网理解成子网络的网络。  </p>
<p>互联网 (Internet) 是世界上最大的广域网。  </p>
<article class="message is-info"><div class="message-body">

<b>Wide area network (WAN): a network connecting computers on different sites, possibly thousands of kilometres apart.</b>

</div></article> 


<p><br></p>
<p>链接广域网的电脑可以享受下面的优点：  </p>
<ul>
<li>可以远程控制另一台计算机。  </li>
<li>可以访问存储在远程计算机上的数据档案。  </li>
<li>信息可以通过数据的方式传送给远程计算机上的用户。  </li>
</ul>
<p><br></p>
<p>一个典型的广域网有下面这些特点：  </p>
<ul>
<li>广域网会被一个组织或一个公司用来连接站点或分支机构。</li>
<li>广域网不属于该组织或公司。</li>
<li>广域网需要从公共交换电话网络公司（PSTN）租借。</li>
<li>如果租借广域网，PSTN将提供一个专门的通信链路。</li>
<li>广域网的传输媒介将是光纤电缆。</li>
<li>广域网内数据的传输在交换机 (Switch) 之间运行。</li>
<li>交换机用来连接广域网和每个节点。</li>
<li>不会有任何终端系统直接连接到广域网上。</li>
</ul>
<p><br></p>
<hr>
<h3 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网 (LAN)"></a><strong>局域网 (LAN)</strong></h3><p>局域网 (Local area network, LAN)，是在一个有限的区域内（住宅，学校，实验室，大学校园或者办公大楼等区域）链接不同终端的一个网络。<br>局域网可大可小，小到一个只有一个用户的家庭网络，或者是一个拥有千万设备的办公网络，都可以叫做一个局域网。  </p>
<article class="message is-info"><div class="message-body">

<b>Local area network (LAN): a network connecting computers in a single room, in a single building or on a single site.</b>

</div></article> 

<p><br></p>
<p>连接到局域网的设备可以享受下面的这些优点：  </p>
<ul>
<li>在每台个人电脑上安装应用软件的费用可以通过在连接到局域网的应用服务器上安装软件来节省。<em>（可以在局域网的服务器上安装一个软件，这样就可以不用接着在每个终端上安装一样的软件了。说白了就是节省成本。）</em>  </li>
<li>使用一个搭建在局域网上的文件服务器，允许用户之间共享文件。  </li>
<li>可以多个设备共用一个设备，比如说连接到局域网的电脑都可以使用一个打印机来打印文件。  </li>
</ul>
<p>现在的局域网都有下面这些特点：  </p>
<ul>
<li>用于组织或者公司的内部组网。  </li>
<li>局域网可以被组织或者公司拥有。  </li>
<li>传输介质一般是双绞线电缆或者Wifi。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="客户机-服务器模型"><a href="#客户机-服务器模型" class="headerlink" title="客户机-服务器模型"></a><strong>客户机-服务器模型</strong></h3><p>客户机-服务器模型 (Client-server model)是一种分布式应用结构，它将任务或工作负载在资源或服务的提供者（称为服务器）和服务请求者（称为客户）之间进行划分。  </p>
<p>在这种结构中，当客户计算机通过互联网向服务器发送数据请求时，服务器接受请求并以所请求的数据进行回应。  </p>
<p>在当今的网络世界中十分的常见。  </p>
<p>还有一个东西叫做瘦客户端 (Thin-client)。瘦客户端的功能就是为用户提供一个输入的窗口，然后再将用户输入的信息打包发送给服务器。最后再将服务器发送回来的数据解析展现给用户。  </p>
<p>与其相反的还有胖客户端 (Thick-client)。与首客户端相反，胖客户端会在传送信息到服务器之前，在本地完成一些或者很多运算。  </p>
<article class="message is-info"><div class="message-body">

<b>Client-server: an architecture where a client runs an application provided by a server on a network.</b>

<br>

<b>Thin-client: a client that only provides input and receives output from the application.</b>

<br>

<b>Thick-client: a client that carries out at least some of the processing itself.</b>

</div></article> 

<hr>
<h3 id="文件的分享"><a href="#文件的分享" class="headerlink" title="文件的分享"></a><strong>文件的分享</strong></h3><p>你可以将文件上传到网络上，然后其他用户就可以在服务器上将你共享的文件下载下来。这就像百度网盘一样。  </p>
<p>当然我们还有其他的方法，比如说点对点网络模型 (Peer-to-peer model)。<br>点对点网络不存在一个中心的服务器来让其他主机访问，相反，P2P网络中的每一个节点都相当于是一台主机。<br>当一台计算机向另一台计算机发送文件请求的时候，那么收到请求的电脑就会变成一个相当于服务器的东西。  </p>
<p>与客户机-服务器模型相比，P2P网络模型有如下优点：  </p>
<ul>
<li>当许多客户端同时请求一个资源的时候，P2P网络就可以很有效地规避网络堵塞。  </li>
<li>一个文件地每一个小部分都可以分开进行下载。  </li>
<li>一个文件的不同部分可以在不同的主机上下载。  </li>
</ul>
<p>而客户机-服务器模型的优点有：  </p>
<ul>
<li>允许组织来控制文件的下载和使用。  </li>
<li>可以提供给文件更好的保护措施。因为所有文件都可以放在一个主机上集中管理。  </li>
</ul>
<hr>
<h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a><strong>网络拓扑结构</strong></h2><p>数据通信系统需要由这些部分组成：发送方，接收方，传输介质，传输的信息和传输协议。  </p>
<p>其中，传输的介质可以是空气(WiFi), 也可以是电缆(比如以太网线)。  </p>
<article class="message is-info"><div class="message-body">

<b>Topology: the configuration of a network that defines how the various devices on the network are connected.</b>

</div></article> 


<p><br></p>
<p>信息可以通过下面这几种不同的方式来通过介质传输：  </p>
<ul>
<li>单工模式 (Simplex mode)，数据仅可以单向传输。  </li>
<li>半双工模式 (Half duplex)，数据可以双向传输，但是不能同时双向传输。  </li>
<li>全双工模式 (Full duplex), 数据不仅可以双向传输，而且还可以同时进行双向传输。  </li>
</ul>
<p><br></p>
<p>一个数据通信系统可以由一个单独的隔离网络组成。<br>隔离网络的拓扑结构有好几种可能性。其中最简单的是两个系统通过一个网络链接连接，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB94efc030e3880498ca28d4e0eed5e1a7?method=download&amp;shareKey=b69f674402d4c4aeddc65a08a89a12e1" alt=""></p>
<p>这是一个典型的点对点网络 (point-to-point network)。 可以理解成两个机器之间的专用线路。传输可以是单工或者是双工。  </p>
<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1b3384dc23156eeca80a7473f07bb546?method=download&amp;shareKey=131a94588bb6c038a1dd82b89c1797ce" alt=""></p>
<p>早期的局域网拓扑结构一般都是用环形或总线拓扑结构。我们没啥必要解释环形拓扑结构，因为现在环形拓扑结构基本上已经灭绝了。  </p>
<p>上图是总线网络 (Bus network)。总线网络包含一条总线，这条总线上连接着不同的终端设备，而且每一个终端之间没有直接连接。<br>所以说如果两个终端需要通信，就必须要通过总线来进行传播。  </p>
<p>这种网络结构是相对比较有弹性的，因为其中一个终端的故障并不会影响到整个网络的瘫痪。  </p>
<article class="message is-info"><div class="message-body">

<b>Bus topology: contains one shared link to which all devices are attached.</b>

<br>

<b>End-system: a computer or server connected to a network.</b>

</div></article> 


<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB553a27eeb08177f1aeec93773346e90f?method=download&amp;shareKey=d7b873808bcf93983a9433b6e3d30f89" alt=""></p>
<p>上图是一个完全连接的网状拓扑结构网络 (mesh topology)。  </p>
<p>在这个配置中，每个主机之间都会被连接。这些传输是双工的。  </p>
<p>但是这样的网络结构一般来说不是特别容易实现，因为链接主机需要的线缆开销就会很大。</p>
<article class="message is-info"><div class="message-body">

<b>Mesh topology: contains direct links between devices.</b>

</div></article> 

<p><br></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4af115136ecd3aa2fb4c02314fc06619?method=download&amp;shareKey=19dd9c1ea082904e169f9ce8c2ebf31c" alt=""></p>
<p>所以说我们可以使用另一种网络结构来解决这个问题，那就是使用一台交换机构成的星状网络 (star topology)。  </p>
<article class="message is-info"><div class="message-body">

<b>Star topology: each end-system is linked to a central device.</b>

</div></article> 

<p>在星状网络中，每个主机都与中心设备具有点对点的链接，而且传输是双工的。<br>和总线结构一样：一个主机的故障不会影响到整个网络，但是中心设备一定不可以发生故障，否则整个网络就会瘫痪。  </p>
<p>星型网络拓扑结构中，<strong>所有的设备都直接链接到中心设备上，同时所有设备互相独立，且仅仅连接到中心设备上。</strong>  </p>
<p>在星状结构中，中心设备也可以用于将网络连接到其他的网络，特别是连接到互联网。   </p>
<p><br></p>
<hr>
<p>当多个局域网联合在一起，他们就可以形成具有不同拓扑结构和技术的一个大网络。这个局域网的集合就变成了一个混合网络 (hybrid network)。  </p>
<article class="message is-info"><div class="message-body">

<b>Hybrid network: a collection of connected LANs where some of them have different topologies or supporting technologies.</b>

<br>

<b>Bandwidth: a measure of the amount of data that can be transmitted per second.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="传输载体"><a href="#传输载体" class="headerlink" title="传输载体"></a><strong>传输载体</strong></h2><h3 id="线缆"><a href="#线缆" class="headerlink" title="线缆"></a><strong>线缆</strong></h3><p>传输网络的线缆可以有这三种：<strong>双绞线 (Twisted pair)</strong>，<strong>同轴线缆 (Coaxial)</strong>和<strong>光纤 (Fibre optic)</strong>。其中，双绞线和同轴线缆都选用了铜作为传输载体。  </p>
<p>不同的线缆拥有不同的特性。下表展示了不同线缆的特性：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">~</th>
<th style="text-align:left">双绞线 (Twisted pair)</th>
<th style="text-align:left">同轴线缆 (Coaxial)</th>
<th style="text-align:left">光纤 (Fibre optic)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">费用</td>
<td style="text-align:left">最低</td>
<td style="text-align:left">高</td>
<td style="text-align:left">最高</td>
</tr>
<tr>
<td style="text-align:left">带宽 / 信息传递速率</td>
<td style="text-align:left">小</td>
<td style="text-align:left">大</td>
<td style="text-align:left">很大</td>
</tr>
<tr>
<td style="text-align:left">高频衰减</td>
<td style="text-align:left">受影响</td>
<td style="text-align:left">最受影响</td>
<td style="text-align:left">最不受影响</td>
</tr>
<tr>
<td style="text-align:left">抗干扰程度</td>
<td style="text-align:left">很受影响</td>
<td style="text-align:left">受点影响</td>
<td style="text-align:left">最不受影响</td>
</tr>
<tr>
<td style="text-align:left">是否需要中继器</td>
<td style="text-align:left">需要</td>
<td style="text-align:left">需要</td>
<td style="text-align:left">一般不需要</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>双绞线电缆被广泛运用在我们的生活之中。一般在家里组局域网就会用双绞线电缆。  </p>
<p>同轴线缆一般被有线电视公司和城域网广泛使用，同轴电缆一般不会用于长途电话布线。  </p>
<p>光纤电缆是长距离布线的首选技术。光纤电缆是由许多单独的纤维捆扎在一起构成的，而同轴电缆就没有。</p>
<p><br></p>
<hr>
<h3 id="无线"><a href="#无线" class="headerlink" title="无线"></a><strong>无线</strong></h3><p>除了选用线缆传输，我们还可以使用无线传输 (Wireless transmission)。  </p>
<article class="message is-info"><div class="message-body">

<b>Wireless: a transmission using radio, microwave or infrared.</b>

</div></article> 

<p>有三种选择：<strong>无线电 (Radio)</strong>，<strong>微波 (Microwave)</strong>和<strong>红外线 (Infrared)</strong>。<br>这三种传输类型的本质区别其实是波的频率。  </p>
<p>上表格：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">~</th>
<th style="text-align:center">无线电 (Radio)</th>
<th style="text-align:center">微波 (Microwave)</th>
<th style="text-align:center">红外线 (Infrared)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">频率分布</td>
<td style="text-align:center">3kHz - 3GHz</td>
<td style="text-align:center">3-300GHz</td>
<td style="text-align:center">300 GHz - 400 THz</td>
</tr>
<tr>
<td style="text-align:left">带宽 / 信息传递速率</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">→</td>
</tr>
<tr>
<td style="text-align:left">高频衰减 <br> <em>(主要由天气影响，如雨)</em></td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">→</td>
</tr>
<tr>
<td style="text-align:left">是否需要中继器</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">→</td>
</tr>
<tr>
<td style="text-align:left">定向传播性</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
<td style="text-align:center">→</td>
</tr>
<tr>
<td style="text-align:left">墙壁穿透能力</td>
<td style="text-align:center">←</td>
<td style="text-align:center">——</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:left">抗干扰程度</td>
<td style="text-align:center">无明显趋势</td>
<td style="text-align:center">无明显趋势</td>
<td style="text-align:center">无明显趋势</td>
</tr>
</tbody>
</table>
</div>
<p>“—— —— →”或者”← —— ——“代表向这个方向递增。  </p>
<p><br></p>
<hr>
<h3 id="有线-VS-无线"><a href="#有线-VS-无线" class="headerlink" title="有线 VS 无线"></a><strong>有线 VS 无线</strong></h3><p>一般来说，有线传输通常被称作为“引导媒体”，无线则被称为“非引导媒体”。  </p>
<p>当我们比较有线传输和无线传输的相对优势时，还有其他几点需要考虑。  </p>
<ul>
<li><p>有一些无线传输的频段是被国家禁止使用的。这意味着使用这些频段进行通信必须要经过国家的审批。  </p>
</li>
<li><p>在这些频段之外，无线传输就不需要任何许可了。与此同时，在地下布下传输线缆必须先经过土地所有者的授权。  </p>
</li>
<li><p>全球通信既可以通过埋在海底的光纤电缆实现，也可以使用卫星传输。  </p>
</li>
<li><p>干扰对于无线传输似乎是一个比较大的问题。干扰的程度取决于具体使用的频段。  </p>
</li>
<li><p>一般来说，无线传输需要的中继器相比有线传输要少得多。  </p>
</li>
<li><p>只有无线网络才可以支撑起现今社会庞大的智能手机网络需求。  </p>
</li>
<li><p>在小企业或者家庭内，有线网络和无线网络几乎处于同等地位，因为他们对用户的区别并不是特别的明显：即便有线网络需要提前布线的情况下。  </p>
</li>
</ul>
<p><br></p>
<p><em>(课本上给出的这些例子怎么想也不是很成系统的一些东西)</em>  </p>
<p><br></p>
<p>我们刚才在全球通信中提到了卫星通信。<br>卫星通信是现代通信系统的一个重要部分。下图显示了不同类型卫星距离地面的高度：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4fcdcedd8dd1db4de1f46fbe064a53df?method=download&amp;shareKey=c49da4e3e22c77a4a5e7e8ba874685b0" alt=""></p>
<p>其中范艾伦辐射带 (Van Allen belt)是含有高浓度带电粒子的区域，会干扰卫星的正常通信。  </p>
<p><br></p>
<p>离地球最远的，处于地球静止轨道 (Geostationary Earth Orbit, GEO)上的卫星是用来提供<strong>长途电话</strong>和<strong>计算机网络通信</strong>的。“地球同步”的意思是卫星轨道运行的速度与地球自转的速度相同，所以从地球上看，那颗卫星就会一直在天空上的同一个位置。只需要3颗GEO卫星就可以覆盖全球。  </p>
<p>离地球比较近，但不是最近的那一组卫星是中地球轨道 (Medium-Earth-orbit, MEO)卫星。这个位置的卫星主要提供全球定位系统(GPS)服务，覆盖全球至少需要10颗MEO卫星。  </p>
<p>最后在近地球轨道 (Low-Earth-orbit, LEO)上的卫星用来填充移动电话网络，覆盖全球至少需要50颗近地轨道卫星。 <em>（虽说现在轨道上已经有上百颗近地轨道卫星了）</em>  </p>
<p><br></p>
<p>卫星最大的问题就是离地面的距离太远，所以延迟就理所应当的成为了一个大问题。所以说现在使用卫星网络一般是有一些专门的应用点，比如在偏远地区使用互联网，或者是使用GPS。  </p>
<p>因为现在光纤的发展成本越来越低，高速的数据传输有着更好的媒介，于是乎对于卫星网络的需求就越来越少了。  </p>
<p><br></p>
<hr>
<h2 id="局域网硬件"><a href="#局域网硬件" class="headerlink" title="局域网硬件"></a><strong>局域网硬件</strong></h2><h3 id="有线局域网"><a href="#有线局域网" class="headerlink" title="有线局域网"></a><strong>有线局域网</strong></h3><p>在早些时候，同轴线缆是用来组局域网的。不过到现在，双绞线线缆是在局域网中最常见的解决方案。你看见的经典水晶头和以太网口一般都是双绞线。同时，光纤也变得越来越普及。  </p>
<p><br></p>
<p>在总线网络配置中，网络由一个总线和一系列由电缆连接的插口组成。总线的两端有<strong>端子 (Terminator)</strong>，可以有效防止信号反射回总线。随后，每一个终端都会有一根相对较短的电缆，每一端都会有一个RJ-45连接器 <em>(就是我们常见的水晶头)</em>， 一端插入总线插座，另一端插入端系统的LAN口。  </p>
<p>总线可以使用<strong>中继器 (Repeater)</strong> 来链接两条总线进行扩展，让信号传达到更远的地方。如果想要扩展信号，那么我们就必须需要中继器。因为远距离传输信号的时候，由于信号的衰减，通信会变得越来越不可靠。<br>中继器在这里会接受所有输入的信号，并且输出一个满血的输出信号，让信号去到更远的地方。  </p>
<p>也有些时候，一个总线网络会用一些分段方式构建。<br>两个网段会使用一个<strong>网桥 (Bridge)</strong>链接，网桥会为他所连接的两个网段中的终端系统存储网络地址，这样两个网段就可以互相通信了。  </p>
<p><br></p>
<p>在星型网络结构中，每一个终端系统都具有相同类型的线缆，同时拥有相同的连接器。因为电缆必须要插入中央设备的插口中，所以电缆往往会更长一些。  </p>
<p>在星型网络结构中，中心设备可能是一个<strong>集线器 (Hub)</strong>，一个<strong>交换机 (Switch)</strong>或者是一个<strong>路由器 (Router)</strong>。现在而言，交换机是最有可能的中心设备：交换机是一种可以将特定的通信引导到特定终端的一个设备。</p>
<p><br></p>
<p>终端系统上的LAN端口和<strong>网络接口卡 (Network Interface Card, NIC)</strong>连接。网络接口卡用来为计算机和其他设备提供专用的网络连接，他同时被称作为网络接口控制器、网络适配器或者是LAN适配器：简称网卡。<br>网卡在制造的过程中都会有一个独特的网络地址，这个地址用来识别安装该网卡的终端系统。这个唯一的网络地址被称作<strong>媒体访问控制(Media Access Control, MAC)</strong>地址，我们一般叫它MAC地址。MAC地址是一个分配给网卡的唯一标识符。  </p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Server: a system providing a service to end-systems.</b>

<br>

<b>Repeater: a device that connects two cables and provides a full strength signal to the second cable.</b>

<br>

<b>Bridge: a device that connects two segments of a LAN.</b>

<br>

<b>Network Interface Card (NIC): a component used to identify the end-system.</b>

<br>

<b>Switch: a connecting device that can send a unicast message.</b>

</div></article> 




<p><br></p>
<hr>
<h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a><strong>无线局域网</strong></h3><p>Wi-Fi <em>(在某些国家叫做WLAN)</em>是一个用于描述无线以太网的术语。<br>它的正式描述是：<strong>IEEE 802.11</strong>，它是一个使用无线电频率传输的无线局域网标准。<br>Wi-Fi局域网的中心设备是一个<strong>无线接入点 (Wireless Access Point, WAP)</strong>，它可以是有线网络中的其中一个终端系统。如果你有一个具有无线功能的路由器，那么他就可以作为一个无线接入点。  </p>
<p>只要在无线局域网中的一个设备安装了<strong>无线网络接口卡 (Wireless Network Interface Card, WNIC)</strong>，WAP就可以与Wi-Fi局域网中的终端系统进行通信。  </p>
<p>无线网络接口卡是一种将你的设备连接到无线网络的设备，他也被称作无线适配器或者无线网卡。无线网络接口卡使用天线，并使用射频波提供无线数据的传输。  </p>
<article class="message is-info"><div class="message-body">

<b>Wireless Access Point (WAP): the connecting device in a WiFi LAN.</b>

<br>

<b>Wireless Network Interface Card (WNIC): provides the NIC function in a WiFi LAN.</b>

</div></article> 

<hr>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a><strong>以太网</strong></h2><p>以太网 (Ethernet)是现代网络世界的两大主导技术之一，以太网主要是用于组建局域网。<br>尽管以太网在20世纪80年代被发明出来，但是不属于任何机构。后来以太网被电气和电子工程师协会 (IEEE)标准化。<br>他们的802委员会负责协定了议定书的制定，最后将有线网络的标准定义为<strong>IEEE 802.3</strong>标准。这个名称有时可以用于替代以太网。  </p>
<p>到目前为止，以太网的标准已经迭代了5个版本：标准，快速，千兆，10千兆和100千兆。<br>名称中的千兆比特部分代表了其数据传输能力。  </p>
<p>标准类型的以太网是在局域网上实现的，一般都会配置为总线或者以集线器为中心设备的星型网络类型。<br>在这两种拓扑中，传输类型都是广播。任何消息对所有的终端都是可用的，而不需要再任何一对端系统之间进行任何受控的通信交换。<br>最后终端系统会检查消息中定义的目的地地址，以确定信息是否发送到了它应该去到的目的地。  </p>
<p>当使用共享介质传输数据的时候，如果两个终端系统同时传送消息，信息就会发生“碰撞”。这是指与传输相关的电压相互干扰，就会导致信息损坏。<br>我们采用的处理方法是：<strong>CSMA/CD (Carrier sense multiple access with collision detection)</strong>。<br>当传输数据的时候，这个系统会通过检测介质中的电压来判断是否存在其他的信息传递。  </p>
<p>有这个系统之后，传输的流程就会变成这样： </p>
<ol>
<li>检查传输介质中的电压。  </li>
<li>如果检测到传输介质中有数据传输，那么就在一段随机时间之后再来检查是否有数据传输。  </li>
<li>如果传输介质中没有数据传输，那么我们就可以开始传输数据了。  </li>
<li>在传输数据的过程中，CSMA/CD会继续检测时候有数据碰撞发生。  </li>
<li>如果没有检测到数据碰撞，就继续传输数据。  </li>
<li>如果检测到数据碰撞，那么就先暂停传输，随后发出一个干扰信号警告所有的终端站点。然后在一段随机时间后再来一次。  </li>
</ol>
<p><br></p>
<p>现代的以太网一般由交换机驱动：星型结构中心会有一个交换机，交换机控制数据端到端的传输。<br>每一个终端系统都是用全双工链路连接到交换机，因此在现在的以太网网络上不会发生数据碰撞。因此在现代的以太网结构中，我们已经不需要CSMA/CD了。    </p>
<p>当出现高强度的数据传输的时候，交换机需要能够将传入的消息存储在缓冲区 (Buffer) 中，只到线缆空闲的时候继续传输。  </p>
<p><br></p>
<hr>
<h2 id="互联网基础设施"><a href="#互联网基础设施" class="headerlink" title="互联网基础设施"></a><strong>互联网基础设施</strong></h2><h3 id="互联网服务提供商-ISP"><a href="#互联网服务提供商-ISP" class="headerlink" title="互联网服务提供商 (ISP)"></a><strong>互联网服务提供商 (ISP)</strong></h3><p>互联网设计出来的时候，美中不足的一点就是没有对他的结构有一个明确的定义。但是互联网服务是存在一个层次的。例如：<strong>互联网服务提供商 (Internet service provider, ISP)</strong>最初的功能是为了给个人或者公司提供互联网接入。现在这个功能被一个叫做“Access ISP”的东西来执行。  </p>
<p>这些“Access ISP”随后会接入到一个“中间层”，叫做“区域ISP (Regional ISP)“。区域ISP随后会连接到主干ISP，或者叫做一级ISP。  </p>
<p>网络和互联网服务提供商之间通过<strong>互联网交流点 (Internet Exchange Points, IXP)</strong>联系，一级ISP和主要的互联网内容提供商一起位于层次结构的顶端。  </p>
<p><br></p>
<hr>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a><strong>路由器</strong></h3><p>路由器可不是只存在于我们的局域网中，互联网中同样有一些路由器。  </p>
<p>我们可以把互联网想象成承载最多流量的一个网络，它由一组铺设在海底或者陆地上的光纤电缆组成，可以被描述成一个网状网络结构。<br>这种网状的电缆包含许多链接在一起的点，我们把他称之为<strong>节点(Node)</strong>，在每一个节点上，都有一个叫做<strong>路由器 (Router)</strong> 的设备。<br>路由器不仅仅是存在于一般互联网中的网状结构中，他也存在于ISP网络中。每一个路由器都连接到其他多个路由器，他的功能是为了传输选择最佳的路线。  </p>
<article class="message is-info"><div class="message-body">

<b>Router: a device that acts as a node on the Internet.</b>

</div></article> 


<p><br></p>
<hr>
<h3 id="公共交换电话网-PSTN"><a href="#公共交换电话网-PSTN" class="headerlink" title="公共交换电话网 (PSTN)"></a><strong>公共交换电话网 (PSTN)</strong></h3><p>当考虑城市建设的时候，一般来说都没有考虑用于因特网传输的专用链路。所以人类历史就这个问题最悠久的解决方案是普通老式电话服务 (Plain old telephone service, POTS)，更正式的描述是<strong>公共交换电话网 (Public switched telephone network)</strong>。  </p>
<p>在早期，电话网络传送模拟语音数据 (Analogue voice data)。 如果我们真的想要将数字数据通过电话网传播，就可以先在发送端使用调制解调器将数字信号转换为模拟信号，经过电话网络传播，然后在接收端使用调制解调器将模拟信号转化为数字信号。<br>这样的“拨号连接”上网方式能为用户提供中等速率的网络访问。  </p>
<p>不过组织或者机构也可以花点小钱购买一种租赁的网络服务，这种网络服务提供了一种永久的，专用的，有传输速度保证的互联网专用链接。<br>现在来看，大多数的组织和机构都是用租用线路来简历广域网或城域网的。  </p>
<p>都2023年了，祖国的网络建设都早早地把主要的通信线路换成光纤电缆了。这就允许ISP提供更好的网络服务，也允许某些人提供自己的ISP服务了。  </p>
<p>现在的服务有这样两种：第一种是传统网络接入的宽带网络连接，另一种是WiFi热点技术。  </p>
<p><br></p>
<hr>
<h3 id="移动电话网络"><a href="#移动电话网络" class="headerlink" title="移动电话网络"></a><strong>移动电话网络</strong></h3><p>对于移动电话来说，有另一种方式来提供互联网连接。<br>在这种情况下，移动电话运营商会充当ISP，为手机提供网络服务。<br>运营商会建立通信塔等基础设施，只要手机上搭载了合适的硬件和软件，就可以使用这样的基站来传输数据。  </p>
<p><br></p>
<hr>
<h2 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a><strong>网络应用</strong></h2><h3 id="万维网-WWW"><a href="#万维网-WWW" class="headerlink" title="万维网 (WWW)"></a><strong>万维网 (WWW)</strong></h3><p>“Using the web”和”using the Internet”看起来像是同一种表述，但实际上不是这样的。<br>互联网是一个互联网络，而万维网是一种运行在Internet上的一个分布式应用程序。<br>你可以把万维网认为成Internet上的所有网页。  </p>
<p>具体来说，web由大量的网站组成，每一个网站都有一个或者多个网页。<br>网页的特别之处就是他们可以包含超链接。当点击这些链接的时候，就可以直接并且基本上立即访问其他网页。  </p>
<p><br></p>
<hr>
<h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a><strong>云计算</strong></h3><p>云计算通常通过互联网提供计算服务。<br>一个组织可以选择建立自己的<strong>私有云 (Private cloud)</strong>。在这种情况下，有一下三中方法：  </p>
<ul>
<li>该组织对于创建和管理安装云系统并链接到互联网负责。  </li>
<li>该组织将会将创建和链接到私有网络的任务外包出去。  </li>
<li>该组织将可上网的系统的创建和1管理工作外包给第三方。</li>
</ul>
<p><em>太抽象了，根本看不懂</em>  </p>
<p>另一种选择是使用<strong>公共云 (Public cloud)</strong>。公共云由第三方云服务商创建，管理和拥有。  </p>
<p>云提供的服务与文件服务器和应用服务器提供的服务十分相似。<br>它们可以通过浏览器访问，因此你可以在任何位置，任何合适的设备商访问公共云 ——— 只要拥有互联网链接。<br>公共云可以被个人用户或者组织访问。  </p>
<p>公共云和私有云之间的最大区别就是系统规模。这种系统由很多大型主机计算机或者服务器群提供服务。<br>公共云所提供的服务可以有以下几种：  </p>
<ul>
<li>提供基础设施。  </li>
<li>提供平台。  </li>
<li>提供软件服务。  </li>
</ul>
<p>云服务的很多优势都以为以下这一点：云服务不是很依赖终端设备的配置。对于基础设施的提供，云服务的优势包括在运行软件时能调用服务器端的算力，存储，从而提供更好的性能或者更大的存储容量。<br>这样的话，我们甚至可以用有限的成本来运行对配置要求更高的应用程序。或者是公司的经费不足以支撑购买这些软件。<br>还有一点好处是：把计算机托管到云端后，会减少用户对于技术水平的需求。  </p>
<p>云服务的劣势大多与公共云有关：云服务提供者可以访问存储在云上的所有数据，所以说云服务用户没有办法确定他们的数据是否被第三方共享。<br>这是一个有关数据隐私的问题，所以说云服务提供商应该有责任确保用户的数据不会丢失。  </p>
<article class="message is-info"><div class="message-body">

<b>Private cloud: owned by and only accessed by an organization.</b>

<br>

<b>Public cloud: owned by a cloud service provider for general access.</b>

</div></article> 

<p><br></p>
<p>云计算的好处有：  </p>
<ul>
<li>只要在有互联网的情况下，就可以在任何地方访问云。  </li>
<li>对本地计算机的配置需求相对较低  </li>
<li>共享数据变得更容易。  </li>
<li>安全措施和保障可能更好。  </li>
<li>扩容更容易。  </li>
</ul>
<p>坏处可能有：  </p>
<ul>
<li>必须使用网络连接才可以访问云。  </li>
<li>在上传数据和下载数据可能需要花费很多时间。  </li>
<li>安全措施可能比较弱。  </li>
</ul>
<hr>
<h3 id="比特流"><a href="#比特流" class="headerlink" title="比特流"></a><strong>比特流</strong></h3><p>流媒体使用互联网来提供在线音乐，视频等相关服务。<br>一般来说，在数据被传输之前，它会被存储在一个字节中，可以用“字节流”的形式，一个一个字节的传输数据。<br>由于涉及到文件的大小，流媒体总是被压缩成一个比特序列，aka“比特流”。  </p>
<p>在第一章提到的压缩技术中，将字节流转化为比特流，也是一种压缩方法。<br>为了使接收端的解码过程正常工作，数据必须作为比特流传输。  </p>
<p><br></p>
<p>对于流媒体来说，“源 (Source)”是一个已经存储了待传输媒体的网站。在这种情况下，使用该资源的其中一个方法是把这个文件下载下来，然后在未来某个时刻方便听或看。<br>但是如果用户不想要等待漫长的下载时间，他们有另一种选择：流媒体。流媒体可以被描述为按需观看或者收听。<br>在这种情况下，媒体的传送和媒体的播放是两个独立的过程。传入的媒体数据被接受到终端机上的缓冲区内，然后终端上安装的媒体播放软件会从缓冲区中获取媒体数据并播放。  </p>
<p>还有另一种流媒体是实时或者直播传输。在这种情况下，内容是在发送时生成的，例如在观看体育赛事的时候同时直播。<br>在接收端，我们还是使用刚才提到的缓冲区加载原理，但是在发送端，可能会产生问题，因为可能会有大量的用户同时观看一个直播，造成网络阻塞。<br>所以现在的解决方式是将媒体传送至很多独立的直播节点，最后再由他们传递给用户。  </p>
<p><br></p>
<p>流媒体技术的一个关键问题是该技术是否能一直为用户提供一个还不错的用户体验。<br>当媒体被创建出来时，它的意图是要以创造时完全相同的速度将媒体传递给用户。如果一首歌曲在录制时持续4分钟，但如果这四分钟再传输的时候拉长成了六分钟，就听起来很奇怪。</p>
<p>传送内容的过程是由<strong>比特率 (Bit rate)</strong>决定的。例如，一个质量相对较差的视频可以用300kbps的比特率发送，但是一个质量相当好的音频文件只需要使用128kbps就可以了。  </p>
<p>下图展示了一个流媒体原理示意图：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1565e4f0cfa79b5b89252b433a29250f?method=download&amp;shareKey=ab17d5a1b5e077eea94982af0e8dc755" alt=""></p>
<p><strong>缓冲区 (Buffer)</strong>必须按照所使用媒体的正确比特率将数据传递给用户。  </p>
<p>发送到缓冲区的数据应该以更高的速率传输给用户。当媒体播放器发现缓冲池中的内容超过了上限和下限，这代表着我们需要向服务器发送获取指令了。  </p>
<p><br></p>
<hr>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a><strong>IP</strong></h2><p>互联网需要技术协议才能运作。标准使用了一套称为TCP/IP的协议(参见第17章)。其中一个方面是IP寻址，用于定义从何处和到何处传输数据。  </p>
<h3 id="IP寻址"><a href="#IP寻址" class="headerlink" title="IP寻址"></a><strong>IP寻址</strong></h3><p>目前互联网使用<strong>IPv4 (Internet Protocol version 4)</strong>来进行寻址。  </p>
<p>IPv4寻址方案基于32位（4个字节）定义一个IPv4地址。32位的IP地址一共有2<sup>32</sup>个不同的IPv4地址，差不多一共有40亿个IPv4地址。  </p>
<p>IPv4是在20世纪70年代发明的，当时PC和手机还没有被发明，当时虽然估计40亿IP地址会允许世界上一半的人使用互联网，但是到现在来说IPv4能提供的IP数量就有些捉襟见肘了。  </p>
<article class="message is-info"><div class="message-body">

<b>IPv4 address: a 32-bit long, hierarchical address of a device on the Internet.</b>

</div></article> 

<p>最初的寻址方案是：IP地址中的一组位(bits)定义一个netID，另一些位定义该网络上面的一个hostID。这样做的目的是为了给互联网上的每一台设备分配一个唯一的，普遍认可的地址。  </p>
<p>以netID和hostID分开的IP地址允许数据先定位到netID进行传输，然后再根据hostID分别传发给不同的主机。主机地址只需要在到达指定网络下检查一下就可以了。  </p>
<p>在继续往下执行传输之前，我们需要注意host可以是子网下的任何一个设备，比如说路由器。  </p>
<p><br></p>
<p>不同的netID和hostID的划分形式，与他们的IP级别有关系：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Class</th>
<th style="text-align:left">Class identifier</th>
<th style="text-align:left">Number of bits for netID</th>
<th style="text-align:left">Number of bits for hostID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Class A</td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left">7</td>
<td style="text-align:left">24</td>
</tr>
<tr>
<td style="text-align:left">Class B</td>
<td style="text-align:left"><code>10</code></td>
<td style="text-align:left">14</td>
<td style="text-align:left">16</td>
</tr>
<tr>
<td style="text-align:left">Class C</td>
<td style="text-align:left"><code>110</code></td>
<td style="text-align:left">21</td>
<td style="text-align:left">8</td>
</tr>
</tbody>
</table>
</div>
<p>上表中可以知道，最高有效位(<em>从左往右数</em>)表示了网络IP的级别。接着其他的有效位会被分配为netID，其余的有效位定义了hostID。  </p>
<p>最大的组织会被分配到A类IP。这些A类IP只能有2<sup>7</sup>个，也就是128个，但是每一个组织都可以有224个不同的host。相比之下，C类IP就一共有2<sup>21</sup>个IP地址，差不多一共有200万个。C类IP中每个组织都只能分配到2<sup>8</sup>个host，说白了就是256个host。  </p>
<p>但是问题在于，一旦局域网下支持PC变得普遍，可用的B类netID就太少了。但是如果把C类ID分配下去的话，hostID又太少了。所以说我们现在有更多更好的方法能解决这些问题。  </p>
<p>在继续深入探讨之前，我们需要先介绍IP地址的表示。<br>在传输过程中，该技术是以32位二进制码为地址传输的。为了让用户更轻松的记忆，我们可以使用小数点分割编码地址。这就叫做<strong>Dotted-decimal notation</strong>。  </p>
<p>比如说：  </p>
<p><code>10000000 00001100 00000010 00011110</code>  </p>
<p>可以被写成：  </p>
<p><code>128.12.2.30</code>  </p>
<p><br></p>
<hr>
<h3 id="无类域间路由（CIDR）"><a href="#无类域间路由（CIDR）" class="headerlink" title="无类域间路由（CIDR）"></a><strong>无类域间路由（CIDR）</strong></h3><p>第一种改进方法被叫做 <strong>无类域间路由 (Classless inter-domain routing, CIDR)</strong>。  他保留了netID和hostID的感念，但是取消了固定的结构，允许netID和hostID根据用户的需求划分边界。  </p>
<p>实现该目标的简单方法是在地址后面添加一个8位后缀，指定netID的位数。  </p>
<p>例如我们把后缀定义为21，这代表着21位会被用于netID使用，剩下的11位还允许指定2<sup>11</sup>不同的hostID。  </p>
<p>假如说这样的一串IP地址： </p>
<p><code>11000011000011000000011000001110/00010101</code></p>
<p><code>/</code>后面的<code>00010101</code>代表着最高前21位被定义为netID。<br>改写成Dotted decimal notation就是：<code>195.12.6.14/21</code>。  </p>
<p>由你所见，CIDR不会使用最高位的前几位来定义IP地址是哪一类的。但是他确实会把存在的A,B,C类地址分别转化为后缀为8,16,24的IP地址一起使用。  </p>
<p><br></p>
<hr>
<h3 id="子网"><a href="#子网" class="headerlink" title="子网"></a><strong>子网</strong></h3><p>子网是另一种解决这个问题的方法。通过对hostID搭建一个结构，我们可以更有效地使用hostID。  </p>
<p>为了学习这一块儿知识，我们考虑一个中型组织的例子，其中大约有150名员工，每个人都有自己的一台PC。<br>假设一共有六个部门的局域网，和一个总体的局域网，那么下图就给定了一个通过原始方案来通过局域网链接Internet的原理图。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7e156b3a1505b9a22d220cbc61dd2516?method=download&amp;shareKey=a70e00f30d03e889ed0f32efcfa38f8b" alt=""></p>
<p>该组织这下需要7个C级netID：每个局域网一个。每一个netID都指向一个局域网网关。<br>每个局域网的netID由IPv4地址的前24个bits表示，剩下的8个比特位是hostID。<br>这意味着在一个局域网中存在256个不同的host。  </p>
<p>如果是在所有7个局域网中，可以确定一共由这些数目的host：  </p>
<p><code>256 × 7 = 1792</code></p>
<p>我们提到过这个公司里面一共有150个个人工作站，因此有1642个IP地址未被使用。这些IP地址就被浪费掉了：因为其他组织也不会使用这些IP。  </p>
<p>然而这个组织的子网解决方案只需要分配到一个C类netID即可。<br>例如分配的IP地址可能是194.10.9.0到194.10.9.225之间，其中netID由前三个字节组成，分别用十进制数194,10,9表示。  </p>
<p>子网现在通过定义构成hostID的256个代码的结构来工作。<br>对于这个组织来说，一个明智的解决方案是使用前三位作为每个局域网的代码，其余五位作为每个工作站的代码。  </p>
<p>下图展示了这种布局的示意图：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBea9ee882317c5849fb357bbac184a5d9?method=download&amp;shareKey=5f0b66131ec15c8d6136c82efa1de800" alt=""></p>
<p>在因特网上，所有分配的IP地址都有一个指向路由器的netID，然后路由器就需要解释hostID，将数据通过网关传输到某个局域网上的适当工作站。<br>工作站可以被这样识别：  </p>
<ul>
<li><p>hostID 为 <code>00001110</code>可能是LAN0 (<em>前三位是000</em>) 上面的第十四个工作站 (<em>第三位到第八位是01110</em>)  </p>
</li>
<li><p>hostID为 <code>01110000</code> 可能是LAN3 (<em>前三位是011</em>) 上面的第16个工作站 (<em>第三位到第八位是10000</em>)</p>
</li>
</ul>
<p>这样的话一共有256个IP地址，显然这个公司的150个工作站还剩下了106个未使用的IP的地址。这剩下的这些IP地址可以保留：为了公司后期的业务扩张而保留。  </p>
<p>也就是说，原定需要6个netID的计划，如果使用子网结构，就只需要1个netID。空余出来的netID可以给其他的组织使用。  </p>
<p><br></p>
<hr>
<h3 id="网络桥接-NAT"><a href="#网络桥接-NAT" class="headerlink" title="网络桥接 (NAT)"></a><strong>网络桥接 (NAT)</strong></h3><p><strong>网络地址转换 (Network address translation, NAT)</strong></p>
<p>网络地址转换是将一个或者多个本地IP地址转换为一个或者多个全局IP地址，同时将全局IP地址转换为一个或者多个全局IP地址的过程，目的是为了为本地主机提供Internet访问。NAT通常是在WAN边缘路由器上实现的，用于实现核心站点，校园网，分支机构和托管站点的Internet接入。  </p>
<p>在网络地址转换中，网络设备(通常是路由器或NAT防火墙)为私有网络中的一台或多台计算机分配一个公共地址。  </p>
<p>网络地址转换(NAT)是一种将一个IP地址空间映射到另一个IP地址空间的方法，它通过修改数据包的IP首部中的网络地址信息，使它们在流量路由设备中传输。</p>
<p>NAT盒子在互联网上有一个可见的IP地址，所以说从互联网发送或者接收数据完全可以使用这个地址。在内部，IP地址就必须从一些范围内选择一个合适的IP地址作为每一个host的IP。  </p>
<p>NAT解决了上述方案中内部网络无法连接到因特网的问题。  </p>
<p>需要注意的是，每个地址可以被任意数量的不同的私有网络同时使用。NAT盒子中的接口安装了软件来检查每一个输入和输出的传输。在传入的传输被定向到了正确的内部地址之前，我们可以对他进行安全检查。查看下图的这些箭头，这代表着在内部的网络结构可以使用不同的网络形式来解决问题。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB84deb201ddc07618f9d1b17d14518c3c?method=download&amp;shareKey=a8ff460dd6e2f722ee2a0ff67081c654" alt=""></p>
<p><br></p>
<hr>
<h3 id="动态和静态IP地址"><a href="#动态和静态IP地址" class="headerlink" title="动态和静态IP地址"></a><strong>动态和静态IP地址</strong></h3><p>之前提到：当用户希望与Internet建立连接时，该链接由ISP处理。这样的话，ISP就需要处理很多可用的hostID。然而,ISP就需要同时支持很多hostID。  </p>
<p>幸运的是，对于ISP和个人用户来说，这些潜在用户中的许多人将不会参与互联网互动。  </p>
<p>所以说ISP会给用户创建一个<strong>动态地址 (Dynamic IP-address)</strong>。当用户与互联网断开连接的时候，这个IP地址就会被释放掉，然后转让给另一个用户使用。  </p>
<p>同样我们也可以向用户分配<strong>静态地址 (Static IP-address)</strong>。静态IP地址永远不会改变。如果用户准备支付额外费用的话，那么运营商就可以向用户提供静态IP地址。  </p>
<p><br></p>
<hr>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a><strong>IPv6</strong></h3><p>IPv6不同与IPv4，它使用128位来表示IP地址，这样就一共允许2<sup>128</sup>个不同的IP地址存在。  </p>
<p>所有的IPv6地址都是使用冒号隔开的十六进制来记录。代码被分解为16位一个部分，每一个部分都会使用4个十六进制数表示。  </p>
<p>如下表所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">IPv6 address</th>
<th style="text-align:left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>68E6:7C48:FFFE:FFFF:3D20:1180:695A:FF01</code></td>
<td style="text-align:left">一个完整的IPv6的IP</td>
</tr>
<tr>
<td style="text-align:left"><code>72E6::CFFE:3D20:1180:295A:FF01</code></td>
<td style="text-align:left">在IPv6中，<code>:0000:0000:</code>会被替换为<code>::</code></td>
</tr>
<tr>
<td style="text-align:left"><code>6C48:23:FFFE:FFFF:3D20:1180:95A:FF01</code></td>
<td style="text-align:left">省略最开始的几个0</td>
</tr>
<tr>
<td style="text-align:left"><code>::192.31.20.46</code></td>
<td style="text-align:left">一个IPv4地址使用IPv6的形式表示</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a><strong>域名</strong></h2><p>在互联网的日常使用中，用户需要识别特定的网页或者电子邮箱的网址。作为用户，没人喜欢记录一串复杂且不好记录的IP地址，所以我们发明了<strong>DNS (Domain name system)</strong></p>
<p>域名服务(DNS)在1983年被发明，DNS服务向互联网主机分配一个可读的域名，并提供一个为单个域名查找IP地址的系统。  </p>
<article class="message is-info"><div class="message-body">

<b>Domain name service (DNS):  a hierarchical distributed database installed on domain name servers that is responsible for mapping a domain name to an IP address. Also known as domain name system.</b>

</div></article> 

<p>DNS系统被设置在一个分层的分布式数据库，并安装在覆盖整个互联网的大量域名服务器上。这些域名服务器以层次结构链接，强大的根服务器位于层次结构的顶端，支撑起整个互联网。  </p>
<p>根服务器是可复制的，这意味着其所有数据的多个副本在任何时候都可以被保存。<br>然后DNS name space会被划分成一些不重叠的区域。每一个区域都有一个主要的名称服务器，上面的数据允许二级服务器从里面读取数据。  </p>
<p><strong>DNS名称空间 (DNS name space)</strong>是在DNS中注册的所有域名的集合。</p>
<p>因此域名分层导致超过有250个通用顶级域名。如.com .edu 或者.gov。  </p>
<p>域名包含在<strong>通用资源定位器 (Universal resource locator)</strong>中。它可以识别网页或者电子邮件地址。  </p>
<p>一个域名是由它向上的路径命名的。比如说<code>eng.cicso.com</code>指的是<code>.com</code>顶级域名中<code>.cisco</code>中域的<code>.eng</code>子域。  </p>
<p>通过域名来查找IP地址被称为“<strong>名称解析 (name resolution)</strong>”。<br>对于这样的查询，一共有三种可能的结果：  </p>
<ul>
<li>如果该域名在被查询的服务器的控制之下，那么将返回一个权威的、正确的IP地址。  </li>
<li>如果域名不在服务器的控制之下，如果IP地址存储在最近请求的地址的缓存中，仍然可以返回，但它可能已经过时了。  </li>
<li>如果查询中的域是远程的，那么查询将被发送到根服务器，它可以提供适当的顶级域的名称服务器的地址。这反过来又可以为下一个低级域的名称服务器提供地址。这种情况一直持续到查询到达可以提供权威性IP地址的名称服务器。  </li>
</ul>
<p><br></p>
<hr>
<h1 id="第三章：硬件"><a href="#第三章：硬件" class="headerlink" title="第三章：硬件"></a><strong>第三章：硬件</strong></h1><p>终于讲到硬件了  </p>
<h2 id="关于计算机"><a href="#关于计算机" class="headerlink" title="关于计算机"></a><strong>关于计算机</strong></h2><p>计算机系统必须支持三个主要领域的作战能力：  </p>
<ul>
<li>处理数据  </li>
<li>存储数据  </li>
<li>输入 / 输出数据  </li>
</ul>
<p><strong>一台计算机的核心是CPU (Central Processing Unit)。</strong></p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="数据的存储，输入与输出"><a href="#数据的存储，输入与输出" class="headerlink" title="数据的存储，输入与输出"></a><strong>数据的存储，输入与输出</strong></h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a><strong>存储</strong></h3><p>先来说存储把。</p>
<p>直接上表：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB08620125ef4847d51d9078aad758f2dc?method=download&amp;shareKey=b5bd394ec28c9c2afa8e65462e92308a" alt="图片"></p>
<p>这些组件由上至下，属性的变化如下：  </p>
<p><strong>读写越来越慢</strong><br><strong>存储空间越来越大</strong><br><strong>尺寸越来越大</strong><br><strong>造价越来越便宜</strong></p>
<p><br></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a><strong>输入</strong></h3><p>诶这个就很简单了，课本上给了如下几个例子  </p>
<ul>
<li>键盘键入  </li>
<li>用一个指向性的设备 （<em>人话就是鼠标，数位板这样的指向性输入设备</em>）  </li>
<li>手柄  </li>
<li>扫描仪  </li>
<li>麦克风阵列  </li>
<li>（从以上提到的任何数据输入设备读取数据）  </li>
<li>网络链路</li>
</ul>
<p><br></p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h3><p>和上面一样的清晰明了：</p>
<ul>
<li>显示屏  </li>
<li>打印机与绘图机  </li>
<li>VR头显 （<em>好像也属于屏幕没错吧</em>）  </li>
<li>扬声器  </li>
<li>（写入以上提到的任何数据存储设备）</li>
<li>网络链路  </li>
</ul>
<p><br></p>
<hr>
<h2 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a><strong>嵌入式系统</strong></h2><p><strong>嵌入式系统 (Embedded system)</strong>是在较大的机械或电子系统中具有专用功能的计算机系统。<br>它作为完整设备的一部分嵌入，通常包括电气或电子硬件和机械部件。<br>嵌入式系统也可以在更大的系统中运行。系统可以是可编程的或具有固定的功能。</p>
<p>嵌入式系统存在与生活中的方方面面，例如:</p>
<ul>
<li>消费类电子产品:数码相机、MP3播放器、DVD播放器和打印机。</li>
<li>家用电器:微波炉、洗衣机、冰箱。</li>
<li>医疗设备:心脏监测器、血糖仪和x光机。</li>
<li>汽车系统:发动机控制单元(ECUs)，安全气囊控制器和防抱死制动系统(ABS)。</li>
<li>工业自动化系统:可编程逻辑控制器(plc)，监控和数据采集(SCADA)系统，分布式控制系统(DCS)。</li>
</ul>
<p>嵌入式系统被设计为在一个更大的机械或电子系统中执行一个特定的功能。它们通常是一个完整设备的一部分，包括电气或电子硬件和机械部件。  </p>
<p>嵌入式系统被编程以执行它所设计的特定功能。例如，洗衣机中的一个嵌入式系统可能被编程为控制水温和旋转周期。同样，数码相机中的嵌入式系统可能被编程为控制快门速度和光圈。</p>
<p><br></p>
<hr>
<h2 id="内存组件"><a href="#内存组件" class="headerlink" title="内存组件"></a><strong>内存组件</strong></h2><p><strong>随机存取存储器 (Random-access memory, RAM)</strong>和<strong>只读存储器 (Read-only memory, ROM)</strong>是计算机存储器的两种类型。  </p>
<p>RAM是一种易失性存储器，在计算机运行时暂时储存数据。它被称为随机存取存储器，因为任何存储位置都可以被直接访问。RAM用于存储计算机需要快速访问的数据。  </p>
<p>ROM是一种非易失性存储器，可以永久地存储数据。它被称为只读存储器，因为它只能被读取而不能被写入。它被用来存储那些即使在计算机关闭时也需要保留的数据。</p>
<p>RAM是易失性存储器，它暂时储存你正在处理的文件。它的速度比ROM快，可以被写入和读出。RAM用于存储计算机需要快速访问的数据。另一方面，ROM是非易失性存储器，永久地存储计算机的指令。它的速度比RAM慢。ROM用于存储需要保留的数据，即使在计算机关闭时也是如此。</p>
<article class="message is-info"><div class="message-body">

<b>Random-access memory (RAM): volatile memory that can be read from or written to any number of times.</b>

<br>

<b>Read-only memory (ROM): non-volatile memory that cannot be written to but can be read from any number of times.</b>

</div></article> 



<p><br></p>
<p>有两种一般类型的RAM技术。<strong>动态RAM (Dynamic random-access memory, DRAM)</strong>由<strong>易失电的电容 (capacitors that leak electricity)</strong>构成，因此需要定期充电(每隔几毫秒)以保持所存储数据的特性。  </p>
<p><strong>静态RAM (Static RAM, SRAM)</strong>由<strong>触发器 (Flip-flops)</strong>构成，当计算机系统打开时，触发器可以无限地存储数据。  </p>
<p><br></p>
<p>ROM有专门的用途，用于存储数据或程序，这些数据或程序将不加改变地反复使用。在通用系统中，最重要的用途是存储bootstrap程序。这是一个在系统打开后立即运行的程序。<br>在这样的系统中，ROM还有许多其他的用途，其中一些我们将在本书后面看到。此外，ROM被用于许多嵌入式系统。</p>
<p>ROM一共有四种类型：  </p>
<ul>
<li><p>一般来说，ROM中的程序或数据是作为制造过程的一部分安装的。如果需要不同的内容，必须更换芯片。</p>
</li>
<li><p>另一种选择是<strong>可编程ROM (Programmable ROM, PROM)</strong>。芯片的制造商向系统建造者提供芯片。系统构建者将程序或数据安装到芯片中。这允许系统构建者在提交整个批次被编程之前测试一些编程芯片的样本。与最简单的ROM一样，程序或数据一旦安装就不能更改。</p>
</li>
<li><p>一种更灵活的ROM类型是<strong>可擦除PROM (Erasable programmable ROM, EPROM)</strong>。已安装的数据或程序可以被擦除（使用紫外线），并可以安装新的数据或新的程序。   然而，这种重新编程通常需要将芯片从电路中移除。  </p>
</li>
<li><p>最灵活的ROM类型是<strong>电可擦除式PROM(Electricity Erasable Programmable ROM, EPROM)</strong>。顾名思义，它的工作方式与EPROM类似，只是可以用电信号来删除现有数据。这有一个主要的优点，即当内容被改变时，芯片可以留在电路中。然而，该芯片仍作为只读使用。</p>
</li>
</ul>
<p><br></p>
<hr>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h3><p>当数据必须从计算机系统的一个部分传输到另一个部分时，如果发送数据的速度比接收数据的速度快，就会出现问题。该问题的解决方案是使用<strong>缓冲区 (Buffer)</strong>。数据在传输到目的地之前先进入缓冲区。<br>缓冲区的功能类似于一个队列，因此数据按照进入缓冲区的顺序出现。<br>通常，缓冲区是在计算机内存中创建的。</p>
<article class="message is-info"><div class="message-body">

<b>Buffer: a temporary storage created for data transmitted from one part of the system to another which functions as a queue.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="二级存储"><a href="#二级存储" class="headerlink" title="二级存储"></a><strong>二级存储</strong></h2><p>在讨论存储设备之前，我们应该介绍一些术语。<br>对于任何硬件设备，无论是计算机系统的组成部分还是与之相连的外设，其运行都需要安装适当的软件。这个软件被称为“设备驱动程序”。<br>这不应该与术语“驱动器”相混淆，特别是与存储设备相关联。  </p>
<p>这一术语最初指的是硬件，即介质在物理上向其传输数据或从其读取数据。然而，就像经常发生的那样，这种区别经常被忽略。因此，例如，“hard disk”，“hard disk drive”或“hard drive”具有相同的含义。</p>
<p><br></p>
<hr>
<h3 id="磁性介质"><a href="#磁性介质" class="headerlink" title="磁性介质"></a><strong>磁性介质</strong></h3><p>磁介质长期以来一直是文件存储技术的支柱。<br>录音磁带的发明比计算机的发明早了许多年。因此，磁带是第一个存储设备。<br>相比之下，硬盘是专门为计算机存储而发明的。硬盘也利用磁化来写入数据，它是在磁带首次用于存储几年之后出现的。  </p>
<p>对于任何一种类型的磁性介质，与它的相互作用是由一个读头和一个写头控制的。磁头使用的基本物理定律是：磁化状态会影响电学特性，写头使用相反的规律。<br>虽然它们是独立的设备，但两个磁头会合并为一个读写磁头。磁化的两种不同状态被解释为输入或输出。  </p>
<p>磁盘的结构一般遵循这些特性：  </p>
<ul>
<li>磁盘里面有很多层盘。  </li>
<li>每一层盘的两面都可以存储数据，读取或者写入。  </li>
<li>盘的转动速度是一致的。  </li>
<li>读写头被连接到驱动器臂上，驱动器臂允许读写头在盘片表面上移动。  </li>
<li>每个读写头的运动与其他层读写头的运动同步。  </li>
<li>在读写头与盘面之间有一层空气，防止磁头接触磁盘表面。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="光学介质"><a href="#光学介质" class="headerlink" title="光学介质"></a><strong>光学介质</strong></h3><p>与磁带介质一样，光存储是由与计算系统无关的现有技术发展而来的。<br>光盘(CD)演变成CD数字音频(CD-DA)，这成为CD-ROM中使用的技术。它被广泛用于分发软件，但还是无法所谓软盘的替代品。<br>后来出现的读写版本(CD-RW)最终意味着CD完全可以替代软盘。<br>然而，CD现在已经让位于DVD(最初是“数字视频光盘”，但后来改名为“数字多功能光盘”)。<br>最新和最强大的技术是蓝光光碟(BD)。</p>
<p>光盘驱动器的设计原理图如下图所示。它可以读取波长为780纳米的红外激光CD或波长为680纳米的红色激光DVD。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe86af2b6d461a61a8a06c13ef35f3c08?method=download&amp;shareKey=fe963d3b4dfd752b223ffe0853adbebb" alt=""></p>
<p>我们可以忽略驱动器构造的细节，而专注于它如何运作的原理。<br>从磁盘读取数据的过程的重要特性如下:  </p>
<ul>
<li>光盘有一条从表面的内端到外缘的螺旋轨道。  </li>
<li>在读取数据的过程中，光盘会转动。  </li>
<li>同时，激光会持续聚焦在螺旋轨道上。  </li>
<li>光盘的表面凹凸不平，有坑(pits)和地(lands)。</li>
<li>发射的光线会从盘面反射。  </li>
<li>坑反射与地反射之间的差异是可被检测。</li>
<li>探测器接收到的光的强度差可以解释为1或0，以便从光盘中读取二进制代码。  </li>
</ul>
<p><br></p>
<p>对于CD-RW和DVD-RW技术，光盘的反射面是由一种特殊的合金材料制成。当数据被写入光盘(“烧录”过程)时，这种材料会吸收激光所产生的热量使材料变为液体形式。<br>根据激光强度的不同，材料冷却后会恢复成晶体或非晶态固体形式。<br>当光盘读取时，激光从晶体固体反射而不是从非晶固体反射，从而允许编码为1或0。</p>
<p><br></p>
<hr>
<h3 id="固体介质"><a href="#固体介质" class="headerlink" title="固体介质"></a><strong>固体介质</strong></h3><p>尽管光学存储技术不断地改进，固态存储器一直是一个巨大的竞争对手。<br>固态存储器的基础是 <strong>“闪存”存储器 (“Flash” memory)</strong>，这是一种没有运动部件（如硬盘的读写头）的半导体技术。  </p>
<p>这样的电路由作为记忆单元的晶体管阵列组成，在这里常用的技术称之为”NAND”，因为其基本电路类似于NAND逻辑门。  </p>
<p>所有的存储单元串联在一起，对存储器的写入和读取的操作是由 <strong>NAND闪存控制器 （NAND flash controller）</strong>。它的特别之处在于，存储单元块的内容可以“在瞬间”被全部删除。  </p>
<p>此外，在将数据写入内存中的一个单元区块之前，必须将该区块内的所有内容先删除。一个内存块有很多好几页内存组成，在读取数据时，一次操作只可以读取一页数据。  </p>
<p>最常使用的是在<strong>记忆卡 (Memory card)</strong>或<strong>USB闪存驱动器 (USB Flash drive, or Memory stick)</strong>。<br>在后一种情况下，闪存被集成到一个设备中，该设备的内存芯片连接到一个标准的USB连接器。这是目前可移动数据存储的技术选择。<br>由于诸如相变随机存取存储器(PRAM)等替代技术已经在开发中，这种USB闪存技术一统江山的现状会持续多久尚不确定。</p>
<p><strong>固态硬盘 (Solid state drive, SSD)</strong>是现在市面上很常见的存储产品。由于固态硬盘没有移动部件，像机械硬盘那样的读写头，很多人认为固态硬盘的存储完全可以伴随我们一辈子。  </p>
<p>但实际上不是这样的。  </p>
<p>随着我们对固态硬盘的使用，里面的内存颗粒会慢慢退化，进而丢失数据。不过好消息是我们有方法可以检测出有问题的部分并加以修正。  </p>
<p>SSD与传统硬盘相比最大的优点就是读取速度超快。  </p>
<p><br></p>
<hr>
<h2 id="通用输出设备"><a href="#通用输出设备" class="headerlink" title="通用输出设备"></a><strong>通用输出设备</strong></h2><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a><strong>显示</strong></h3><p>在第1章我们讲述了如何将图像存储为由像素构成的位图(bitmap)。<br>屏幕显示也是基于像素的概念，但有一个主要的区别。<br>一个屏幕像素由三个子像素组成，通常分别代表红、绿、蓝。<br>通过改变各个子像素发出的光的水平，可以显示出全范围的颜色。</p>
<p>显示技术这几年迭代的速度十分的快。  </p>
<p>在最初的<strong>阴极射线管(Cathode ray tube ,CRT)</strong>技术中，每一个像素没有单独的组件支撑起发光的任务。<br>屏幕的内表面覆盖着荧光粉，当电子落在这种荧光粉上时候屏幕就会发光。通过控制电子束的方向，来点亮特定的像素。<br>彩色CRT显示器有独立的红色、绿色和蓝色荧光粉，以像素阵列排列。  </p>
<p>现在，平板显示技术占据市场的一大半。<br>以<strong>液晶显示技术 (Liquid-crystal display, LCD)</strong>为例：它使用包含液晶的单个单元来创建每个像素。<br>像素矩阵由一个统一的背光 (Backlight)来照明，每个像素都可以控制光的传输，从而创建屏幕上的图像，如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB616876cfe5bd36e2221d7be528db3dd9?method=download&amp;shareKey=cf5b535a73ff18c827a170267f28fdfe" alt=""></p>
<p>背光照明通常由<strong>发光二极管(LED)</strong>提供。<br>偏振光会指向像素矩阵，并且在像素矩阵和屏幕之间放置更多的偏振器。<br>如果电压施加到单个像素单元，就会影响液晶分子的排列，然后改变光的偏振光，从而改变屏幕上显示的内容。  </p>
<article class="message is-info"><div class="message-body">

<b>Liquid-crystal display (LCD): a screen back-lit by light-emitting diodes and with liquid crystal cells sandwiched between polarisers.</b>

</div></article> 



<p><br></p>
<hr>
<h3 id="文本输出"><a href="#文本输出" class="headerlink" title="文本输出"></a><strong>文本输出</strong></h3><p>有两种技术已经开始主导从计算机系统中存储的数据打印文档。这些是<strong>喷墨打印机 (Inkjet printer)</strong>和<strong>激光打印机 (Laserjet printer)</strong>。这两种技术都可以用于打印文本或图像。  </p>
<p>喷墨打印机的工作原理如下:  </p>
<ol>
<li>填入一张纸  </li>
<li>打印头在纸上移动，将墨水打在纸上  </li>
<li>纸张向前移动一点位置，打印头再次在纸上移动。</li>
<li>这个过程一直持续到纸张完全打印出来。</li>
<li>打印头由喷嘴组成，将液滴喷在纸上。墨水从一个或多个墨盒供应到打印头。</li>
</ol>
<p>激光打印机的步骤就相对复杂些了：  </p>
<ol>
<li>给硒鼓施加一个电荷。  </li>
<li>硒鼓开始旋转。  </li>
<li>在每一个步骤中，激光束被镜子和其他光学组件引导到硒鼓上的不同位置。  </li>
<li>被激光照射到的硒鼓表面会使得电荷存在或者剥离。  </li>
<li>这个过程重复执行，直到整个硒鼓上面产生了完整的静电图像。  </li>
<li>硒鼓被涂上一层带电的碳粉，这些碳粉只粘在硒鼓表面被释放电荷的位置。  </li>
<li>硒鼓在一张赋予电荷的纸上面移动。  </li>
<li>最后将纸张排出的同时，使用加热过的轮子来融化碳粉，是的碳粉融合，形成图像。  </li>
<li>在打印下一张文件之前，硒鼓上面的电荷会全部被排掉。  </li>
</ol>
<p><br></p>
<hr>
<h2 id="通用输入设备"><a href="#通用输入设备" class="headerlink" title="通用输入设备"></a><strong>通用输入设备</strong></h2><p>键盘允许用户输入文本数据。<br>在文本输入过程中，似乎只要按下一个键，就会立即将相应的字符传输到计算机屏幕上，但这是错误的。按键必须先转换为<strong>字符编码(Character code)</strong>，然后传输给处理器。随后，处理器会在操作系统的控制下，确保文本字符在屏幕上显示。<br>如果使用键盘发起某些操作，也会发生相同的过程，例如使用快捷键组合。不同之处在于，处理器必须采取所请求的操作进行响应。</p>
<p>为了实现这个功能，键盘有电路和它自己的微处理器和ROM芯片。键盘如何工作的重要细节如下：  </p>
<ol>
<li>按键位于<strong>按键矩阵 (Key matrix)</strong>的正上方。按键矩阵由一组行列导线组成。  </li>
<li>按下一个按键后，按键会与导线产生接触，这就会使得行列导线连通，从而允许电流通过。  </li>
<li>随后，微处理器会不断地检测是否存在电路闭合。如果电路闭合，那么微处理器就可以识别出哪里出现了电路闭合。  </li>
<li>然后，处理器使用存储在ROM中的数据来识别与该交叉点相关联的字符代码，然后将这个字符发送给计算机。  </li>
</ol>
<p><br></p>
<hr>
<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a><strong>GUI</strong></h3><p>通过与屏幕的交互，用户可以通过多种方式输入数据。<br>很久之前，计算机系统用户只能使用键盘和鼠标向电脑交互，然后使用屏幕作为显示器。而且当时的UI十分的简陋，用户的屏幕上只能生成一个菜单，用户可以通过从菜单中输入一个数组来选择一个选项。  </p>
<p>随着<strong>图形化用户界面 (Graphical user interface, GUI)</strong>的普及，用户使用计算机的体验又更上一层楼。具体就是今天的所有图形化操作系统一样，直观，易操作。  </p>
<p><br></p>
<hr>
<h3 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a><strong>触摸屏</strong></h3><p>触摸屏有两种：<strong>电阻式触摸屏 (Resistive touch screen)</strong>和<strong>电容式触摸屏 (Capacitive touch screen)</strong>。  </p>
<p>电阻式触摸屏的上层屏幕不是刚性的，所以当手指按压屏幕的时候，屏幕会发生弯曲。这种弯曲就可以被下层检测出阻值的变化，从而推算出手指触摸的位置。  </p>
<p>但是电阻式触摸屏有一个显著的缺点：他只能支持单点触控，也就是说，只允许同时出现一个物体触控屏幕。  </p>
<p>另一个是电容式触摸屏。它运用了“人体本身是一种带电体”的原理实现了触摸屏。<br>电容式触摸屏不再需要一个软皮屏幕作为表面了，因为当你的手指触碰屏幕的时候，下层的电路元件会检测到电容的变化。  </p>
<p>现在最有效的触控技术是基于互电容的<strong>投射性电容触控(Projective capacitive touch, PCT)</strong>技术。这种技术允许我们在屏幕上多点触控。  </p>
<article class="message is-info"><div class="message-body">

<b>Resistive touch screen: a flexible surface that causes contact between electricity resistive layers beneath when touched.</b>

<br>

<b>Capacitive touch screen:  a grid surface above a conductive layer that undergoes a change in electrical state when a finger touches the screen.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="影像输入"><a href="#影像输入" class="headerlink" title="影像输入"></a><strong>影像输入</strong></h3><p>在计算机中存储和使用图像(图形)数据有几种方法。<br><strong>网络摄像头 (Webcam)</strong>是一种用于将视频图像流式传输到计算机系统的设备。<br><strong>数码相机 (Digital camera)</strong>可以连接到电脑。当链接到电脑时，储存的图像或视频就可以下载到电脑上。  </p>
<p>另一种选择是使用<strong>扫描仪 (Scanner)</strong>。  </p>
<p>实际上，扫描仪颠倒了打印过程，它获取图像并从图像中创建数字表示。<br>首先一张包含图像(可能是文本)的纸被固定在一个固定的位置，光源从纸的一端移动到另一端。它覆盖了纸张的宽度。<br>反射光被一个由镜子和透镜组成的系统引导到一个<strong>电荷耦合器件(Charge-coupled device, CCD)</strong>上。随后CCD就会向计算机发送数据。  </p>
<p>你需要了解下面这些有关于CCD的有趣事实：  </p>
<ul>
<li>CCD由光敏单元阵列组成</li>
<li>CCD产生的电响应与每个电池的光强成正比</li>
<li>CCD需要一个<strong>模数转换器 (Analogue-to-digital converter)</strong>来产生数字值并传输到计算机。</li>
</ul>
<p><br></p>
<hr>
<h2 id="声音的输入与输出"><a href="#声音的输入与输出" class="headerlink" title="声音的输入与输出"></a><strong>声音的输入与输出</strong></h2><h3 id="语音输入输出"><a href="#语音输入输出" class="headerlink" title="语音输入输出"></a><strong>语音输入输出</strong></h3><p>IP电话 (IP Telephony)和视频会议 (Video conferencing)是两种同时需要语音输入和语音输出的应用。此外，语音识别可以作为输入数据到计算机的替代技术，而语音合成正被用于越来越多的应用。  </p>
<p>我们需要一个<strong>麦克风 (Microphone)</strong>来完成声音的输入，这是一种带有隔膜的设备。<br>麦克风中有一种柔性材料，它会因传入的声音而振动。如果膜片连接到合适的电路，振动会引起电信号的变化。<br>电容传声器采用电容变化作为机构;另一种选择是使用压电晶体。模拟电信号通过模数转换器 (ADC)转换成数字信号，以便在计算机内部进行处理。  </p>
<p>同样我们需要一个<strong>扬声器 (Speaker)</strong>完成音频输出工作。它的工作原理实际上是输入的反向过程。  </p>
<p>来自计算机系统的数字数据通过数字模拟转换器转换为模拟。模拟信号以变化的电流的形式供给扬声器。<br>在大多数扬声器中，电流流过一个线圈，线圈悬浮在扬声器中永磁体提供的磁场中。随着电流的大小和方向不断变化，线圈向前和向后移动。<br>这种运动控制着<strong>隔膜 (Diaphragm)</strong>的运动，然后隔膜会产生声音。</p>
<p><br></p>
<hr>
<h1 id="第四章：逻辑门与逻辑电路"><a href="#第四章：逻辑门与逻辑电路" class="headerlink" title="第四章：逻辑门与逻辑电路"></a><strong>第四章：逻辑门与逻辑电路</strong></h1><h2 id="布尔逻辑与问题陈述"><a href="#布尔逻辑与问题陈述" class="headerlink" title="布尔逻辑与问题陈述"></a><strong>布尔逻辑与问题陈述</strong></h2><p>这里有一条陈述：  </p>
<p><code>俄罗斯比新加坡更靠北吗？</code>  </p>
<p>无论这是不是一个低智商问题，他只有两个答案：<strong>是</strong>或者<strong>不是</strong>。<br>放在布尔值里面就是<code>TRUE</code>和<code>FALSE</code>。  </p>
<p><br></p>
<p>我们现在分别假设了以下两个陈述：  </p>
<ul>
<li><p>如果<em>天气预报说一会下雨</em>或者<em>现在正在下雨</em>，你就应该出门带伞。  </p>
</li>
<li><p>只有<em>在工作时间中</em>并且<em>屋内气温高于25<sup>°</sup>C</em>，才可以开启空调。  </p>
</li>
</ul>
<p>像这样的陈述，我们管他叫做问题陈述：  </p>
<article class="message is-info"><div class="message-body">

<b>Problem statement: an informal definition of an outcome which is dependent on one logic proposition or a combination of two or more logic propositions.</b>

</div></article> 

<p><strong>问题陈述：依赖于一个逻辑命题或者两个以上逻辑命题组合的句子。</strong>  </p>
<hr>
<h2 id="布尔运算器"><a href="#布尔运算器" class="headerlink" title="布尔运算器"></a><strong>布尔运算器</strong></h2><p>三个基本的布尔运算器分别是<code>AND</code>， <code>OR</code>和<code>NOT</code>。  </p>
<p>简单说下每一个的表述，A与B都存在两个情况：<code>TRUE</code>或<code>FALSE</code>   </p>
<ul>
<li><code>AND</code>：若A为<code>TRUE</code>，B也为<code>TRUE</code>，则<code>A AND B</code>输出为<code>TRUE</code>。  </li>
<li><code>OR</code>：A或者B两者有一个<code>TRUE</code>，则<code>A OR B</code>输出为<code>TRUE</code>。  </li>
<li><code>NOT</code>：如果A为<code>FALSE</code>，则<code>NOT A</code>为<code>TRUE</code>  </li>
</ul>
<p><br></p>
<p>像这样，我们在上一个小节中列举的例子就可以使用布尔运算器符进行表示了：  </p>
<ul>
<li><p><code>Take_umbrella = TRUE IF (raining = TRUE) OR (rain_forecast = TRUE)</code>  </p>
</li>
<li><p><code>AC_on = TRUE IF (office hours = TRUE) AND (temperature &gt; 25)</code>  </p>
</li>
</ul>
<p>现在我们陈述的问题已经变成了像这样的条件语句。我们管这种语句叫做<strong>逻辑表达式</strong>：  </p>
<article class="message is-info"><div class="message-body">

<b>Logic expression: logic propositions combined using Boolean operators, which may be equated to a defined outcome.</b>

</div></article> 

<p><strong>逻辑表达式：使用布尔运算符组合的逻辑命题，可以推出一个确切的结果。</strong>  </p>
<p><br></p>
<p><br></p>
<p>任何逻辑表达式都可只使用布尔运算<code>AND</code>, <code>OR</code>和<code>NOT</code>表示，但是只用他们三个就有些麻烦，不如使用一些其他的布尔运算：<code>NAND</code>,<code>NOR</code>和<code>XOR</code>  </p>
<ul>
<li><code>NAND</code>:如果A是<code>FALSE</code>或者B是<code>FALSE</code>，则<code>A NAND B</code>输出为<code>TRUE</code>。  </li>
<li><code>NOR</code>:若A为<code>FALSE</code>，B也为<code>FALSE</code>，则<code>A NOR B</code>输出为<code>TRUE</code>。  </li>
<li><code>XOR</code>:如果A是<code>TRUE</code>或者B是<code>TRUE</code>，而且两者都不能同时是<code>TRUE</code>，<code>A XOR B</code>会输出为<code>TRUE</code>。  </li>
</ul>
<p>等到了学逻辑门的那一节，我再画一个汇总表格。  </p>
<p><br></p>
<hr>
<h2 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a><strong>真值表</strong></h2><p>真值表简单又强大，可以用来表示任何逻辑表达式或者描述逻辑电路的可能输出结果。  </p>
<p>在真值表内，我们将<code>TRUE</code>定义为1，<code>FALSE</code>定义为0。这样可以很简单地表示出有关布尔运算的任何逻辑。  </p>
<p>真值表中的表头分A，B和X。<br>A列和B列代表最初开始的值，而X列则代表经过逻辑运算之后得出的值。<br>也可以通过一个等式表示：<code>X = A AND B</code>。  </p>
<p>这里我们以<code>AND</code>作为一个例子：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h2 id="逻辑电路与逻辑门"><a href="#逻辑电路与逻辑门" class="headerlink" title="逻辑电路与逻辑门"></a><strong>逻辑电路与逻辑门</strong></h2><p>构成计算机系统的内部电路都由逻辑电路运行。这些电路的每个状态要么就是开，要么就是关。（1和0）  </p>
<p>逻辑电路由一个叫做逻辑门的部件组成，每一个不同的逻辑门都对应着一个布尔运算。  </p>
<article class="message is-info"><div class="message-body">

<b>Logic gate: a component of a logic circuit that has an operation matching that of a Boolean operator.</b>

</div></article> 

<p><br></p>
<p><br></p>
<p>逻辑门都有他们自己的符号，下图展示了每种逻辑门所对应的布尔运算，图标，和真值表。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc4c86bb95bdd7c5362e832da16aaf91c?method=download&amp;shareKey=61cee546e9bb8ad8e26ba776d9b0d77d" alt=""></p>
<p><br></p>
<p>特别提及以下几点：  </p>
<ul>
<li><code>NOT</code>门是一个特例，由于他的输出是他的输入的相反值，<code>NOT</code>只有一个输出。  </li>
<li><code>NAND</code>门实际上是<code>AND</code>门紧接着跟了一个”NOT”。  </li>
<li><code>NOR</code>门实际上是<code>OR</code>门后面跟了一个”NOT”。  </li>
<li><code>NAND</code>和<code>NOR</code>门产生了与<code>AND</code>和<code>OR</code>一样的互补输出。  </li>
<li><code>XOR</code>是比较输入的两个数据是否不同。<strong>相同输出0，不同输出1</strong>。</li>
</ul>
<p><br></p>
<p><br></p>
<p>如果想要从真值表构建逻辑电路，我们首先要创建逻辑表达式。<br>要做到这一点，我们只需要看看真值表里面输出为1的行。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>我们发现表格中有三行的输出为1，这三行分别是：  </p>
<p><code>A = 0, B = 0 and C = 1</code><br><code>A = 0, B = 1 and C = 1</code><br><code>A = 1, B = 0 and C = 0</code>  </p>
<p><em>以上三行中出现的and不代表逻辑运算</em>  </p>
<p>每一行都可以转换成这样的逻辑表达式：  </p>
<p><code>NOT A AND NOT B AND C</code><br><code>NOT A AND B AND C</code><br><code>A AND NOT B AND NOT C</code>  </p>
<p>然后再将这三行结合起来：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NOT A AND NOT B AND C</span><br><span class="line">OR</span><br><span class="line">NOT A AND B AND C</span><br><span class="line">OR A AND NOT B AND NOT C</span><br></pre></td></tr></table></figure>
<p>现在这个结果就可以用于创建逻辑电路了，但是这个电路是非常复杂的。<br>在后面的第19章，我们会去讲解如何在指定逻辑问题下写出最简便的电路。</p>
<p><br></p>
<hr>
<h1 id="第五章：处理器基本原理"><a href="#第五章：处理器基本原理" class="headerlink" title="第五章：处理器基本原理"></a><strong>第五章：处理器基本原理</strong></h1><h2 id="冯·诺依曼结构"><a href="#冯·诺依曼结构" class="headerlink" title="冯·诺依曼结构"></a><strong>冯·诺依曼结构</strong></h2><p>初中小宝宝都知道的基本知识：  </p>
<p>冯·诺依曼是第一位解释计算机基本结构原则的人。  </p>
<p>符合冯·诺依曼结构 (von Neumann model) 的计算机符合以下几个条件：  </p>
<ul>
<li>处理器 （CPU） - 负责处理数据<ul>
<li>处理器可以直接访问内存  </li>
<li>处理器按顺序执行指令  </li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>内存包含一个“<strong>s存储程序 (Stored program)</strong>”和该程序所需的数据<ul>
<li>‘存储程序’可以在任何时候被另一个程序替换</li>
<li>存储程序由独立的指令组成  </li>
</ul>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="中央处理器（CPU）的结构"><a href="#中央处理器（CPU）的结构" class="headerlink" title="中央处理器（CPU）的结构"></a><strong>中央处理器（CPU）的结构</strong></h2><p>中央处理器 (Central Processing Unit),简称CPU。  </p>
<p>结构图示如下：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB07bdb35bcc4604f42d278288fd7ca8c8?method=download&amp;shareKey=0ef5ed620db555623249697d0ad7a588" alt="CPU结构图"></p>
<p>然后我们拆开讲解：  </p>
<p><br></p>
<hr>
<h3 id="CPU的活动部分"><a href="#CPU的活动部分" class="headerlink" title="CPU的活动部分"></a><strong>CPU的活动部分</strong></h3><p>CPU的主要活动部分有两部分：   </p>
<p><strong>Arithmetic Logic Unit (ALU) ：算术逻辑单元</strong>  </p>
<p>算术逻辑单元是中央处理器的执行单元，进行整数运算的结构。<br>这是个能实现多组算术运算和逻辑运算的组合逻辑电路，是所有中央处理器的核心组成部分。<br>用逻辑门构成的算数逻辑单元，主要进行二位元的算术运算，比如说加减乘。（没有整数除法）  </p>
<p><br></p>
<p><strong>Control unit : 控制单元</strong>  </p>
<p>控制单元负责程序的流程管理，是整个CPU的指挥和控制中心。 </p>
<p>由三个部件组成：  </p>
<p><strong>Instruction Register (IR) ： 指令寄存器</strong><br><strong>Instruction Decoder (ID) ： 指令译码器</strong><br><strong>Operation Controller (OC) ： 操作控制器</strong>  </p>
<p>基本功能是从内存取指令、分析指令和执行指令。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>在控制单元内有一个重要部分，那就是时钟。<br>控制单元通过时钟来同步处理过程。  </p>
<p>时钟分两种： <strong>Internal clock</strong> 和 <strong>System clock</strong>  </p>
<article class="message is-info"><div class="message-body">

<b>Internal clock: controls the cycles of activity within the processor.</b>
<br>
<br>
<b>System clock: controls the cycles of activity outside the processor.</b>

</div></article> 

<p>Internal clock控制处理器内活动周期。<br>System clock控制处理器外部活动。  </p>
<p><br></p>
<hr>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p><strong>Register</strong>，叫做<strong>寄存器</strong>  </p>
<p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。<br>之前提到过，寄存器在所有的存储单位里面，与CPU的交互是最快的，造价也是最高的。<br>因为寄存器的位置挨着ALU （算术逻辑单元），所以的读写速度会比较快。<br>寄存器的存储空间都很小，差不多就16、32或者64bits。  </p>
<p><br>  </p>
<p>寄存器有<strong>通用的(General purpose)</strong>，也有<strong>专用的(Special purpose</strong>)。<br>如果只存在一个通用寄存器，我们会称其为<strong>累加器 (Accumulator)</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Accumulator: a general-purpose register that stores a value before and after the execution of an instruction by the ALU.</b>

</div></article> 

<p>上面说：<strong>累加器一种通用寄存器，会在ALU（算术逻辑单元）执行指令之前和之后存储一个值。</strong><br>或者说：<strong>累加器是一种寄存器，用来储存计算产生的中间结果。</strong>  </p>
<p>如果没有累加器的存在，在每次进行一次计算（加法，乘法，移位等）之后都会把结果写进内存，即便这个结果会马上在接下来的一个运算中直接使用。<br><em>这样就太慢了。</em>  </p>
<p><br></p>
<hr>
<p><br></p>
<p>专用寄存器也各不相同。下面这张表列出了一些专用寄存器。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Register name<br>(寄存器名称)</th>
<th style="text-align:center">Abbreviation<br>(缩写)</th>
<th style="text-align:center">Register’s function<br>(功能)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Current instruction register<br>(当前指令寄存器)</td>
<td style="text-align:center"><strong>CIR</strong></td>
<td style="text-align:center">Stores the current instruction while it is being decoded and executed.<br>(<strong>在对当前指令进行解码和执行时存储该指令</strong>)</td>
</tr>
<tr>
<td style="text-align:center">Index register<br>(变址寄存器)</td>
<td style="text-align:center"><strong>IX</strong></td>
<td style="text-align:center">Stores a value; only used for indexed addressing.<br>(<strong>可以存储一个值，而且只用于索引寻址</strong>)</td>
</tr>
<tr>
<td style="text-align:center">Memory address register<br>(储存器地址寄存器)</td>
<td style="text-align:center"><strong>MAR</strong></td>
<td style="text-align:center">Stores the address of a memory location or an I/O component which is about to have a value read from or written to.<br>(<strong>存储即将对其进行读取或写入的内存位置或I/O组件的地址</strong>)</td>
</tr>
<tr>
<td style="text-align:center">Memory data register<br><del>memory buffer register</del><br>(内存资料寄存器)</td>
<td style="text-align:center"><strong>MDR</strong></td>
<td style="text-align:center">Stores data that has just been read from memory or is just about to be written to memory.<br>(<strong>存储刚从内存中读取或者即将写入内存的数据</strong>)</td>
</tr>
<tr>
<td style="text-align:center">Program counter<br>(程序计数器)</td>
<td style="text-align:center"><strong>PC</strong></td>
<td style="text-align:center">Stores the address of where the next instruction is to be read from.<br>(<strong>存储从哪里读取下一条指令的地址</strong>)</td>
</tr>
<tr>
<td style="text-align:center">Status register<br>(状态寄存器)</td>
<td style="text-align:center"><strong>SR</strong></td>
<td style="text-align:center">Contains bits that are either set or cleared which can be referenced individually.<br>(<strong>用来存放指令招待后的有关CPU的状态</strong>)</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h2 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a><strong>系统总线</strong></h2><p><strong>System bus</strong>,又名曰<strong>系统总线</strong>。<br>不过我们需要先理解什么是<strong>总线(Bus)</strong>。  </p>
<p><strong>总线是连接多个部件的信息传输线，是各部件共享的传输介质。</strong><br>而<strong>系统总线，是CPU、主存、I/O设备各大部件之间的信息传输线。</strong>  </p>
<p>系统总线分为三部分：<strong>地址总线 (Address bus)</strong>， <strong>数据总线 (Data bus)</strong> 和 <strong>控制总线 (Control bus)</strong>:  </p>
<p><br></p>
<p>CPU，内存和I/O与这三部分的总线的关系如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB37ba6027dba5bb7a263b7296bf187d34?method=download&amp;shareKey=b9069a1484092bd4c59ef1257ce6c201" alt="System bus">  </p>
<p>接下来一个一个说这些总线都是写啥。  </p>
<p><br></p>
<hr>
<h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a><strong>地址总线</strong></h3><p>定义：  </p>
<article class="message is-info"><div class="message-body">

<b>Address bus: a component that carries an address.</b> This can be to the memory controller to identify a location in memory which is to be read from or written to or it can be to the I/O system to identify the source or destination of the data.

</div></article> 

<p><strong>地址总线 (Address bus)：用来指出数据总线上的源数据或目的数据在主存单元的地址或I/O设备的地址。</strong>  </p>
<p>地址总线的唯一功能是携带地址。  </p>
<p>当控制单元给到了一个命令后，地址会从MAR（储存器地址寄存器）中加载到总线上。<br>一个地址制定了内存中的一个位置，或者一个待接受的数据，亦或者是从中读取数据的一个I/O组件。  </p>
<p><strong>地址总线是单向的</strong>，所以说<strong>它只能向内存控制器 (Memory controller)或者I/O控制器 (I/O Controller)发送地址，不能用于将地址传回到CPU。</strong>  </p>
<p><br></p>
<p>地址总线的带宽定义了地址的二进制代码中的位数。<br>以一个很基础的计算机系统为例子：总线带宽是16位，因此它允许65536个 (2<sup>16</sup>)内存位置被直接寻址。  </p>
<p>不过对于现代计算机系统来说，这点儿内存是完全不够用的：即便将地址总线的宽度增加到32位，也仅仅允许40多亿个地址进行直接寻址。  </p>
<p>因此当内存容量比直接寻址大得多的时候，我们会使用到一些特殊技巧。  </p>
<p><br></p>
<hr>
<h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a><strong>数据总线</strong></h3><article class="message is-info"><div class="message-body">

<b>Data bus: a component that can carry data from the processor to the memory or to an output device or can carry data from the memory or from an input device.</b>

</div></article> 


<p><strong>数据总线 (Data bus)：用来传输各功能部件之间的数据信息。</strong>   </p>
<p>数据总线的功能是传送数据，传输的数据可以是指令，地址，也可以是一个确切的值。  </p>
<p><strong>数据总线是双向的(Bidirectional)</strong>，这意味着它可以将数据从CPU传输到内存，也可以从内存传输到CPU。<br>同样的，数据总线也可以选择将数据传入I/O设备，或者从I/O设备传出数据。  </p>
<p>在上面的那张图里面，没有明确表示出从输入设备发来的数据是先传输到CPU还是存储器里面，这么做是有依据的。<br>比如：部分计算机系统只允许数据存储在内存之前输入CPU，也有的系统允许数据直接传输到内存。  </p>
<p><br>  </p>
<hr>
<h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a><strong>控制总线</strong></h3><p><strong>控制总线 (Control bus)： 用来发出各种控制信号的传输线。</strong>  </p>
<p><del>书上没有定义</del>  </p>
<p>控制总线的主要用途是<strong>传送定时信号</strong>。<br>控制总线以时钟周期规定的时间间隔，传输定时信号，这就确保了一个组件传输数据的时间和另一个组件读取数据的时间同步。  </p>
<p><strong>数据总线也是双向的(Bidirectional)</strong>，数据总线将信号从控制单元传输到任何其他的系统部件，或者将信号传回到控制单元。  </p>
<p>数据总线没啥必要拓宽带宽，所以数据总线一般有八条导线。  </p>
<p><br></p>
<hr>
<h2 id="左右系统性能的因素"><a href="#左右系统性能的因素" class="headerlink" title="左右系统性能的因素"></a><strong>左右系统性能的因素</strong></h2><p>首先是处理器时钟速度。  </p>
<p>处理器时钟速度<em>可能是</em>决定系统处理速度的一个重要因素。因为<strong>一个时钟周期定义了任何操作可以采取的最短时间</strong>。但是“可能是”也是有原因的，因为并不是所有的部件都可以像CPU那样飞速计算。  </p>
<p>因为这个问题，一个现代的CPU的结构远比我们讨论的CPU结构复杂。<br>比如说，现在的CPU基本都是多核的，每一个核都是一个单独的处理器，CPU性能也会随着核心数量的增加而增加。而且现代CPU的高速缓存一般都全部封装在CPU的内部，因此达到最快的访问速度。  </p>
<p>在继续下面的内容之前，我们需要了解什么是字。  </p>
<h3 id="字"><a href="#字" class="headerlink" title="字"></a><strong>字</strong></h3><p>没错，这东西就叫字。  </p>
<article class="message is-info"><div class="message-body">

<b>Word: a small number of bytes that can be handled as a unit by the computer system.</b>

</div></article> 

<p>*<em>一个小的字节数,可以由计算机系统作为一个单元处理</em>  </p>
<p><strong>计算机进行数据处理时，一次存取、加工和传送的数据长度称为字 (Word)。</strong><br><strong>计算机的每个字所包含的位数称为字长。</strong></p>
<p><br></p>
<p>一个字通常由一个或多个（一般是字节的整数位）字节构成，<strong>计算机的字长决定了其CPU一次操作处理实际位数的多少</strong>，由此可见计算机的字长越大，其性能越优越。  </p>
<p>多多少少与你操作系统的位数有关，典中典的字长，有16、32或者64位，分别是2、4、8字节。  </p>
<p>字长将会影响组件存储容量和架构方面的设计。比如说，寄存器的大小一般都会与字长匹配，字长也会影响总线带宽。  </p>
<p><br></p>
<hr>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a><strong>I/O</strong></h2><p><strong>I/O，全称(Input/Output)，代表输入/输出。</strong>  </p>
<p>我们一般指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。  </p>
<p>每一个I/O设备都会被连接到一个叫做“端口”的接口，每个端口都连接到I/O或者设备控制器 (Device controller)。  </p>
<p>顺带一提<strong>设备控制器 (Device controller)负责处理CPU和I/O设备之间的交互。</strong>  </p>
<p>如果连接的I/O设备是计算机系统的一个组成部分，我们就将连接它的端口叫做内部端口。<br>反之，连接其他外围I/O设备的端口，叫做外部端口。  </p>
<p><br></p>
<hr>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a><strong>USB</strong></h3><p>简单说下USB。  </p>
<p><strong>USB，全程 Universal Serial Bus,译为通用串行总线。</strong><br>现在你可以在几乎任何设备上见到它。  </p>
<p>USB的出现至关重要。在USB诞生之前，普通用户一般不会去尝试添加外设，因为当时添加外设需要一定的技术知识。  </p>
<p>USB的出现推动了即插即用技术的发展，即插即用技术诞生的目标就是消除人们对于技术水平的需求，所以任何计算机用户都可以连接他们需要的外设。即插即用只有通过创建USB标准才能实现。  </p>
<p>*<em>USB是一条总线，USB驱动器存储数据并连接到USB端口，USB端口允许数据沿着总线传输。</em>  </p>
<p><br></p>
<hr>
<h3 id="专用多媒体端口"><a href="#专用多媒体端口" class="headerlink" title="专用多媒体端口"></a><strong>专用多媒体端口</strong></h3><p>这也不代表着所有的外部设备都使用这USB作为数据传输的媒介：一些特定的设备需要特定的接口。  </p>
<p>在几年之前(<em>HDMI还不算流行的日子</em>)，投影仪或者显示器之类的设备选择使用VGA (Video Graphics Array : 视频图形阵列)接口进行连接，传输视频流。  </p>
<p>而现在，这类设备都基本采用的DP(Displayport)接口或者HDMI(High Definition Multimedia Interface : 高清多媒体接口)接口，其中一个原因是VGA并不支持传输音频数据。  </p>
<p><br></p>
<hr>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a><strong>指令周期</strong></h2><p>指令周期，又名读取－执行周期 (fetch-and-execute cycle)，指的是CPU要执行指令需要经过的步骤。  </p>
<p>计算机之所以能自动地工作，是因为CPU能从存放程序的内存里取出一条指令并执行这条指令；紧接着又是取指令，执行指令，如此周而复始，构成了一个封闭的循环。除非遇到停机指令，否则这个循环将一直继续下去。  </p>
<p>下图展示了一个指令周期的结构：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8880a148d3160e94b1183f21b8cdff9e?method=download&amp;shareKey=621a92c868fbda37e22608bdb0c8bb51" alt="Fetch-execute cycle">  </p>
<p>图中，我们假设程序已经在运行。所以程序计数器就会找到下一条指令的地址。  </p>
<p>在提取阶段，会执行以下步骤：  </p>
<ol>
<li>首先，下一个指令的地址会存在程序计数器(Program counter，可写作PC)中。这个地址会先被传送到MAR(Memory address register)中。  </li>
</ol>
<p>随后处理器开始工作。  </p>
<ol>
<li><p>在下一个时钟周期内，这两件事会同时发生：  </p>
<ul>
<li>在MAR所指向的地址中保存的指令被提取到MDR(Memory data register)中</li>
<li>程序计数器(Program counter)中存储的地址+1。  </li>
</ul>
</li>
<li><p>然后在MDR中存储的指令会在CPU中传输到CIR(Current instruction register)<br>这里需要注意两点：  </p>
<ul>
<li>时钟周期是由系统时钟控制的周期。系统时钟将有设置，允许在为一个周期定义的时间内从内存发生一次数据传输。  </li>
<li>在最后一步中，程序计数器会加一。但是如果刚才加载的指令是一个跳转指令，程序计数器就必须根据跳转条件更新程序计数器的内容。这一步只会在指令被解码之后发生。  </li>
</ul>
</li>
</ol>
<p>在解码阶段，存储在CIR中的指令就会作为输入内容，被控制单元内的电路读取。根据指令的类型，控制单元会向适当的组件发送信号，准备开始执行阶段。<br>在执行阶段内，如果指令需要算数或者逻辑处理，就会把ALU拉下水。  </p>
<p><br></p>
<hr>
<h2 id="寄存器传输语言"><a href="#寄存器传输语言" class="headerlink" title="寄存器传输语言"></a><strong>寄存器传输语言</strong></h2><p><strong>寄存器传输语言 (Register transfer notation)，表示了寄存器数据传输操作和各模块内部和模块之间连接关系的记法。</strong>  </p>
<p>涉及到寄存器的操作可以通过这种语言描述。<br>举个例子，一个完整的指令周期的fetch阶段可以被这样表示：  </p>
<p>    <code>MAR ⬅ [PC]</code>  </p>
<p>    <code>PC ⬅ [PC] + 1; MDR ⬅ [[MAR]]</code>  </p>
<p>    <code>CIR ⬅ [MDR]</code></p>
<p>在寄存器传输记法中，单个数据传输的基本格式与变量赋值的格式相似。  </p>
<p><strong>箭头左边的那一项是数据的目的地</strong>，这里使用适当的缩写来标识特定的寄存器。<br><strong>箭头右边是那个数据的定义</strong>。在这个定义中，<strong>寄存器缩写周围的方括号表示正在移动寄存器的内容</strong>，这个动作也可能包括一个算术运算。<br><strong>当两个数据操作放在由分号分隔的同一行上时，这意味着两个传输同时进行</strong>。<br>第二行的两对方括号需要注意下：MAR的内容是一个地址;它是该地址的内容，正在被转移到MDR</p>
<p>两队方括号代表<strong>CPU必须进行一个逻辑处理，然后才能复制该值。</strong></p>
<p><br></p>
<hr>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a><strong>中断处理</strong></h2><p>计算机有很多情况会产生中断。比如说：  </p>
<ul>
<li>程序中的一个严重错误  </li>
<li>硬件问题  </li>
<li>等待I/O开始处理数据  </li>
<li>用户交互  </li>
<li>一个计时器信号  </li>
</ul>
<p>在产生了中断后，我们需要处理这些发生的中断。每一个不同的中断需要进行合适的处理，不同的中断还会有不一样的优先级，因此，处理器就必须具备判断中断类型的能力。  </p>
<p>在处理器中加入一个中断寄存器可以是一个方法。它的工作方式与状态寄存器很相似：每一个单独的bit都作为特定类型中断的标志。  </p>
<p><br></p>
<hr>
<h1 id="第六章：汇编语言程序设计"><a href="#第六章：汇编语言程序设计" class="headerlink" title="第六章：汇编语言程序设计"></a><strong>第六章：汇编语言程序设计</strong></h1><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a><strong>机器码</strong></h2><h3 id="操作码与操作数"><a href="#操作码与操作数" class="headerlink" title="操作码与操作数"></a><strong>操作码与操作数</strong></h3><p>在深入了解什么是机器码之前，我们需要先了解什么是操作码和操作数。</p>
<p><br></p>
<hr>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Opcode: defines the action associated with the instruction</b>

</div></article> 

<p><em>操作码:定义与指令相关联的操作</em>  </p>
<p>操作码指计算机程序中所规定的要执行操作的那一部分指令或字段。其实就是指令序列号，用来告诉CPU需要执行哪一条指令。  </p>
<p>指令系统的每一条指令都有一个操作码，它表示该指令应进行什么性质的操作。<br>不同的指令用操作码这个字段的不同编码来表示，每一种编码代表一种指令。组成操作码字段的位数一般取决于计算机指令系统的规模。</p>
<p><br></p>
<hr>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Operand: defines any data needed by the instruction</b>

</div></article> 

<p><em>操作数：定义指令需要的任何数据</em></p>
<p>操作数指出指令执行的操作所需要数据的来源。操作数是汇编语言指令的一个字段。</p>
<p><br></p>
<hr>
<h3 id="机器码-1"><a href="#机器码-1" class="headerlink" title="机器码"></a><strong>机器码</strong></h3><p>所以说什么是机器码？  </p>
<article class="message is-info"><div class="message-body">

<b>Machine code instruction: a binary code with a defined number of bits that comprises an opcode and, most often, one operand</b> 

</div></article> 

<p><em>机器指令码(Machine code instruction):由一个操作码和一个操作数(通常是一个操作数)组成的二进制代码</em>  </p>
<p>机器码是机器指令码的缩写。  </p>
<p><br></p>
<p>一开始，我们用机器码来编写程序，称之为机器语言。<br>机器语言虽然能够被计算机理解和接受，但毕竟根人话完全不擦边，不易被人们理解和记忆，并且用它编程容易出差错。<br>所以，我们用助记符 (mnemonic) 代替机器码，从而形成了汇编语言。这让指令容易理解和记忆，而且便于交流。</p>
<p><br></p>
<p>在继续下面的内容之前，我需要列举几个事实中的事实：  </p>
<ul>
<li>在所有语言里面，CPU只认<strong>机器码 (Machine code)</strong></li>
<li>机器代码由一系列指令组成  </li>
<li>一条指令中包含一个<strong>操作码 (opcode)</strong>  </li>
<li>一条指令可以没有<strong>操作数 (operand)</strong>，但最多可以有三个操作数  </li>
<li>不同的处理器有不同的指令集  </li>
<li>对于相同的操作，不同的处理器会有类似的指令，但是指令的编码是不同的。  </li>
</ul>
<p>对一个特定的处理器来说，每个单独的机器码指令都必须定义了以下内容：  </p>
<ul>
<li>整个指令的总比特数或字节数  </li>
<li>定义操作码的位数 (<em>number of bits that define the opcode</em>)  </li>
<li>在剩余位 (<em>remaining bits</em>) 中定义的操作数的个数  </li>
<li>操作码占用最高有效位 (<em>most significant bits</em>) 还是最低有效位 (<em>least significant bits</em>)  </li>
</ul>
<p><br></p>
<p>操作码所需要的位数取决于处理器指令集中不同操作码的数量。操作码可以由定义操作的前几位和与寻址相关的剩余位构成。下图展示了简单处理器的合理指令格式：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB13c4419645cb8310b1323b57a0a3fe78?method=download&amp;shareKey=e03683744089f148c6ebec24f58df1e5" alt="A s1mple instruction format">  </p>
<p>一条指令由两部分组成：操作码和操作数<br>操作码长度为8位，其中有4位用来记录操作，2位用于记录地址类型，剩余的位数交给寻址寄存器处理。<br>此操作码将占用指令中的最高有效位。因为在某些情况下操作数会是一个内存地址，给它分16位可以与地址总线的位数一致。  </p>
<p><br></p>
<p>当一条指令到达CPU的时候，控制单元会先检查操作码，来解析这一条指令定义了什么操作。这一步在指令周期内属于解码步骤。<br>它可以使用上一张学过的寄存器传输语言进行描述，但是需要进行一些小小的修改。  </p>
<p><br></p>
<p>       <code>CU ⬅ [CIR(23:16)]</code>  </p>
<p><br></p>
<p>这一行表示了16到23位之间的数据(表示的是操作码)从当前指令寄存器中传输到控制单元。  </p>
<p><em>p.s.</em><br>上面图片中一串命令一共有24位。我们从左边数第一个位，记为第0位，同理可得最后一位是第23位。<br>如果命令中大位在前小位在后，代表位数是从后往前数<br>同样的，小位在前大位在后，代表位数是从前往后数</p>
<p><br></p>
<hr>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a><strong>汇编语言</strong></h2><p>程序员们希望能够编写一种程序，这种程序可以直接控制处理器的一举一动。<br>有些人认为这是最有效的程序类型，但是作为一个正常人用机器码程序会把你累个半死，因为这样的程序确实难写，很抽象的。<br>因此将一个实质性的程序以机器码的形式来进行编写就会花费很长很长的时间，并且人在编写这种语言的时候会经常犯错，因为机器码和人类语言相差的太远了。<br>针对这种编程需求，汇编语言是最好的解决方案。除了具有唯一定义的机器代码语言之外，每个处理器都有自己的汇编语言。  </p>
<p><br></p>
<hr>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Assembly language: a low-level language related to machine code where opcodes are written as mnemonics and there is a character representation for an operand</b> 

</div></article> 

<p><em>汇编语言 (Assembly language) :是一种与机器码有关的低级语言，其中操作码被写成助记符 (mnemonic) 形式，并且操作数用字符表示</em>  </p>
<p>低级语言的低级不是说它有多拉跨，而是指汇编语言比较接近硬件底层。  </p>
<p>在汇编语言中，我们用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。<br>特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。  </p>
<p><br>  </p>
<hr>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Assembler: a program used to translate an assembly language program into machine code</b> 

</div></article>

<p><em>汇编器 (Assembler) :用来把汇编语言程序翻译成机器代码的程序</em>  </p>
<p>如果用汇编语言写出一个程序，他必须要被翻译成机器码才能够被CPU执行。翻译的活就是汇编器干的。</p>
<p>一般而言，汇编生成的是目标代码，需要经链接器（Linker）生成可执行代码才可以执行。<br>作为一门语言，对应于高级语言的编译器，需要一个“汇编器”来把汇编语言原文件汇编成机器可执行的代码。  </p>
<p><del>把半人话翻译成电脑话</del>  </p>
<p><br>  </p>
<hr>
<p><br></p>
<p>汇编语言的本质是，对于每条机器代码指令，都有一条等价的汇编语言指令，其中包括:  </p>
<ul>
<li>操作码的助记符(符号缩写)  </li>
<li>操作数的字符表示形式</li>
</ul>
<p>汇编语言的优点比较明显，比如说对程序员来说，汇编语言相比机器码写起来要更加容易。<br>此外，汇编语言还允许程序员们做一些机器码无法做到的事情，比如说：  </p>
<ul>
<li>做注释  </li>
<li>用符号做变量名  </li>
<li>地址标签  </li>
<li>宏命令 </li>
<li>指令 (Directives)  </li>
</ul>
<p>这里的指令告诉汇编器如何构造最终可执行机器代码的指令。<br>而宏命令是代表程序中要多次使用的一系列指令。有点像鼠标宏：记录鼠标移动信息之后，按某个键触发后回放此路径。  </p>
<p><br></p>
<hr>
<h2 id="寻址类型"><a href="#寻址类型" class="headerlink" title="寻址类型"></a><strong>寻址类型</strong></h2><p>有如下几种寻址类型：  </p>
<p><strong>Symbolic addressing: 符号寻址</strong><br><strong>Relative addressing: 相对寻址</strong><br><strong>Absolute addressing: 绝对寻址</strong>  </p>
<p>当考虑汇编程序是如何将汇编语言程序转换为机器码是，我们很有必要去了解下他们之间的区别。<br>我们假设有这样一个汇编程序，它的目的就是把键盘上输入的单个数字相加。<br><strong>我们会在接下来的文章内反复使用这个例子！</strong>所以说好好看看这个程序是很有必要的（  </p>
<p>下表左侧分步骤描述了一个使用符号寻址编写的汇编程序，以及对每条指令的解释：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">使用符号寻址的汇编程序 命令 (助记符+参数)</th>
<th style="text-align:center">命令解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>IN</code></td>
<td style="text-align:center">这一步通过键盘输入一个数字，并将它的ASCII码存入进累加器中</td>
</tr>
<tr>
<td style="text-align:center"><code>SUB #48</code></td>
<td style="text-align:center">这一步是减法运算，将ASCII码转换成二进制</td>
</tr>
<tr>
<td style="text-align:center"><code>STO MAX</code></td>
<td style="text-align:center">声明一个地址，名称为<code>MAX</code>，将累加器中的数字存储进去</td>
</tr>
<tr>
<td style="text-align:center"><code>LDM #0</code></td>
<td style="text-align:center">向累加器中添加<code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>STO TOTAL</code></td>
<td style="text-align:center">将累加器中的这个<code>0</code>存入一个地址，名称为<code>TOTAL</code></td>
</tr>
<tr>
<td style="text-align:center"><code>STO COUNT</code></td>
<td style="text-align:center">将累加器中的这个<code>0</code>存入一个地址，名称为<code>COUNT</code></td>
</tr>
<tr>
<td style="text-align:center"><code>STRTLP :IN</code></td>
<td style="text-align:center">再次通过键盘输入一个数字，并将它的ASCII码存入进累加器中</td>
</tr>
<tr>
<td style="text-align:center"><code>SUB #48</code></td>
<td style="text-align:center">这一步是减法运算，将ASCII码转换成二进制</td>
</tr>
<tr>
<td style="text-align:center"><code>ADD TOTAL</code></td>
<td style="text-align:center">将地址为<code>TOTAL</code>的值与累加器中的值相加，并将总和存储在累加器中</td>
</tr>
<tr>
<td style="text-align:center"><code>STO TOTAL</code></td>
<td style="text-align:center">然后再把累加器中的数据存入名叫<code>TOTAL</code>的地址中</td>
</tr>
<tr>
<td style="text-align:center"><code>LDD COUNT</code></td>
<td style="text-align:center">将存储在地址<code>COUNT</code>的值加载到累加器中</td>
</tr>
<tr>
<td style="text-align:center"><code>INC ACC</code></td>
<td style="text-align:center">向累加器中加<code>1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>CMP MAX</code></td>
<td style="text-align:center">比较累加器中的值与存储在地址<code>MAX</code>中的值</td>
</tr>
<tr>
<td style="text-align:center"><code>JPN STRTLP</code></td>
<td style="text-align:center">如果比较值不相等，程序会跳转回标记为<code>STRTLP</code>的指令</td>
</tr>
<tr>
<td style="text-align:center"><code>END</code></td>
<td style="text-align:center">程序结束执行</td>
</tr>
<tr>
<td style="text-align:center"><code>MAX:</code></td>
<td style="text-align:center">一个可以存储值的标记地址</td>
</tr>
<tr>
<td style="text-align:center"><code>TOTAL:</code></td>
<td style="text-align:center">一个可以存储值的标记地址</td>
</tr>
<tr>
<td style="text-align:center"><code>COUNT:</code></td>
<td style="text-align:center">一个可以存储值的标记地址</td>
</tr>
</tbody>
</table>
</div>
<p>其中有几行需要格外解释下：  </p>
<p><strong>LDM (Load much): 多数据加载,将地址上的值加载到寄存器上</strong></p>
<p>按照惯例：标签的后面会写有冒号，但是引用标签的时候需要去除冒号。  </p>
<p><br> </p>
<hr>
<p><br></p>
<p>使用符号寻址可以让程序员使用汇编语言代码，而不需要担心程序运行的时候代码在内存中的位置。<br>编写汇编代码也可以将符号寻址替换为相对寻址或绝对寻址。  </p>
<p>下表显示了上面那个表格中使用这些替代方法转换后的简单代码：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB38e3562e28832957b60b19339bbc7068?method=download&amp;shareKey=b8c26385c454c64539b9dd9707f054f5" alt="Table"></p>
<p>你可能发现在相对寻址改写的程序中，有<code>[BR]</code>这个东西。<br>这里我们假设有一个基址寄存器 (base register)，包含程序基址。<br><strong>程序基址是程序中第一条指令的地址。</strong> 查看上图的例子：使用绝对寻址的程序的第一行代码的地址是200，所以BR中存储的基址为200。<br>调用基址寄存器中的内容，可以使用<code>[BR]</code>。  </p>
<p><br></p>
<hr>
<h2 id="两步汇编程序的汇编过程"><a href="#两步汇编程序的汇编过程" class="headerlink" title="两步汇编程序的汇编过程"></a><strong>两步汇编程序的汇编过程</strong></h2><p>对于任何汇编程序，在进行任何转换之前，都必须对汇编语言代码进行许多处理。比如说：  </p>
<ul>
<li>移除注释  </li>
<li>用构成宏定义的指令列表替换指令中使用的宏名称  </li>
<li>删除和存储稍后要执行的指令</li>
</ul>
<p><br></p>
<hr>
<p><br>  </p>
<p>我们在<strong>寻址类型</strong>章节里面设计了一个汇编程序，这个程序内包括了向前引用。<br>有些指令有操作数的符号地址，但在程序的那个阶段，我们不知道这个地址的位置。需要一个两遍汇编程序，以便在第一遍中确定前向引用的地址的位置。  </p>
<p>为了在第一次传递期间实现这一点，汇编程序使用了一个符号表。<br>代码是逐行读取的。当一个符号地址第一次遇到时，这个名字就会被输入到一张符号表中。<br>在名称旁边，必须尽快添加一个相应的地址，以便识别。  </p>
<p>下表给出了针对<strong>寻址类型</strong>章节中那个程序创建的符号表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Symbol</th>
<th style="text-align:center">Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>MAX</code></td>
<td style="text-align:center">+15</td>
</tr>
<tr>
<td style="text-align:left"><code>TOTAL</code></td>
<td style="text-align:center">+16</td>
</tr>
<tr>
<td style="text-align:left"><code>COUNT</code></td>
<td style="text-align:center">+17</td>
</tr>
<tr>
<td style="text-align:left"><code>STRTLP</code></td>
<td style="text-align:center">+7</td>
</tr>
</tbody>
</table>
</div>
<p>请注意，汇编程序在读取代码时必须对指令进行计数。当它遇到一个标签时，汇编程序可以将偏移值(offset)输入到符号表中。  </p>
<p><em>用人话来讲就是数顺序来让处理器确定自己读的是哪一行代码。</em><br>把程序的开始设为偏移值为零，则<code>IN</code>这个操作有+1的偏移量，有<code>STRTLP</code>的那一行机器码的偏移量是+7</p>
<p><br>  </p>
<hr>
<p><br></p>
<p>在第二步中，汇编程序会使用符号表(symbol table)和一个查找表(lookup table)，表格中包含每个操作码的二进制代码。<br>每一个处理器定义过的操作码，在这个表里都可以找到对应的信息。  </p>
<p>下表列出了我们举的例子中使用的指令对应的条目。需要注意的是：这里的二进制代码是对于待使用代码的一个建议。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf3650c45807785f33ac93b368fa88b62?method=download&amp;shareKey=df38fda7b2a948a32f27df18fe2e4990" alt="Table"></p>
<p>如果不出意外的话（比如说汇编发生错误），那么第二遍的输出就是机器码程序了。<br>下面这个表格将原始汇编代码和编译好的机器码程序列在了一起，我们可以简单比较一下：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBab306e5096e4bc745cbe01207487e10b?method=download&amp;shareKey=8375e8b3c421e667241633a2d4e187a3" alt="Table"></p>
<p><br></p>
<p>有以下几点需要简单注意下：  </p>
<ul>
<li>大多数的指令都有一个16位二进制数的操作数。  </li>
<li>通常来说这表示一个地址，但对于<code>SUB</code>和<code>LDM</code>指令，操作数会被用作一个值。  </li>
<li><code>IN</code>和<code>END</code>指令没有操作数。  </li>
<li><code>INC</code>指令是一个特例。汇编语言代码中存在操作数，但它只用来定义寄存器。在机器码中，寄存器是在操作码中标识的，因此就不需要操作数了。</li>
<li>在编译机器码的时候，第一个步骤会占用第零个地址。</li>
<li>像这种形式的代码是不可执行的，但它却是汇编程序的一个有效输出。</li>
<li>当程序加载到内存中准备执行时，就需要把地址稍微改改了。</li>
<li>程序代码之后的三个内存位置将会分配为零，以确保程序执行后可以正常使用它们。</li>
</ul>
<p><br></p>
<hr>
<h2 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a><strong>寻址模式</strong></h2><p>当一条指令需要将一个值加载到寄存器中时，我们有不同的方法来识别该值。其中的每一种都被称为寻址模式 (Addressing mode)。  </p>
<p><em>顺带附上寻址模式的定义：</em>  </p>
<article class="message is-info"><div class="message-body">

<b>Addressing mode: when the instruction uses a value this defines how the operand must be used to find the value.</b> 

</div></article>

<p>*<em>当指令需要使用一个值时，寻址模式定义了如何使用操作数来查找这个值。</em></p>
<p>在本单元的开始就说过：对于一个简单处理器，机器码指令中的操作码位将用于定义寻址模式。加起来一共允许有4种不同的寻址模式，如下表所示。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">寻址模式</th>
<th style="text-align:left">操作数的使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Immediate</strong><br>立即寻址</td>
<td style="text-align:left">在这种情况中，操作数是<strong>要在指令中使用的值</strong>；<br><code>SUB #48</code><br>就是一个很好的例子。<br><br><strong><em>人话：操作数是一个确切的数学值，不需要存入任何累加器就可以直接引用的值。比如说全体正整数。</em></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Direct</strong><br>直接寻址</td>
<td style="text-align:left">在这种情况中，操作数是<strong>保存要在指令中使用的值的地址</strong>；<br><code>ADD TOTAL</code><br>是其中的一种情况。<br><br><strong><em>人话：操作数是一个地址，执行指令的时候会使用操作数指定内存中的数据</em></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Indirect</strong><br>间接寻址</td>
<td style="text-align:left">在这种情况中，操作数是<strong>一个地址</strong>，这个地址记录了<strong>要在指令中使用的值</strong>。<br><br><strong><em>人话：操作数是一个地址，但是与直接寻址不同的是：此操作数中的值会被作为一个新的地址再次重定向，直到读取该重定向后地址中的值。</em></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Indexed</strong><br>变址寻址</td>
<td style="text-align:left">在这种情况中，操作数是<strong>一个地址</strong>，但是<strong>必须将当前变址寄存器(IX)中的值加到该地址上</strong>，才可以获得要在指令中使用的值的地址。<br><br><strong><em>人话：操作数是一个地址，但是最后调用数据的地址是当前操作数所定义的地址数加上变址寄存器的值，并找到最后的值。</em></strong></td>
</tr>
</tbody>
</table>
</div>
<p>对于立即寻址，有三种定义值的选项:  </p>
<ul>
<li><code>#48</code>指定了十进制值48  </li>
<li><code>#B00110000</code>指定等价的二进制内容  </li>
<li><code>#&amp;30</code>指定了等价的十六进制内容  </li>
</ul>
<p><br></p>
<hr>
<h2 id="汇编语言指令"><a href="#汇编语言指令" class="headerlink" title="汇编语言指令"></a><strong>汇编语言指令</strong></h2><p>继续回到具有有限指令集的简单处理器上。<br>我们在这里举出的所有例子，都不会与特定处理器的汇编所匹配。<br>每一个指令都需要基于平台，针对性的设计汇编程序。  </p>
<p><br></p>
<hr>
<h3 id="数据的移动"><a href="#数据的移动" class="headerlink" title="数据的移动"></a><strong>数据的移动</strong></h3><p>这些指令种类各不一样。有些可以将数据加载到寄存器中，有一些可以将数据存储在内存里。<br>下面这个表格举出了一些例子：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令操作码</th>
<th style="text-align:center">指令操作数</th>
<th style="text-align:left">简单的解释(<del>但愿吧</del>)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>LDM</code></td>
<td style="text-align:center"><code>#n</code></td>
<td style="text-align:left">立即寻址，将数字“n”加载到累加器(ACC)中。</td>
</tr>
<tr>
<td style="text-align:center"><code>LDR</code></td>
<td style="text-align:center"><code>#n</code></td>
<td style="text-align:left">立即寻址，将数字“n”加载到变址寄存器(IX)中。</td>
</tr>
<tr>
<td style="text-align:center"><code>LDD</code></td>
<td style="text-align:center"><code>&lt;address&gt;</code></td>
<td style="text-align:left">直接寻址，将给定地址的内容加载到累加器中。</td>
</tr>
<tr>
<td style="text-align:center"><code>LDI</code></td>
<td style="text-align:center"><code>&lt;address&gt;</code></td>
<td style="text-align:left">间接寻址，给定的地址将会被使用，而第二个地址的内容会加载到累加器中。</td>
</tr>
<tr>
<td style="text-align:center"><code>LDX</code></td>
<td style="text-align:center"><code>&lt;address&gt;</code></td>
<td style="text-align:left">变址寻址，地址由<code>&lt;address&gt;</code>+变址寄存器中的内容组成，然后将计算出来的地址中的内容加载到累加器中。</td>
</tr>
<tr>
<td style="text-align:center"><code>MOV</code></td>
<td style="text-align:center"><code>&lt;register&gt;</code></td>
<td style="text-align:left">将累加器中的内容移动至一个指定的寄存器中(IX)。</td>
</tr>
<tr>
<td style="text-align:center"><code>STO</code></td>
<td style="text-align:center"><code>&lt;address&gt;</code></td>
<td style="text-align:left">将寄存器中的内容储存到一个指定的地址。</td>
</tr>
</tbody>
</table>
</div>
<p>在这里，左侧这一列的助记符定义了指令的类型，包括了在运算中涉及到的所有寄存器，以及可能会使用到的恰当的寻址模式。  </p>
<p><strong>仔细阅读助记符是很重要的！</strong>  </p>
<p>在以下所有的表格中：  </p>
<blockquote>
<p><code>&lt;address&gt;</code>代表操作数是一个地址<br><code>&lt;register&gt;</code>代表操作数是一个寄存器缩写<br><code>#n</code>代表这是一个十进制值。比如说<code>#23</code>代表十进制数字23。  </p>
</blockquote>
<p><br></p>
<hr>
<p><br></p>
<p>来一个背景解释一下上面表格的内容：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3473ec319b5ca955ebfb4e19c9c2aac3?method=download&amp;shareKey=2d02a8fbc22db5542be18f25c0038ac3" alt=""></p>
<p>根据上图所示的内存内容，下面我会给出一些例子：  </p>
<p><code>LDD 103</code>代表<strong>值110被存入了累加器中</strong><br><code>LDI 106</code>代表<strong>来自地址101的值208被存入了累加器中</strong><br><code>STO 106</code>代表<strong>值208被存进了地址106中</strong><br><code>LDD INDEXVALUE</code>代表<strong>值”3”被存入了累加器</strong><br><code>MOV IX</code>代表<strong>累加器里面的那个”3”被存入了变址寄存器中</strong><br><code>LDX 102</code>代表<strong>来自地址105的值206被存入了累加器中</strong>  </p>
<p><br></p>
<hr>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a><strong>输入和输出</strong></h3><p>下面这两个指令用于输入或输出。<br>在每种情况下，这些指令都只有一个操作码，没有操作数。</p>
<ul>
<li>以助记符为<code>IN</code>代表的操作会将键盘上输入的字符的ASCII码存储在累加器中。  </li>
<li>相反，以助记符为<code>OUT</code>代表的操作会将累加器中存储的ASCII码显示出来。</li>
</ul>
<p><br></p>
<hr>
<h3 id="比较和跳步"><a href="#比较和跳步" class="headerlink" title="比较和跳步"></a><strong>比较和跳步</strong></h3><p>程序是不会傻到一直一条条执行命令的——至少当他们要求被这样做的时候会这样。  </p>
<p>程序有些时候会在每行命令之间跳转。有一些情况是无条件的，也有一些情况是有条件的：比如说执行了比较命令。  </p>
<p>下图给出了一些比较命令的例子：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作码</th>
<th style="text-align:left">操作数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>JMP</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">跳转到指定的地址。</td>
</tr>
<tr>
<td style="text-align:left"><code>CMP</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">将累加器中的内容与指定地址中的内容比较。</td>
</tr>
<tr>
<td style="text-align:left"><code>CMP</code></td>
<td style="text-align:left"><code>#n</code></td>
<td style="text-align:left">将累加器中的内容与指定十进制值比较</td>
</tr>
<tr>
<td style="text-align:left"><code>CMI</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">是个间接寻址。命令会将累加器中的内容与操作数给到的地址中的内容比较。</td>
</tr>
<tr>
<td style="text-align:left"><code>JPE</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">它会跟在一个比较命令后面。如果比较的结果为True，则会跳转到操作数给定的地址。</td>
</tr>
<tr>
<td style="text-align:left"><code>JPN</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">它会跟在一个比较命令后面。如果比较的结果为True，则会跳转到操作数给定的地址。</td>
</tr>
</tbody>
</table>
</div>
<p>这里所有介绍的比较命令，都是比较<strong>两个数据是否相等。</strong><br>相等输出为<code>True</code>，不相等输出为<code>False</code>。  </p>
<p>比较的结果会被记录在状态寄存器中的一个标志中。<br>当我们执行跳转指令的时候，我们首先需要检查状态寄存器中是否有这个标志。<br>然后执行跳转命令的时候，我们不会立即执行，而是需要先向程序计数器提供一个新的偏移量，让程序可以继续在正确的地址上获取下一条指令。<br>因此在向程序计数器提供新的偏移量的时候，程序计数器就不会执行简单的+1操作了。</p>
<p><br></p>
<hr>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a><strong>数学运算</strong></h3><p>简单的数学运算，但是在这里我们暂时不考虑乘除的运算，因为他们相比加减法运算没有通用性或一致性。  </p>
<p>下表列出了一些例子：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作码</th>
<th style="text-align:left">操作数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ADD</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">将操作数给定地址内的内容加到累加器中。</td>
</tr>
<tr>
<td style="text-align:left"><code>ADD</code></td>
<td style="text-align:left"><code>#n</code></td>
<td style="text-align:left">将操作数给定的十进制数字加载到累加器中。</td>
</tr>
<tr>
<td style="text-align:left"><code>SUB</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">从累加器中减去操作数给定地址中的内容。</td>
</tr>
<tr>
<td style="text-align:left"><code>SUB</code></td>
<td style="text-align:left"><code>#n</code></td>
<td style="text-align:left">从累加器中减去操作数给定的十进制数字。</td>
</tr>
<tr>
<td style="text-align:left"><code>INC</code></td>
<td style="text-align:left"><code>&lt;register&gt;</code></td>
<td style="text-align:left">向给定的寄存器内+1。 （累加器或者是变址寄存器）</td>
</tr>
<tr>
<td style="text-align:left"><code>DEC</code></td>
<td style="text-align:left"><code>&lt;register&gt;</code></td>
<td style="text-align:left">向给定的寄存器内-1。 （累加器或者是变址寄存器）</td>
</tr>
</tbody>
</table>
</div>
<p>下面展示了一个以5累加到75的程序：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc474f69079272e1b19e9af865951b687?method=download&amp;shareKey=577ac5abfbaf4cb49a8419d96d1d573a" alt=""></p>
<p>简单解释一下程序的运行过程：  </p>
<ul>
<li>前三行命令初始化了计数器和求和功能  </li>
<li>在地址103的命令是每次迭代的第一行命令。  </li>
<li>接下来的三行命令会向地址中的值+1，然后存储回原来的地址。  </li>
<li>地址106到地址108中的指令会向总和中+5。  </li>
<li>地址109和地址110的命令用来检查总和有没有到达75目标值。如果没有就重复下一次迭代。  </li>
<li>到达目标值75后，地址111到地址113的命令用来输出计数结果（一共加了15次75，所以输出计数结果15。）  </li>
</ul>
<p><br></p>
<hr>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a><strong>移位运算</strong></h3><p>逻辑移位：左移时最低位补0，右移时最高位补0的移位</p>
<article class="message is-info"><div class="message-body">

<b>Logical shift:where bits in the accumulator are shifted to the right or to the left and a zero moves into the bit position vacated.</b> 

</div></article>

<p>比如说：<code>0101</code><br>向左移1位就是：<code>1010</code>,最高位补了一个0。<br>向右移1位就是：<code>0010</code>，最低位补了一个0。  </p>
<p><br></p>
<p>逻辑移位可以做一些很有意思的东西，比如让一个数字扩大一倍。但是这是有先决条件：<strong>这一串二进制的最高位和最低位必须是零</strong>，因此没有任何的信息丢失。<br>举个例子  </p>
<p><code>00001010</code>代表十进制的10。<br>但是将其向左逻辑移位（一位）：<br><code>00010100</code>代表了十进制的20。  </p>
<p>同样的，向右逻辑移位代表减小一倍。<br>左移一位是扩大一倍最简单的做法。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>知道了什么叫做逻辑移位，现在介绍两个移位运算命令：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作码</th>
<th style="text-align:left">操作数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>LSL</code></td>
<td style="text-align:left"><code>#n</code></td>
<td style="text-align:left">将累加器中的值向<strong>左</strong>以操作数给定的位做逻辑移位</td>
</tr>
<tr>
<td style="text-align:left"><code>LSR</code></td>
<td style="text-align:left"><code>#n</code></td>
<td style="text-align:left">将累加器中的值向<strong>右</strong>以操作数给定的位做逻辑移位</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<p><br></p>
<p>移位并不是仅存在逻辑移位，我们还有其他的两种移位方式：<strong>循环移位（Cyclic shift）</strong>和<strong>算术移位（Arithmetic shift）</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Cyclic shift: similar to a logical shift but bits shifted from one end reappear at the other end.</b> 

</div></article>

<p><strong>循环移位：在移位时不丢失移位前原范围的位，而是将它们作为另一端的补入位。</strong>  </p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Arithmetic shift: uses the shift to carry out manipulation or division of a signed integer stored in the accumulator.</b> 

</div></article>

<p><strong>算术移位：使用移位对累加器中存储的有符号整数进行操作或除法。</strong>  </p>
<p>这俩了解就好。  </p>
<p><br></p>
<hr>
<h3 id="按位逻辑操作"><a href="#按位逻辑操作" class="headerlink" title="按位逻辑操作"></a><strong>按位逻辑操作</strong></h3><p>命令：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作码</th>
<th style="text-align:left">操作数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AND</code></td>
<td style="text-align:left"><code>#Bn</code></td>
<td style="text-align:left">将累加器中的每一位都与操作数指定值进行AND运算</td>
</tr>
<tr>
<td style="text-align:left"><code>AND</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">将累加器中的每一位都与操作数指定地址中的值进行AND运算</td>
</tr>
<tr>
<td style="text-align:left"><code>XOR</code></td>
<td style="text-align:left"><code>#Bn</code></td>
<td style="text-align:left">将累加器中的每一位都与操作数指定值进行XOR运算</td>
</tr>
<tr>
<td style="text-align:left"><code>XOR</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">将累加器中的每一位都与操作数指定地址中的值进行XOR运算</td>
</tr>
<tr>
<td style="text-align:left"><code>OR</code></td>
<td style="text-align:left"><code>#Bn</code></td>
<td style="text-align:left">将累加器中的每一位都与操作数指定值进行OR运算</td>
</tr>
<tr>
<td style="text-align:left"><code>OR</code></td>
<td style="text-align:left"><code>&lt;address&gt;</code></td>
<td style="text-align:left">将累加器中的每一位都与操作数指定地址中的值进行OR运算</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h1 id="第七章：控制与监控系统"><a href="#第七章：控制与监控系统" class="headerlink" title="第七章：控制与监控系统"></a><strong>第七章：控制与监控系统</strong></h1><h2 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a><strong>监控系统</strong></h2><p>监控系统可以用于创建一段时间内系统状态的记录。<br>监控系统被广泛用于监控系统的特定物理特性（照度，温度，湿度…）何时超出阈值。<br>比如说温控系统检测CPU过热，会自动降低频率。  </p>
<p><br></p>
<hr>
<p><br></p>
<p>我们在这里以温度作为一个例子：<br>如果计算机想要知道当前机箱内实时温度，那么计算机就必须需要一种设备来获取相关数据，并精确的传送到计算机。  </p>
<p>这一种测量设备叫做<strong>传感器</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Sensor: a hardware device that measures a property and transmits a value to a controlling computer.</b>

</div></article> 

<p><strong>传感器：测量属性并可以将值传递到计算机的一种硬件。</strong>  </p>
<p>在这个情景中，可以监控计算机机箱内温度的硬件就是热电偶。热电偶会根据温度的变化更改它的输出电压。在一些老式的电脑上，如果传感器检测到了机箱内的温度过高，会奏响它的小蜂鸣器提醒用户。  </p>
<p><br></p>
<p>有一点需要注意，在一个监控系统内，传感器是没有任何的集成智能在里面的，所以说但凡这传感器遇上了问题，它都没有办法自我修复，那基本上就得报废了。  </p>
<p>传感器还可以检测运动，红外，声音，ph值等各种属性。  </p>
<p><br></p>
<hr>
<h2 id="控制系统"><a href="#控制系统" class="headerlink" title="控制系统"></a><strong>控制系统</strong></h2><p>控制系统包含了监视系统的权限和功能，但是不止如此，控制系统还可以去对系统做出一些调整与改变。  </p>
<p>监视系统需要一个必不可少的元件：<strong>致动器 (Actuator)</strong>。制动器是连接到其他控制设备的电机，可以应用一些改动。  </p>
<article class="message is-info"><div class="message-body">

<b>Actuator: a hardware device that receives a signal from a computer and adjusts the setting of a controlling device.</b>

</div></article> 

<p><br></p>
<hr>
<p><br></p>
<p>下图是一个计算机控制环境的示意图。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB278206278b3ad34a89bcf6465e40e9c3?method=download&amp;shareKey=76274d616b9bc247e5541757971939c0" alt=""></p>
<p>上图中包含了一个模数转换器(ADC)和一个数字模拟转换器(DAC)，它们俩都是独立的组件。在实际的系统中，它们有可能是传感器或者执行器设备的组成部分。  </p>
<p>上图所示的系统中，计算机会定期向传感器请求数据，接着计算机就会处理这一部分数据。如果接受的数据不在期望的范围内，计算机就会采取一些操作。下一次数据请求只会发生在此操作完成后。  </p>
<p><br></p>
<p>下图是一个闭环反馈控制系统：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf9ad1cf3c6e929a5ee41011380693835?method=download&amp;shareKey=7b18e81015534e1e9d9f117b2156879f" alt=""></p>
<p>其中的控制器由微处理器组成，他们可以将传感器读取的实际输出值与期望的值作比较，随后会将一个值继续传输给执行器。  </p>
<p><br></p>
<hr>
<h2 id="控制设备的位操作"><a href="#控制设备的位操作" class="headerlink" title="控制设备的位操作"></a><strong>控制设备的位操作</strong></h2><p>担任控制工作的计算机或者微处理器里面都必须有一个时刻运行的实时程序。该程序可以根据传感器检测到的内容为布尔变量设置值。  </p>
<p>比如说：如果一个受控环境中有两个需要监视和控制的属性，我们就可以定义并使用四个布尔变量。  </p>
<p>赋值就牵扯到了赋值语句，就像这样：  </p>
<p><code>IF SensorDifference1 &gt; 0 THEN Sensor1HighFlag ← TRUE</code><br><code>IF SensorDifference1 &lt; 0 THEN Sensor1LowFlag ← TRUE</code><br><code>IF SensorDifference2 &gt; 0 THEN Sensor2HighFlag ← TRUE</code><br><code>IF SensorDifference2 &lt; 0 THEN Sensor2LowFlag ← TRUE</code>  </p>
<p>与此同时，监控和控制程序的另一个部分会检查是否已经定义了任意一个标识。运行这样的一个程序的机器代码可以使用单独的位来表示每一个标识。  </p>
<p>下面的表格说明了设置和读取表示的方法。<br>在这些代码片段中，每个字节的三个最低有效位 (第0, 1和第2位)会被用作标识。  </p>
<p><br></p>
<p>下面演示了在系统打开时可能使用的所有位为零的设置：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><code>LDD 0034</code></th>
<th style="text-align:left">将一个来自某地址的字节转入累加器中。</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AND #B00000000</code></td>
<td style="text-align:left"><strong>使用位与(AND)运算将累加器的内容和操作数转换为0。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>STO 0034</code></td>
<td style="text-align:left"><strong>将改变后的字节存储在原始地址中。</strong></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>下面的例子说明了某一个确切位值的切换。这将改变标志的值。<br>可能是因为遇到了问题，也可能是因为解决了问题。</p>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><code>LDD 0034</code></th>
<th style="text-align:left">将一个来自某地址的字节转入累加器中。</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AND #B00000000</code></td>
<td style="text-align:left"><strong>使用按位异或(XOR)运算将累加器中的第2位切换。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>STO 0034</code></td>
<td style="text-align:left"><strong>将改变后的字节存储在原始地址中。</strong></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>下面演示了如何将一个位的值设置为1，不管它现在的值是多少。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><code>LDD 0034</code></th>
<th style="text-align:left">将一个来自某地址的字节转入累加器中。</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AND #B00000000</code></td>
<td style="text-align:left"><strong>将累加器的内容与操作数进行按位或(OR)运算来设置第二位所表示的值。所有其他比特位保持不变。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>STO 0034</code></td>
<td style="text-align:left"><strong>将改变后的字节存储在原始地址中。</strong></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>下面演示了将所有位都设置为0，除了一个特定的位的方法。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><code>LDD 0034</code></th>
<th style="text-align:left">将一个来自某地址的字节转入累加器中。</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AND #B00000000</code></td>
<td style="text-align:left"><strong>对累加器的内容和操作数进行位与(AND)运算，保持第1位的值不变，但将其他所有位转换为0。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>STO 0034</code></td>
<td style="text-align:left"><strong>将改变后的字节存储在原始地址中。</strong></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h1 id="第八章：系统软件"><a href="#第八章：系统软件" class="headerlink" title="第八章：系统软件"></a><strong>第八章：系统软件</strong></h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><strong>操作系统</strong></h2><p>在1960年代，人们使用计算机的操作大概是这样的：  </p>
<ol>
<li>进入一个有很多穿孔纸条和穿孔卡片的房间  </li>
<li>打开计算机  </li>
<li>将穿孔卡片插入读卡器，然后按下按钮  </li>
<li>将穿孔纸条插入读取器，然后按下按钮  </li>
<li>按下另一个按钮来启动在穿孔卡片上存储的程序。这时候穿孔纸条会当做内存使用。  </li>
<li>按下按钮将输出打印在纸上  </li>
<li>关掉计算机</li>
<li>离开房间  </li>
</ol>
<p>当时的计算机用户只能通过按钮来与计算机交互。要是放到今天得需要数不清的按钮了。<br>所以在1960年代，确实的计算机的一个重要成分便是<strong>操作系统</strong>了。  </p>
<article class="message is-info"><div class="message-body">

<b>Operating system: a software platform that provides facilities for programs to be run which are of benefit to a user.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="操作系统活动"><a href="#操作系统活动" class="headerlink" title="操作系统活动"></a><strong>操作系统活动</strong></h2><p>操作系统的构造实际上是非常复杂的，我们在这里寥寥数句肯定是说不清楚的。<br>但是我们可以大致介绍一下操作系统的大致活动与功能：  </p>
<p><br></p>
<hr>
<h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a><strong>用户界面</strong></h3><p>操作系统里面的用户界面可以允许用户通过它去与系统硬件更高效地交互，从而完成一些有意思的事情。  </p>
<p>一个操作系统至少需要满足以下两点中的其中一个对用户的输出方式：  </p>
<ul>
<li>一个命令行样式的用户界面  </li>
<li>一个图形化的用户界面</li>
</ul>
<p>我们用的绝大多数操作系统都是带有图形化用户界面的。  </p>
<p><br></p>
<hr>
<h3 id="程序硬件接口"><a href="#程序硬件接口" class="headerlink" title="程序硬件接口"></a><strong>程序硬件接口</strong></h3><p>程序员的可以编写软件，用户运行这个软件。<br>软件需硬件的运行，所以操作系统必须保证硬件可以执行软件所希望执行的操作。  </p>
<p>现在的程序员编写软件不再需要去了解如何针对某个别的硬件进行编程了，尤其是处理器。<br>随后操作系统就会担任这个工作：把人话翻译成机器听的话。  </p>
<p><br></p>
<hr>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a><strong>资源管理</strong></h3><p>如果一个程序正在运行，我们会管他叫做一个<strong>进程</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Process: a program that has begun execution.</b>

</div></article> 

<p>在现代的计算机系统内，任何进程都不可能一直不间断地运行下去，而且在计算机系统上会运行很多的进程，每一个进程都需要访问计算机系统提供的资源。  </p>
<p>操作系统中的资源管理旨在发挥计算机使用过程中的最佳性能。管理资源最重要的两个方面是：  </p>
<ul>
<li>进程的调度  </li>
<li>冲突进程的管理 <em>(当两个进程同时需要计算机系统提供的同一份资源，就会产生冲突。)</em>  </li>
</ul>
<p><br></p>
<hr>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><p>以下三点在内存管理中比较重要：  </p>
<ul>
<li>内存保护：确保两个程序不会共用同一个内存地址。  </li>
<li>组织内存：通过组织内存的使用方案来实现有限资源的最大化利用（或者发挥最大性能），比如说虚拟内存。  </li>
<li>内存优化：决定有哪些进程会保持运行在主内存中。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a><strong>设备管理</strong></h3><p>每一个计算机系统都会连接各式各样的设备，比如说鼠标键盘，打印机复印机，摄像头等等。  </p>
<p>设备管理有一下两点：  </p>
<ul>
<li>为设备安装正确的驱动程序。  </li>
<li>控制设备有关进程的使用。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h3><ul>
<li>文件命名  </li>
<li>目录结构</li>
<li>访问控制机制  </li>
</ul>
<p><br></p>
<hr>
<h3 id="安全控制"><a href="#安全控制" class="headerlink" title="安全控制"></a><strong>安全控制</strong></h3><ul>
<li>当文件丢失时提供恢复</li>
<li>防止计算机被入侵</li>
<li>确保文件的安全性</li>
</ul>
<p><br>  </p>
<hr>
<h3 id="错误检测与恢复"><a href="#错误检测与恢复" class="headerlink" title="错误检测与恢复"></a><strong>错误检测与恢复</strong></h3><p>程序在执行的过程中很有可能出现错误。这有可能是因为程序编写错误，也有可能是提供了不正确的数据。<br>但是无论错误的原因是什么，操作系统都应该有中断进程和错误诊断的能力。<br>在极端的情况下，操作系统也需要有组织性地关闭系统，同时不丢失数据。  </p>
<p><br></p>
<hr>
<h2 id="应用程序软件"><a href="#应用程序软件" class="headerlink" title="应用程序软件"></a><strong>应用程序软件</strong></h2><p>应用程序可以由操作系统提供，用户也可以单独安装。<br>应用程序不是操作系统能够正常运行的必要条件，而是用户或者操作系统可以在需要时决定运行的程序。  </p>
<p>举一些例子，每一个例子具体是什么样我就不展开成一个个小章节解释了，已经属于是基础知识了。  </p>
<p><br></p>
<p><br></p>
<ul>
<li><strong>硬盘格式化软件和硬盘检测软件。</strong>  </li>
</ul>
<p>DiskGenius就是这样的一款优秀软件。这样的软件可以格式化你的磁盘，或者检查硬盘是否有任何坏道错误。  </p>
<p><br></p>
<p><br></p>
<ul>
<li><strong>硬盘碎片化整理程序</strong>  </li>
</ul>
<p>机械硬盘因为其物理限制（转盘和磁头导致机械硬盘大多以顺序读取为主），随机读取的性能远远低于SSD（固态硬盘）的性能，所以适当的整理磁盘上的文件排布对于系统读取文件来说是很有帮助的。  </p>
<p>我们在日常使用电脑的时候很容易产生很多碎片。这些碎片可以是不连续的，在机械硬盘中会极其拖慢系统的运行速度。<br>所以碎片化整理程序就可以将碎片化的文件以机械硬盘喜欢的方式重新排列，让随机读取文件更靠近顺序读取。  </p>
<p>所以这样的碎片化整理程序对于SSD是没什么用的，除了心理作用。  </p>
<p><br></p>
<p><br></p>
<ul>
<li><strong>备份文件</strong>  </li>
<li><strong>杀毒软件</strong></li>
</ul>
<p>这两个不用说了吧。</p>
<p><br></p>
<hr>
<h2 id="Program-libraries-程序库"><a href="#Program-libraries-程序库" class="headerlink" title="Program libraries 程序库"></a><strong>Program libraries 程序库</strong></h2><p>这些在Program libraries中是为了执行特定任务而创建的程序。任何程序员都可以在自己的项目里使用它们。  </p>
<p>所有新开发的程序里面都会包含错误。这些错误在程序员debug中可能很难发现，但是在用户的日常使用中可以变的越来越明显。而这些已经验证过没有问题的Program libraries中的子程序就可以被程序员拿来直接用，省去了大量的精力去调试或者编写程序。  </p>
<p><br></p>
<p>另一种方法是使用动态链接库（DLL）。当程序员决定使用DLL的时候，在自己的可执行代码内就可以只包含一点点代码。这允许它在程序运行的时候连接到单独存储在内存中的例程。使用DLL的优点是所有程序的可执行文件都可以做到较小的存储空间，对内存的需求也最小化。另一个有点事如果有新的例程版本可用，我们就可以直接讲新的例程加载到内存中，以便使用它的任意程序都可以升级到新的例程，而不需要去大刀阔斧地改代码。 </p>
<p>但是问题是如果DLL损坏或者新版本的DLL存在兼容性问题或者内容错误，直接一影响就影响一片程序。同样DLL确实也是用户在使用计算机的时候经常发生的问题。这时候就需要用户去手动添加缺失的DLL。  </p>
<p><br></p>
<hr>
<h2 id="计算机语言转换"><a href="#计算机语言转换" class="headerlink" title="计算机语言转换"></a><strong>计算机语言转换</strong></h2><p>还记得第六章的汇编器吗？这一个小结介绍类似汇编器的其他程序，不过这些程序是用来翻译高级过程语言编写程序的翻译器。  </p>
<h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a><strong>编译器和解释器</strong></h3><p>使用<strong>编译器 (Compilers)</strong>或者<strong>解释器 (Interpreter)</strong>的先决条件是：必须应用于源代码，而源代码必须是用高级语言编写的程序。  </p>
<p>一个解释器工作的基本过程如下：  </p>
<ol>
<li>解释程序，源代码文件和源代码程序使用的数据都可以使用。  </li>
<li>解释程序现在开始运行。  </li>
<li>读取源代码的第一行。  </li>
<li>每一行会被按下面5-7步的顺序分析： </li>
<li>如果有发现错误，解释程序会暂停运行，并将错误信息上报。  </li>
<li>如果没有错误发现，源代码中的这一行就会被解释程序转换成中间代码。<em>（中间代码是一种面向语法，易于翻译成目标程序的源程序的等效内部表示代码）</em>  </li>
<li>解释程序会根据生成的中间代码来执行所需要的操作。  </li>
<li>然后解释程序就会重复运行4-8步的步骤分析下一行代码。  </li>
</ol>
<p><br></p>
<p>一个编译器工作的基本过程如下：  </p>
<ol>
<li>需要编译程序和源代码，但是不需要源代码使用的数据参与其中。  </li>
<li>编译程序开始运行。  </li>
<li>读取源代码的第一行。  </li>
<li>每一行会被按下面5-7步的顺序分析：  </li>
<li>如果有错误发生，编译程序会报告这个错误。  </li>
<li>如果没有发生错误，那么源代码中的这一行就会被转换成中间代码。  </li>
<li>编译程序会重复运行4-7步的步骤分析下一行代码。  </li>
<li>当整个源代码处理完毕后，会发生下面两种情况的其中之一：  </li>
</ol>
<ul>
<li><ul>
<li>如果在整个源代码中没有发现错误，就将完整的代码转换为目标代码。  </li>
</ul>
</li>
<li><ul>
<li>如果发现了任何错误，就会输出错误列表，并且不生成目标代码。  </li>
</ul>
</li>
</ul>
<p><br></p>
<p>对于程序员和开发者来说，编译器和解释器各有所长：  </p>
<ul>
<li><p>在开发程序的时候，解释器具有优势，因为它可以在错误发生的时候识别错误并尝试修正，而无需等待整个源代码被读取和分析。  </p>
</li>
<li><p>解释器的缺点在于：在程序的特定执行过程中，解释器可能无法访问包含语法错误的部分代码。因此错误就只会在结束的时候被发现。  </p>
</li>
<li><p>编译器的优点是可以将可执行文件(exe)发行给用户，这样用户就没办法访问源代码了。  </p>
</li>
</ul>
<p><br></p>
<p>而在用户这边，编译器和解释器也都有自己的优缺点：  </p>
<ul>
<li><p>对于解释程序来说，当每一次运行一个没有错误的程序的时候，解释程序和源代码都必须可用。  </p>
</li>
<li><p>对于编译后的程序，当每次运行一个没有错误的程序时候，只有目标代码可用。  </p>
</li>
<li><p>编译后的目标代码可以提供相比于解释程序更快的执行速度。  </p>
</li>
<li><p>编译后的程序可以有风险，因为它可能含有潜在的病毒或垃圾文件。  </p>
</li>
</ul>
<p><br></p>
<p>无论使用的是编译器还是解释器，如果他们的程序是为了特定处理器而写，则程序只能在具有特定处理器的计算机上运行。  </p>
<p>如果有特定的条件，那么在开发程序的时候选择解释器是比较合理的。因为：  </p>
<ul>
<li>程序中的一个错误可能会造成多米诺效应：一错错一片。  </li>
<li>解释器可以检测并修正在代码中发生的早期错误，从而限制后续发生更多问题。  </li>
<li>在开发过程中，解释器附带的debug程序可以梗方便的减少工作时间。  </li>
</ul>
<p>同样在某些时候，我们也可以选择使用编译器。因为：  </p>
<ul>
<li>编译器可以生成一个可执行文件(.exe)。  </li>
<li>编译器生成的可执行文件可以更方便的用来传播。  </li>
<li>编译器生成的程序相比于解释器的程序来说，运行速度更快。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>当Java正在创建的时候，Java团队设想了一些十分新颖的想法。<br>每一个计算机都可以安装一个Java虚拟机（Java Virtual Machine）。当程序员构造一个Java程序的时候，会首先编译成Java字节码指令(Java Byte Code)。<br>当这个程序运行的时候，会被JVM解释，随后就可以将程序转移到任何安装有Java虚拟机的计算机上运行。  </p>
<p><br></p>
<hr>
<h2 id="集成开发环境-IDE"><a href="#集成开发环境-IDE" class="headerlink" title="集成开发环境(IDE)"></a><strong>集成开发环境(IDE)</strong></h2><p>集成开发环境(Integrated development environment)是用于提供程序开发环境的应用程序。一般包括代码编辑器，编译器，调试器和图形用户界面等工具。继承了代码编写功能，分析功能，调试功能等一体化的开发软件服务套。<br>所有具备这一特性的软件或者软件组都可以叫做集成开发环境。  </p>
<p>常见的IDE有微软的Visual studio系列，Jetbrains的IDEA，Pycharm。  </p>
<h3 id="代码高亮-Prettyprinting"><a href="#代码高亮-Prettyprinting" class="headerlink" title="代码高亮 (Prettyprinting)"></a><strong>代码高亮 (Prettyprinting)</strong></h3><p>计算机语言一般每行由不同的成分构成，有命令或者各种参数。<br>代码高亮功能可以将代码的每一部分通过不同的颜色或者图样展示出来，方便我们区分并阅读代码。  </p>
<p>就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.**.lib.lib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myclass</span>  {</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">"Hello world"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    System.out.print(<span class="string">"Hello world"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="上下文敏感提示-Context-sensitive-prompts"><a href="#上下文敏感提示-Context-sensitive-prompts" class="headerlink" title="上下文敏感提示 (Context-sensitive prompts)"></a><strong>上下文敏感提示 (Context-sensitive prompts)</strong></h3><p>在一段代码的上文你可能定义了一堆变量，在代码的下文IDE就有机会自动补全你写过的变量名称。  </p>
<p><br></p>
<h3 id="语法检查-Syntax-check"><a href="#语法检查-Syntax-check" class="headerlink" title="语法检查 (Syntax check)"></a><strong>语法检查 (Syntax check)</strong></h3><p>IDE会分析你的代码，并且通过画波浪线的方式提示你你的这部分代码可能有误。<br>有些IDE只负责检查错误，不过现在的IDE大多都可以为你提供更正提示。  </p>
<h3 id="代码折叠-Expanding-and-collapsing-code-blocks"><a href="#代码折叠-Expanding-and-collapsing-code-blocks" class="headerlink" title="代码折叠 (Expanding and collapsing code blocks)"></a><strong>代码折叠 (Expanding and collapsing code blocks)</strong></h3><p>当你在代码中的一个循环（或者其他组容器内）写了很多的代码，那么IDE提供了可以将容器内的代码折叠的选项。<br>这让你更方便的在长文件里梳理代码结构。  </p>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a><strong>Debug</strong></h3><p>IDE一般都会附有调试工具来帮助你进行Debug操作。<br>Debug大约是程序检查去除漏洞的意思。  </p>
<article class="message is-info"><div class="message-body">

<b>Debug: finding and correcting errors, often called 'bugs', in a program.</b>

</div></article> 

<p>在调试过程中你可以为程序中的某几行打上一个断点(Breakpoint)。<br>当程序开始运行后到达了断点处，程序会暂时停止运行。<br>然后你可以选择继续运行，或者逐行运行。  </p>
<p>这对于梳理程序逻辑很有帮助。  </p>
<p><br></p>
<hr>
<h1 id="第九章：安全、隐私和数据完整性"><a href="#第九章：安全、隐私和数据完整性" class="headerlink" title="第九章：安全、隐私和数据完整性"></a><strong>第九章：安全、隐私和数据完整性</strong></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a><strong>数据完整性</strong></h3><p>定义什么是数据完整性挺容易，但是确保数据完整就不那么容易了。<br>只有准确并最新的数据才会存在数据完整性，任何存储数据的个人和机构都必须尽可能地确保数据的完整性。  </p>
<p>我们会在本章和第十一章讨论确保数据完整性的方法。  </p>
<article class="message is-info"><div class="message-body">

<b>Data integrity: a requirement for data to be accurate.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="数据隐私"><a href="#数据隐私" class="headerlink" title="数据隐私"></a><strong>数据隐私</strong></h3><p>数据隐私指的是保持数据的私密性，而不是任凭数据公开访问权，以至于每人都可以随便使用。此现象都可以发生在个人和组织上。<br>每个人都有他们自己的隐私数据，而且大家都会选择保密这一部分数据不被公开。  </p>
<p>对于个人而言，如果没有适当的法律来约束侵犯隐私的违法者，那么保证数据隐私就相对困难了。  </p>
<p>保护数据隐私的法律必须要涉及以下几点：  </p>
<ul>
<li>这些数据是私人数据，因为他们主要是面向提供给个人和组织的。  </li>
<li>提供数据是为了允许组织使用它，但只能用于个人理解和同意的目的。</li>
<li>数据保护法要求组织机构确保这些数据的隐私性和完整性。  </li>
<li>不幸的是，拥有法律并不能保证遵守它们，但它们确实起到了威慑作用，可以使不法行为者受到法律诉讼。  </li>
</ul>
<article class="message is-info"><div class="message-body">

<b>Data protection law: a lao that relates to data privacy.</b>

</div></article>   

<p><br></p>
<hr>
<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a><strong>数据安全</strong></h3><p>数据在我们想要使用它们的时候永远可用。如果数据已经丢失或者损坏，那么我们可以说数据的安全性已经被破坏了。  </p>
<p>在实现数据完整性或数据隐私之前必须先实现数据安全，但数据安全本身并不能保证数据完整性或数据隐私。<br>保护数据的要求之一是用来存储数据的系统的安全性。<br>系统安全不仅仅保护数据。 系统安全措施有两个主要目标：  </p>
<ul>
<li>确保系统持续执行用户需要的任务。  </li>
<li>以确保只有授权用户才能访问系统。    </li>
</ul>
<article class="message is-info"><div class="message-body">

<b>Data security: a requirement for data to be available for use when needed, ensures that only authorized users have access to the system and data can be recovered if lost or corrupted.</b>

</div></article>   

<p><br></p>
<hr>
<h2 id="对计算机系统及其存储数据安全的威胁"><a href="#对计算机系统及其存储数据安全的威胁" class="headerlink" title="对计算机系统及其存储数据安全的威胁"></a><strong>对计算机系统及其存储数据安全的威胁</strong></h2><p>对计算机系统的数据安全侵犯可能因为以下原因形成：  </p>
<ul>
<li>个人用户不关注数据安全  </li>
<li>内部的管理混乱  </li>
<li>自然灾害  </li>
<li>未经授权的个体侵入系统  </li>
<li>有害程序进入计算机系统  </li>
</ul>
<p><br></p>
<h3 id="网络和互联网对计算机和数据安全的威胁"><a href="#网络和互联网对计算机和数据安全的威胁" class="headerlink" title="网络和互联网对计算机和数据安全的威胁"></a><strong>网络和互联网对计算机和数据安全的威胁</strong></h3><p>现在我们的计算机都会连接到互联网。互联网上充斥着各种各样的信息，同样的可能会存在各式各样的有害文件。部分黑客可以在系统未经授权之时入侵系统。黑客可以通过这样的手段非法获取系统内的数据。  </p>
<p>所以说检查是否有恶意软件进入系统确实挺有必要。  </p>
<article class="message is-info"><div class="message-body">

<b>Malware: malicious software that has the intension of causing harm to a system or its contents.</b>

</div></article>   

<p><br></p>
<hr>
<h3 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a><strong>恶意软件</strong></h3><p>恶意软件是恶意软件的统称。<br>它是为了有害的目的而被引入系统的软件。<br>含有恶意软件的各种类型的程序代码有:</p>
<ul>
<li>病毒：试图在其他可执行代码中复制自己。  </li>
<li>蠕虫：独立运行，并尝试将自身传播到网络上的其他主机。  </li>
<li>逻辑炸弹：在满足某些条件之前保持潜伏。  </li>
<li>特洛伊木马：替换全部或者部分的程序，知道达到木马的目的。  </li>
<li>间谍软件：收集信息，然后将其传输到另一个系统。  </li>
<li>bot：控制一台计算机并且利用它来发动攻击。  </li>
</ul>
<p>不同类型之间的恶意软件差异并不大，有些例子属于这些类别中的一个或者不属于任何一个。<br>病毒类别通常根据病毒所附着的软件进行细分，例如引导扇区病毒和宏病毒。  </p>
<p><br></p>
<hr>
<p>恶意软件也可以通过他们的行为来归类：  </p>
<ul>
<li>钓鱼：以发送看似合法的电子邮件等手段来套取有用的信息。  </li>
<li>冒充：冒充一个以假乱真的官方网站。  </li>
<li>键盘记录程序:记录用户的键盘使用情况。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="由用户活动引起的系统漏洞"><a href="#由用户活动引起的系统漏洞" class="headerlink" title="由用户活动引起的系统漏洞"></a><strong>由用户活动引起的系统漏洞</strong></h3><p>许多系统漏洞与系统合法用户的活动直接相关，而不是恶意软件。<br>下面是两个不涉及恶意软件的例子：  </p>
<ul>
<li>使用弱密码，特别是与他们自身相关的密码。一个弱密码很容易被别人猜到或者被暴力穷举。</li>
<li>用户不太容易识别网络钓鱼和攻击，所以很容易泄露有用的信息。  </li>
</ul>
<p>用户的以下操作很有可能出现安全事故：  </p>
<ul>
<li>插入一个移动存储设备  </li>
<li>在邮件内打开未知的超链接  </li>
<li>打开一个未知的网站  </li>
<li>从网络上下载未知的文件  </li>
</ul>
<p><br></p>
<hr>
<h3 id="系统本身产生的漏洞"><a href="#系统本身产生的漏洞" class="headerlink" title="系统本身产生的漏洞"></a><strong>系统本身产生的漏洞</strong></h3><p>系统在某些情况下比较容易产生漏洞。下面给出了几个例子。  </p>
<ol>
<li><p>有一些操作系统的安全性可能较差。随着时间的推移，操作系统越来越复杂，这就容易导致安全性下降的可能。操作系统的定期更新，打补丁或者更新服务包等都可以增强系统的安全性。  </p>
</li>
<li><p>在之前，应用程序会有较大的概率携带电脑病毒等有害程序。不过现在这种情况几乎不会存在了。  </p>
</li>
<li><p>还有一个比较特殊的漏洞，就是缓冲区溢出。用C语言编写的程序有很大的一部分是不会自动执行数组绑定检查的。如果有一个程序故意将代码写入内存中超出为数组定义的地址的那一部分，那么这个部分会被定义为缓冲区。</p>
</li>
</ol>
<p><br></p>
<hr>
<h2 id="保持计算机数据良好的措施"><a href="#保持计算机数据良好的措施" class="headerlink" title="保持计算机数据良好的措施"></a><strong>保持计算机数据良好的措施</strong></h2><h3 id="灾难恢复"><a href="#灾难恢复" class="headerlink" title="灾难恢复"></a><strong>灾难恢复</strong></h3><p>对某些大厂来说，大型计算机的运营连续性十分的重要。<br>我们需要保证无论发生了什么时间，计算机系统都可以正常的工作。如果必须需要关闭系统，那么我们也必须要确保系统在很短的时间内再次启动恢复正常。  </p>
<p>一般来说，互联网大厂会同步很多副服务器，以便于主服务器在提供服务的时候发生不可抗力因素而失去服务。<br>他们像是一种后备服务器，允许主服务器瘫痪之后能够继续提供服务。<br>我们将这种后备的服务器叫做“热点”。  </p>
<p><br></p>
<hr>
<h3 id="安全更新系统"><a href="#安全更新系统" class="headerlink" title="安全更新系统"></a><strong>安全更新系统</strong></h3><p>当系统应用了一些新的更新以后，难免会遇见一些硬件上或者软件上的小错误。<br>一般来说，提供服务的大厂会选择在计算机不提供服务的时候进行系统更新，这样技术团队就可以用这段时间来调试新系统。  </p>
<p>但是在现代的互联网公司内，他们的服务是24小时全年无休的。所以更新系统就可以使用到我们上一个话题内提到的“热点”系统：通过另一些主机来提供服务。  </p>
<p><br></p>
<hr>
<h3 id="用户身份验证"><a href="#用户身份验证" class="headerlink" title="用户身份验证"></a><strong>用户身份验证</strong></h3><p>即使你自己的电脑只有你自己一个用户，我们也很有必要去设置一个用户账户。<br>账户系统十分重要，尤其是有很多人需要使用同一台电脑的情况下。<br>用户账户的主要安全特征是用户身份验证，我们通常的方法是设置密码，然后将每一个用户和他们的密码做出关联。<br>当然我们也有其他方法，比如说使用生物识别验证和安全令牌。  </p>
<p>生物识别验证是使用我们的指纹，人脸甚至虹膜来验证身份。安全令牌可以是一种硬件，比如说加密狗。  </p>
<p>当然也不是说我们只能生物识别安全令牌和密码二选一。我们一般会将这些额外的验证方法与密码相结合。</p>
<p><br></p>
<hr>
<h3 id="良好的使用习惯"><a href="#良好的使用习惯" class="headerlink" title="良好的使用习惯"></a><strong>良好的使用习惯</strong></h3><p>在使用计算机的时候保持一些良好的使用习惯，可以减少计算机被入侵的可能性。  </p>
<p>比如在不用计算机的时候关机，不要在公共的计算机上记录你的个人信息等等。  </p>
<p><br></p>
<hr>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a><strong>防火墙</strong></h3><p>设置防火墙可以让你的电脑免于网络上有害信息的传递和黑客对你的计算机的入侵。  </p>
<p><br></p>
<hr>
<h2 id="数据的安全性与完整性"><a href="#数据的安全性与完整性" class="headerlink" title="数据的安全性与完整性"></a><strong>数据的安全性与完整性</strong></h2><p>其中一种方法是检查并核验输入。  </p>
<h3 id="输入数据验证"><a href="#输入数据验证" class="headerlink" title="输入数据验证"></a><strong>输入数据验证</strong></h3><p>虽说是验证输入数据，但是实际上验证完了输入数据之后的数据也会发生错误。<br>我们这里的验证数据实际上是验证数据的各项指标，比如说大小，格式或者更多其他的内容。<br>我们在这里举几个例子：  </p>
<ul>
<li><strong>Presence check:</strong> 样式检查，用来检查输入的内容是否是空的。  </li>
<li><strong>Format check:</strong> 格式检查，来检查输入的数据是否符合要求的格式(比如日期的格式就必须是 dd/mm/yyyy )。</li>
<li><strong>Length check:</strong> 长度检查，用来检查数据是否符合应有的长度。比如说用来检查输入的电话号码是否是11位。</li>
<li><strong>Range check:</strong> 范围检查，用来检查输入的数据是否在合法范围内。</li>
<li><strong>Limit check:</strong> 限制检查，检查输入的数据是否突破了一个阈值。</li>
<li><strong>Type check:</strong> 数据形式检查，用来检查输入的数据形式是否合法。(比如说构成日期的每一位数据都必须是正整数，不能是小数。)</li>
<li><strong>Existence check:</strong> 存在性检查，检查输入的内容是否已经出现过，或者检查输入的内容是否在一个列表内。例如在同一个文件夹下将一个文件重命名成另一个文件的样子会报错，是因为存在Existence check。</li>
</ul>
<p><br></p>
<h3 id="验证输入的数据"><a href="#验证输入的数据" class="headerlink" title="验证输入的数据"></a><strong>验证输入的数据</strong></h3><p>跟上一个话题看起来很像，但实际上不是一个操作。<br>在这一步，我们需要尽可能让用户输入的数据是正确的。<br>要达成这一点，我们可以要求用户再次确认数据，或者让他们自己检查输入的数据。  </p>
<p>比如在注册账号密码的时候，要求用户重复输入密码。<br>或者在填写完表单之后，将用户填写的数据重新陈列在屏幕上，以便用户检查。  </p>
<p><br></p>
<hr>
<h3 id="按位检查"><a href="#按位检查" class="headerlink" title="按位检查"></a><strong>按位检查</strong></h3><p>有些时候某些数据载体上面会包含一个叫做纠错码的部分。这部分允许计算机可以根据这些纠错码来判断或还原之前丢失或损坏的数据。  </p>
<p>这里有加和验证和其他数学方法验证。加和生成的数据会被记录到最后一位上。  </p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Validation: a check that data entered is of the correct type and format; it does not guarantee that data is accurate.</b>

</div></article>   


<article class="message is-info"><div class="message-body">

<b>Verification: confirmation of data received by a system.</b>

</div></article>   

<p>这两者之间的区别就是一个是确认数据的输入，一个是验证输入数据是否合法的。  </p>
<p><br></p>
<hr>
<h3 id="数据传输过程中的验证"><a href="#数据传输过程中的验证" class="headerlink" title="数据传输过程中的验证"></a><strong>数据传输过程中的验证</strong></h3><p>数据在传输的过程中是很有可能被损坏的，比如说其中的一个位反转了过来，从0变成了1。<br>所以说，验证技术就会介入，来检查数据是否发生损坏。  </p>
<p>其中最简单的方法就是使用<strong>一位奇偶校验 (One-bit parity check)</strong>。如果传输的数据是七位一字节传输的话，系统就可以在这一个字节中的第八位存储奇偶校验的信息。  </p>
<p>下面就是一位奇偶校验的检查步骤：  </p>
<ol>
<li>在数据传输之后，我们会检查这一个7位字节中有多少个1。  <ul>
<li>如果1的数量是奇数的话，校验位会被设为1。  </li>
<li>如果1的数量是偶数的话，校验位会被设为0。</li>
</ul>
</li>
<li>这样的过程会在传输每一个字节的过程中重复。</li>
<li>在传输的最后，八位字节中的所有1的数量会被数出来。</li>
<li>如果这个个数是偶数，那么这个字节就是完好无误的。</li>
<li>这样的步骤也会被重复到每一个8位字节。</li>
</ol>
<p><br></p>
<p>奇偶校验也不是万金油，数据在损坏后也有可能通过奇偶校验。比如说当一个7位字节里面反转了两个位，最后数出来的奇偶个数还是与原数据一致。<br>所以说比起改正传输数据的错误，奇偶校验更像是一个验证传输数据是否有错的算法。所以说如果奇偶校验发现了错误，那么我们就只能要求服务器重新发送数据了。  </p>
<p><br></p>
<p>另一种验证方法叫做<strong>校验和</strong>。这是一个端到端的校验和，由发送端计算，然后由接收端验证。  </p>
<ol>
<li>将传输的数据当成若干位（如8位、16位或32位）的整数序列，将这些整数加起来，舍弃进位，得到一个结果。  </li>
<li>将这个结果取反码，即将0变为1，将1变为0，得到一个校验和。  </li>
<li>将校验和附加到数据后面，一起发送给接收方。  </li>
<li>接收方收到数据后，将数据和校验和一起按照同样的方法进行累加，并舍弃进位，得到一个新的结果。  </li>
<li>如果新的结果是全1，则说明数据没有发生改动或错误；如果新的结果不是全1，则说明数据有损坏或篡改。  </li>
</ol>
<p><br></p>
<p>一位奇偶校验和校验和是有区别的。一位奇偶校验用于存储数据，而校验和只用于传输的数据。  </p>
<p><br></p>
<p>想要验证数据在哪一位出错了，就比上面的这些验证方法要更加复杂了。  </p>
<p><br></p>
<hr>
<h1 id="第十章：道德与所有权"><a href="#第十章：道德与所有权" class="headerlink" title="第十章：道德与所有权"></a><strong>第十章：道德与所有权</strong></h1><p><em>（标题翻译过来有点奇怪不过问题不大。这章的原标题叫做”Ethics and ownership”）</em></p>
<h2 id="道德-Ethics"><a href="#道德-Ethics" class="headerlink" title="道德(Ethics)"></a><strong>道德(Ethics)</strong></h2><p>不是很理解所谓标题是什么意思。  </p>
<p>你可以找到道德的很多定义。  </p>
<ul>
<li>伦理学是道德科学的一个分支。  </li>
<li>道德指的是任何人的行为准则。  </li>
<li>道德是在特定职业或人类生活中公认的行为准则。  </li>
</ul>
<p>在这个单元中，我们不会牵扯到第一个定义，而第三个定义才是我们这一个章节研究的东西，虽然说计算机科学家和开发人员的行为准则必须反映第二个定义的道德原则。  </p>
<p>道德原则牵扯到对与错。美得的概念通常被认为是正确的东西在一系列的发生。至于什么是对与错，可以从以下几个观点之一考虑：哲学、宗教、法律或者实用主义。  </p>
<p>有关于哲学的辩论已经开始了2000多年，其中不乏一些伟大的人物提出的观点，比如说亚里士多德和孔子。宗教就是大家所熟悉的宗教，法律是来判断事物对与错的一种工具，而实用主义可以定义为运用常识。  </p>
<p>虽然我们学的是CS，但是宗教信仰这类的东西确实需要在工作环境中加以考虑。法律问题显然会影响工作时间，但是他们很少会是行为准则的主要焦点。行为规则的基础仍然是有关于对与错的哲学观念和常识性的实用主义观点。这些东西会构成本章后续内容的一个框架。  </p>
<p><br></p>
<hr>
<h2 id="计算机专业人员"><a href="#计算机专业人员" class="headerlink" title="计算机专业人员"></a><strong>计算机专业人员</strong></h2><p>无论这些人的专业是个啥，他们最起码得遵守道德规范。专业人士可以通过假如适当的专业组织来获得道德行为指导。这样的组织内会有一个行为准则，其中就会包括有关于道德实践的参考。  </p>
<p>举个例子：英国计算机协会(British Computer Society)有四个行为准则：  </p>
<ol>
<li>公共利益  </li>
<li>专业能力与诚信  </li>
<li>对相关机构的责任  </li>
<li>对此专业的责任   </li>
</ol>
<p>另一些机构和组织，比如IEEE-CS／ACM联合工作组软件工程道德规范定义了八项基础原则：  </p>
<ol>
<li>公共 - 软件工程师的行为应该符合公共利益  </li>
<li>客户与雇主 - 软件工程师的行为应该符合客户和雇主的最大利益，同时也需要符合公共利益。  </li>
<li>产品 - 软件工程师应当确保他们的产品和相关的变体符合最高的专业标准。 </li>
<li>批判与判断 - 软件工程师应该保持他们专业判断的完整性和独立性。  </li>
<li>管理 - 软件工程经理和领导应当支持并促进软件的开发和维护。 </li>
<li>专业 - 软件工程师应当促进相对专业的诚信和声誉，同时符合公众利益。 </li>
<li>同事 - 软件工程师应当公平对待他们的同事，同时也要去支持他们。  </li>
<li>自身 - 软件工程师应当参与与其专业实践相关的终身学习，并促进职业实践。  </li>
</ol>
<p>虽然说上面的规则多少有些不一样，但是其中的一些内容是大致一致的：  </p>
<ul>
<li>都重视公众利益  </li>
<li>都提出了专业人员的基本原则  </li>
<li>专业人员应当自行判断情况  </li>
<li>如果不确定，专业人员应该寻求建议。  </li>
</ul>
<p>(<em>我确实觉得是上面这些内容过度抽象了，我有一说一不清楚他们想让我学啥。</em>)  </p>
<p><br></p>
<hr>
<h2 id="所有权与版权"><a href="#所有权与版权" class="headerlink" title="所有权与版权"></a><strong>所有权与版权</strong></h2><p>上面ethic的部分实在是过于抽象所以我选择直接跳转到Ownership这一部分，至少这一部分有些实质性的内容。  </p>
<p>如果一个人创作并且出版了一些具有独创性的作品，那么这个人就是这个作品的所有者。他就有资格去要求版权。<br>在这里有一个例外：个体在组织中工作。如果一个或者多个人为该组织工作并发表了他们的作品，那么这个组织就可以要求申请这些作品的版权。  </p>
<article class="message is-info"><div class="message-body">

<b>Copyright: a formal recognition of ownership of a created and published work.</b>

</div></article>   

<p><br></p>
<hr>
<p>版权可以被下面这些形式的作品申请：  </p>
<ul>
<li>文学作品</li>
<li>音乐作品</li>
<li>电影和影视作品</li>
<li>电视广播，电台和博客</li>
<li>艺术作品</li>
<li>一个计算机程序</li>
</ul>
<p>版权因以下的两个观点而存在：<br>第一是：创作需要时间和精力，需要独创性思维。因此版权所有者应当有机会为此挣钱。<br>第二是：其他的一些个人或者组织可能会在不向创作者支付任何费用的情况下复制作品并从中赚钱。这对于版权所有者来说是十分不公平的。  </p>
<p>版权需要通过法律程序来保护。不同的国家对于版权的法律有细微差别，但是有这么一个国际协议：版权法，是每个国家必须遵守的。例如：未经原版权持有人许可，某人不允许在另一个国家出版作品。  </p>
<p>一般来说，版权法会包含：  </p>
<ul>
<li>要求记录作品的创作时间。  </li>
<li>在规定的期限内，版权法会保护作品。  </li>
<li>如果版权持有人去世，应当适用的法律。  </li>
<li>采用版权的内容会被”©”符号注释。  </li>
</ul>
<p>如果有人买下了版权内容，那么他们就允许无限制地复制这些内容，前提是这些内容仅供个人使用。  </p>
<p><br></p>
<hr>
<h2 id="软件许可"><a href="#软件许可" class="headerlink" title="软件许可"></a><strong>软件许可</strong></h2><h3 id="商业软件"><a href="#商业软件" class="headerlink" title="商业软件"></a><strong>商业软件</strong></h3><p>商业软件本质上与一些商业产品没什么大的差别。他们一般都是由一家旨在盈利的公司创建并销售。但是他们有一个显著的差别：  </p>
<p>设想你在科技市场买下了一台电脑，那么你就拥有这台电脑的所有权。但是如果你买下了一款计算机软件，你实际上是不会拥有他的使用权的，软件的所有权还是归属于供应商。  </p>
<p>也就是说，买下计算机软件就是相当于买下了一个许可证，你可以在期限内使用这款软件。软件许可证可以是有期限的，也可以是买断制永久性的。  </p>
<p>一般来说，买软件的时候都会出现一下这一些情况：  </p>
<ul>
<li>购买软件的每一个个体都需要去支付一定的费用。  </li>
<li>一个组织可以订购一批许可证。组织内的每一个个体可以在规定的时间期限内使用这个软件。  </li>
<li>对于教育工作者或者学生来说，需要支付的费用可能要相对便宜一些。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="开源软件或自由软件"><a href="#开源软件或自由软件" class="headerlink" title="开源软件或自由软件"></a><strong>开源软件或自由软件</strong></h3><p>这两种类别都十分相似，他们都是非盈利性质的。<br>一些软件提供给你免费的使用权，但是软件本身是不开源的，这意味着你无法去编辑这些代码，查找代码中的BUG，或者制造属于你自己的版本。  </p>
<p>开源软件允许你去修改代码，并基于此软件创造或者开发一个全新的软件（前提是你不要去违反开源软件的协议。）开源软件允许用户和个体查看代码的好处有很多：个体可以遍历代码并找出代码中的错误，他们也可以在一些代码托管平台上(例如Github,Gitlab)去提交自己修改的分支，以改进原来的开源部分。他们也可以发表PR(Pull request)提交合并申请或者报告开源软件的问题。也就是说：开源软件由一个强大的社区支持，而社区的力量允许开源软件作者享受好处。  </p>
<article class="message is-info"><div class="message-body">

<b>Open source software: software provided with the source code.</b>

<br>

<b>Free software: software provided with he source code when the user is free to use it as they wish.</b>

<br>

<b>Shareware: software provided free of charge for a limited period but no source code provided.</b>

<br>

<b>Freeware: software provided free of charge with no time limit for its use but no source code provided.</b>

</div></article>   

<p><br></p>
<hr>
<h2 id="人工智能-AI"><a href="#人工智能-AI" class="headerlink" title="人工智能(AI)"></a><strong>人工智能(AI)</strong></h2><p>人工智能是多个学科的共同产物，包括哲学，心理学，神经科学，数学，语言学和控制工程。  </p>
<p>人工智能涉及使用计算机或者计算机控制的设备来执行通常与人类智能行为相关的任务。我们将考虑智能人类行为的五个方面，讨论模拟这种人类行为的人工智能的一些应用。  </p>
<p><br></p>
<hr>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a><strong>解决问题</strong></h3><p>人工智能可以做到与你在国际象棋中对局。这可以被认为是显示了人工智能，但这只是因为国际象棋的规则是有限的。只要一台计算机拥有足够的存储容量和算力，那么这一个人工智能程序会在大量的训练之后研究更多的选项来解决现实生活中的问题，以至于人类的智力能力都无法与其竞争。  </p>
<p><br></p>
<h3 id="语言学"><a href="#语言学" class="headerlink" title="语言学"></a><strong>语言学</strong></h3><p>语音识别和语音合成技术已经开发并投入使用了。比如说你打一个客服电话，但是对面应答的不是一个人，而是一个机器。如果你可以清楚地描述你遇到的问题，计算机系统可能会识别你的需求，并将你移交给合适的人来帮助你。  </p>
<p>现在的GPT语言模型也是十分的强势。没有试过的可以去注册一个New Bing试试看。  </p>
<p><br></p>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a><strong>自动化</strong></h3><p>现在，机器人已经进入了工厂，开始协助大规模的生产了。这些机器人会被程序要求执行特定的循环操作。机器人的每次动作都是由某一些机制触发的。然而如果这些机器人碰到了意料之外的情况，他们就会停止运行，无论他们是否造成了任何损坏。  </p>
<p>现在已经有很多研究旨在加速自主意识机器人的研发，为了工厂中的机器能够更灵活的处理各种任务。我们必须要在这些机器人上面增加传感器，传感器将外界信号传递给处理器，然后再由程序进行判断。  </p>
<p>无人驾驶汽车就是一个很好的例子。不过现在在驾驶领域应用比较广的还得是自动泊车。  </p>
<p><br></p>
<h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a><strong>推理</strong></h3><p>有一些AI允许程序能够从证据和线索出发，来推理出最终的结论。最好的例子就是将数学定理交给计算机程序去进行证明和验证。  </p>
<p><br></p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h3><p>机器学习是目前AI领域里面能给人们带来最大惊喜的分支。AI会在实际的例子中积累经验，通过正向和逆向反馈来进行学习。AI会使用一套适当的数学统计算法来学习。  </p>
<p>这方面大家懂得都懂所以我就少写点了……  </p>
<p><br></p>
<h3 id="AI的影响"><a href="#AI的影响" class="headerlink" title="AI的影响"></a><strong>AI的影响</strong></h3><p>AI确实可以提升社会的工作效率，因为AI很适合节省一些需要重复的简单工作。在这些任务中AI可以做到比人类更高的稳定性和速度。  </p>
<p>现在ChatGPT的爆火证明了社会确实对于AI新技术的认可和兴趣，因为AI的诞生和发展增加了人们工作的效率，减轻了人们工作的脑力支配。  </p>
<p>然而有很多人担忧AI在未来会取代很多人类的工作，比如工厂的装配工之类的工作。这很有可能引发一批批的失业。有些人也认为AI是不具备处理部分复杂信息的能力的，比如说自动驾驶的稳定性。  </p>
<p>只能说仁者见仁智者见智吧。  </p>
<p><br></p>
<hr>
<h1 id="第十一章：数据库"><a href="#第十一章：数据库" class="headerlink" title="第十一章：数据库"></a><strong>第十一章：数据库</strong></h1><p>第二章到第十章中间的内容之后目前还没讲，之后再说  </p>
<h2 id="关于数据库"><a href="#关于数据库" class="headerlink" title="关于数据库"></a><strong>关于数据库</strong></h2><p>我们所说的数据库，一般指的是数据库管理系统，又叫数据库管理软件。英文为：Database Management System (DBMS)。  </p>
<p>常用的数据库管理软件有<code>MySQL</code>，<code>SQLite</code>等。<br>在很多大型公司里，一个数据库往往是一个项目的核心。</p>
<p>那么数据库存在的意义是什么？既然只是为了记录数据，我为啥要使用数据库？<br>主要是因为，我们存在大批量的数据并且还需要高速有效地写入或检索出来。</p>
<p>下面用一个例子来简单解释一下数据库的优势：  </p>
<p><br></p>
<hr>
<p><br></p>
<p>设想一下，你在一家电影院里工作，影院需要录入每一部电影的片名，上映时间，电影类型等等数据，并且使用<strong>文字处理软件</strong>进行记录。<br>在这个例子中，我们就假定使用Windows自带的“记事本”进行txt文件的编辑吧。<br>这样有专门的工作人员手动往这个txt文件里塞入一行一行有关的信息。一行写满了一部电影的数据，就像这样：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">片名</th>
<th style="text-align:center">导演</th>
<th style="text-align:center">电影类型</th>
<th style="text-align:center">时长</th>
<th style="text-align:center">票价</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">《数据库》</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">科幻</td>
<td style="text-align:center">110分钟</td>
<td style="text-align:center">56元</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">《开学》</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">惊悚</td>
<td style="text-align:center">124分钟</td>
<td style="text-align:center">79元</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p>那么这种处理数据的方法都会出现哪些问题捏？  </p>
<p><br></p>
<hr>
<p>     <strong>· 冗余</strong>  </p>
<p>一次换班过后，原来负责记录信息的工作人员润了。取而代之的是一个新的员工。<br>有一天，一部叫做《数据库》电影返场了。所以这一位新员工理所当然地更新了数据：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">片名</th>
<th style="text-align:center">导演</th>
<th style="text-align:center">电影类型</th>
<th style="text-align:center">时长</th>
<th style="text-align:center">票价</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">《数据库》</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">科幻</td>
<td style="text-align:center">110分钟</td>
<td style="text-align:center">56元</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">《开学》</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">惊悚</td>
<td style="text-align:center">124分钟</td>
<td style="text-align:center">79元</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">541</td>
<td style="text-align:center">《数据库》</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">科幻</td>
<td style="text-align:center">110分钟</td>
<td style="text-align:center">56元</td>
</tr>
</tbody>
</table>
</div>
<p>这显然是不合理的，因为新录入的信息与之前的老信息发生了重复。<br>作为一款文字处理软件，想要排查这样的错误无异于大海捞针。<br>但是使用数据库就不会出现这种问题。  </p>
<p><br></p>
<hr>
<p>     <strong>· 无法检索并汇总</strong>  </p>
<p>假设电影院至今已经播出了114514部不同的电影，每一部电影都存在于这份文档中。<br>然后有一天你的老板让你整理出来所有票价高于80元的电影的片名，导演，电影类型等数据，汇总给老板看。  </p>
<p>然后你打开了txt文件——</p>
<p><strong>寄。</strong>  </p>
<p>你会发现你无法通过限定数据来进行检索和整理输出。因此最好的方法就是滑动鼠标滚轮靠肉眼一行一行人工检索了。  </p>
<p>同理，使用数据库就不会出现这种问题。  </p>
<p><br></p>
<hr>
<p>     <strong>· 可移带性、规范性差</strong></p>
<p>然后假如电影院记录的数据十分的完整，以至于有其他的电影院想有偿使用你的这一份txt文件。<br>然后对方付了钱，你发过去了这一份txt文件。  </p>
<p>但是与此同时，收到这一份文件的另一家电影院已经开始痛苦面具了——因为标准或者语言的不同，使用的这一份数据无法直接部署给对方使用，导致对方需要花费大量的经历去做数据的重新整理。</p>
<p>而数据库有一套比较统一的语言系统和语法，允许数据库方便地在不同计算机上转移数据。</p>
<p><br></p>
<p>当然还会有更多的问题，这里就不列举了</p>
<p><br></p>
<hr>
<h2 id="数据库的标准"><a href="#数据库的标准" class="headerlink" title="数据库的标准"></a><strong>数据库的标准</strong></h2><p>像TCP,UDP之类的传输协议，都是一些白纸黑字的成文标准。SQL也是如此。<br>SQL，全称 Structured Query Language。 </p>
<h2 id="关系型数据库内容"><a href="#关系型数据库内容" class="headerlink" title="关系型数据库内容"></a><strong>关系型数据库内容</strong></h2><p>现在很多应用都需要处理对象与对象之间的关系。<br>有关数据，抽离对象，数据，以及他们的关系，就可以用面向对象的语言来进行编写。<br>但是如果要根据此类数据创建一个数据库，就可以用关系型数据库将我们现在最主流的应用的数据平滑地记录下来。  </p>
<p><br></p>
<p>下面来介绍一下数据库的成分：  </p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a><strong>table</strong></h3><p>关系型数据库表达主体和关系，是通过<code>Relation</code>来完成的。（<del>俗话说就是表格</del>）<br><code>Attribute</code>代表在表格里面的一个列。<br>而<code>Tuple</code>就代表其中的一个行。<br>就是和Excel很像，但也仅仅是看着像了。</p>
<article class="message is-info"><div class="message-body">

<b>Relation: the special type of table which is used in a relational database.</b>

<br>

<b>Attribute: a column in a relation that contains values.</b>

<br>

<b>Tuple: a row in a relation storing data for one instance of the relation.</b>

</div></article>



<p><br></p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a><strong>key</strong></h3><p><strong><code>key</code>（键）代表一个专用的特征码，甄别唯一性的一串字符。</strong>    </p>
<p><strong><code>Primary key</code> 为”主键“，代表现役判断重复性的根据。</strong><br>在作为<code>Primary key</code>的那一项，数据不能为空，也不能重复（只能唯一）。    </p>
<p><strong>在CIE考试里，在创建数据库的时候，都必须需要一个主键存在。</strong>  </p>
<p><strong><code>Candidate key</code> 是<code>Primary key</code> 的候选，都可以满足<code>Primary key</code>的特征以及功能。</strong>   </p>
<p>而<strong><code>Primary key</code>可以不是由<code>Candidate key</code>里面选出</strong>，因为<code>Candidate key</code>的定义为： “a key that could be chosen as the primary key.”    </p>
<p><code>Foreign key</code>（外键）是在某一些表内的主键<del>必须是主键</del>，作为在不同表之间确定信息以及联动查询的基础。  </p>
<p>一个表格内的一个主键拿出去给别的表做一个外键，这样就可以确定在两个表内不同的数据的联系，还可以保护数据的完整性。如果不用外键来引入与别的表格的联系，就需要将数据从另一个表格中再次输入一遍。这就出现了冗余现象。  </p>
<article class="message is-info"><div class="message-body">

<b>Primary key: an attribute or a combination of attributes for which there is a value in each tuple and that value is unique.</b>

<br>

<b>Candidate key: a key that could be chosen as the primary key.</b>  

<br>

<b>Secondary key: a candidate key that has not been chosen as the primary key.</b>

<br>

<b>Foreign key: an attribute in one table that refers to the primary key in another table.</b>

<br>

<b>Referential integrity: the use of a foreign key to ensure that a value can only be entered in one  table when the same value already exists in the referenced table.</b>

</div></article>





<p><br></p>
<hr>
<p><span class="tag is-warning">Example</span></p>
<p>有关于这点，这里举个例子解释一下：  </p>
<p>这里有一个考试表。下面开始在考试表内记录数据： </p>
<blockquote><p>9月1日，1号学生在4号考场里考了语文。<br>9月3日，一号学生在4号考场里考了计算机。<br>…  </p>
</blockquote>
<p>你会发现，其中没有一个类型的Attribute可以作为一个key来确定。所以这样就找不出一个<code>Candidate key</code>了：  </p>
<ul>
<li>学生不可以做为key，因为学生可以考多个科目。  </li>
<li>科目不可以作为key，因为一个科目可以重复被考。  </li>
<li>日期就更不用说了。</li>
</ul>
<p>但是我们需要联合两个或多个数据（不会和别的搭配重合的数据）来创建一个key，其中的每一个元素可以没有作为key的潜质。  </p>
<p>比如我规定查询”一号学生的语文考试记录“，就一定包含唯一性。<br>但是只去查询日期，就没法精准定位了。  </p>
<p><br></p>
<hr>
<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a><strong>三范式</strong></h2><p>三范式存在的意义是让数据库的设计更加合理化，并落实成关系型数据库。当然，你也可以选择不去遵守三范式。  </p>
<h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a><strong>第一范式(1NF)</strong></h3><p>第一范式的内容：  </p>
<article class="message is-info"><div class="message-body">

<b>数据表中的每一列(每个字段)必须是不可拆分的最小单元,也就是确保每一列的原子性。</b>

</div></article>


<p>简单来说就是一个单元格内只能去输入一个最小不可拆分的单元，不可再分。  </p>
<p>比如说像这样填表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">Student</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">19班20号</td>
</tr>
</tbody>
</table>
</div>
<p>这样是不满足1NF的。满足第一范式写法需要改成：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">Student_Class</th>
<th style="text-align:center">Student_ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">19</td>
<td style="text-align:center">20</td>
</tr>
</tbody>
</table>
</div>
<p><br><br><br></p>
<h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a><strong>第二范式(2NF)</strong></h3><article class="message is-info"><div class="message-body">

<b>在满足第一范式的情况下：表中的所有列，都必须依赖于同一个主键（或者联合主键的部分），而不能有任何一列与主键没有关系。</b>

</div></article>

<p>也就是说，一个表格需要描述一类信息，一张表仅描述一件事。</p>
<p>其实就是为了去冗余。  </p>
<p><br></p>
<hr>
<p><br></p>
<p><span class="tag is-warning">Example</span>  </p>
<p>表格：Exam  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Student_ID</th>
<th style="text-align:center">Course_ID</th>
<th style="text-align:center">Date</th>
<th style="text-align:center">Student_Name</th>
<th style="text-align:center">Course_Name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">101</td>
<td style="text-align:center">2002.3.10</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">Linear Algebra</td>
</tr>
</tbody>
</table>
</div>
<p>在这个表格里，<code>Student_ID</code>,<code>Course_ID</code>和<code>Date</code>作联合主键。因为三者制约完全可以保证确定一个数据。  </p>
<p><code>Student_Name</code>依赖于<code>Student_ID</code>, <code>Course_Name</code>依赖于<code>Course_ID</code>。这种情况叫做部分依赖。<br>而部分依赖，是不符合第二范式的。  </p>
<p><br></p>
<p>因此，我们可以将<code>Student_Name</code>和<code>Course_Name</code>抽离至两个新表格<code>Student</code>和<code>Course</code>。<br>在<code>Student</code>表格内，<code>Student_ID</code>为<code>Student</code>表主键。需要将<code>Student_ID</code>列抽离到学生考试表格做外键。<br>在<code>Student</code>表格内，<code>Course_ID</code>为<code>Course</code>表主键。需要将<code>Course_ID</code>列抽离到学生考试表格做外键。  </p>
<p>如下所示：</p>
<p>Student ( <u>Student_ID</u>, Student_Name )<br>Course ( <u>Course_ID</u>, Course_Name )<br>Exam ( <u>Student_ID, Course_ID, Date</u>, <em>Student_ID(fk)</em>, <em>Student_ID(fk)</em> )</p>
<p>下划线代表主键，(fk)代表外键。  </p>
<h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a><strong>第三范式(3NF)</strong></h3><article class="message is-info"><div class="message-body">

<b>在满足第二范式的情况下，任何的非主属性不得依赖于其他非主属性</b>

</div></article>

<p>好比说我在列一张表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><u><em>main</em></u></th>
<th style="text-align:center">commits</th>
<th style="text-align:center">branch</th>
<th style="text-align:center">system</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>规定<code>main</code>是主键，则<code>commits</code>,<code>branch</code>,<code>system</code>都必须与<code>main</code>有联系。  </p>
<p>假如说<code>system</code>仅与<code>branch</code>有关系，则证明不符合第三范式。  </p>
<p><br></p>
<hr>
<h3 id="使用三范式规范化数据库"><a href="#使用三范式规范化数据库" class="headerlink" title="使用三范式规范化数据库"></a><strong>使用三范式规范化数据库</strong></h3><p>下面是一张信息表。将其转换成数据库的形式，并符合三范式要求。  </p>
<blockquote><p><strong>Order no:</strong> 07845<br><strong>Date:</strong> 25-06-2016<br><strong>Customer no:</strong> 056<br><strong>Customer name:</strong>  CUP<br><strong>Address:</strong> Cambridge square      Cambridge<br><strong>Sales rep no:</strong> 2<br><strong>Sales Rep name:</strong>  Dylan Stoddart  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Product no</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Quantity</th>
<th style="text-align:center">Price / unit</th>
<th style="text-align:center">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">327</td>
<td style="text-align:center">Inkjet cartridges</td>
<td style="text-align:center">24</td>
<td style="text-align:center">$30</td>
<td style="text-align:center">$720</td>
</tr>
<tr>
<td style="text-align:center">563</td>
<td style="text-align:center">Laser toner</td>
<td style="text-align:center">5</td>
<td style="text-align:center">$25</td>
<td style="text-align:center">$125</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>Total Price:</strong></td>
<td style="text-align:center">$835</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p><br></p>
<hr>
<p><br></p>
<p>在表格上方的数据，都具有原子性。  </p>
<p>解释一下上半部分的数据：  </p>
<p><strong><code>customer_name</code>：</strong>  </p>
<ul>
<li><code>customer_name</code>显然是依赖于<code>customer_id</code>的，而且与<code>order_id</code>没有任何关系。<br>因此在<code>order_table</code>内不应该包含<code>customer_id</code>。  </li>
</ul>
<p><strong><code>sales_rep_name</code>：</strong>  </p>
<ul>
<li><p>同理，<code>sales_rep_name</code>是依赖于<code>sales_rep_id</code>的，而且与<code>order_id</code>没有任何关系。  </p>
<p>因此在<code>order_table</code>内不应该包含<code>sales_rep_name</code>。</p>
</li>
</ul>
<p><strong><code>address</code>：</strong>  </p>
<ul>
<li><p><code>address</code>是可以发生变化的。如果<code>address</code>依赖于<code>customer_id</code>，则代表<code>address</code>是固定的。 但是在实际情况下，一个订单只能有一个地址，但是收货人可以选择相对于他的多个地址。<br>比如说第一次寄到学校，第二次寄到公司，第三次寄到家里…  </p>
<p>因此，<code>address</code>是依赖于<code>order_id</code>的。  </p>
</li>
</ul>
<hr>
<p>接下来再分析一下下面表格的数据：  </p>
<p><strong><code>price/unit</code>：</strong>  </p>
<ul>
<li>这是一个比较纠结的问题。  <code>price/unit</code>实际上是不依赖于<code>product_id</code>的。<br>因为如果实际操作中一旦改价格，主键不允许重复的特性会导致之前的老价格丢失掉。  </li>
<li>但是书上是学的理论知识，将<code>price</code>放到<code>product_table</code>里面也是可以的。因为没有违反任何范式。</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<p>因为第二范式的存在，我们不得不生成一个叫做<code>product_table</code>的表格,记录产品信息：  </p>
<p>表格： <code>product_table</code>  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><u><em>product_id</em></u></th>
<th style="text-align:center">description</th>
<th style="text-align:center">price/unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">327</td>
<td style="text-align:center">Inkjet cartridges</td>
<td style="text-align:center">$30</td>
</tr>
<tr>
<td style="text-align:center">563</td>
<td style="text-align:center">Laser toner</td>
<td style="text-align:center">$25</td>
</tr>
</tbody>
</table>
</div>
<p>还需要生成<code>customer_table</code>和<code>rep_table</code>两个表格记录ID和名字的对应信息及关系：  </p>
<p>表格： <code>customer_table</code>  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><u><em>customer_id</em></u></th>
<th style="text-align:center">customer_name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">056</td>
<td style="text-align:center">CUP</td>
</tr>
</tbody>
</table>
</div>
<p>表格： <code>rep_table</code>  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><u><em>sales_rep_id</em></u></th>
<th style="text-align:center">sales_rep_name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Dylan Stoddart</td>
</tr>
</tbody>
</table>
</div>
<p>还需要一张记录所有order信息的表格，记录order的信息。<br><code>product_table</code>和<code>rep_table</code>中的主键，在此表格中为外键。</p>
<p>表格： <code>order_table</code>   </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><u><em>order_id</em></u></th>
<th style="text-align:center">date</th>
<th style="text-align:center"><em>customer_id (fk)</em></th>
<th style="text-align:center">address</th>
<th style="text-align:center"><em>sales_rep_id (fk)</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">07845</td>
<td style="text-align:center">25-06-2016</td>
<td style="text-align:center">056</td>
<td style="text-align:center">Cambridge square, Cambridge</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p>在此表格中，<code>order_id</code>构成主键。  </p>
<p>我们在上面创建的所有表格之间都确立了某种联系。<br>所有的表格创建完之后，就可以使用内外键来从<code>Product_order</code>表中确定商品和订单的关系了。</p>
<p>表格： <code>Product_order</code>    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><u><em>product_id</em></u></th>
<th style="text-align:center"><u><em>order_id</em></u></th>
<th style="text-align:center">description</th>
<th style="text-align:center">quantity</th>
<th style="text-align:center">total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>本表格是<code>product</code>和<code>order</code>的关系表。  </p>
<p>在此表格中，<code>product_id</code>和<code>order_id</code>构成联合主键。  </p>
<p><br></p>
<hr>
<h2 id="数据库管理系统-DBMS"><a href="#数据库管理系统-DBMS" class="headerlink" title="数据库管理系统 (DBMS)"></a><strong>数据库管理系统 (DBMS)</strong></h2><h3 id="有关DBMS"><a href="#有关DBMS" class="headerlink" title="有关DBMS"></a><strong>有关DBMS</strong></h3><p>数据库不仅仅是数据的集合，理解这一点至关重要。<br>数据库是按照理论模型的规则实现的。<br>大约40年前，ANSI(美国国家标准协会)在其三级模型中提出了这一基本概念。这三个层次是:</p>
<ul>
<li>外部层面 (External level)  </li>
<li>概念层面 (Conceptual level)</li>
<li>内部层面 (Internal level)</li>
</ul>
<p>结构如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb850dbffc799d820725511421e115469?method=download&amp;shareKey=82e37f3d519539ff07cddbdb382fd0d7" alt=""></p>
<p>这个图面内容展示了数据存储在硬盘上的结构。<br>数据库存储的细节只有内部层面 (Internal level)才被指示出来，内部层面是ANSI架构中最低级的一个层级。<br>所有的访问数据的请求和处理，全部由<strong>数据库管理系统 (Database management system, DBMS)</strong>控制。  </p>
<p>在更高一层的概念层面，数据库有一个单一的通用视图 (View)，这个视图可以由一个有特定权限访问DBMS的管理员控制，叫做<strong>数据库管理员 (Database Administrator)</strong>。 </p>
<p>向用户提供视图的好处是：他们可以被数据库管理员用作一种确保安全性的机制。<br>单个用户或者用户组可以被DBA管理赋予适当的访问权限，以控制该试图允许的操作。<br>例如，用户可以读取数据，但是不能修改数据。或者用户只能访问数据库中有限数量的表。  </p>
<p>在ANSI体系结构中，概念层面有一个描述用户或者程序员感知的数据组织的概念模式，这也可以被描述成<strong>逻辑模式 (Logical schema)</strong>。  </p>
<p>逻辑模式是由数据库设计者综合所有的数据需求，并从全局的角度对数据库中全部数据的逻辑结构和特征的总体描述。是所有用户的公共数据视图，也叫做全局视图。  </p>
<article class="message is-info"><div class="message-body">

<b>Data management system (DBMS): software that controls access to data in a database.</b>

<br>

<b>Database administrator: a person who uses the DBMS to customize the database to suit user and programmer requirements.</b>

</div></article>

<p><br></p>
<hr>
<h3 id="DBMS提供的功能"><a href="#DBMS提供的功能" class="headerlink" title="DBMS提供的功能"></a><strong>DBMS提供的功能</strong></h3><p>无论数据库的大小如何，一种通用的人机沟通方法是使用专用语言SQL。SQL语言会在下一节讨论。  </p>
<p>对于大多数的DBMS类型，都有SQL命令的替代方案。比如说DBMS通过开发者接口提供软件管理工具，这种工具允许他们去在数据库内创建表格，并定义属性以及数据类型。  </p>
<p>此外，DBMS还为程序员提供了开发用户界面的工具。DBMS还提供了一个<strong>查询处理器 (Query processor)</strong>，查询处理器允许我们创建和处理数据库中的查询操作。查询就是从数据库中提取和操作数据的机制。  </p>
<p>DBMS还可以生成一个和格式化的报告，或者一个表格。程序员可以在UI中合并对于查询和报表的访问。  </p>
<article class="message is-info"><div class="message-body">

<b>Developer interface: gives access to software tools provided by a DBMS for creating tables.</b>

<br>

<b>Query processor: software tools provided by a DBMS to allow creation and execution of a query.</b>

<br>

<b>Query: used to select data from a database subject to defined conditions.</b>

</div></article>

<p><br></p>
<hr>
<h3 id="被DBA使用的DBMS功能"><a href="#被DBA使用的DBMS功能" class="headerlink" title="被DBA使用的DBMS功能"></a><strong>被DBA使用的DBMS功能</strong></h3><p>DBA的职务是负责设置用户和程序员视图，并定义适当的、特定的访问权限。  </p>
<p>DBMS的一个重要特性是<strong>数据词典 (Data dictionary)</strong>，他是数据库的一部分。除了DBA之外，没有人能够看见数据词典。<br><strong>数据词典包含了有关数据的元数据。</strong><br>数据词典内可以包含以下内容：  </p>
<ul>
<li>Field / Attribute names</li>
<li>Table name</li>
<li>Validation rules</li>
<li>Data types</li>
<li>Primary keys / Foreign keys</li>
<li>Relationships</li>
</ul>
<p>综上所述，数据词典包含所有表的属性和定义的细节，同时也包括物理存储是如何组织的。  </p>
<p>DBA也可以为表格创建<strong>索引 (Index)</strong>来提高数据库查找数据的性能和能力。  </p>
<p>索引是一个用于快速搜索的小型辅助表，它包含被搜索表中的一个attribute和指向该表中tuple的指针。</p>
<p>如果表中包含大量的attribute或者tuple,我们就很有必要为表格创建索引。<br>索引是具有为一只的属性相关联的辅助表。索引表包含属性值和指向原表中对应tuple的指针。索引可以在主键上，也可以在辅助键上。<br>搜索索引表通常来说比全表查询要快得多。  </p>
<article class="message is-info"><div class="message-body">

<b>Index: a small secondary table used for rapid searching which contains one attribute from the table being searched and pointers to the tuples in that table.</b>

</div></article>

<p><br></p>
<hr>
<h2 id="MySQL及命令及语法"><a href="#MySQL及命令及语法" class="headerlink" title="MySQL及命令及语法"></a><strong>MySQL及命令及语法</strong></h2><h3 id="数据定义语言-DDL"><a href="#数据定义语言-DDL" class="headerlink" title="数据定义语言 (DDL)"></a><strong>数据定义语言 (DDL)</strong></h3><p><strong>数据定义语言 (Data definition language, DDL)</strong>是SQL中用于创建或者修改表的语言。这些命令只会创建数据库的结构，但是他们不负责将任何数据存入数据库。  </p>
<p>下面这是一段DDL的实例：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE BandBooking;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Band (</span><br><span class="line">  BandName <span class="type">varchar</span>(<span class="number">25</span>),</span><br><span class="line">  NumberOfMembers <span class="type">integer</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Band <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (BandName);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Band<span class="operator">-</span>Booking; </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (BandName); </span><br><span class="line"><span class="keyword">REFERENCES</span> Band(BandName);</span><br></pre></td></tr></table></figure>
<p>DDL有一些特性：  </p>
<ul>
<li>SQL命令由一系列命令组成。  </li>
<li>每一个命令由<code>;</code>终止。  </li>
<li>一个命令可以包含多行。  </li>
<li>不区分大小写。  </li>
<li>但是对于命令中的关键字，比如说<code>CREATE</code>或者<code>ALTER</code>使用全大写。对表格名称，attribute名称或者数据类型使用小写。   </li>
<li>当命令包含一系列项目的时候，每一个项目使用逗号隔开。  </li>
</ul>
<p>这些例子表明，一旦创建了数据库，就可以创建表和定义属性。<br>可以在<code>CREATE TABLE</code>命令中定义一个主键和一个外键，但是也可以使用如下所示的<code>ALTER TABLE</code>命令(它也可以用来添加额外的attribute)。  </p>
<p><br></p>
<hr>
<h3 id="数据操作语言-DML"><a href="#数据操作语言-DML" class="headerlink" title="数据操作语言 (DML)"></a><strong>数据操作语言 (DML)</strong></h3><p><strong>数据操作语言 (Data manipulation language, DML)</strong>可以用于下面这三种情况：  </p>
<ul>
<li>在创建数据库的时候将数据插入到表格中。  </li>
<li>修改或删除数据库中的数据。  </li>
<li>读取存储在数据库中的数据。  </li>
</ul>
<p>下面我会给出一系列例子来展示使用DML来向表格中填充数据：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Band (<span class="string">'ComputerKidz'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Band<span class="operator">-</span>Booking (BandName, BookingID)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'ComputerKidz'</span>, <span class="string">'2016/023'</span>)  </span><br></pre></td></tr></table></figure>
<p>第一行的插入数据的方式是，根据<code>INSERT INTO</code>后面括号里的数据，依次填充每一个attribute。  </p>
<p>第二第三行就使用了一种相对保守的方法。<br>首先第二行指定了我需要填充<code>Band-Booking</code>表格中的<code>BandName</code>和<code>BookingID</code>两个attribute，然后在第三行使用<code>VALUES</code>命令按照第二行定义的数据顺序为他们赋值。  </p>
<p>你会发现：  </p>
<ul>
<li>两个命令都使用了括号。  </li>
<li>如果需要向表格中每一个attribute添加一个值，那么使用<code>INSERT</code>命令比较合理。  </li>
<li>这些属性都有顺序。  </li>
</ul>
<p><br></p>
<hr>
<p>DML的另一个用途是从数据库中查询数据，无论是原始数据还是合并数据。<br>这些命令总是先从<code>SELECT</code>命令开始。  </p>
<p>最简单的查询形式是将attribute作为输出列出来：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BandName <span class="keyword">FROM</span> Band; </span><br></pre></td></tr></table></figure>
<p>代表从<code>Band</code>表格中选出了<code>BandName</code>这个attribute。<br>注意每一个元素中间都有一个空格。  </p>
<p>我们假设<code>Band</code>表格只有两个属性。如果要列出两者的值，我们同样由两个方法。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BandName, NumberOfMembers</span><br><span class="line"><span class="keyword">FROM</span> Band;</span><br></pre></td></tr></table></figure>
<p>或者:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Band</span><br></pre></td></tr></table></figure>
<p>在第一种方式中，被选中的attribute之间使用逗号隔开，我们也不需要使用括号把attribute括起来。<br>在第二种方式里面，我们使用<code>*</code>(星号)来表示表格中的所有attribute。  </p>
<p><br></p>
<p>我们可以在SQL中使用控制输出指令，来规范我们输出的样式。<br>我们可以使用<code>ORDER BY</code> 命令来将输出的内容排序。比如说我们使用字母顺序来显示乐队名的数据：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BandName, NumberOfMembers</span><br><span class="line"><span class="keyword">FROM</span> Band</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> BandName</span><br></pre></td></tr></table></figure>
<p>在上面的实例中，我们将<code>BandName</code>和<code>NumberOfMembers</code>两个attribute根据<code>BandName</code>进行了排序。请记住，<strong><code>ORDER BY</code>命令的排序是默认升序排序</strong>，如果想使用倒序排序，我们可以将最后一行命令改成这样：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> BandName <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>升序是小在上大在下，降序是大在上小在下。  </p>
<p>在这次查询中，没有重复条目的问题，因为<code>BandName</code>是<code>BandName</code>表的主键。<br>然而，在<code>Band-Booking</code>表中，一个单独的<code>BandName</code>值会出现很多次。因为一个乐队可以有很多不同的Booking。返回Booking值会蹦出很多相同的<code>BandName</code>值。<br>所以我们可以使用<code>GROUP BY</code>可以防止这种情况，如下所示:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BandName</span><br><span class="line"><span class="keyword">FROM</span> Band<span class="operator">-</span>Booking</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> BandName;</span><br></pre></td></tr></table></figure>
<p>这样输出的值就会按照不同的<code>BandName</code>归类了。  </p>
<p><br></p>
<p>我们也可以将输出的数据加一些限制条件。这时候就可以使用<code>WHERE</code>命令了：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BandName</span><br><span class="line"><span class="keyword">FROM</span> Band<span class="operator">-</span>Booking</span><br><span class="line"><span class="keyword">WHERE</span> Headlining <span class="operator">=</span> <span class="string">'Y'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> BandName</span><br></pre></td></tr></table></figure>
<p>上面的命令只会返回当<code>Headlining</code>的值为<code>Y</code>的结果。  </p>
<p>也可以同时查询多个attribute：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BandName, NumberOfMembers</span><br><span class="line"><span class="keyword">FROM</span> Band <span class="keyword">WHERE</span> NumberOfMembers <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> BandName;</span><br></pre></td></tr></table></figure>
<p>返回所有人数大于二的乐队。返回内容包含符合条件的两个attribute的内容。  </p>
<p><br></p>
<p><strong>聚合函数 (Aggregate functions)</strong>可以对一组值进行计算，并返回一个单一的值。聚合函数有很多种，比如<code>SUM</code>,<code>COUNT</code>或者<code>AVG</code>等等。  </p>
<p>下面开始举例：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Band;</span><br></pre></td></tr></table></figure>
<p>表示Band中所有tuple的数量。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(NumberOfMembers)</span><br><span class="line"><span class="keyword">FROM</span> Band; </span><br></pre></td></tr></table></figure>
<p>返回在<code>Band</code>表格中所有<code>NumberOfMembers</code>的平均值。<br>同样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(NumberOfMembers)</span><br><span class="line"><span class="keyword">FROM</span> Band; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>返回在<code>Band</code>表格中所有<code>NumberOfMembers</code>的总和。  </p>
<p><br></p>
<p>有时候我们需要的数据存在在两张不同的表格中，这时候我们就需要用到连表查询。<br>查询可以基于两个表中数据之间的连接条件，最常用的链接方式是内连接 (inner join)。如下所示：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VenueName, <span class="type">Date</span></span><br><span class="line"><span class="keyword">FROM</span> Booking</span><br><span class="line"><span class="keyword">WHERE</span> Band<span class="operator">-</span>Booking.BookingID <span class="operator">=</span> Booking.BookingID</span><br><span class="line"><span class="keyword">AND</span> Band<span class="operator">-</span>Booking.BandName <span class="operator">=</span> <span class="string">'ComputerKidz'</span></span><br></pre></td></tr></table></figure>
<p><em><code>Band-Booking.BandName</code>代表在<code>Band-Booking</code>表格中的attribute<code>BandName</code>。</em>  </p>
<p>上表将<code>Band-Booking</code>中的<code>BookingID</code>和<code>Booking</code>中的<code>BookingID</code>连接在了一起。其中<code>Band-Booking</code>表中的<code>BookingID</code>等于<code>Booking</code>表中的<code>BookingID</code>，并且<code>Band-Booking</code>表中的<code>BandName</code>列等于<code>ComputerKidz</code>。  </p>
<p>这就是内连接，内连接的条件是<code>Band-Booking.BookingID = Booking.BookingID</code>。  </p>
<p>Query Processor会这样处理这一段代码：  </p>
<ul>
<li>搜索乐队名称为ComputerKidz的实例。</li>
<li>查看BookingID。  </li>
<li>然后，在Booking表中搜索具有此值的tuple。    </li>
<li>对于符合条件的每一个数据，VenueName和Date都在输出中显示。  </li>
</ul>
<p>你也可以使用<code>INNER JOIN</code>命令来执行内连接操作。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column1, table2.column2</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_field <span class="operator">=</span> table2.common_field</span><br></pre></td></tr></table></figure>
<p>选定了需要输出attribute之后，使用<code>INNER JOIN</code>命令来确定谁与这些内容发生内连接。  </p>
<p>随后使用<code>ON</code> 命令写出内连接条件。  </p>
<p><br></p>
<p>DML的另一个用途是修改存储在数据库中的数据。<br><code>UPDATE</code>命令用于修改数据。如果ComputerKidz乐队招募了一个额外的成员，下面的SQL语句会做出必要的改变:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Band</span><br><span class="line"><span class="keyword">SET</span> NumberOfMembers <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">WHERE</span> BandName <span class="operator">=</span> <span class="string">'ComputerKidz'</span></span><br></pre></td></tr></table></figure>
<p>首先定位需要更改值的表格，然后声明我要将<code>NumberOfMembers</code>改成6。<br>最后使用<code>WHERE</code>告诉Query processor说，我要更改<code>BandName</code>是<code>ComputerKidz</code>的值。  </p>
<p>如果不使用这个<code>WHERE</code>指令，数据库就会把表格中所有的<code>NumberOfMembers</code>改成6。  </p>
<p><br></p>
<p><code>DELETE</code>命令用于从数据库中删除数据，我们必须谨慎处理删除数据的操作。<br>假如说乐队<code>ITWizz</code>决定解散，我们就可以从数据库中删除他们的名字：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Band<span class="operator">-</span>Booking</span><br><span class="line"><span class="keyword">WHERE</span> BandName <span class="operator">=</span> <span class="string">'ITWizz'</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Band</span><br><span class="line"><span class="keyword">WHERE</span> BandName <span class="operator">=</span> <span class="string">'ITWizz'</span></span><br></pre></td></tr></table></figure>
<p>这样的就在<code>Band-Booking</code>表格和<code>Band</code>表格中都删除了这个乐队。  </p>
<p><br></p>
<hr>
<h3 id="命令基本操作"><a href="#命令基本操作" class="headerlink" title="命令基本操作"></a><strong>命令基本操作</strong></h3><p>下面来实操一下：  </p>
<p>首先我们需要创建一个数据库。<br>使用<code>create database</code>命令创建一个database。<br>比如说，下列命令：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> database school_system;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以创建一个叫做school_system的一个数据库。  </p>
<p>输出为：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，可以使用<code>show databases;</code>命令展示现有的所有数据库。  </p>
<p>运行<code>show databases</code>的输出为：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Database                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> school_system                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，<code>school_system</code>数据库即为我们刚才创建的数据库，其余的都是自带的。    </p>
<hr>
<p>如果想向数据库内添加数据，需要进入到特定的数据库内。(类似于cd命令)<br>这里可以使用<code>use *数据库名*</code>来进入到特定的数据库。    </p>
<p>运行<code>use school_system</code>命令的输出结果为：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Database changed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代表我们已经成功地进入了此数据库。  </p>
<hr>
<p>接下来，使用<code>create *参数*</code>命令是要定义数据结构。<br>此命令后面需要跟着要填入的数据以及信息。    </p>
<p>比如说此命令：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">student_id <span class="type">int</span>,</span><br><span class="line">student_name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">student_gender <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>命令代表创建一个叫做student的表格。<br>里面的参数为：<br><br></p>
<p><code>student_id int,</code>代表创建一个名称为<code>student_id</code>的Field。它的数据类型为整型。  </p>
<p><br></p>
<p><code>student_name varchar(50),</code>代表数据类型是<code>student_name</code>，数据类型是<code>varchar</code>，长度上限为50。<br>P.S. <code>varchar</code>代表“可变的数据长度“。  </p>
<p><br></p>
<p><code>student_gender char(1),</code>代表在<code>student_gender</code>中，数据类型是<code>char</code>，上限为1。<br><code>char</code>代表”定长数据“。  </p>
<p><br></p>
<p>输出结果为:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代表表格创建成功了。</p>
<p>这里有几个注意事项：</p>
<ul>
<li><code>;</code>代表一行命令结束。当写下一行命令后，程序不会直接完成操作，直到出现了一个<code>;</code>。  </li>
<li>如果在<code>student_gender char(1)</code>的末尾加一个逗号，会判定为错误。因为这已经是此次create命令里面最后一行参数，不需要再次使用逗号隔开参数。  </li>
<li>多有<code>()</code>是成对出现的。括号的范围代表命令参数的范围。</li>
</ul>
<p><br></p>
<hr>
<p>使用<code>show tables;</code>命令展示数据库内所有的table。<br>在这里运行<code>show tables;</code>的结果为：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_school_system <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> student                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明已经存在一个student table了</p>
<hr>
<p>之后，我们需要写入数据。  </p>
<p>使用<code>insert into</code>命令写入数据。<br>以下命令：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1000</span>, <span class="string">'张三'</span>,<span class="string">'M'</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代表向student表格内插入<code>(1000, '张三','M')</code>三个数据。其中：<br><code>1000</code>对应<code>student_id</code><br><code>张三</code>对应<code>student_name</code><br><code>M</code>对应<code>student_gender</code>  。  </p>
<p>运行后输出为：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样代表写入成功。  </p>
<p>输入<code>select</code>命令，可以查看table中的数据：<br>运行<code>select * from student;</code>命令的输出为：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> student_id <span class="operator">|</span> student_name <span class="operator">|</span> student_gender <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>             <span class="number">1000</span> <span class="operator">|</span> 张三                    <span class="operator">|</span> M                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------------------+-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在此命令中，<code>*</code>代表范围内的全部。  </p>
<hr>
<h1 id="PART-TWO：基本问题的解决与编程技能"><a href="#PART-TWO：基本问题的解决与编程技能" class="headerlink" title="PART TWO：基本问题的解决与编程技能"></a><strong>PART TWO：基本问题的解决与编程技能</strong></h1><h1 id="第十二章：算法设计与解决问题"><a href="#第十二章：算法设计与解决问题" class="headerlink" title="第十二章：算法设计与解决问题"></a><strong>第十二章：算法设计与解决问题</strong></h1><h2 id="计算思维"><a href="#计算思维" class="headerlink" title="计算思维"></a><strong>计算思维</strong></h2><p>计算思维是一种解决问题的思路，通常以清晰的步骤来呈现。<br>计算思维是一种逻辑思维，在计算机这门学科中，使用计算思维来解决问题是十分常见的。  </p>
<p>计算思维包括五大部分：“抽象问题”，“分解问题”，“数据建模”，“样式识别”和“算法思维”。  </p>
<h3 id="抽象问题"><a href="#抽象问题" class="headerlink" title="抽象问题"></a><strong>抽象问题</strong></h3><p>抽象问题的目标是将问题最本质最中心的部分提取出来，过滤掉我们不需要的信息，以便我们分析并解决问题。<br>这在我们的生活中是很常见的，比如开车在市中心规划最近的路线，我们就可以抽象我们想要的信息单独处理。  </p>
<p>就像数学中的化简思维一样，把复杂的问题简单化，就可以让我们解决更困难的问题。  </p>
<p><br></p>
<h3 id="分解问题"><a href="#分解问题" class="headerlink" title="分解问题"></a><strong>分解问题</strong></h3><p>下一步就是要把一个大块的问题分解成若干小问题，并一个一个解决。  </p>
<p><br></p>
<h3 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a><strong>数据建模</strong></h3><p>数据建模管的是数据的管理，分析和处理。  </p>
<p><br></p>
<h3 id="样式识别"><a href="#样式识别" class="headerlink" title="样式识别"></a><strong>样式识别</strong></h3><p>有点像是套公式的意思：总结问题并发现是不是已经有相关的；成系统的解决方法，可以解决这个问题。<br>比如说移用已经存在的算法，比如冒泡排序。  </p>
<p><br></p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a><strong>算法设计</strong></h3><p>最后我们就需要设计一个可以解决问题的算法。  </p>
<article class="message is-info"><div class="message-body">

<b>Algorithm: a sequence of defined steps that can be carried out to perform a task.</b>

</div></article>   

<p><br></p>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><p>我们每天都会使用算法。<br>假如说你想要烤个蛋糕，你可以遵循下面的步骤：  </p>
<ol>
<li>称量下列的原料：200g白糖，200g黄油，4个鸡蛋，200g面粉，2茶匙的酵母和2茶匙的牛奶。  </li>
<li>将这些食材放入一个大碗中混合，只到混合物变得质地均匀。  </li>
<li>将混合物倒入一个蛋糕模具。  </li>
<li>放入烤箱，将烤箱设置为190℃，烘烤20分钟。  </li>
<li>检查蛋糕到底有没有烤好。  </li>
<li>将蛋糕从烤箱中的模具中拿出来，并放置在铁架上冷却。  </li>
</ol>
<p>上面的这一些步骤就是一个算法。这些食材是输入部分，而蛋糕就是这个算法的输出。算法具体的过程是讲原料混合，然后放入烤箱烘烤。  </p>
<p><br></p>
<p>有些时候问题是会发生一些灵活的变化的，其中一些条件变化就会影响到我们解决问题的步骤。<br>比如说我们现在要去考虑如何在伦敦地铁中到达想要去的目的地。  </p>
<p>从 King’s Cross St. Pancras 到 Westminster,一共有两条备选路线：  </p>
<p>A：乘坐Victoria Line 到Green Park(4站)，然后再换乘Jubilee Line到Westminster(1站)。<br>B：乘坐Piccadilly Line 到Green Park(6站)，然后再换乘Jubilee Line到Westminster(1站)。  </p>
<p>A看起来像是最好的路线，但是如果在Victoria Line上面有施工的话，那么B就是最好的路线。这种情况下我们就需要重新设计我们的算法。  </p>
<p>如果以上的逻辑写成有点类似于代码的形式，那么它看起来就是这样的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF there are engineering works on the Victoria Line</span><br><span class="line"></span><br><span class="line">  THEN</span><br><span class="line">    Take the Piccadilly Line to Green Park (6 stations)</span><br><span class="line">    Take the Jubilee Line to Westminster (1 station)</span><br><span class="line">  ELSE</span><br><span class="line">    Take the Victoria Line to Green Park (4 stations)</span><br><span class="line">    Take the Jubilee Line to Westminster (1 station)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="算法的表示"><a href="#算法的表示" class="headerlink" title="算法的表示"></a><strong>算法的表示</strong></h2><p>在计算机中，我们会先将代码的结构或者思路以<strong>结构化英语 (Structured English)</strong>或者<strong>伪代码 (Pseudocode)</strong>表示。<br>有时我们也会使用<strong>流程图 (Flowchart)</strong>，侧重于表示代码的逻辑过程。  </p>
<article class="message is-info"><div class="message-body">

<b>Structured English: a subset of the English language that consists of command statements used to describe an algorithm.</b>

<br>

<b>Pseudocode: a way of using keywords and identifiers to describe an algorithm without following the syntax of a particular programming language.</b>

<br>

<b>Flowchart: shapes linked together to represent the sequential steps of an algorithm.</b>

</div></article>   

<p><br></p>
<p>算法包含很多细分的步骤，但是有些时候我们不想让计算机执行某几行代码，或者我们想重复某几行代码。<br>在计算机科学这门课程中，当我们在编写算法的时候，我们需要遵守下面这几个基本的结构：  </p>
<ul>
<li>赋值： 赋予数值一个名称，或者叫做标识符，或者更改指定标识符所代表的值。  </li>
<li>顺序： 一个接一个地执行步骤。  </li>
<li>选择： 在某些条件下执行某些步骤，否则就执行另一些步骤。  </li>
<li>重复： 一系列的步骤被重复执行多次，这也可以被叫做迭代或者循环。  </li>
</ul>
<p><br></p>
<p>我们在使用计算机解决问题时会涉及各种各样的数据，数据流在计算机中的处理方式一般是输入 -&gt; 处理 -&gt; 输出。  </p>
<p>处理好输入和输出后，我们就需要深入处理部分。首先我们需要了解处理的详细方法是什么，处理的步骤是什么样子的，我们的程序会怎么样设计。  </p>
<p>下面给出了部分处理的不同表示方法。包括结构化英语，伪代码和流程图。  </p>
<ol>
<li><p>分配与顺序：  </p>
<ul>
<li><p>结构化英语：   </p>
<p>SET A TO 34<br>INCREMENT B</p>
</li>
<li><p>伪代码：  </p>
<p>A ← 34<br>B ← B + 1</p>
</li>
</ul>
</li>
<li><p>选择：  </p>
<ul>
<li><p>结构化英语：  </p>
<p>IF A IN GREATER THAN B<br> THEN …<br> ELSE …</p>
</li>
<li><p>伪代码：  </p>
<p>IF A &gt; B<br> THEN ….<br> ELSE ….<br>ENDIF</p>
</li>
</ul>
</li>
<li><p>重复：  </p>
<ul>
<li><p>结构化英语：  </p>
<p>REPEAT UNTIL A IS EQUAL TO B…</p>
</li>
<li><p>伪代码：  </p>
<p>REPEAT<br> …<br>UNTIL A = B</p>
</li>
</ul>
</li>
<li><p>输入：  </p>
<ul>
<li><p>结构化英语：  </p>
<p>INPUT A </p>
</li>
<li><p>伪代码：  </p>
<p>INPUT “Prompt: “ A</p>
</li>
</ul>
</li>
<li><p>输出：  </p>
<ul>
<li><p>结构化英语：  </p>
<p>OUTPUT “Message”<br>OUTPUT B</p>
</li>
<li><p>伪代码：  </p>
<p>OUTPUT “Message”, B</p>
</li>
</ul>
</li>
</ol>
<p><br></p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>当我们在程序中处理数据的时候，他们都需要被存进内存中。<br>我们需要把这些数据放在一个特殊的位置，好允许他们去自由读写。<br>我们一般将这些内存中的位置叫做<strong>变量 (Variables)</strong>。<br>这些变量就好比是一个贴上标签的盒子。当一个值被输入了之后，值就会被存在一个有标识的容器内。  </p>
<article class="message is-info"><div class="message-body">

<b>Variable: a storage location for a data value that has an identifier.</b>

</div></article>   

<p><br></p>
<h3 id="标识符表"><a href="#标识符表" class="headerlink" title="标识符表"></a><strong>标识符表</strong></h3><p>标识符表是用来解释每一个变量是干嘛用的，一般来说还要列出他们的数据类型。  </p>
<article class="message is-info"><div class="message-body">

<b>Identifier table: a table listing the variable identifiers required for the solution, with explanations and data types.</b>

</div></article>   

<p>比如说我这里有一个被写成结构化英语形式的问题：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INPUT number of miles</span><br><span class="line">CALCULATE number of km</span><br><span class="line">OUTPUT calculated result as km</span><br></pre></td></tr></table></figure></p>
<p>在我开始写伪代码之前，我需要先分析问题如何解决。<br>在这个问题中，我们需要设计一个变量，来存储输入的里程值，叫做<code>Miles</code>好了。<br>同时还需要另一个变量，用来存储转化为公里数后的结果。这里我选择定义这个变量为<code>Km</code>。  </p>
<p>这样就可以开始列表了：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Identifier</th>
<th style="text-align:center">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Miles</td>
<td style="text-align:center">Distance as a whole number of miles.</td>
</tr>
<tr>
<td style="text-align:center">Km</td>
<td style="text-align:center">The result from using the given formula: Km = Miles * 1.61.</td>
</tr>
</tbody>
</table>
</div>
<p>请记住：所有的标识符表中都必须包含<strong>标识符，数据类型和解释。</strong>  </p>
<p>（<em>我只不过是没在这里加数据类型而已，因为数据类型在下一章才会接触到</em>）</p>
<hr>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a><strong>赋值</strong></h2><p>下面我们会写到很多伪代码。<br>课本里出现的伪代码并不是一个确切的语言，也就是说，可能每一家出版社的计算机课本的伪代码语法都不一样。<br>下面的赋值内容中出现的所有伪代码，同样确定了本书伪代码的语言规范。本书之后所有的伪代码全部遵守下面的语法规范。  </p>
<h3 id="向变量中赋值"><a href="#向变量中赋值" class="headerlink" title="向变量中赋值"></a><strong>向变量中赋值</strong></h3><p>我们来简单举一个例子。这个例子在下面的小节中也会用到。  </p>
<p>假如说我有一个变量<code>NumberOfGuesses</code>,用来记录在一个猜数字的游戏中，玩家一共猜了多少次；<br>玩家的名字会存储在一个叫做<code>ThisPlayer</code>的变量中。<br>玩家猜的数字会存在一个叫做<code>Number</code>的变量中。</p>
<p>那么下面的伪代码就讲述了我将用户的输入存入<code>Number</code>的过程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INPUT Number</span><br></pre></td></tr></table></figure></p>
<p>随后我们要将<code>NumberOfGuesses</code>中的数值变为1，因为玩家做出了他的第一次猜测：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NumberOfGuesses ← 1 </span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="更新值"><a href="#更新值" class="headerlink" title="更新值"></a><strong>更新值</strong></h3><p>假设玩家再次做出了一次猜测，那么变量<code>NumberOfGuesses</code>就应该加一：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NumberOfGuesses ← NumberOfGuesses + 1</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a><strong>复制值</strong></h3><p>值可以被从一个变量中复制到另一个变量中。</p>
<p>假如说我们有一个变量<code>Value1</code>，里面有一个值<code>15</code>。<br>现在我们想要将这个值复制到变量<code>Value2</code>中，伪代码就可以这么写：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value2 ← Value1</span><br></pre></td></tr></table></figure>
<p>放在左边的变量是复制操作的目标变量。<br>复制完成后，<code>Value1</code>和<code>Value2</code>的值都是15。</p>
<p><br></p>
<h3 id="交换值"><a href="#交换值" class="headerlink" title="交换值"></a><strong>交换值</strong></h3><p>如果我们想要交换两个值，我们就需要第三个变量帮忙了。  </p>
<p>假设<code>Value1</code>为15，<code>Value2</code>为34。<br>我想要让<code>Value1</code>和<code>Value2</code>的位置交换，这时候我可以定义一个新的变量，叫做<code>Temp</code>，用于存放临时数据。  </p>
<p>接下来就可以写伪代码了。这看起来应该不算难理解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Temp ← Value1</span><br><span class="line">Value1 ← Value2</span><br><span class="line">Value2 ← Temp</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a><strong>逻辑表达式</strong></h2><p>还记得一开始的地铁问题吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IF there are engineering works on the Victoria Line</span><br><span class="line"></span><br><span class="line">  THEN</span><br><span class="line">    Take the Piccadilly Line to Green Park (6 stations)</span><br><span class="line">    Take the Jubilee Line to Westminster (1 station)</span><br><span class="line">  ELSE</span><br><span class="line">    Take the Victoria Line to Green Park (4 stations)</span><br><span class="line">    Take the Jubilee Line to Westminster (1 station)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个问题的实际解决过程中，我们需要使用逻辑表达式来解决问题。具体是用于判断那个IF条件。  </p>
<p>下面我会列出一些本书中会用到的逻辑运算符：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Operator</th>
<th style="text-align:left">Comparison</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&gt;</code></td>
<td style="text-align:left"><strong>不等于</strong></td>
</tr>
</tbody>
</table>
</div>
<p>经过逻辑运算后，会输出一个布尔值（TRUE 或者 FALSE）。<br>特别注意的是：在一些语言里面，’=’符号通常作为赋值使用，但是再本书的伪代码部分中，<strong>‘=’是逻辑运算符，’←’是赋值符号。</strong>  </p>
<p><span class="tag is-warning">Example</span></p>
<p>举个例子：  </p>
<p>13岁以下的人被归类为儿童，19岁以上的人被归类为成年人。如果他们在13到19岁之间，他们被归类为青少年。我们可以把这些语句写成逻辑语句：  </p>
<ul>
<li><code>If Age &lt; 13 then person is a child.</code></li>
<li><code>If Age &gt; 19 then person is an adult.</code></li>
<li><code>If Age &gt;= 13 AND Age &lt;= 19 then person is a teenager.</code></li>
</ul>
<p><br></p>
<p><span class="tag is-warning">Example</span></p>
<p>我们再举一个例子：这里有一个猜数字的游戏。猜数游戏会根据特定条件采取不同的步骤。下面是算法描述。  </p>
<ul>
<li>玩家需要输入一个数字，来猜测存储的秘密数字。  </li>
<li>如果猜对了，那么程序就会显示祝贺语。  </li>
<li>如果这个数字比秘密数字要大，就会显示“秘密数字比他要小。”  </li>
<li>如果这个数字比秘密数字要小，就会显示“秘密数字比他要大。”  </li>
</ul>
<p>我们就可以将这个算法用伪代码写出来：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SET value for secret number</span><br><span class="line">INPUT Guess</span><br><span class="line">IF Guess = SecretNumber</span><br><span class="line">  THEN</span><br><span class="line">    OUTPUT "Well done. You have guessed the secret number."</span><br><span class="line">  ELSE</span><br><span class="line">    IF Guess &gt; SecretNumber</span><br><span class="line">      THEN</span><br><span class="line">        OUTPUT "Secret number is smaller."</span><br><span class="line">      ELSE</span><br><span class="line">        OUTPUT "Secret number is greater."</span><br><span class="line">    ENDIF</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>使用逻辑操作符<code>AND</code>、<code>OR</code>和<code>NOT</code>可以形成更复杂的条件。<br>例如，猜数字游戏可能允许玩家多次猜测,如果玩家猜了10次仍然没有猜出秘密数字，则输出不同的消息:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IF Guess = SecretNumber</span><br><span class="line">  THEN</span><br><span class="line">    OUTPUT "Well done. You have guessed the secret number."</span><br><span class="line">  ELSE</span><br><span class="line">    IF Guess &gt; SecretNumber AND NumberofGuesses = 10</span><br><span class="line">      THEN</span><br><span class="line">        OUTPUT "You still have not guessed the secret number."</span><br><span class="line">      ELSE</span><br><span class="line">        IF Guess &gt; SecretNumber</span><br><span class="line">          THEN</span><br><span class="line">            OUTPUT "Secret number is smaller."</span><br><span class="line">          ELSE</span><br><span class="line">            OUTPUT "Secret number is greater."</span><br><span class="line">        ENDIF</span><br><span class="line">    ENDIF</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<p>像上面这样：当一个IF语句包含另一个IF语句时，我们称它们为嵌套IF语句。  </p>
<article class="message is-info"><div class="message-body">

<b>Nested IF statements: conditional statements within conditional statements.</b>

</div></article>   

<p><br></p>
<hr>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a><strong>循环</strong></h2><p>有些时候我们的代码需要重复执行某些命令。大家都知道代码是由上到下顺序执行的。也就是说，如果按照传统的方法重复指令，就需要一遍又一遍的写下这些代码。这就会给代码带来冗余。  </p>
<p>但是如果我们使用重复结构，或者叫做循环，就可以避免一遍又一遍地写相同的伪代码。  </p>
<p><br></p>
<p><span class="tag is-warning">Example</span></p>
<p>给个例子：  </p>
<p>我需要写一个程序，目标是将输入的10个数字里面找出最大的数字。  </p>
<p>我们还需要一个变量来存储一个计数器，以便我们知道什么时候比较了10个数字。  </p>
<p>先写标识符表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Identifier</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>BiggestSoFar</code></td>
<td style="text-align:left">Stores the biggest number input so far.</td>
</tr>
<tr>
<td style="text-align:left"><code>NextNumber</code></td>
<td style="text-align:left">The next number to be input.</td>
</tr>
<tr>
<td style="text-align:left"><code>Counter</code></td>
<td style="text-align:left">Stores how many numbers have been input so far.</td>
</tr>
</tbody>
</table>
</div>
<p>代码写出来是这样的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INPUT BiggestSoFar</span><br><span class="line">Counter ← 1</span><br><span class="line">REPEAT</span><br><span class="line">    INPUT NextNumber</span><br><span class="line">    Counter ← Counter + 1</span><br><span class="line">    IF NextNumber &gt; BiggestSoFar</span><br><span class="line">      THEN</span><br><span class="line">        BiggestSoFar ← NextNumber</span><br><span class="line">    ENDIF</span><br><span class="line">UNTIL Counter = 10</span><br><span class="line">OUTPUT BiggestSoFar</span><br></pre></td></tr></table></figure>
<p>在这个程序中出现了循环指令：<code>REPEAT...UNTIL</code>  </p>
<p>在REPEAT和UNTIL包裹的区域内，是将要循环的步骤。<br>UNTIL后面会跟一个逻辑表达式。当逻辑表达式成立的时候，跳出循环。  </p>
<p><br></p>
<p>这个题目还可以换一种方法来写：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Identifier</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>BiggestSoFar</code></td>
<td style="text-align:left">Stores the biggest number input so far.</td>
</tr>
<tr>
<td style="text-align:left"><code>NextNumber</code></td>
<td style="text-align:left">The next number to be input.</td>
</tr>
<tr>
<td style="text-align:left"><code>Counter</code></td>
<td style="text-align:left">Counts the number of times round the loop.</td>
</tr>
</tbody>
</table>
</div>
<p>请注意，<code>Counter</code>变量的用途已经改变了。这里的<code>Counter</code>是要记录循环的次数。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INPUT BiggestSoFar</span><br><span class="line">FOR Counter ← 2 TO 10</span><br><span class="line">    INPUT NextNumber</span><br><span class="line">    IF NextNumber &gt; BiggestSoFar</span><br><span class="line">      THEN</span><br><span class="line">        BiggestSoFar ← NextNumber</span><br><span class="line">    ENDIF</span><br><span class="line">NEXT Counter</span><br><span class="line">OUTPUT BiggestSoFar</span><br></pre></td></tr></table></figure>
<p>在第一次循环的时候，<code>Counter</code>的值被设为了2，下一次循环就变成了3，以此类推。最后一次循环的时候，<code>Counter</code>的值会被设为10。这时候达到了第二行定义过的<code>Counter</code>最大值，所以就会跳出循环。</p>
<p><br></p>
<p>Rogue value是在算法上下文中的一个特殊值，通常出现在递归或者循环算法中，作为终止条件出现。  </p>
<article class="message is-info"><div class="message-body">

<b>Rogue value: a value used to terminate a sequence of values.</b>

</div></article>   

<p><span class="tag is-warning">Example</span></p>
<p>下面我来用一个例子具体解释一下rogue value是干嘛用的：  </p>
<p>有一个非零数列以0结尾。这个数列是输入部分，请你找出这个数列中的最大值。  </p>
<p>在这个例子中，我们可以将rogue value设为0。因为0与数据类型相同，但是超出了我们正常期望值的范围。好比说如果我的输入会包含0，那么我也可以选择-1作为rogue value。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Identifier</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>BiggestSoFar</code></td>
<td style="text-align:left">Stores the biggest number input so far.</td>
</tr>
<tr>
<td style="text-align:left"><code>NextNumber</code></td>
<td style="text-align:left">The next number to be input.</td>
</tr>
</tbody>
</table>
</div>
<p>其中一个可行的方案可以是这样的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INPUT BiggestSoFar</span><br><span class="line">REPEAT</span><br><span class="line">    INPUT NextNumber</span><br><span class="line">    IF NextNumber &gt; BiggestSoFar</span><br><span class="line">      THEN</span><br><span class="line">        BiggestSoFar ← NextNumber</span><br><span class="line">    ENDIF</span><br><span class="line">UNTIL NextNumber = 0</span><br><span class="line">OUTPUT BiggestSoFar</span><br></pre></td></tr></table></figure>
<p>这种算法在绝大多数的情况下可以正常工作，但是如果唯一的输入是零，整个程序就炸了。  </p>
<p>所以说我们可以使用WHILE…ENDWHILE循环来实现同样的目的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INPUT NextNumber</span><br><span class="line">BiggestSoFar ← NextNumber</span><br><span class="line">WHILE NextNumber &lt;&gt; 0 DO</span><br><span class="line">    INPUT NextNumber</span><br><span class="line">    IF NextNumber &gt; BiggestSoFar</span><br><span class="line">      THEN</span><br><span class="line">        BiggestSoFar ← NextNumber</span><br><span class="line">    ENDIF</span><br><span class="line">ENDWHILE</span><br><span class="line">OUTPUT BiggestSoFar</span><br></pre></td></tr></table></figure>
<p>在我们进入循环之前，我们需要检查是否存在一个非零的数字输入进来。为了处理第一个数字，我们需要将其存储在<code>NextNumber</code>和<code>BiggestSoFar</code>变量中。如果我们的第一个数字是零，就不执行循环中的指令。  </p>
<p><br></p>
<hr>
<h2 id="逐步求精法"><a href="#逐步求精法" class="headerlink" title="逐步求精法"></a><strong>逐步求精法</strong></h2><p>就像我们一开始在计算机思维那里提到过的：许多我们想要解决的问题比我们目前遇到的问题更大。为了让更大的问题更容易解决，我们将问题分解为更小的步骤。这些可能需要进一步分解，直到步骤足够小，可以轻松解决。  </p>
<p>为了使问题的解决方案可编程，我们需要将解决方案的步骤分解为序列、分配、选择、重复、输入和输出。</p>
<p>我们可以使用一种称为逐步求精的方法，将轮廓解决方案的步骤分解为更小的步骤，直到它足够详细。<br>在本章节的一开始，我们就举了一个烤蛋糕的例子。当时的第二步就被我们简单的细化了一下。</p>
<article class="message is-info"><div class="message-body">

<b>Stepwise refinement: breaking down the steps of an outline solution into smaller and smaller steps.</b>

</div></article>   

<p><span class="tag is-warning">Example</span></p>
<p>老规矩，上例子：  </p>
<p>写一个程序：将选定的符号和一个奇数作为输入。输出一个完全由选定的符号组成的金字塔形状，最后一行中的符号数量与输入的数字匹配。  </p>
<p>好比说我输入一个数字9，就会给我输出这个：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   AAA</span><br><span class="line">  AAAAA</span><br><span class="line"> AAAAAAA</span><br><span class="line">AAAAAAAAA</span><br></pre></td></tr></table></figure>
<p><em>上面的排版可能会歪掉，所以我简单描述下：上面代码块里面就是一个由A组成的，最下面一行有九个A的三角形。</em></p>
<p>首先分解问题：具体的步骤可以写成下面的这几行结构化英语：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.  Set up initial values</span><br><span class="line">2.  REPEAT</span><br><span class="line">3.      Output number of spaces</span><br><span class="line">4.      Output number of symbols</span><br><span class="line">5.      Adjust number of spaces and number of symbols to be output in next row</span><br><span class="line">6.  UNTIL the required number of symbols have been output in one row</span><br></pre></td></tr></table></figure>
<p>这里的1. 2. 3.等代表解决问题需要的步骤，下面会有提到。  </p>
<p>首先初始化，然后重复以下步骤，直到完成第一行的输出：  </p>
<ul>
<li>输出空格数</li>
<li>输出符号</li>
<li>调整下一行要输出的空格数和符号数</li>
</ul>
<p><br></p>
<p>其次我们还需要考虑需要使用哪些变量，以及这些变量的作用。<br>比如说，我们还需要：  </p>
<ul>
<li>组成金字塔的符号（组成金字塔具体的字符）</li>
<li>在最后一行中字符的个数（为了让金字塔看起来对称，我们必须输入一个奇数）</li>
</ul>
<p><br></p>
<p>然后我们还需要计算形成第一行需要多少空格。如果这个金字塔是对称的，那么第一行的最后一个字符一定出现在最后一行字符的中间位置。  </p>
<p>我们需要将第一行输出的符号数量设置为1，这样我们就需要下面的标识符：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Identifier</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Symbol</code></td>
<td style="text-align:left">The character symbol to form the pyramid.</td>
</tr>
<tr>
<td style="text-align:left"><code>MaxNumberOfSymbols</code></td>
<td style="text-align:left">The number of symbols in the final row.</td>
</tr>
<tr>
<td style="text-align:left"><code>NumberOfSpaces</code></td>
<td style="text-align:left">The number of spaces to be output in the current row.</td>
</tr>
<tr>
<td style="text-align:left"><code>NumberOfSymbols</code></td>
<td style="text-align:left">The number of symbols to be output in the current row.</td>
</tr>
</tbody>
</table>
</div>
<p>分解问题之后，解决他就相对简单了。  </p>
<p>解决完前摇之后，就可以将精力专注于写解决方案上了：  </p>
<p>第一部分初始化的代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INPUT Symbol</span><br><span class="line">INPUT MaxNumberOfSymbols</span><br><span class="line">NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2</span><br><span class="line">NumberOfSymbols ← 1</span><br></pre></td></tr></table></figure>
<p>因为变量<code>MaxNumberOfSymbols</code>需要一个合法的输入（一个奇数），所以我们就需要将第二行替换成下面这样，才可以保证合法输入。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">    INPUT MaxNumberOfSymbols</span><br><span class="line">UNTIL MaxNumberOfSymbols MOD 2 = 1</span><br></pre></td></tr></table></figure>
<p>这里的MOD是取余的意思。如果<code>MaxNumberOfSymbols</code>除以二之后是1，那么这就代表输入是合法的。<br>如果不合法，那么程序就会一直重复输入这一步，直到输入合法。  </p>
<p>替换进去，第一步的完整代码就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INPUT Symbol</span><br><span class="line">REPEAT</span><br><span class="line">    INPUT MaxNumberOfSymbols</span><br><span class="line">UNTIL MaxNumberOfSymbols MOD 2 = 1</span><br><span class="line">NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2</span><br><span class="line">NumberOfSymbols ← 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>第二步就是个重复开始字段，所以接下来细说第三步和第四步。  </p>
<p>这是第三步的解法：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR i ← 1 TO NumberOfSpaces</span><br><span class="line">    OUTPUT Space</span><br><span class="line">NEXT i</span><br></pre></td></tr></table></figure>
<p>一个原味i循环。  </p>
<p>然后是第四步：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOR i ← 1 TO NumberOfSymbols</span><br><span class="line">    OUTPUT Symbol</span><br><span class="line">NEXT i</span><br><span class="line">OUTPUT Newline</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>在第五步中，我们需要将接下来每一行的空格的数量减少1，将符号的数量增加2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NumberOfSpaces ← NumberOfSpaces - 1</span><br><span class="line">NumberOfSymbols ← NumberOfSymbols + 2</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>第六步会检查下一行的符号数量现在是否大于开始时输入的值:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNTIL NumberOfSymbols &gt; MaxNumberOfSymbols</span><br></pre></td></tr></table></figure>
<p>最后就可以把整块代码合起来了。这就是最后的产物：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INPUT Symbol</span><br><span class="line">REPEAT</span><br><span class="line">    INPUT MaxNumberOfSymbols</span><br><span class="line">UNTIL MaxNumberOfSymbols MOD 2 = 1</span><br><span class="line">NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2</span><br><span class="line">NumberOfSymbols ← 1</span><br><span class="line">REPEAT</span><br><span class="line">    FOR i ← 1 TO NumberOfSpaces</span><br><span class="line">        OUTPUT Space</span><br><span class="line">    NEXT i</span><br><span class="line">    FOR i ← 1 TO NumberOfSymbols</span><br><span class="line">        OUTPUT Symbol</span><br><span class="line">    NEXT i</span><br><span class="line">    OUTPUT Newline</span><br><span class="line">    NumberOfSpaces ← NumberOfSpaces - 1</span><br><span class="line">    NumberOfSymbols ← NumberOfSymbols + 2</span><br><span class="line">UNTIL NumberOfSymbols &gt; MaxNumberOfSymbols</span><br></pre></td></tr></table></figure>
<p>Stepwise refinement本质上来讲就是分解步骤。把他用到写程序中是一个很好的习惯（  </p>
<p><br></p>
<hr>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a><strong>模块</strong></h2><p>另一种开发解决方案的方法是将问题分解为子任务。每个子任务可以被认为是一个单独细化的模块。模块里面包含的东西是<strong>过程 (Procedure)</strong>和<strong>函数 (Function)</strong>。  </p>
<p><strong>过程 (Procedure)</strong>将许多小的步骤组合在一起，并给它们一个名称(标识符)。<br>当我们想引用这组步骤时，可以使用这个标识符。<br>当我们想要执行过程中的步骤时，我们通过过程的名称调用该过程。</p>
<article class="message is-info"><div class="message-body">

<b>Procedure: a sequence of steps that is given an identifier and can be called to perform a sub-task.</b>

</div></article>   

<p><em>过程是一组给定标识符的步骤，可以调用它们执行一个子任务</em></p>
<p><br></p>
<p><strong>函数 (Function)</strong>同样将许多步骤组合在一起，并给它们一个名称(标识符)。<br>但是这些步骤会生成并返回一个用于表达式的值。  </p>
<article class="message is-info"><div class="message-body">

<b>Function: a sequence of steps that is given an identifier and returns a single value; function call is part of an expression.</b>

</div></article>   


<p><strong>函数和过程的区别在于，函数可以返回值，而过程则不能。</strong><br>因为函数和过程是两种不同的代码块，它们的设计目的和用途不同。<br><strong>函数的设计目的是为了返回一个值，而过程的设计目的是为了执行一些操作。</strong>虽然说你可以将函数看作是一种特殊的过程，因为它们都是由一些语句组成的代码块。</p>
<p>因为函数返回一个值，所以函数定义同样声明了这个值的数据类型。<br>我们会在下一章详细介绍数据类型。</p>
<p><br></p>
<p><span class="tag is-warning">Example</span></p>
<p>上一个小结说过的画金字塔的例子，可以完全改成模块化的。  </p>
<p>首先根据之前的解决方法，先写一个主程序：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CALL SetValues</span><br><span class="line">REPEAT</span><br><span class="line">    CALL OutputSpaces</span><br><span class="line">    CALL OutputSymbols</span><br><span class="line">    CALL AdjustValuesForNextRow</span><br><span class="line">UNTIL NumberOfSymbols &gt; MaxNumberOfSymbols</span><br></pre></td></tr></table></figure>
<p>你会发现主程序里面充满了<code>CALL</code>。<code>CALL</code>说白了就是调用。举个例子，<code>CALL SetValues</code>就是要调用<code>SetValues</code>模块。  </p>
<p>然后我们填充每一个模块中的内容，就可以完美运行了：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE SetValues</span><br><span class="line">    INPUT Symbol</span><br><span class="line">    INPUT MaxNumberOfSymbols</span><br><span class="line">    NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2</span><br><span class="line">    NumberOfSymbols ← 1</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCEDURE InputMaxNumberOfSymbols</span><br><span class="line">    REPEAT</span><br><span class="line">        INPUT MaxNumberOfSymbols</span><br><span class="line">    UNTIL MaxNumberOfSymbols MOD 2 = 1</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCEDURE OutputSpaces</span><br><span class="line">    FOR i ← 1 TO NumberOfSpaces</span><br><span class="line">        OUTPUT Space</span><br><span class="line">    NEXT i</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCEDURE OutputSymbols</span><br><span class="line">    FOR i ← 1 TO NumberOfSymbols</span><br><span class="line">        OUTPUT Symbol</span><br><span class="line">    NEXT i</span><br><span class="line">    OUTPUT Newline</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCEDURE AdjustValuesForNextRow</span><br><span class="line">    NumberOfSpaces ← NumberOfSpaces - 1</span><br><span class="line">    NumberOfSymbols ← NumberOfSymbols + 2</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL SetValues</span><br><span class="line">REPEAT</span><br><span class="line">    CALL OutputSpaces</span><br><span class="line">    CALL OutputSymbols</span><br><span class="line">    CALL AdjustValuesForNextRow</span><br><span class="line">UNTIL NumberOfSymbols &gt; MaxNumberOfSymbols</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样也可以将某些模块从过程换为函数。过程基本是一样的所以不多赘述了。  </p>
<p><br></p>
<p>变量分<strong>全局变量 (Global variable)</strong>和<strong>局部变量 (Local variable)</strong>。</p>
<p>局部变量是在函数内部定义的变量，只在本函数范围内有效。<br>全局变量是在函数外部定义的变量，从定义变量的位置到本源文件结束都有效。  </p>
<p>在函数中，局部变量和全局变量的区别在于它们的作用域和生命周期。<br>局部变量只在函数内部有效，而全局变量则在整个程序中都有效。  </p>
<p>比如说：以下代码段中，<code>x</code>是一个局部变量，只在 <code>myFunction()</code> 函数内部有效。而 <code>y</code> 是一个全局变量，在整个程序中都有效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// 局部变量</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<article class="message is-info"><div class="message-body">

<b>Local variable: a variable that is accessible only within the module in which is declared.</b>

<br>

<b>Global variable: a variable that is accessible from all modules.</b>

</div></article>   

<p><br></p>
<hr>
<h1 id="第十三章：数据类型与结构"><a href="#第十三章：数据类型与结构" class="headerlink" title="第十三章：数据类型与结构"></a><strong>第十三章：数据类型与结构</strong></h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h3><p>基本数据类型是那些可以通过编程语言内建的命令简单定义的变量。基本数据类型也称为原子数据类型。  </p>
<p>在计算机科学中，整数称为整数，带有小数点的数称为实数。<br>如果条件要么为真，要么为假，那么这些就是逻辑值，称为布尔值 (Boolean)。<br>有时，我们可能想存储一个字符，这就是所谓的<code>CHAR</code>。<br>如果值总是整数，则应该定义为<code>INTEGER</code>类型，例如在计算循环的迭代次数时。</p>
<p><br></p>
<h3 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a><strong>其他数据类型</strong></h3><p>如下表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Data type</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>INTEGER</code></td>
<td style="text-align:left">一个正负数字</td>
</tr>
<tr>
<td style="text-align:left"><code>REAL</code></td>
<td style="text-align:left">一个正负数字，但是这个数字有小数位</td>
</tr>
<tr>
<td style="text-align:left"><code>CHAR</code></td>
<td style="text-align:left">一个字符</td>
</tr>
<tr>
<td style="text-align:left"><code>STRING</code></td>
<td style="text-align:left">字符串（一堆字符）</td>
</tr>
<tr>
<td style="text-align:left"><code>BOOLEAN</code></td>
<td style="text-align:left">逻辑表述：真或假 （<code>TRUE</code>or<code>FALSE</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>DATE</code></td>
<td style="text-align:left">由日、月和年组成的日期，有时包括小时、分钟和秒的时间</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h2 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a><strong>记录类型</strong></h2><p>有时不同数据类型的变量是一个逻辑组。<br>例如关于一个人的数据可以包含姓名、出生日期、身高、兄弟姐妹数量、是否是全日制学生，等等。<br>其中：姓名的数据类型是<code>STRING</code>，出生日期的数据类型是<code>DATE</code>，身高的数据类型是<code>REAL</code>，兄弟姐妹数量的数据类型是<code>INTEGER</code>，是否是全日制学生<code>BOOLEAN</code>。  </p>
<p>我们可以声明一个包含复杂属性的一个变量。record type是一种用户定义的类型(user-defined type)，因为程序员可以决定将哪些变量(字段)记录下来。</p>
<p><strong>记录类型(Record type)也称为复合类型(Composite type)。</strong>  </p>
<p>可以在伪代码中以这样的形式创建一个记录类型：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TYPE &lt;TypeIdentifier&gt;</span><br><span class="line">    DECLARE &lt;field identifier&gt; : &lt;data type&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">ENDTYPE</span><br></pre></td></tr></table></figure>
<p>其中：<code>&lt;TypeIdentifier&gt;</code>是这个记录类型的名称，<code>&lt;field identifier&gt;</code>是其中的一个参数，而<code>&lt;data type&gt;</code>就是声明这个参数的数据类型。  </p>
<p>我们现在狠狠的声明了一个数据类型。如果我们想要为一个变量赋予这样的数据类型的话，我们需要先声明：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE &lt;variable identifier&gt; : &lt;TypeIdentifier&gt;</span><br></pre></td></tr></table></figure>
<p>想要去调用某个参数，我们就可以使用这样的语法：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TypeIdentifier&gt;.&lt;field identifier&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p>十分的容易，十分的简单。  </p>
<p>按照上面的“关于一个人的数据”，我们可以将定义这个记录类型的过程写成伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TYPE PersonType</span><br><span class="line">    Name : STRING</span><br><span class="line">    DateOfBirth : DATE</span><br><span class="line">    Height : REAL</span><br><span class="line">    NumberOfSiblings : INTEGER</span><br><span class="line">    IsFullTimeStudent : BOOLEAN</span><br><span class="line">ENDTYPE</span><br></pre></td></tr></table></figure>
<p>假如说我们要赋予<code>Person</code>这个变量这样的数据类型，我们就先来一步声明：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE Person : PersonType</span><br></pre></td></tr></table></figure>
<p>然后我们就可以对其中的一些参数执行一些操作了。比如说：  </p>
<p>赋值：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.Name ← "Fred"</span><br><span class="line">Person.NumberOfSiblings ← 3</span><br><span class="line">Person.IsFullTimeStudent ← TRUE</span><br></pre></td></tr></table></figure>
<p>想要输出其中的一个参数，直接运行下面的命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT Person.Name</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>接下来唠唠数组。  </p>
<p>有时我们需要将数据值组织成一个列表或表格，亦或者是矩阵。<br>在大多数编程语言中，这些结构称为数组。<br>数组是一组有序的数据项，通常里面所有元素的数据类型相同，并使用一个标识符组合在一起。<br>使用数组维度的<strong>数组索引 (Array index)</strong>来对各个数组元素进行寻址操作。  </p>
<p>你可以这么理解：一个列表是一个一维数组，而一个表格或者是矩阵是一个二维数组。  </p>
<p>在编写伪代码时，数组需要在使用之前声明。<br>这意味着要选择一个<em>标识符</em>、要存储在数组中的值的<em>数据类型</em>以及每个维度的<strong>上界 (Upper bound)</strong>和<strong>下界 (Lower bound)</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Array index: row or column number of an individual array element.</b>

<br>

<b>Upper bound: the highest number index of an array dimension</b>

<br>

<b>Lower bound: the smallest number index of an array dimension.</b>

</div></article>   

<p><br></p>
<hr>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a><strong>一维数组</strong></h2><p>当我们在纸上写下一个列表的时候，我们一般会不自觉地给每一个元素编号。第一个元素的编号通常是1。所以我们可以像看待标号列表一样看待数组。  </p>
<p>很多的编程语言，像Java，Python，或者是VB.NET，都将第一个元素编号设为0.这同样是这个数组的下界。上界就是这个数列里面最大编号。  </p>
<p>在伪代码中，可以使用下面的方式来声明一个一维数组：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE &lt;arrayIdentifier&gt; : ARRAY[&lt;lowerBound&gt;:&lt;upperBound&gt;] OF &lt;dataType&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;arrayIdentifier&gt;</code>是这个数组的标识符，<code>&lt;lowerBound&gt;</code>和<code>&lt;upperBound&gt;</code>是这个数组的上下界，然后<code>&lt;dataType&gt;</code>是这个数组内元素的数据类型。  </p>
<p><br></p>
<p>举例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE List1 : ARRAY[1:3] OF STRING</span><br><span class="line">DECLARE List2 : ARRAY[0:5] OF INTEGER</span><br><span class="line">DECLARE List3 : ARRAY[1:100] OF INTEGER</span><br><span class="line">DECLARE List4 : ARRAY[0:25] OF CHAR</span><br></pre></td></tr></table></figure>
<p>这几个数组的特性依次如下：  </p>
<ul>
<li>数组<code>List1</code>的上下界是1和3，内容的数据类型为<code>STRING</code>,这个数组内一共有3个元素。  </li>
<li>数组<code>List2</code>的上下界是0和5，内容的数据类型为<code>INTEGER</code>,这个数组内一共有6个元素。  </li>
<li>数组<code>List3</code>的上下界是1和100，内容的数据类型为<code>INTEGER</code>,这个数组内一共有100个元素。  </li>
<li>数组<code>List4</code>的上下界是0和25，内容的数据类型为<code>CHAR</code>,这个数组内一共有26个元素。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="访问一维数组"><a href="#访问一维数组" class="headerlink" title="访问一维数组"></a><strong>访问一维数组</strong></h3><p>可以通过索引值访问数组中的特定元素。在伪代码中，我们可以这样写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;arrayIdentifier&gt;[x]</span><br></pre></td></tr></table></figure>
<p><code>&lt;arrayIdentifier&gt;</code>是数组的标识符，而<code>[x]</code>是索引值，用于索引对应的元素。  </p>
<p><br></p>
<p>比如说有一个数组<code>MyList</code>,那么它的第n个元素就是<code>MyList[n]</code>。  </p>
<p>你可以用它来执行各种操作。比如说赋值：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NList[25] ← 0</span><br><span class="line">AList[3] ← 'D'</span><br></pre></td></tr></table></figure>
<p>一个是将<code>NList</code>中的第25个元素赋值为<code>0</code>，一个是将<code>AList</code>中第3个元素赋值为字符<code>D</code>。  </p>
<p><br></p>
<p><span class="tag is-warning">Example</span></p>
<p>上例题：你会输入一个值，然后你需要在包含7个数字的ID数组中查找这个数字。  </p>
<p>从数组的第一个元素开始，依次检查每个元素，直到找到搜索值或到达数组的末尾。这种方法称为<strong>线性搜索 (Linear search)</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>Linear search: checking each element of an array in turn for a required value.</b>

</div></article>   



<p>先上标识符表：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Identifier</th>
<th style="text-align:left">Data type</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>MyList</code></td>
<td style="text-align:left"><code>ARRAY[0:6] OF INTEGER</code></td>
<td style="text-align:left">Data structure (1D array) to store seven numbers.</td>
</tr>
<tr>
<td style="text-align:left"><code>MaxIndex</code></td>
<td style="text-align:left"><code>INTEGER</code></td>
<td style="text-align:left">The number of elements in the array.</td>
</tr>
<tr>
<td style="text-align:left"><code>SearchValue</code></td>
<td style="text-align:left"><code>INTEGER</code></td>
<td style="text-align:left">The value to be searched for.</td>
</tr>
<tr>
<td style="text-align:left"><code>Found</code></td>
<td style="text-align:left"><code>BOOLEAN</code></td>
<td style="text-align:left"><code>TRUE</code>if the value has been found. <br> <code>FALSE</code> if the value has not been found.</td>
</tr>
<tr>
<td style="text-align:left"><code>Index</code></td>
<td style="text-align:left"><code>INTEGER</code></td>
<td style="text-align:left">Index of the array element currently being processed.</td>
</tr>
</tbody>
</table>
</div>
<p>然后就是伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MaxIndex ← 6</span><br><span class="line">INPUT SearchValue</span><br><span class="line">Found ← FALSE</span><br><span class="line">Index ← -1</span><br><span class="line">REPEAT</span><br><span class="line">    Index ← Index + 1</span><br><span class="line">    IF MyList[Index] = SearchValue</span><br><span class="line">      THEN</span><br><span class="line">        Found ← TRUE</span><br><span class="line">    ENDIF</span><br><span class="line">UNTIL Found = TRUE OR Index &gt;= MaxIndex</span><br><span class="line">IF Found = TRUE</span><br><span class="line">  THEN</span><br><span class="line">    OUTPUT "Value found at location: " Index</span><br><span class="line">  ELSE</span><br><span class="line">    OUTPUT "Value not found"</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<p>挺好理解的一个程序。通过每轮循环Index + 1来实现数组的遍历。</p>
<p><br></p>
<hr>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h2><p>当我们在纸上写下一个矩阵，并希望使用索引来指出我需要引用的元素的时候，按惯例来讲是<em>先提供行号，再提供列号</em>。  </p>
<p>所以说在我们声明二位数组的时候，我们需要先给出行数，再给出列数。同样，我们还需要提供每一个维度的上下界。  </p>
<p>在伪代码中，定义一个二维数组都是这样写的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE &lt;identifier&gt; : ARRAY[&lt;1Bound1&gt;:&lt;uBound1&gt;,&lt;1Bound2&gt;:&lt;uBound2&gt;] OF &lt;datatype&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;identifier&gt;</code>是二维数组的标识符，<code>&lt;1Bound1&gt;</code>和<code>&lt;uBound1&gt;</code>是第一维的上下界，<code>&lt;1Bound2&gt;</code>和<code>&lt;uBound2&gt;</code>是第二维的上下界。<code>&lt;datatype&gt;</code>是我们需要向元素定义的数据类型。  </p>
<p>在一个二维数列中，一个元素可以从0开始标记。但是有些时候还是使用从标签1开始的行列标记更直观一点。  </p>
<p>比如说我们想要声明一个二维数列，用来表示一个棋盘。这个棋盘有6行7列。<br>这样写伪代码是没有问题的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board : ARRAY[1:6,1:7] OF INTEGER</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="访问二维数列"><a href="#访问二维数列" class="headerlink" title="访问二维数列"></a><strong>访问二维数列</strong></h3><p>想要访问二维数列中的元素，我们需要使用一对儿索引来访问二维数列中的一个元素。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;arrayIdentifier&gt;[x,y]</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;arrayIdentifier&gt;</code>是需要读取的数列的标识符，<code>[x,y]</code>是这一对索引。这一对索引就可以像坐标一样定位其中的一个确切元素。  </p>
<p>比如说下面的伪代码：    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board[3,4] ← 0</span><br></pre></td></tr></table></figure>
<p>这一步可以将第三行第四列的元素设为0。  </p>
<p><br></p>
<p>当我们想要读取一个一维数列中的全部元素，就需要使用循环来遍历出每一个元素的内容。<br>而在二维数列，我们需要使用一个循环语句来遍历每一行，然后在遍历每一行的同时遍历每一列，以读取出所有的数据。<br>这里是用了一个循环嵌套，aka (nested loops)，我们在之前有提到。  </p>
<p>这样的话用结构化英语写出来就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For each row</span><br><span class="line">  For each column</span><br><span class="line">    Assign the initial value to the element at the current position</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="文本文档"><a href="#文本文档" class="headerlink" title="文本文档"></a><strong>文本文档</strong></h2><p>当我们需要需要永久存储数据时，使用文本文件是其中的一种方法。  </p>
<p>例如，程序执行时保存在数组中的任何数据都将在程序停止时丢失。你可以将数据保存到文件中，并在后续执行时需要读取。  </p>
<p><br></p>
<hr>
<h3 id="向文本文档中写入"><a href="#向文本文档中写入" class="headerlink" title="向文本文档中写入"></a><strong>向文本文档中写入</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPENFILE &lt;filename&gt; FOR WRITE           // open the file for writing</span><br><span class="line">WRITEFILE &lt;filename&gt;, &lt;stringValue&gt;     // write a line of text to the file</span><br><span class="line">CLOSEFILE &lt;filename&gt;                    // close file</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="从文本文档中读取"><a href="#从文本文档中读取" class="headerlink" title="从文本文档中读取"></a><strong>从文本文档中读取</strong></h3><p>现有的文件可以由程序读取。<br>下面伪代码语句提供了从文件读取数据的功能:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPENFILE &lt;filename&gt; FOR READ              // open the file for writing</span><br><span class="line">READFILE &lt;filename&gt;, &lt;stringVariable&gt;     // write a line of text to the file</span><br><span class="line">CLOSEFILE &lt;filename&gt;                      // close file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="向文本文档中追加内容"><a href="#向文本文档中追加内容" class="headerlink" title="向文本文档中追加内容"></a><strong>向文本文档中追加内容</strong></h3><p>有时，我们可能希望向现有文件添加数据，而不是创建新文件，这可以在追加模式下完成：它将新数据添加到现有文件的末尾。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPENFILE &lt;filename&gt; FOR APPEND          # open file for append</span><br><span class="line">WRITEFILE &lt;filename&gt;, &lt;stringValue&gt;     # write a line of text to the file</span><br><span class="line">CLOSEFILE &lt;filename&gt;                    # close file</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="文件终止符-EOF"><a href="#文件终止符-EOF" class="headerlink" title="文件终止符 (EOF)"></a><strong>文件终止符 (EOF)</strong></h3><p>The <strong>End-of-file marker (EOF)</strong>.  </p>
<p>如果想从头到尾读取文件，可以使用条件循环。<br>每一个文本文件的末尾有一个特殊的标记，我们可以对它进行测试。<br>测试这个特殊的文件结束标记是许多编程语言的标准函数。每次调用这个函数时，它都会测试这个标记，如果还没有到达文件末尾，则返回FALSE，如果到达文件末尾标记，则返回TRUE。  </p>
<p>在伪代码中，我们将这个函数称为<code>EOF()</code>。我们可以使用结构<code>REPEAT.. until EOF()</code>。<br>如果文件可能不包含任何数据，最好使用<code>WHILE NOT EOF()</code>。</p>
<p><br></p>
<hr>
<h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型 (ADT)"></a><strong>抽象数据类型 (ADT)</strong></h2><p><strong>抽象数据类型 (Abstract data type, ADT)</strong>是一组数据和一组相关操作的集合。  </p>
<p>说的简单点，抽象数据类型就是与对该数据类型有意义的操作封装在一起的数据类型。</p>
<p>抽象数据类型与下方的几个条件息息相关：  </p>
<ul>
<li>创建该数据结构的一个新实例</li>
<li>在数据结构中查找一个元素</li>
<li>向数据结构中插入一个新成员</li>
<li>从数据结构中删除一个元素</li>
<li>以系统的方式访问存储在数据结构中的所有元素。</li>
</ul>
<article class="message is-info"><div class="message-body">

<b>Abstract Data Type: a collection of data with associated operations.</b>

</div></article>   

<p>本章的其余部分介绍下列抽象数据类型，分别是栈、队列和链表。  </p>
<p><br></p>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h2><p>想下现实世界中的栈有哪些特征?要堆东西，我们把东西堆在一起。可访问的元素是栈顶的元素。如果我们试图在堆栈中找到一个元素并将其取出，很可能会导致这一堆元素坍塌。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4a6b4649bb9e28b3b7a2a8f8c8564042?method=download&amp;shareKey=c35ea6d3290bdc10432b8879cfd244cf" alt=""></p>
<p>上图显示了我们如何以如下顺序添加四个元素时表示堆栈:A、B、C、D。<br>注意，这些槽是从下往上编号的，因为这感觉更自然。</p>
<p><code>BaseOfStackPointer</code>始终指向栈中的第一个位置。<code>TopOfStackPointer</code>指向最后一个压入栈的元素。<br>当一个元素从栈中<strong>弹出(POP)</strong>时，<code>TopOfStackPointer</code>将递减，指向当前栈顶的元素。<br>当栈为空时，<code>TopOfStackPointer</code>的值为-1。</p>
<p>要使用一维数组来实现这个栈，可以这样写:  </p>
<p><code>DECLARE Stack:ARRAY[0:7] OF CHAR</code></p>
<p><br></p>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h2><p>现实世界中的<strong>队列 (Queue)</strong>有哪些特征?<br>当人们排队时，他们在最后加入队伍。人们从队伍的前面离开队伍。如果是一个有序的队列，就不会有人插队，人们也不会从其他位置离开。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB108883d40d0a36d463abd78e763eafcc?method=download&amp;shareKey=a9c1c3143ae5e63cc2102e170818c8a3" alt=""></p>
<p>上图展示了如何表示有5个元素以如下顺序加入队列:a、B、C、D、E。</p>
<p>要使用数组实现队列，我们可以假设队列的前端位于位置0。<br>当队列为空时，<code>EndOfQueuePointer</code>的值为-1。当有一个值加入队列时，<code>End0fQueuePointer</code>会先加1，然后再将该值添加到指针所指向的数组元素中。<br>当队列最前面的项离开时，我们需要将其他所有项向前移动一个位置，并调整<code>EndOfQueuePointer</code>。</p>
<p>这种方法涉及大量的数据移动。一个更有效的利用槽的方法是循环队列的概念。<br>指针表示队列的前端和尾部，最终，队列将“绕回”起始位置。<br>下图展示了一个11个元素加入队列、5个元素离开队列的循环队列：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3c97a93cead64e3e89be9a838179c3c3?method=download&amp;shareKey=95f47734ed87b724b0882cc4142bda51" alt=""></p>
<p><br></p>
<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h2><p>在之前的章节中，我们使用数组作为线性列表。<br>在线性列表中，列表项存储在连续的位置上，但是这并不总是合适的。<br>另一种方法是将单个列表项存储在任何可用的位置，并使用指针将单个列表项链接到一个有序序列中。</p>
<p>列表中的元素称为<strong>节点 (Node)</strong>。节点可以由多个数据项和一个<strong>指针 (Pointer)</strong>组成，指针是一个变量，存储了它所指向的节点的地址。</p>
<p>存储第一个元素地址的变量称为<strong>起始指针(Start pointer)</strong>。</p>
<article class="message is-info"><div class="message-body">

<b>Node: an element of a list.</b>

<br>

<b>Pointer: a variable that stores the address of the node it points to.</b> 

<br>

<b>Null pointer: a pointer that does not point at anything.</b>

<br>

<b>Start pointer: a variable that describes of the first element of a linked list.</b>

</div></article>   

<p><br></p>
<p>在下面的图中，节点框中的数据值表示该节点的key字段。每个节点可能关联许多数据项。箭头表示指针。<br>它没有显示节点存储在哪个地址，因此图没有给出指针的值，只给出它在概念上链接到的位置。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc25e0ac2424463782319b14df2bb40fb?method=download&amp;shareKey=d02e311f730a9faa88e8bf9a2952bc44" alt=""></p>
<p>下图展示了如何将一个新节点a插入到链表的开头，<code>StartPointer</code>的内容被复制到新节点的指针字段中，并且<code>StartPointer</code>被设置为指向新节点 A。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfd1e70fa19ce75ccf0074832e4901760?method=download&amp;shareKey=0b9950ed8c2d00cd75eeda0569665486" alt=""></p>
<p>在下面的图中，一个新节点P被插入到列表的末尾。<br>节点L的指针字段指向新节点R，新节点P的指针字段包含null指针。</p>
<p>为了删除列表中的第一个节点，我们将待删除节点的指针字段复制到<code>StartPointer</code>中：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6d4e4b9a71794344d93d2a113fc4b4bb?method=download&amp;shareKey=ec73abdc6242e8c1f3caddf4abcfdc43" alt=""></p>
<p>为了删除列表中的最后一个节点，我们需要将前一个节点的指针字段设置为null指针：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf4cc0882079be871612588b48ac98c07?method=download&amp;shareKey=4d9ff05bc0a0c77724b20e93b9e5237c" alt="">  </p>
<p><br></p>
<p>有时，节点按关键字段值的顺序链接在一起，以生成一个有序链表。这意味着可能需要在两个现有节点之间插入或删除一个新节点。</p>
<p>如下图所示：为了在现有节点B和D之间插入一个新节点C，我们将节点B的指针字段复制到新节点C的指针字段中。我们将节点B的指针字段改为指向新节点C：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4e3024d5bb52e5141e011e9ad8ed05cc?method=download&amp;shareKey=b5ee34331a4326bf376bee4e388281ba" alt=""></p>
<p>要删除列表中的节点D，我们将待删除节点D的指针字段复制到节点B的指针字段中：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c01e9bf65640b4f91b30eaa79284b1a?method=download&amp;shareKey=f0d86fc56ae1da7eecc237bff0b48d1a" alt=""></p>
<p><br></p>
<p>请记住，在实际应用程序中，数据可能不止包含一个关键字段和一个数据项。这就是链表优于线性表的原因。<br>当链表元素需要重新排序时，只需要改变链表中的指针。在线性列表中，需要移动所有的数据项。<br>使用链表可以节省时间，但是指针字段需要更多的存储空间。  </p>
<p><br></p>
<p>要使用数组来实现链表，可以使用一维数组来存储数据，使用一维数组来存储指针。<br>读取相同索引处的数组值时，一行代表一个节点：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd884dea7e65e66dcb10dd2ac9d012135?method=download&amp;shareKey=1e1f130f679c40e9c3fe0086faf262dc" alt=""></p>
<p>下图展示了如何将一个新节点添加到使用数组实现的链表的开头。<br>请注意，值”A”被添加到索引3处，但起始指针被调整为列表的新第一个元素。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1071d5dddafc0dc1342176a070a4c19c?method=download&amp;shareKey=10b6a780f990cf4fcfd99b70a115a5cb" alt=""></p>
<p>下图展示了如何将一个新节点添加到使用数组实现的链表的末尾。<br>注意，“P”值是在索引3处添加的。原来包含null指针(索引为0)的结点现在调整为指向新的一个node。  </p>
<p><br></p>
<p>删除节点时，只需要调整指针。<br>因为旧数据可以保留在数组中，但由于没有指针指向它，因此不再可以访问它。</p>
<p>下图展示了如何调整起始指针，以有效地删除链表的第一个元素。<br>请注意，开始指针现在包含了被删除结点的指针值。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8443d8877e3af41fcc92c401bdc732ba?method=download&amp;shareKey=836e08461f4163fc2760c2637b2bf3c3" alt="">  </p>
<p>下图给出了链表倒数第二个结点的指针值如何变为null指针的过程：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5a38c06c3d8d69e9c87cc52cdc026613?method=download&amp;shareKey=9d4e228eee2c4cb87307b0d9a00f4017" alt=""></p>
<p><br></p>
<p>在向列表中添加需要插入的节点时，该数据会被添加到data数组的任何空闲元素中。<br>新节点的指针被设置为指向插入点之后的节点的索引。<br>注意，这是插入点之前节点的指针的值，插入点之前的节点的指针设置为指向新节点。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBbbf733201dec9b89f2b12008477910a7?method=download&amp;shareKey=4686a60fb1cbf13235ffc6a180fb045c" alt=""></p>
<p>同样，在删除节点时，只需要调整指针即可。<br>下图说明了如何将待删除结点的指针复制到前一个结点的指针。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7e5b0a7682dfdf4b10ac8528e493430e?method=download&amp;shareKey=e2b810da295c8e52fb081de997bf3d15" alt="">  </p>
<p><br></p>
<p>未使用的节点需要被轻易定位到。一种合适的技术是将未使用的结点连接起来，形成另一个链表:未使用链表。  </p>
<p>下图展示了我们的链表及其空闲列表：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb21fbca29bb802ddaea196ca1ed93a1b?method=download&amp;shareKey=10f22ad3957610ebfb2b93845c640c1c" alt=""></p>
<p>当节点数组第一次初始化为链表时，链表是空的，所以开始的指针是空指针。<br>所有节点都需要连接起来，形成未使用内存块的链表。<br>下图展示了向链表插入数据之前链表实现的一个例子：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8b78f5645eb082bf509bb5287b85e155?method=download&amp;shareKey=0f07779b4a2400a6c3169bdfe4706df9" alt=""></p>
<p><br></p>
<p>假设“L”、“B”和“D”被添加到链表中，并按字母顺序保存。</p>
<p>下图展示了这些值是如何存储在Data数组中的，以及链表和未使用链表的指针是如何发生调整的：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8f6b1c4bbe92190c1ee813fb3311f0ef?method=download&amp;shareKey=d994768cf323feb3c44fc7d8042ed191" alt="">  </p>
<p>如果要删除包含”B”的结点，则需要将该结点的数组元素重新链接到未使用链表中。<br>下图展示了如何将该节点添加到未使用内存链表的前端：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2badc75189a212215c4e7b345dabd354?method=download&amp;shareKey=afe63985272662d7e6d47a882f322e31" alt=""></p>
<p><br></p>
<p>在之前的小节中，我们介绍了用户定义的记录类型。<br>我们将相关的数据项分组为记录数据结构。<br>要使用记录变量，我们首先定义一个记录类型。然后我们声明该记录类型的变量。</p>
<p>我们可以将这个链表存储在一个记录数组中。<br>一条记录代表一个节点，由数据和指针组成：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfb16961432a706bc5f8b668fb7e9185e?method=download&amp;shareKey=fd9701f15a3b83e7f1430c925c8a1e4d" alt=""></p>
<p><br></p>
<hr>
<h1 id="第十四章：编程与数据的表示"><a href="#第十四章：编程与数据的表示" class="headerlink" title="第十四章：编程与数据的表示"></a><strong>第十四章：编程与数据的表示</strong></h1><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a><strong>编程语言</strong></h2><p>在前两章节中我们学习了如何使用流程图或者伪代码来描述一个程序。我们现在介绍几个比较出名且普遍运用的编程语言：  </p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h3><p>Python是一种多范式编程语言，这意味着Python完全支持面向对象的编程和结构化编程。  </p>
<p>Python有如下特性：  </p>
<ul>
<li>每个语句必须在单独的一行上。</li>
<li>缩进十分的重要。这就是所谓的 <strong>“缩进规则” (Off-side rule)</strong>。</li>
<li>关键字用小写字母书写。</li>
<li>Python区分大小写，比如说标识符<strong>Number1</strong>与<strong>Number1</strong>或<strong>Number1</strong>不同。</li>
<li>Python中的一切都是对象，所以Python是面向对象的编程语言。</li>
<li>代码大量使用了名为“切片”的概念。</li>
<li>Python程序是解释型程序。</li>
</ul>
<p>你可以在Python Shell中输入一条语句，Python解释器会立即运行它。   </p>
<p>你还可以在Python编辑器(如IDLE)中输入程序代码，用扩展名<code>.py</code>保存它，然后在编辑器窗口的运行菜单中运行程序代码。  </p>
<p><br></p>
<hr>
<h3 id="Visual-Basic-Console-Mode-VB-NET"><a href="#Visual-Basic-Console-Mode-VB-NET" class="headerlink" title="Visual Basic Console Mode (VB.NET)"></a><strong>Visual Basic Console Mode (VB.NET)</strong></h3><p>VB.NET是在.NET框架上实现的一种多范式的高级程序设计语言。<br>微软推出了VB.NET作为其最初的Visual Basic语言的继承者。<br>微软的集成开发环境(IDE)，用于用VB进行开发，其中的NET就是Visual Studio。  </p>
<p>隶属微软的Visual Studio Express和Visual Studio Community都是免费软件。<br>课本里面的所有Visual Basic程序都是使用Microsoft Visual Basic 2010 Express Console应用程序编写的。  </p>
<p>有关于VB.NET，这里有一些事实：  </p>
<ul>
<li>每个语句都应该在单独的一行中。可以在同一行中键入语句，以冒号<code>:</code>作为分隔符。但是，我们不推荐这样做。</li>
<li>缩进是好文明（</li>
<li>VB.NET中不区分大小写。现代的VB.NET编辑器将自动从标识符的第一个定义中复制案例。</li>
<li>我们一般对标识符和关键字使用CamelCaps表示方法(也称为PascalCaps)。</li>
<li>程序需要编译才能运行。</li>
</ul>
<p><strong>CamelCaps代表首字母大写的命名法则。</strong></p>
<p>当我们在IDE中输入程序代码，保存代码之后单击Run按钮。这将启动编译器。<br>如果没有语法错误，编译后的程序就会运行。输出将显示在一个单独的控制台窗口中。  </p>
<p>注意，当程序完成执行时，控制台窗口会自动关闭。<br>所以为了让控制台窗口一直打开以便能看到输出，程序的最后一条语句应该加上这一行：  </p>
<p><code>Console.ReadLine()</code>  </p>
<p><br></p>
<hr>
<h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>Java最初由James Gosling在Sun Microsystems(现为Oracle所有)开发，于1995年发布。  </p>
<p><strong>Java运行环境(Java Runtime Environment, JRE)</strong>的目标是面向用户，而<strong>Java开发包(Java Development Kit, JDK)</strong>面向软件开发人员，其中包含<strong>Java编译器 (Java Compiler)</strong>和调试器等开发工具。  </p>
<p>Java的设计与运行平台无关。也就是说Java编译后的代码可以在所有的操作系统上运行。  </p>
<p>有关Java的一些事实：  </p>
<ul>
<li>每个语句都以分号<code>;</code>结尾。一行可以包含多条语句，但我们不推荐这样做。</li>
<li>缩进是一种很好的做法。</li>
<li>Java区分大小写。</li>
<li>按照惯例，标识符使用CamelCaps格式大写，关键字使用小写，<strong>类 (class)</strong>的标识符使用大写。</li>
<li>复合语句由括在花括号<code>{</code>中的语句序列组成。</li>
<li>只要Java语法需要使用语句，就可以使用复合语句。</li>
<li>程序需要编译成字节码，然后使用<strong>Java虚拟机 (Java Virtual Machine)</strong>运行。  </li>
</ul>
<p>Java几乎被设计为一种完全面向对象的语言。<br>Java中所有代码都是在<strong>类 (Class)</strong>中编写的。<br>只有简单数据类型(如integer、real)不是对象。字符串也是对象。</p>
<p>源文件必须以其包含的public类命名，并添加java后缀，例如<code>Exl.java</code>。<br>它首先必须使用Java编译器编译成字节码，生成一个名为Exl.class的文件。只有这样它才能被执行。</p>
<p>方法名<code>main</code>在Java语言中不是关键字。它只是Java启动器为将控制权传递给程序而调用的方法的名称。  </p>
<p>和VB.NET一样：如果没有语法错误，编译后的程序就会运行。输出将显示在输出窗口中。  </p>
<p><br></p>
<hr>
<h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a><strong>编程基础</strong></h2><p>(你可能发现这一小结的目录充满了冗余。不过我也没啥办法因为这个Hexo主题没法支持四级标题lol)</p>
<h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a><strong>变量的声明</strong></h3><p>大多数编程语言都要求你声明要存储在变量中的数据的类型，以便编译器能够分配正确数量的内存空间。  </p>
<p>声明变量的时候，数据类型决定了它能存储的内容。<br>声明为存储整数(integer)的变量就不能用于存储字母数字字符(字符串)，反之亦然。<br>VB.NET和Java要求在使用变量之前声明变量。  </p>
<p>在伪代码中，声明变量可以以下面的方法完成：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE &lt;identifier&gt; : &lt;datatype&gt;</span><br></pre></td></tr></table></figure>
<p>下面的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE Number1 : INTEGER</span><br><span class="line">DECLARE YourName : STRING</span><br><span class="line">DECLARE N1, N2, N3 : INTEGER</span><br><span class="line">DECLARE Name1, Name2 : STRING</span><br></pre></td></tr></table></figure>
<p>分别为：  </p>
<p>定义<code>Number1</code>用于存储数字。<br>定义<code>YourName</code>用于存储字符串。<br>定义3个整数变量。<br>定义两个字符串变量。  </p>
<p><br></p>
<hr>
<h3 id="语法定义和例子"><a href="#语法定义和例子" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">~</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left">Python没有变量声明。</td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>Dim &lt;identifier&gt;[,&lt;identifier&gt;]As &lt;datatype&gt;</code> <br> 每一行声明必须以<code>Dim</code>开头。</td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>&lt;datatype&gt; &lt;identifier&gt;[, &lt;identifier&gt;]</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Number1 of type Integer</span></span><br><span class="line"><span class="comment"># YourName of type String</span></span><br><span class="line"><span class="comment"># N1, N2, N3 of type Integer;</span></span><br><span class="line"><span class="comment"># Name1, Name2 of type String;</span></span><br></pre></td></tr></table></figure>
<p>这里面都是注释。虽然Python没有变量声明，但我们还是应该在模块开头添加注释。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> Number <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"><span class="keyword">Dim</span> YourName <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"><span class="keyword">Dim</span> N1, N2, N3 <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"><span class="keyword">Dim</span> Name1, Name2 <span class="keyword">As</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>可以将多个相同类型的变量放在同一行中。</p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number1;</span><br><span class="line">String yourName;</span><br><span class="line"><span class="type">int</span> n1, n2, n3;</span><br><span class="line">String name1, name2;</span><br></pre></td></tr></table></figure>
<p>同样，你可以将多个相同类型的变量放在同一行中。  </p>
<p><br></p>
<hr>
<h3 id="常量的声明和赋值"><a href="#常量的声明和赋值" class="headerlink" title="常量的声明和赋值"></a><strong>常量的声明和赋值</strong></h3><p>有时，我们在程序中使用一个永远不变的值，例如数学常数pi的值。<br>为常量指定一个名称，并在程序开始时声明它，这是一种好习惯，有助于提高可读性，而不是在程序语句中直接使用一个实际的值。  </p>
<p>在为代码中，我们将这样的常量赋值写为：  </p>
<p><code>CONSTANT &lt;identifier&gt; = &lt;value&gt;</code></p>
<p>比如：  </p>
<p><code>CONSTANT Pi = 3.14</code></p>
<p>。</p>
<p><br></p>
<hr>
<h3 id="语法定义和例子-1"><a href="#语法定义和例子-1" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">~</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left"><code>&lt;identifier&gt; = &lt;value&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>Const &lt;identifier&gt; = &lt;value&gt;</code> <br> 每一行声明都必须以关键字<code>Const</code>开头。</td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>static final &lt;datatype&gt; &lt;identifier&gt; = &lt;value&gt;</code> <br> 每一行常量定义都必须以<code>static final</code>开头。</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<p>在Python中，我们约定俗成的规定是只使用大写来写常量标识符。常量的值是可以改变的，但我们最好是要把它们当作不能改变的值。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<p>在VB.NET中，常量的值不能够再被修改了。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<p>同样，在Java中，常量的值不能够再被修改了。    </p>
<p><br></p>
<hr>
<h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a><strong>变量的赋值</strong></h3><p>一旦声明了变量，就可以给它赋值。  </p>
<p>伪代码可以这样写：  </p>
<p><code>&lt;identifier&gt; ← &lt;expression&gt;</code></p>
<p>比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A ← 34</span><br><span class="line">B ← B + 1</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-2"><a href="#语法定义和例子-2" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">~</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left"><code>&lt;identifier&gt; = &lt;expression&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>&lt;identifier&gt; = &lt;expression&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>&lt;identifier&gt; = &lt;expression&gt;;</code></td>
</tr>
</tbody>
</table>
</div>
<p>不难看出：三家的赋值语法都基本一致，不过Java的赋值语句最后还要多一个分号<code>;</code>。  </p>
<p><br></p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">34</span></span><br><span class="line">B = B + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>赋值符是<code>=</code>。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">34</span></span><br><span class="line">B = B + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同样，赋值符是<code>=</code>。  </p>
<p>但是VB.NET允许你在声明数据的同时初始化变量。比如：  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> Number1 <span class="keyword">As</span> <span class="type">Integer</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">34</span>;</span><br><span class="line">B = B + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>同样，赋值符是<code>=</code>。<br>Java也允许在声明语句中初始化变量，例如:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>VB.NET和Python都允许你将递增语句例如<code>B = B + 1</code>写成 <code>B += 1</code></p>
<p>Java则需要将递增语句例如<code>b = b + 1</code>写成<code>b++;</code></p>
<p><br></p>
<hr>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a><strong>算数运算符</strong></h3><p>赋值不只是给变量赋初始值。需要存储计算结果时，也可以使用赋值操作。<br>用于计算的算术运算符如下表所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">伪代码</th>
<th style="text-align:left">Python</th>
<th style="text-align:left">VB.NET</th>
<th style="text-align:left">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">加法</td>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left"><code>+</code></td>
</tr>
<tr>
<td style="text-align:left">减法</td>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left"><code>-</code></td>
</tr>
<tr>
<td style="text-align:left">乘法</td>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left"><code>*</code></td>
</tr>
<tr>
<td style="text-align:left">除法</td>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left"><code>/</code> <br> <strong>仅除以float或double类型时使用此运算符。</strong></td>
</tr>
<tr>
<td style="text-align:left">指数</td>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left"><code>**</code></td>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">在Java里面没有专门用于指数运算的运算符。 <br> 唯一的方法是使用这行代码： <code>Math.pow(n,e)</code></td>
</tr>
<tr>
<td style="text-align:left">整数除法</td>
<td style="text-align:left"><code>DIV</code></td>
<td style="text-align:left"><code>//</code></td>
<td style="text-align:left"><code>\</code></td>
<td style="text-align:left"><code>/</code> <br> <strong>仅对integer数据类型作整数除法时使用。</strong></td>
</tr>
<tr>
<td style="text-align:left">取余</td>
<td style="text-align:left"><code>MOD</code></td>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left"><code>mod</code></td>
<td style="text-align:left"><code>%</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>当表达式中出现多个操作符时，求值的顺序取决于数学的<strong>优先级规则 (Rules of precedence)</strong>:括号、幂、乘、除、加、减。</p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>Rules of precedence: define the order of the calculations to be performed.</b>

</div></article>   

<p><br></p>
<hr>
<h3 id="输出信息"><a href="#输出信息" class="headerlink" title="输出信息"></a><strong>输出信息</strong></h3><p>在伪代码中这么写：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT &lt;string&gt;</span><br><span class="line">OUTPUT &lt;identifier(s)&gt;</span><br></pre></td></tr></table></figure>
<p>当输出文本和数据到控制台屏幕时，我们可以在print列表中列出输出字符串和变量值的混合。</p>
<p><br></p>
<hr>
<h3 id="语法定义和例子-3"><a href="#语法定义和例子-3" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下面展示了语法定义：  </p>
<p><strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(&lt;printlist&gt;)</span><br><span class="line"><span class="built_in">print</span>(&lt;printlist&gt;, end =<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>打印列表中不同的项使用逗号<code>,</code>分隔。<br>为避免移到输出后的下一行，使用<strong>end = ‘’</strong><br>双引号中的内容填充打印列表中两个元素之间的内容。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&lt;printlist&gt;)</span><br><span class="line">Console.Write(&lt;printlist&gt;)</span><br></pre></td></tr></table></figure>
<p>打印列表中所有的项用<code>&amp;</code>隔开。<br><code>Console.Writeline</code>会在输出后移动到下一行，而<code>Console.Write</code>会在输出完毕后继续留在同一行。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(&lt;printlist&gt;);</span><br><span class="line">System.out.printIn(printlist);</span><br></pre></td></tr></table></figure>
<p>打印列表中所有的项用<code>+</code>隔开。<br><code>System.out.print</code>会在输出后移动到下一行，而<code>Console.Write</code>会在输出完毕后继续留在同一行。  </p>
<p><br></p>
<p>在伪代码中想使用差不多的换行操作，就要在打印列表后面使用注释声明了。  </p>
<p><code>// newline</code>和<code>// no new line</code>就可以实现这样的操作。  </p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span>, YourName, <span class="string">". Your number is "</span>, Number1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello "</span>, end= <span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"Hello "</span> &amp; YourName &amp; <span class="string">". Your number is "</span> &amp; Number1)</span><br><span class="line">Console.Write(<span class="string">"Hello"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.printIn(<span class="string">"Hello "</span> + YourName + <span class="string">". Your number is "</span> + number1);</span><br><span class="line">System.out.print(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>在上面的代码示例中，您可以看到当输出语句非常长时，它们可以分散在多行中。因此必须将两个打印列表项之间的行分隔开。<br>你不能在一个字符串的中间折断，除非你把它变成两个单独的字符串。  </p>
<p><br></p>
<p>在Python和VB.NET中，你也可以使用占位符来将输出排序。<br>在打印列表中，要打印的变量的顺序用<code>{}</code>中的序号表示，变量按正确的顺序从后面的变量列在字符串后面，中间用逗号分隔:  </p>
<p>    <strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello {0}. Your number is {1} "</span> .<span class="built_in">format</span>(YourName,Number1))</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong></p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"Hello {0}. Your number is {1}"</span>, YourName, Number1)</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="从用户获取输入"><a href="#从用户获取输入" class="headerlink" title="从用户获取输入"></a><strong>从用户获取输入</strong></h3><p>在编写输入语句时，最好提示用户他们要输入什么。<br>例如下面的伪代码:  </p>
<p><code>INPUT "Enter a number: " A</code></p>
<p>就是可以起到这样的作用。  </p>
<p><br></p>
<hr>
<h3 id="语法定义和例子-4"><a href="#语法定义和例子-4" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">input</span>(<span class="string">"Enter a number: "</span>)</span><br></pre></td></tr></table></figure>
<p>用户输入的内容会传输到变量A内。<br>输入的数据格式默认为字符串。因此如果想要转化成别的数据形式就需要特意多敲两个字转一下格式了。<br>双引号和单引号都可以用于输出提示信息。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(<span class="string">"Enter a number: "</span>)</span><br><span class="line">A = Console.ReadLine()</span><br></pre></td></tr></table></figure>
<p>提示符必须单独作为输出语句提供。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">console</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">"Enter a number: "</span>);</span><br><span class="line">a = console.next();</span><br></pre></td></tr></table></figure>
<p>必须先从Java库中导入Scanner类，并创建一个Scanner对象，然后才能使用它读取输入字符串。  </p>
<p>提示符必须单独作为输出语句提供。  </p>
<p><br></p>
<hr>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h3><p>写注释是个很好的文明（  </p>
<p><br></p>
<hr>
<h3 id="语法定义和例子-5"><a href="#语法定义和例子-5" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this is a comment</span></span><br><span class="line"><span class="comment"># this is a another comment</span></span><br></pre></td></tr></table></figure>
<p>注释使用<code>#</code>开头。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">' this is a comment</span></span><br><span class="line"><span class="comment">' this is a another comment</span></span><br></pre></td></tr></table></figure>
<p>注释使用<code>'</code>开头。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is a comment</span></span><br><span class="line"><span class="comment">//this is another comment</span></span><br><span class="line"><span class="comment">/* this is a multiline</span></span><br><span class="line"><span class="comment">  comment</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注释使用<code>//</code>开头。</p>
<p>使用<code>/*</code>和<code>*/</code>来插入一个多行注释。  </p>
<p><br></p>
<hr>
<h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>每种编程语言都有内置的数据类型，下表给出了其中的一个子集。<br>对于VB.NET和Java，分配给给定类型变量的内存字节数在括号中给出。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据描述</th>
<th style="text-align:left">伪代码</th>
<th style="text-align:left">Python</th>
<th style="text-align:left">VB.NET</th>
<th style="text-align:left">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">带符号的整数</td>
<td style="text-align:left"><code>INTEGER</code></td>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left"><code>Integer</code> (4个字节)</td>
<td style="text-align:left"><code>int</code> (4个字节)</td>
</tr>
<tr>
<td style="text-align:left">带符号的有小数点的数字</td>
<td style="text-align:left"><code>REAL</code></td>
<td style="text-align:left"><code>float</code></td>
<td style="text-align:left"><code>Single</code> (4个字节) <br> <code>Double</code> (8个字节)</td>
<td style="text-align:left"><code>float</code> (4个字节) <br> <code>double</code> (8个字节)</td>
</tr>
<tr>
<td style="text-align:left">一个字符</td>
<td style="text-align:left"><code>CHAR</code> (使用单引号来分隔字符)</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left"><code>Char</code> (2字节的Unicode)</td>
<td style="text-align:left"><code>char</code> (2字节的Unicode)</td>
</tr>
<tr>
<td style="text-align:left">字符串</td>
<td style="text-align:left"><code>STRING</code> (使用双引号来分隔字符串)</td>
<td style="text-align:left"><code>str</code> (虽然以ASCII码存储，但是Unicode也同样支持。) <br> (使用单引号，双引号或者三个引号来分割字符串)</td>
<td style="text-align:left"><code>String</code> (每个字符使用2个字节存储，使用双引号来分割字符串)</td>
<td style="text-align:left"><code>String</code> (每个字符使用2个字节存储，使用双引号来分割字符串)</td>
</tr>
<tr>
<td style="text-align:left">逻辑表示符</td>
<td style="text-align:left"><code>BOOLEAN</code></td>
<td style="text-align:left"><code>boo1</code>，可以有：<code>True</code>,<code>False</code></td>
<td style="text-align:left"><code>Boolean</code> (2个字节)，可以有：<code>True</code>,<code>False</code></td>
<td style="text-align:left"><code>Boolean</code>，可以有：<code>true</code>,<code>false</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>在Python中，单个字符表示为长度为1的字符串。  </p>
<p>在VB.NET中，字符串中的每个字符都需要两个字节的内存，并且每个字符在内存中表示为Unicode(在Unicode中，从1到127对应于ASCII)。  </p>
<p><br></p>
<p>Date具有各种内部表示形式，但均以传统格式输出:  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据描述</th>
<th style="text-align:left">伪代码</th>
<th style="text-align:left">Python</th>
<th style="text-align:left">VB.NET</th>
<th style="text-align:left">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Date value</td>
<td style="text-align:left"><code>DATE</code></td>
<td style="text-align:left">使用datetime类表示</td>
<td style="text-align:left"><code>Date</code> (8个字节)</td>
<td style="text-align:left">Date在Java中是一个类。需要使用Date请先敲入：<code>import java.util.Date;</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a><strong>布尔表达式</strong></h2><p>在之前的笔记中，我们介绍了逻辑语句。<br>这些语句包含一个条件。条件也称为布尔表达式，计算结果为<code>True</code>或<code>False</code>。其中，<code>True</code>和<code>False</code>都是布尔值。</p>
<p>简单的布尔表达式涉及比较操作符，而复杂的布尔表达式涉及布尔操作符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">伪代码</th>
<th style="text-align:left">Python</th>
<th style="text-align:left">VB.NET</th>
<th style="text-align:left">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">等于</td>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left"><code>==</code></td>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left"><code>==</code></td>
</tr>
<tr>
<td style="text-align:left">不等于</td>
<td style="text-align:left"><code>&lt;&gt;</code></td>
<td style="text-align:left"><code>!=</code></td>
<td style="text-align:left"><code>&lt;&gt;</code></td>
<td style="text-align:left"><code>!=</code></td>
</tr>
<tr>
<td style="text-align:left">大于</td>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left"><code>&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">小于</td>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left"><code>&lt;</code></td>
</tr>
<tr>
<td style="text-align:left">大于等于</td>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left"><code>&gt;=</code></td>
</tr>
<tr>
<td style="text-align:left">小于等于</td>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left"><code>&lt;=</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>到这里三家语言都出奇的一致啊。  </p>
<p>还有逻辑运算符：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">伪代码</th>
<th style="text-align:left">Python</th>
<th style="text-align:left">VB.NET</th>
<th style="text-align:left">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AND <br> (逻辑连接)</td>
<td style="text-align:left"><code>AND</code></td>
<td style="text-align:left"><code>and</code></td>
<td style="text-align:left"><code>And</code></td>
<td style="text-align:left"><code>&amp;&amp;</code></td>
</tr>
<tr>
<td style="text-align:left">OR <br> (逻辑包含)</td>
<td style="text-align:left"><code>OR</code></td>
<td style="text-align:left"><code>or</code></td>
<td style="text-align:left"><code>Or</code></td>
<td style="text-align:left">`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td style="text-align:left">NOT <br> (逻辑否定)</td>
<td style="text-align:left"><code>NOT</code></td>
<td style="text-align:left"><code>not</code></td>
<td style="text-align:left"><code>Not</code></td>
<td style="text-align:left"><code>!</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>!</p>
<p><br></p>
<hr>
<h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a><strong>选择语句</strong></h2><h3 id="If…Then语句"><a href="#If…Then语句" class="headerlink" title="If…Then语句"></a><strong>If…Then语句</strong></h3><p>在伪代码这么写：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;Boolean expression&gt;</span><br><span class="line">    THEN</span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-6"><a href="#语法定义和例子-6" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下面展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;Boolean expression&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p>注意，在显示哪些语句是条件语句的一部分时，用冒号<code>:</code>替换了关键字THEN。  </p>
<p>换言之，IF的条件后面必须跟<code>:</code>。</p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> &lt;<span class="type">Boolean</span> expression&gt;<span class="keyword">Then</span></span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>
<p><code>Then</code>与逻辑表达式同行，而且<code>End If</code>要与<code>If</code>有同样的缩进。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (&lt;Boolean expression&gt;)</span><br><span class="line">    &lt;statement&gt;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，布尔表达式被括在括号中。<br>如果条件语句中需要包含多个语句，则这些语句必须括在花括号<code>{}</code>中。  </p>
<p><strong>全部的语言都需要注意缩进！</strong>  </p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Negative"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> x &lt; <span class="number">0</span> <span class="keyword">Then</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Negative"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    System.out.printIn(<span class="string">"Negative"</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="If…Then…Else语句"><a href="#If…Then…Else语句" class="headerlink" title="If…Then…Else语句"></a><strong>If…Then…Else语句</strong></h3><p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;Boolean expression&gt;</span><br><span class="line">    THEN</span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line">    ELSE</span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-7"><a href="#语法定义和例子-7" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下面展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;Boolean expression&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p>缩进用于显示哪些语句是条件语句的一部分，<code>else</code>关键字必须与相应的<code>if</code>关键字对齐。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> &lt;<span class="type">Boolean</span> expression&gt; <span class="keyword">Then</span></span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>
<p>照格式看就好，不多赘述了。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (&lt;Boolean expression&gt;)</span><br><span class="line">    &lt;statement&gt;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &lt;statement&gt;;</span><br></pre></td></tr></table></figure>
<p>如果else部分需要多个语句，则这些语句必须被括在花括号<code>{}</code>中。  </p>
<p><strong>全部的语言都需要注意缩进！</strong>  </p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Negative"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Positive"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> x &lt; <span class="number">0</span> <span class="keyword">Then</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Negative"</span>)</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Positive"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    System.out.printIn(<span class="string">"Negative"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.printIn(<span class="string">"Positive"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="嵌套IF语句"><a href="#嵌套IF语句" class="headerlink" title="嵌套IF语句"></a><strong>嵌套IF语句</strong></h3><p>在伪代码这么写：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;Boolean expression&gt;</span><br><span class="line">    THEN</span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line">    ELSE</span><br><span class="line">        IF &lt;Boolean expression&gt;</span><br><span class="line">            THEN</span><br><span class="line">                &lt;statement(s)&gt;</span><br><span class="line">            ELSE</span><br><span class="line">                &lt;statement(s)&gt;</span><br><span class="line">        ENDIF</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-8"><a href="#语法定义和例子-8" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下面展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;Boolean expression&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;Boolean expression&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p>注意关键字<code>elif</code>必须与对应的<code>if</code>对齐。<br>这个结构中可以有任意多的<code>elif</code>部分。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> &lt;<span class="type">Boolean</span> expression&gt;<span class="keyword">Then</span></span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">ElseIf</span></span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>
<p>如果<code>ElseIf</code>用作一个单词，那么在这个结构的末尾只需要一个<code>End If</code>。  <code>ElseIf</code>的数量可以根据需要而定。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (&lt;Boolean expression&gt;)</span><br><span class="line">    &lt;statement&gt;;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (&lt;Boolean expression&gt;)</span><br><span class="line">    &lt;statement&gt;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &lt;statement&gt;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Negative"</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Zero"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Positive"</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> x &lt; <span class="number">0</span> <span class="keyword">Then</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Negative"</span>)</span><br><span class="line"><span class="keyword">ElseIf</span> x = <span class="number">0</span> <span class="keyword">Then</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Zero"</span>)</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Positive"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    System.out.printIn(<span class="string">'Negative'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    System.out.printIn(<span class="string">'Zero'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    System.out.printIn(<span class="string">'Positive'</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="CASE语句"><a href="#CASE语句" class="headerlink" title="CASE语句"></a><strong>CASE语句</strong></h3><p>另一种选择结构是CASE语句。<br>CASE语句就像是条件判断：满足了哪一个条件就执行哪一个。<br>每个CASE的条件的类型可以是:  </p>
<ul>
<li>单个值</li>
<li>用逗号分隔的单个值</li>
<li>一个范围</li>
</ul>
<p>在伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CASE OF &lt;expression&gt;</span><br><span class="line">    &lt;value1&gt;                : &lt;statement(s)&gt;</span><br><span class="line">    &lt;value2&gt;,&lt;value3&gt;       : &lt;statement(s)&gt;</span><br><span class="line">    &lt;value4&gt; TO &lt;value5&gt;    : &lt;statement(s)&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    OTHERWISE &lt;statement(s)&gt;</span><br><span class="line">ENDCASE</span><br></pre></td></tr></table></figure>
<p><code>&lt;statement(s)&gt;</code>的值决定执行哪些语句。根据需要可以有很多不同的情况。<code>OTHERWISE</code>是可选的，用于处理错误，我们一般叫错误捕获。  </p>
<p><br></p>
<hr>
<h3 id="语法定义和例子-9"><a href="#语法定义和例子-9" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<p><strong>Python里面没有CASE语句</strong>。你需要使用连环I语句才能达到同样的效果。</p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Case</span> &lt;expression&gt;</span><br><span class="line">    <span class="keyword">Case</span> value1</span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line">    <span class="keyword">Case</span> value2,value3</span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line">    <span class="keyword">Case</span> value4 <span class="keyword">To</span> value5</span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="keyword">Case</span> <span class="keyword">Else</span></span><br><span class="line">        &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Select</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (&lt;expression&gt;)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        &lt;statement(s)&gt;;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2: <span class="keyword">case</span> value3:</span><br><span class="line">        &lt;statement(s)&gt;;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="keyword">default</span>: &lt;statement(s)&gt;;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE OF Grade</span><br><span class="line">    "A"         : OUTPUT "Top grade"</span><br><span class="line">    "F", "U"    : OUTPUT "Fail"</span><br><span class="line">    "B".."E"    : OUTPUT "Pass"</span><br><span class="line">OTHERWISE OUTPUT "Invalid grade"</span><br><span class="line">ENDCASE</span><br></pre></td></tr></table></figure>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> Grade == <span class="string">"A"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Top grade"</span>)</span><br><span class="line"><span class="keyword">elif</span> Grade == <span class="string">"F"</span> <span class="keyword">or</span> Grade == <span class="string">"U"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Fail"</span>)</span><br><span class="line"><span class="keyword">elif</span> Grade <span class="keyword">in</span> (<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Pass"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid grade"</span>)</span><br></pre></td></tr></table></figure>
<p>所以说想要达到CASE语句的效果，python就只能嵌套if了。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Case</span> Grade</span><br><span class="line">  <span class="keyword">Case</span> <span class="string">"A"</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Top grade"</span>)</span><br><span class="line">  <span class="keyword">Case</span> <span class="string">"F"</span>,<span class="string">"U"</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Fail"</span>)</span><br><span class="line">  <span class="keyword">Case</span> <span class="string">"B"</span> <span class="keyword">To</span> <span class="string">"E"</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Pass"</span>)</span><br><span class="line">  <span class="keyword">Case</span> <span class="keyword">Else</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Invalid grade"</span>)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">Select</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">        System.out.printIn(<span class="string">"Top Grade"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'F'</span>: <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">        System.out.printIn(<span class="string">"Fail"</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">        System.out.printIn(<span class="string">"Pass"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">        System.out.printIn(<span class="string">"Invalid grade"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a><strong>迭代</strong></h3><p>在伪代码中，计数控制循环的写法如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR &lt;control variable&gt; ← s TO e STEP i</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">NEXT &lt;control variable&gt;</span><br></pre></td></tr></table></figure>
<p>里面的<code>STEP</code>值是可选的。<br><code>&lt;statement(s)&gt;</code>为两次缩进。<br>控制变量的值从<code>s</code>开始，每次循环递增<code>i</code>，直到到达值<code>e</code>时结束。  </p>
<p><br></p>
<hr>
<h3 id="语法定义和例子-10"><a href="#语法定义和例子-10" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;control variable&gt; <span class="keyword">in</span> <span class="built_in">range</span>(s, e, i):</span><br><span class="line">    &lt;statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p>值<code>s</code>、<code>e</code>和<code>i</code>必须是整数类型。<br>当控制变量略低于<code>e</code>时，循环结束。<br><code>s</code>和<code>i</code>是可选的，如果没有输入，则它们的默认值分别为0和l。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> &lt;control variable&gt; = s <span class="keyword">To</span> e <span class="keyword">Step</span> i</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">Next</span></span><br></pre></td></tr></table></figure>
<p><code>s</code>、<code>e</code>和<code>i</code>的类型可以是整型或浮点型。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s; i &lt; e; i ++)</span><br><span class="line">    &lt;statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p><code>i</code>是其中的控制变量。  </p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FOR x ← 1 TO 5</span><br><span class="line">    OUTPUT x</span><br><span class="line">NEXT x</span><br><span class="line"></span><br><span class="line">FOR x = 2 TO 14 STEP 3</span><br><span class="line">    OUTPUT x</span><br><span class="line">NEXT x</span><br><span class="line"></span><br><span class="line">FOR x = 5 TO 1 STEP -1</span><br><span class="line">    OUTPUT x</span><br><span class="line">NEXT x</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p><code>x</code>的起始值是0，每次迭代都会加一。<br>输出为： <code>0 1 2 3 4</code></p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p>x的起始值为2，终止值为14，步长为3。<br><strong>注意，在执行迭代循环的时候，第一次输出一定是起始值的值。</strong><br>输出为：<code>2 5 8 11</code></p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p>x的起始值为5，步长为-1，因此每次迭代都会使x的值减少1。<br>输出为：<code>5 4 3 2</code></p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]:</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>控制变量每次迭代时按顺序取方括号<code>[]</code>的一个值。<br>输出为：<code>abc</code>  </p>
<p><br></p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> x = <span class="number">1</span> <span class="keyword">To</span> <span class="number">5</span></span><br><span class="line">    Console.Write(x)</span><br><span class="line"><span class="keyword">Next</span></span><br></pre></td></tr></table></figure>
<p>输出：<code>1 2 3 4 5</code></p>
<p><br></p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> x = <span class="number">2</span> <span class="keyword">To</span> <span class="number">14</span> <span class="keyword">Step</span> <span class="number">3</span>  </span><br><span class="line">    Console.Write(x)</span><br><span class="line"><span class="keyword">Next</span></span><br></pre></td></tr></table></figure>
<p>输出：<code>2 5 8 11 14</code></p>
<p><br></p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> x = <span class="number">5</span> <span class="keyword">To</span> <span class="number">1</span> <span class="keyword">Step</span> -<span class="number">1</span></span><br><span class="line">    Console.Write(x)</span><br><span class="line"><span class="keyword">Next</span></span><br></pre></td></tr></table></figure>
<p>输出：<code>5 4 3 2 1</code></p>
<p><br></p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> x = <span class="number">1</span> <span class="keyword">To</span> <span class="number">2.5</span> <span class="keyword">Step</span> <span class="number">0.5</span></span><br><span class="line">    Console.WriteLine(x)</span><br><span class="line"><span class="keyword">Next</span></span><br></pre></td></tr></table></figure>
<p>因为命令是<code>Console.WriteLine()</code>，所以输出需要换行。<br>输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1.5</span><br><span class="line">2</span><br><span class="line">2.5</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> x <span class="keyword">In</span> {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>}</span><br><span class="line">    Console.Write(x)</span><br><span class="line"><span class="keyword">Next</span></span><br></pre></td></tr></table></figure>
<p>控制变量每次迭代时按顺序取花括号<code>{}</code>的一个值。<br>输出：<code>abc</code></p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; x &lt; <span class="number">6</span>; x++)</span><br><span class="line">{</span><br><span class="line">    System.out.print(x);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>输出： <code>12345</code></p>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>; x &lt; <span class="number">15</span>; x = x + <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">    System.out.print(x + <span class="string">"  "</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>输出： <code>2  5  8  11  14</code></p>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>; x &lt; <span class="number">0</span>; x--)</span><br><span class="line">{</span><br><span class="line">    System.out.print(x + <span class="string">"  "</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>输出： <code>5  4  3  2  1</code></p>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; x &lt; <span class="number">3</span>; x = x + <span class="number">0.5</span>)</span><br><span class="line">{</span><br><span class="line">    System.out.print(x + <span class="string">"  "</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>输出： <code>1.0  1.5  2.0  2.5</code></p>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] letter = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> x : letter )</span><br><span class="line">{</span><br><span class="line">    System.out.print(x)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>控制变量每次迭代时按顺序取<code>letter</code>中的一个值。<br>输出： <code>abc</code></p>
<p><br></p>
<hr>
<h3 id="后置条件循环"><a href="#后置条件循环" class="headerlink" title="后置条件循环"></a><strong>后置条件循环</strong></h3><p>后条件循环顾名思义，即循环内的语句至少执行一次，因为循环内的语句必须等到满足条件时才可以跳出循环。  </p>
<p>当运行到后置条件时，我们需要对其进行评估。<br>只要条件求值为<code>False</code>，循环内的语句就会再次执行。当条件求值为<code>True</code>时，执行将转到循环后面的下一个语句。  </p>
<p>编写后置条件循环时，必须确保循环内部有一条语句，在某个时刻将结束条件改为<code>True</code>。否则，循环将永远执行下去。  </p>
<p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">UNTIL &lt;condition&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-11"><a href="#语法定义和例子-11" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下面展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<p>Python中没有后置条件循环。如果需要完成同样的目标就需要使用前置条件循环。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Do</span></span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">Loop</span> <span class="keyword">Until</span> &lt;condition&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">} <span class="keyword">while</span> &lt;condition&gt;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">    INPUT "Enter Y or N: " Answer</span><br><span class="line">UNTIL Answer = "Y"</span><br></pre></td></tr></table></figure>
<p>    <strong>Python</strong>  </p>
<p>Python的执行方法放到下一个部分：前置条件语句中。</p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Do</span></span><br><span class="line">    Console.Write(<span class="string">"Enter Y or N: "</span>)</span><br><span class="line">    Answer = Console.ReadLine()</span><br><span class="line"><span class="keyword">Loop</span> <span class="keyword">Until</span> Answer = <span class="string">"Y"</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">    System.out.print(<span class="string">"Enter Y or N: "</span>);</span><br><span class="line">    answer = console.next();</span><br><span class="line">} <span class="keyword">while</span> (!(answer.equals(<span class="string">"Y"</span>)));</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="前置条件语句"><a href="#前置条件语句" class="headerlink" title="前置条件语句"></a><strong>前置条件语句</strong></h3><p>前置条件循环，顾名思义，就是在循环内的语句执行之前计算条件。<br>只要条件求值为<code>True</code>，前置条件循环就会执行循环中的语句。当条件求值为<code>False</code>时，执行将转到循环后面的下一个语句。<br>注意，第一次遇到循环结构时，条件语句中使用的任何变量都不能是未定义(undefined)。  </p>
<p>编写前置条件循环时，必须确保循环内部有一条语句在某个时候改变控制条件的值。否则循环将永远执行下去。</p>
<p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE &lt;condition&gt; DO</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">ENDWHILE</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-12"><a href="#语法定义和例子-12" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;condition&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p>注意，循环中的语句必须按一定数量的空格缩进。<br>循环后的第一个语句必须减少缩进。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Do</span> <span class="keyword">While</span> &lt;condition&gt;</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">Loop</span></span><br><span class="line"><span class="keyword">Do</span> <span class="keyword">Until</span> &lt;condition&gt;</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">Loop</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是：<code>Loop</code>关键字表示循环结束。<br>VB.NET也有一个前置条件，直到遇见<code>Loop</code>。只要条件求值为<code>False</code>，就执行循环中的语句。如果第一次遇到循环时，条件的计算结果为<code>True</code>，则不执行循环中的语句。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (&lt;condition&gt;)</span><br><span class="line">{</span><br><span class="line">    &lt;statement(s)&gt;;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Answer ← ""</span><br><span class="line">WHILE Answer &lt;&gt; "Y" DO</span><br><span class="line">    INPUT "Enter Y or N: " Answer</span><br><span class="line">ENDWHILE</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Answer = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> Answer != <span class="string">'Y'</span>:</span><br><span class="line">    Answer = <span class="built_in">input</span>(<span class="string">"Enter Y or N: "</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> Answer <span class="keyword">As</span> <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">Do</span> <span class="keyword">While</span> Answer &lt;&gt; <span class="string">"Y"</span></span><br><span class="line">    Console.Write(<span class="string">"Enter Y or N: "</span>)</span><br><span class="line">    Answer = Console.ReadLine()</span><br><span class="line"><span class="keyword">Loop</span></span><br><span class="line">Answer = <span class="string">""</span></span><br><span class="line"><span class="keyword">Do</span> <span class="keyword">Until</span> Answer = <span class="string">"Y"</span></span><br><span class="line">    Console.Write(<span class="string">"Enter Y or N: "</span>)</span><br><span class="line">    Answer = Console.ReadLine()</span><br><span class="line"><span class="keyword">Loop</span></span><br></pre></td></tr></table></figure>
<p>可以将多个相同类型的变量放在同一行中。</p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span>(answer.equals(<span class="string">"Y"</span>) == <span class="literal">false</span>)</span><br><span class="line">{</span><br><span class="line">    System.out.print(<span class="string">"Enter Y or N: "</span>)</span><br><span class="line">    answer = console.next();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="如何决定使用哪个循环？"><a href="#如何决定使用哪个循环？" class="headerlink" title="如何决定使用哪个循环？"></a><strong>如何决定使用哪个循环？</strong></h3><p>如果你知道程序执行到循环语句时需要执行多少次循环，就使用计数控制的循环。<br>如果循环的终止取决于循环内部发生的某些条件，那么就使用条件循环。<br>前置条件循环还有一个好处，那就是如果条件不需要循环，就可以根本不进入循环。</p>
<p><br></p>
<hr>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><strong>内置函数</strong></h2><p>编程环境提供了许多内置函数。<br>其中一些在任何情况下都可以使用，而有些需要从特定的模块库中导入。  </p>
<h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a><strong>字符串操作函数</strong></h3><p>下表给出了一堆处理字符串的函数：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:left">伪代码</th>
<th style="text-align:left">Python</th>
<th style="text-align:left">VB.NET</th>
<th style="text-align:left">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">访问<code>ThisString</code>中的第<code>P</code>个字符</td>
<td style="text-align:left"><code>ThisString[P]</code> <br> （从1开始计数）</td>
<td style="text-align:left"><code>ThisString[P]</code> <br> （从0开始计数）</td>
<td style="text-align:left"><code>ThisString(P)</code> <br> （从0开始计数）</td>
<td style="text-align:left"><code>ThisString.charAt(P)</code> <br> （从0开始计数）</td>
</tr>
<tr>
<td style="text-align:left">返回ASCII值为i的字符</td>
<td style="text-align:left"><code>CHR(i : INTEGER) RETURNS CHAR</code></td>
<td style="text-align:left"><code>chr(i)</code></td>
<td style="text-align:left"><code>Chr(i)</code></td>
<td style="text-align:left"><code>(char) i;</code></td>
</tr>
<tr>
<td style="text-align:left">返回字符<code>ch</code>的ASCII值</td>
<td style="text-align:left"><code>ASC(ch) RETURNS INTEGER</code></td>
<td style="text-align:left"><code>ord(ch)</code></td>
<td style="text-align:left"><code>Asc(ch)</code></td>
<td style="text-align:left"><code>(int) ch;</code></td>
</tr>
<tr>
<td style="text-align:left">返回字符串<code>S</code>的长度的整数值</td>
<td style="text-align:left"><code>LENGTH(S : STRING) RETURNS INTEGER</code></td>
<td style="text-align:left"><code>len(S)</code></td>
<td style="text-align:left"><code>len(S)</code></td>
<td style="text-align:left"><code>S.length();</code></td>
</tr>
<tr>
<td style="text-align:left">返回<code>S</code>的最左边的<code>L</code>个字符</td>
<td style="text-align:left"><code>LEFT(S : STRING, L : INTEGER) RETURNS STRING</code></td>
<td style="text-align:left"><code>S[0:L]</code></td>
<td style="text-align:left"><code>Left(S, L)</code></td>
<td style="text-align:left"><code>S.subString(0, L)</code></td>
</tr>
<tr>
<td style="text-align:left">返回<code>S</code>的最右边的<code>L</code>个字符</td>
<td style="text-align:left"><code>RIGHT(S : STRING, L : INTEGER) RETURNS STRING</code></td>
<td style="text-align:left"><code>S[-L:]</code></td>
<td style="text-align:left"><code>Right(S, L)</code></td>
<td style="text-align:left"><code>S.subString(S.length() - L)</code></td>
</tr>
<tr>
<td style="text-align:left">在字符串<code>S</code>中，返回从<code>P</code>开始<code>L</code>个长度的字符串</td>
<td style="text-align:left"><code>MID(S : STRING, P : INTEGER, L : INTEGER) RETURNS STRING</code></td>
<td style="text-align:left"><code>S[P : P + L]</code></td>
<td style="text-align:left"><code>mid(S, P, L)</code></td>
<td style="text-align:left"><code>S.subString(P, P + L)</code></td>
</tr>
<tr>
<td style="text-align:left">返回<code>Ch</code>的小写等价字符值</td>
<td style="text-align:left"><code>LCASE(Ch : CHAR) RETURNS CHAR</code></td>
<td style="text-align:left"><code>Ch.lower()</code></td>
<td style="text-align:left"><code>LCase(Ch)</code></td>
<td style="text-align:left"><code>Character.toLowerCase(ch)</code></td>
</tr>
<tr>
<td style="text-align:left">返回<code>Ch</code>的大写等价字符值</td>
<td style="text-align:left"><code>UCASE(Ch : CHAR) RETURNS CHAR</code></td>
<td style="text-align:left"><code>Ch.upper()</code></td>
<td style="text-align:left"><code>UCase(Ch)</code></td>
<td style="text-align:left"><code>Character.toUpperCase(ch)</code></td>
</tr>
<tr>
<td style="text-align:left">将字符串<code>S</code>全转换为大写</td>
<td style="text-align:left"><code>TO_UPPER(S : STRING) RETURNS STRING</code></td>
<td style="text-align:left"><code>S.upper</code></td>
<td style="text-align:left"><code>S.ToUpper()</code></td>
<td style="text-align:left"><code>S.toUpperCase()</code></td>
</tr>
<tr>
<td style="text-align:left">将字符串<code>S</code>全转换为小写</td>
<td style="text-align:left"><code>TO_LOWER(S : STRING) RETURNS STRING</code></td>
<td style="text-align:left"><code>S.lower()</code></td>
<td style="text-align:left"><code>S.ToLower()</code></td>
<td style="text-align:left"><code>S.toLowerCase()</code></td>
</tr>
<tr>
<td style="text-align:left">粘合两个字符串</td>
<td style="text-align:left"><code>S1 &amp; S2</code></td>
<td style="text-align:left"><code>s = S1 + S2</code></td>
<td style="text-align:left"><code>s = S1 + S2</code> <br> 或者： <code>s = S1 &amp; S2</code></td>
<td style="text-align:left"><code>s = S1 + S2</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="Python中的切片操作"><a href="#Python中的切片操作" class="headerlink" title="Python中的切片操作"></a><strong>Python中的切片操作</strong></h3><p>在Python中，<strong>切片操作(slicing)</strong>是对序列型对象(如<code>list</code>, <code>string</code>, <code>tuple</code>)的一种高级索引方法。<br>普通索引只取出序列中一个下标对应的元素，而切片取出序列中一个范围对应的元素，这里的范围不是狭义上的连续片段。  </p>
<p>下图显示了ThisString的表示形式。<br>如果我们想返回从位置3开始的长度为3的切片，我们使用<code>ThisString[3 : 6]</code>来给出返回<code>DEF</code>。  </p>
<p><strong>位置从0开始计数，切片上界的位置不包含在子字符串中。</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa6225a80d7d6d706accc6f17ab1c4056?method=download&amp;shareKey=d9355b93c15e6cf5d0c64c71941eafee" alt=""></p>
<p><br></p>
<p>如果您想象每个元素的编号从左端开始，那么更容易看到左元素(下界)是如何包括在内的，而右元素(上界)是如何被排除在外的。<br>下表显示了Python中其他一些有用的切片：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表示</th>
<th style="text-align:left">输出</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ThisString[2:]</code></td>
<td style="text-align:left"><code>CDEFG</code></td>
<td style="text-align:left">如果不给定上界，则切片包含到<strong>字符串末尾的所有字符。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>ThisString[:2]</code></td>
<td style="text-align:left"><code>AB</code></td>
<td style="text-align:left">如果不给定下界，则切片包括<strong>字符串开头的所有字符。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>ThisString[-2:]</code></td>
<td style="text-align:left"><code>FG</code></td>
<td style="text-align:left">负下界意味着它<strong>从字符串的末尾开始取切片。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>ThisString[:-2]</code></td>
<td style="text-align:left"><code>ABCDE</code></td>
<td style="text-align:left">负上界意味着它<strong>在该位置终止字符串。</strong></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="数据截断"><a href="#数据截断" class="headerlink" title="数据截断"></a><strong>数据截断</strong></h3><p>有时我们只需要实数没有经过四舍五入后的整数部分。<br>这就是所谓的<strong>截断 (Truncation)</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">代码</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">伪代码</td>
<td style="text-align:left"><code>INT(x : REAL) RETURNS INTEGER</code></td>
<td style="text-align:left">直接返回<code>x</code>的整数部分。</td>
</tr>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left"><code>int(x)</code></td>
<td style="text-align:left">如果<code>x</code>是一个浮点类型的数据，则输出将会截断为0.</td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>Math.Truncate(x)</code></td>
<td style="text-align:left">返回实数<code>x</code>的整数部分。</td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>(int) x;</code></td>
<td style="text-align:left">将数字<code>x</code>强制转换为整数。</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="将字符串转换为数字"><a href="#将字符串转换为数字" class="headerlink" title="将字符串转换为数字"></a><strong>将字符串转换为数字</strong></h3><p>有时整数可以保存为字符串的形式。<br>要在计算中使用这样的数字，首先需要将其转换为整数。<br>比如说，这些函数可以从字符串<code>5</code>返回整数值5：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left"><code>int(S)</code></td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>CInt(S)</code></td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>Integer.valueOf(S)</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>有时带小数点的数字可以保存为字符串的形式。<br>要在计算中使用这样的数字，首先需要将其转换为<strong>实数 (REAL)</strong>，或者<strong>浮点数 (Float)</strong>。<br>例如，以下函数从字符串<code>75.43</code>返回实数75.43:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">代码</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">伪代码</td>
<td style="text-align:left"><code>STRING_TO_NUM(x : STRING) RETURNS REAL</code></td>
<td style="text-align:left">返回字符串的数字形式。</td>
</tr>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left"><code>float(x)</code></td>
<td style="text-align:left">返回为浮点类型数据。</td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>CDbl(x)</code></td>
<td style="text-align:left">返回为<strong>双精度浮点型数据 (double)</strong>。</td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>Float.valueOf(x)</code></td>
<td style="text-align:left">返回为浮点类型数据。</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a><strong>生成随机数</strong></h3><p>当我们在做仿真中经常需要用到随机数。<br>大多数编程语言都有各种可用的随机数生成器。<br>由于这些随机数是通过程序生成的，它们被称为“伪随机数”。<br>下面的代码示例展示了一些最有用的随机数生成器：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in the random library:</span></span><br><span class="line">randint(<span class="number">1</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码生成了一个介于1和6之间的随机数(包括1和6)。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> RandomNumber <span class="keyword">As</span> <span class="built_in">New</span> Random</span><br><span class="line"><span class="keyword">Dim</span> x <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line">x = RandomNumber.<span class="keyword">Next</span>(<span class="number">1</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>首先我们必须建立一个<code>RandomNumber</code>对象。建立对象的内容到Paper 4会涉及。<br>这段代码生成一个介于<strong>包含1到不包含6</strong>之间的整数。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="type">Random</span> <span class="variable">randomNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> randomNumber.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>我们同样需要建立一个<code>RandomNumber</code>对象。建立对象的内容到Paper 4会涉及。<br>这段代码生成一个介于<strong>包含1到包含6</strong>之间的整数。  </p>
<p><br></p>
<hr>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><p>在第12章中，我们使用<strong>过程 (Procedure)</strong>作为给一组语句命名的一种方式。<br>当我们想编写一个过程时，需要在主程序之前定义它。<br>当我们希望执行过程体中的语句时，我们就可以在主程序中调用它。</p>
<p>在伪代码中，过程的定义为：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE &lt;procedureIdentifier&gt;</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">ENDPROCEDURE</span><br></pre></td></tr></table></figure>
<p>想要调用过程时，需要使用下面这行代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL &lt;procedureIdentifier&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-13"><a href="#语法定义和例子-13" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;identifier&gt;():</span><br><span class="line">    &lt;statement(s)&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> &lt;identifier&gt;()</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>
<p>可以将多个相同类型的变量放在同一行中。</p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> &lt;identifier&gt;()</span><br><span class="line">{</span><br><span class="line">    &lt;statement(s)&gt;;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>同样，你可以将多个相同类型的变量放在同一行中。  </p>
<p><br></p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE InputOddNumber</span><br><span class="line">    REPEAT</span><br><span class="line">        INPUT "Enter an odd number: " Number</span><br><span class="line">    UNTIL Number MOD 2 = 1</span><br><span class="line">    OUTPUT "Valid number entered"</span><br><span class="line">ENDPROCEDURE</span><br></pre></td></tr></table></figure>
<p>在主代码中使用该过程就可以：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL InputOddNumber</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InputOddNumber</span>():</span><br><span class="line">    Number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> Number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        Number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"Enter an odd number: "</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Valid number entered)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#***************** main program starts here ********************</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">InputOddNumber()</span></span><br></pre></td></tr></table></figure>
<p>Python编辑器对语句的不同部分进行颜色编码，这在你输入自己的代码时很有帮助。<br>缩进显示了哪些语句是循环的一部分。<br>内置函数<code>input</code>返回一个字符串，必须将其转换为整数才能作为数字使用。    </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Module1</span><br><span class="line">    <span class="keyword">Dim</span> Number <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> InputOddNumber()</span><br><span class="line">        <span class="keyword">Do</span></span><br><span class="line">            Console.Write(<span class="string">"Enter an odd number: "</span>)</span><br><span class="line">            Number = Console.ReadLine</span><br><span class="line">        <span class="keyword">Loop</span> <span class="keyword">Until</span> Number <span class="built_in">Mod</span> <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Valid number entered"</span>)</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line">    <span class="keyword">Sub</span> Main()</span><br><span class="line">        InputOddNumber()</span><br><span class="line">        Console.ReadLine()</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>
<p>Visual Basic Express编辑器对语句的不同部分进行了颜色编码，因此很容易看出是否有语法错误。<br>编辑器还会自动缩进关键字并将其大写。<br>变量需要在使用之前进行声明。<br>当输入一个标识符而不跟随初始的大小写时，编辑器将跟随变量声明的大小写。<br>编辑器可以预测你的输入:当您键入语句的第一部分时，将显示弹出列表。  </p>
<p>当你要运行主程序时，使用<code>Console.ReadLine()</code>命令来使得控制台一直打开。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exl;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exl</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inputOddNumber</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">console</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            System.out.print(<span class="string">"Enter an odd number: "</span>);</span><br><span class="line">            number = console.nextInt();</span><br><span class="line">        } <span class="keyword">while</span> (number % <span class="number">2</span> != <span class="number">1</span>);</span><br><span class="line">        System.out.printIn(<span class="string">"Valid number entered"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        inputOddNumber();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编辑器会自动对关键字和字符串进行颜色编码。<br>过程体包含在花括号<code>{}</code>中。<br>编辑器可以预测你下一步输入的内容:当输入语句的第一部分时，IDE将显示弹出列表。<br>变量需要在使用之前进行声明。    </p>
<p><br></p>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><p>在之前的一个小节中，我们使用了内置函数。<br>这些是由其他程序员编写的有用的子程序，在模块库中提供。<br>最常用的库通常在系统库中，因此无需导入即可使用。</p>
<p>除了那些内置的函数，你可以编写自己的函数。<br>如果你构建了自己的模块库，那么你编写的任何函数都可以在另一个程序中使用。</p>
<p>函数用作表达式的一部分。<br>当程序执行到达表达式中包含函数调用的语句时，该函数就会被执行，然后在表达式中使用这个函数调用的<strong>返回值 (Return value)</strong>。</p>
<p><strong>函数与过程最大的区别就是：函数有返回值。</strong>  </p>
<p>编写自己的函数时，确保在组成函数(函数体)的语句中始终返回一个值。<br>如果函数体中有不同的结果，可以存在多个<code>RETURN</code>语句。  </p>
<p><br></p>
<p>伪 be like:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION &lt;functionIdentifier&gt; RETURNS &lt;dataType&gt;</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">    RETURN &lt;value&gt;</span><br><span class="line">ENDFUNCTION</span><br></pre></td></tr></table></figure>
<article class="message is-info"><div class="message-body">

<b>Return value: the value replacing the function call used in the expression</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="语法定义和例子-14"><a href="#语法定义和例子-14" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;functionIdentifier&gt;():</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;value&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Function</span> &lt;functionIdentifier&gt;() <span class="keyword">As</span> &lt;datatype&gt;</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">    &lt;functionIdentifier&gt; = &lt;value&gt; <span class="comment">'Return &lt;value&gt; (返回&lt;value&gt;)  </span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;data type&gt; &lt;functionIdentifier&gt;()</span><br><span class="line">{</span><br><span class="line">    &lt;statement(s)&gt;;</span><br><span class="line">    <span class="keyword">return</span> &lt;value&gt;;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>当编程一个函数时，函数的定义应该写在与过程相同的地方。<br>该函数是从主程序中的表达式或过程中调用的。  </p>
<p>不同的编程语言对其子程序使用不同的术语，如下表所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">伪代码</th>
<th style="text-align:left"><code>PROCEDURE</code></th>
<th style="text-align:left"><code>FUNCTION</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left">void function</td>
<td style="text-align:left">fruitful function</td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left">Subroutine</td>
<td style="text-align:left">Function</td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left">void method</td>
<td style="text-align:left">method</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>Void的意思是“什么都没有”。Python和Java都使用这个术语来表示它们的过程类型子例程没有返回值。<br>Python将这两种类型的子例程都称为函数。有”Fruit function”返回一个或多个值。</p>
<p><br></p>
<p><br></p>
<p>这里根据刚才讲过程的那一个小结，重新以函数的形式写出来：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION InputOddNumber RETURNS INTEGER</span><br><span class="line">    REPEAT</span><br><span class="line">        INPUT "Enter an odd number: " Number</span><br><span class="line">    UNTIL Number MOD 2 = 1</span><br><span class="line">    OUTPUT "Valid number entered"</span><br><span class="line">    RETURN Number</span><br><span class="line">ENDFUNCTION</span><br></pre></td></tr></table></figure>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InputOddNumber</span>():</span><br><span class="line">    Number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> Number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        Number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"Enter an odd number: "</span>))</span><br><span class="line">    <span class="keyword">return</span> Number</span><br><span class="line"></span><br><span class="line"><span class="comment"># ************** main program starts here *****************</span></span><br><span class="line"></span><br><span class="line">NewNumber = InputOddNumber()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在声明阶段中，变量<code>Number</code>无法在主程序中使用，因为在Python中只要一个变量没有全局声明，就不可以在整个程序之间随意使用。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<p>VB这边强势的给出了两种解法：  </p>
<p>首先是使用了全局变量的方案：  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Module1</span><br><span class="line">    <span class="keyword">Dim</span> Number, NewNumber <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Function</span> InputOddNumber()</span><br><span class="line">        <span class="keyword">Do</span></span><br><span class="line">            Console.Write(<span class="string">"Enter an odd number: "</span>)</span><br><span class="line">            Number = Console.ReadLine</span><br><span class="line">        <span class="keyword">Loop</span> <span class="keyword">Until</span> Number <span class="built_in">Mod</span> <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">        InputOddNumber = Number</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> Main()</span><br><span class="line">        NewNumber = InputOddNumber()</span><br><span class="line">        Console.ReadLine()</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>
<p>其次是使用了局部变量的方案：  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Module1</span><br><span class="line">    <span class="keyword">Dim</span> NewNumber <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Function</span> InputOddNumber()</span><br><span class="line">        <span class="keyword">Dim</span> Number <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line">        <span class="keyword">Do</span></span><br><span class="line">            Console.Write(<span class="string">"Enter an odd number: "</span>)</span><br><span class="line">            Number = Console.ReadLine</span><br><span class="line">        <span class="keyword">Loop</span> <span class="keyword">Until</span> Number <span class="built_in">Mod</span> <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">        InputOddNumber = Number</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> Main()</span><br><span class="line">        NewNumber = InputOddNumber()</span><br><span class="line">        Console.ReadLine()</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exl;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exl</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">inputOddNumber</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">console</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            System.out.print(<span class="string">"Enter an odd number: "</span>);</span><br><span class="line">            number = console.nextInt();</span><br><span class="line">        } <span class="keyword">while</span> (number % <span class="number">2</span> != <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">newNumber</span> <span class="operator">=</span> inputOddNumber();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>同样，因为没有全局声明过，变量<code>number</code>无法在主程序中调用。  </p>
<p><br></p>
<p>全局变量可以在程序代码的任何部分使用，但是将变量声明为仅在子程序中使用的局部变量是一种良好的编程习惯。  </p>
<p>在Python中，每个变量都是局部变量，除非我们主动声明它们为全局变量。<br>在VB.NET中，我们需要为子例程内的局部变量编写声明语句。<br>Java不支持全局变量。但是，类 (class)中声明的静态变量在整个类中都可以访问。  </p>
<p><br></p>
<hr>
<h2 id="向子程序传参"><a href="#向子程序传参" class="headerlink" title="向子程序传参"></a><strong>向子程序传参</strong></h2><p>当<strong>子例程 (Subroutine)</strong>需要主程序的一个或多个值时，我们在调用时将这些值作为<strong>参数 (Argument / Parameter)</strong>提供给子例程。这就是我们使用内置函数的方式。<br>当我们调用内置函数时，我们不需要知道函数中使用的标识符。</p>
<p>当我们定义一个需要将值传递给子例程主体的子例程时，我们在子例程头中使用参数列表。  </p>
<p>当子例程被调用时，我们需要在括号中提供参数。提供的<strong>实参 (Argument)</strong>被赋值给子例程的相应<strong>形参 (Parameter)</strong>(注意，形参列表中的形参顺序必须与实参列表中的顺序相同)。这就是所谓的<strong>子程序接口 (Subroutine interface)</strong>。</p>
<p>你可能发现参数分为实参和形参。一般来说，当<strong>定义一个方法的时候，我们传递到方法中的变量叫做形参</strong>。，当<strong>调用一个方法的时候，传给方法的值叫做实参</strong>。</p>
<article class="message is-info"><div class="message-body">

<b>Argument: the actual input expression or value with which the subroutine is being called.</b>

<br>

<b>Parameter: the variable(s) used inside a subroutine which will take values passes into a subroutine at call time.</b>

<br>

<b>Subroutine interface: the parameters being passed between the subroutine and the calling program.</b>

<br>

<b>Function / Procedure header: the first line of a function or procedure definition showing the identifier and parameter list.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="向函数中传参"><a href="#向函数中传参" class="headerlink" title="向函数中传参"></a><strong>向函数中传参</strong></h2><p>在为代码中，一个<strong>函数头</strong>是这样写的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION &lt;functionIdentifier&gt; (&lt;parameterList&gt;) RETURNS &lt;dataType&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;parameterList&gt;</code>是形参的标识符及其数据类型的列表，使用逗号分隔。  </p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION SumRange(FirstValue : INTEGER, LastValue : INTEGER) RETURNS INTEGER</span><br><span class="line">    DECLARE Sum, ThisValue : INTEGER</span><br><span class="line">    Sum ← 0</span><br><span class="line">    FOR ThisValue ←FirstValue TO LastValue</span><br><span class="line">        Sum ← Sum + ThisValue</span><br><span class="line">    NEXT ThisValue</span><br><span class="line">    RETURN Sum</span><br><span class="line">ENDFUNCTION</span><br></pre></td></tr></table></figure>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SumRange</span>(<span class="params">FirstValue, LastValue</span>):</span><br><span class="line">    Sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ThisValue <span class="keyword">in</span> <span class="built_in">range</span>(FirstValue, LastValue + <span class="number">1</span>):</span><br><span class="line">        Sum = Sum + ThisValue</span><br><span class="line">    <span class="keyword">return</span> Sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># ************ main program starts here ********************</span></span><br><span class="line"></span><br><span class="line">NewNumber = SumRange(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(NewNumber)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Module1</span><br><span class="line">    <span class="keyword">Dim</span> Number, NewNumber <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Function</span> SumRange(<span class="keyword">ByVal</span> FirstValue, <span class="keyword">ByVal</span> LastValue)</span><br><span class="line">        <span class="keyword">Dim</span> Sum, ThisValue <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line">        Sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">For</span> ThisValue = FirstValue <span class="keyword">To</span> LastValue</span><br><span class="line">            Sum = Sum + ThisValue</span><br><span class="line">        <span class="keyword">Next</span></span><br><span class="line">        SumRange = Sum</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> Main()</span><br><span class="line">        NewNumber = SumRange(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">        Console.WriteLine(NewNumber)</span><br><span class="line">        Console.ReadLine()</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exl</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> firstValue, <span class="type">int</span> lastValue)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">thisValue</span> <span class="operator">=</span> firstValue; thisValue &lt;= lastValue; thisValue++)</span><br><span class="line">        {</span><br><span class="line">            sum = sum + thisValue;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">newNumber</span> <span class="operator">=</span> sumRange(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.printIn(newNumber);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="向过程中传参"><a href="#向过程中传参" class="headerlink" title="向过程中传参"></a><strong>向过程中传参</strong></h2><p>如果形参<strong>传递值 (passed by value)</strong>，那么在调用时形参可以是一个实际值。<br>如果传进去的参数是一个变量，那么将该变量<strong>当前值的副本</strong>传递给子例程。<br>也就是说，调用程序中的变量的值不受子例程中发生的事情的影响。调用该变量后不会对元变量的值发生任何改变。<em>（除非你的过程里面写了把变量值变换的条件）</em>  </p>
<p>对于过程，我们可以通过<strong>引用 (By reference)</strong>传递参数。<br>在调用时，实参必须是变量。指向该变量的内存位置(地址)的指针被传递到过程中。对变量内容的任何更改都将在调用程序/模块的过程之外有效。</p>
<p>人话讲：By value就是传进去的是一个值，但是这个值不会改变原变量的值——他就只是一个值而已。<br>而By reference就是直接把这个变量的内存地址给传进去了。所有的更改就会直接叠加在原变量上。  </p>
<article class="message is-info"><div class="message-body">

<b>By value: the actual value is passed into the procedure.</b>

<br>

<b>By reference: the address of the variable is passed into the procedure.</b>

</div></article> 

<p><br></p>
<p>请注意，这<strong>两种参数传递方法都不适用于Python</strong>。<br>在Python或Java中，这个方法被称为<strong>对象引用传递(pass by object reference)</strong>。<br>这基本上是一种面向对象的参数传递方式，超出了本章的范围。重点是要了解如何使用Python和Java编程以获得所需的效果。</p>
<p><br></p>
<hr>
<p>伪代码中的<strong>过程头 (Procedure header)</strong>：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE &lt;ProcedureIdentifier&gt; (&lt;parameterList&gt;)</span><br></pre></td></tr></table></figure>
<p>参数列表需要过程定义的更多信息。<br>在伪代码中，列表中的参数以下列格式之一表示：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BYREF &lt;identifier1&gt; : &lt;dataType&gt;</span><br><span class="line">BYVALUE &lt;identifier2&gt; : &lt;dataType&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="按值传递参数"><a href="#按值传递参数" class="headerlink" title="按值传递参数"></a><strong>按值传递参数</strong></h3><p>伪代码中：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE OutputSymbols(BYVALUE NumberOfSymbols : INTEGER, Symbol : CHAR)</span><br><span class="line">    DECLARE Count : INTEGER</span><br><span class="line">    FOR Count ← 1 TO NumberOfSymbols</span><br><span class="line">        OUTPUT Symbol // without moving to the next line</span><br><span class="line">    NEXT Count</span><br><span class="line">    OUTPUT NewLine</span><br><span class="line">ENDPROCEDURE </span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<p>在Python中，所有参数的行为都类似于局部变量，它们的效果就与传递值一样：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">OutputSymbols</span>(<span class="params">NumberOfSymbols, Symbol</span>):</span><br><span class="line">    <span class="keyword">for</span> Count <span class="keyword">in</span> <span class="built_in">range</span>(NumberOfSymbols):</span><br><span class="line">        <span class="built_in">print</span>(Symbol, end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ********** main program starts here ***********</span></span><br><span class="line"></span><br><span class="line">OutputSymbols(<span class="number">5</span>, <span class="string">'*'</span>)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong></p>
<p>在VB.NET中，传参方式默认为按值传递。<br>关键字<code>ByVal</code>是由编辑器自动插入的：  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Module1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> OutputSymbols(<span class="keyword">ByVal</span> NumberOfSymbols, <span class="keyword">ByVal</span> Symbol)</span><br><span class="line">        <span class="keyword">Dim</span> Count <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line">        <span class="keyword">For</span> Count = <span class="number">1</span> <span class="keyword">To</span> NumberOfSymbols</span><br><span class="line">            Console.Write(Symbol)</span><br><span class="line">        <span class="keyword">Next</span></span><br><span class="line">        Console.WriteLine()</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> Main()</span><br><span class="line">        OutputSymbols(<span class="number">5</span>, <span class="string">"*"</span>)</span><br><span class="line">        Console.ReadLine()</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong></p>
<p>在Python中，所有参数的行为都类似于局部变量，它们的效果就与传递值一样：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exl</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outputSymbols</span><span class="params">(<span class="type">int</span> numberOfSymbols, <span class="type">char</span> symbol)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; count &lt;= numberOfSymbols; count++)</span><br><span class="line">        {</span><br><span class="line">            System.out.print(symbol);</span><br><span class="line">        }</span><br><span class="line">        System.out.printIn();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        outputSymbols(<span class="number">5</span>, <span class="string">'*'</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a><strong>按引用传递参数</strong></h3><p>当参数通过引用传递时，当子例程内的值发生变化时，会影响调用程序中变量的值。  </p>
<p>下面会给出一个有关于过程<code>AdjustValuesForNextRow</code>的例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE AdjustValuesForNextRow(BYREF Spaces : INTEGER, Symbols : INTEGER)</span><br><span class="line">    Spaces ← Spaces - 1</span><br><span class="line">    Symbols ← Symbols + 2</span><br><span class="line">ENDPROCEDURE</span><br></pre></td></tr></table></figure>
<p>如果想要调用函数，就需要打出下面这行命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols)</span><br></pre></td></tr></table></figure>
<p>在调用该函数时，参数空格和符号的值会在过程中更改。<br>调用之后，程序代码中的变量<code>NumberOfSpaces</code>和<code>NumberOfSymbols</code>将存储从过程中传递回来的更新后的值。</p>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<p>Python没有提供按引用传递参数的功能。相反，下面的子程序表现为一个函数并返回多个值。<br>注意，在程序的主体部分中，变量是用来接收这些值的顺序的：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">AdjustValuesForNextRow</span>(<span class="params">Spaces, Symbols</span>):</span><br><span class="line">    Spaces = Spaces - <span class="number">1</span></span><br><span class="line">    Symbols = Symbols + <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> Spaces, Symbols</span><br><span class="line"></span><br><span class="line"><span class="comment"># ******** main program starts here *********</span></span><br><span class="line"></span><br><span class="line">NumberOfSpaces = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">NumberOfSymbols = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">NumberOfSpaces, NumberOfSymbols = AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols)</span><br><span class="line"><span class="built_in">print</span>(NumberOfSpaces)</span><br><span class="line"><span class="built_in">print</span>(NumberOfSymbols)</span><br></pre></td></tr></table></figure>
<p>这种将多个值作为一个单位处理的方式称为<code>tuple</code>。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong></p>
<p>在VB.NET中，<code>ByRef</code>关键字放在每个按引用传递的参数前面，用来表示按引用传递参数：  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Module1</span><br><span class="line">    <span class="keyword">Dim</span> NumberOfSpaces, NumberOfSymbols <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> AdjustValuesForNextRow(<span class="keyword">ByRef</span> Spaces, <span class="keyword">ByRef</span> Symbols)</span><br><span class="line">        Spaces = Spaces - <span class="number">1</span></span><br><span class="line">        Symbols = Symbols + <span class="number">2</span></span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Sub</span> Main()</span><br><span class="line">        NumberOfSpaces = Console.ReadLine()</span><br><span class="line">        NumberOfSymbols = Console.ReadLine()</span><br><span class="line">        AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols)</span><br><span class="line">        Console.WriteLine(NumberOfSpaces)</span><br><span class="line">        Console.WriteLine(NumberOfSymbols)</span><br><span class="line">        Console.ReadLine()</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong></p>
<p>Java没有提供通过引用传递简单变量参数的功能，只有对象可以通过引用传递。<br>在Java中，数组是对象，所以数组是通过引用传递的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exl;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exl</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RowData</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">spaces</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">symbols</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustValuesForNextRow</span><span class="params">(RowData thisRow)</span></span><br><span class="line">    {</span><br><span class="line">        thisRow.spaces--;</span><br><span class="line">        thisRow.symbols = thisRow.symbols + <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">console</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">RowData</span> <span class="variable">thisRow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowData</span>();</span><br><span class="line">        System.out.print(<span class="string">"Enter number of spaces: "</span>);</span><br><span class="line">        thisRow.spaces = console.nextInt();</span><br><span class="line">        System.output.print(<span class="string">"Enter number of symbols: "</span>);</span><br><span class="line">        thisRow.symbols = console.nextInt();</span><br><span class="line">        adjustValuesForNextRow(thisRow);</span><br><span class="line">        System.out.printIn(thisRow.spaces);</span><br><span class="line">        System.out.printIn(thisRow.symbols);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a><strong>数组</strong></h2><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a><strong>创建一维数组</strong></h3><p>Python，VB.NET和Java从下界值为0开始计算数组元素。  </p>
<p>伪代码be like:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE &lt;arrayIdentifier&gt; : ARRAY[&lt;lowerBound&gt;:&lt;upperBound&gt;] OF &lt;dataType&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-15"><a href="#语法定义和例子-15" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">~</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left">在Python中没有数组。等价的数据结构称为<strong>列表 (list)</strong>，列表是一组有序的元素序列，它们的数据类型不必相同。</td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>Dim &lt;arrayIdentifier&gt;(&lt;upperBound&gt;) As &lt;dataType&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>&lt;datatype&gt;[] &lt;arrayIdentifier&gt;;</code> <br> <code>&lt;arrayIdentifier&gt; = new int[&lt;upperBound&gt;+1];</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE List1 : ARRAY[1:3] OF STRING // 3 elements in this list</span><br><span class="line">DECLARE List2 : ARRAY[0:5] OF INTEGER // 6 elements in this list</span><br><span class="line">DECLARE List3 : ARRAY[1:100] OF INTEGER // 100 elements in this list</span><br><span class="line">DECLARE List4 : ARRAY[0:25] OF STRING // 26 elements in this list</span><br></pre></td></tr></table></figure>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List1 = []</span><br><span class="line">List1.append(<span class="string">"Fred"</span>)</span><br><span class="line">List1.append(<span class="string">"Jack"</span>)</span><br><span class="line">List1.append(<span class="string">"Ali"</span>)</span><br><span class="line"></span><br><span class="line">List2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">List3 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line">Alist = [<span class="string">""</span>] * <span class="number">26</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>List1：由于没有数据类型声明和列表声明，生成列表的唯一方法是初始化一个列表。<br>然后可以向现有列表中添加元素。  </p>
<p>List2：可以将元素包含在<code>[]</code>中。  </p>
<p>List3：你也可以使用一个循环来为列表添加内容。  </p>
<p>AList：可以提供一个初始值，乘以所需元素的数量。<code>""</code>填入初始值。  </p>
<p><br></p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> List1 <span class="keyword">As</span> <span class="type">String</span> () = {<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>}</span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> List2(<span class="number">5</span>) <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> List3(<span class="number">100</span>) <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> AList(<span class="number">0</span> <span class="keyword">To</span> <span class="number">25</span>) <span class="keyword">As</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>可以像List1一样，在声明时初始化数组。<br>注意，List3有101个元素。<br>你可以使用范围作为数组的维度(如AList)，但下界必须为0。</p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] list1 = {<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] list2;</span><br><span class="line">list2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] list3;</span><br><span class="line">list3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">String[] aList;</span><br><span class="line">aList = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">25</span>];</span><br></pre></td></tr></table></figure>
<p>同样，你可以在声明时初始化数组(如list1)。</p>
<p><br></p>
<hr>
<h3 id="访问一维数组-1"><a href="#访问一维数组-1" class="headerlink" title="访问一维数组"></a><strong>访问一维数组</strong></h3><p>在伪代码中，需要使用一个<strong>索引值 (Index value)</strong>来访问数组中的一个特定内容：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;arrayIdentifier&gt;[x]</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>下面开始举例：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NList[25] = 0  // set 25th element to zero(0)</span><br><span class="line">AList[3] = "D"  // set 3rd element to letter D</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NList[<span class="number">24</span>] = <span class="number">0</span></span><br><span class="line">AList[<span class="number">3</span>] = <span class="string">"D"</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>VB.NET</strong></p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NList(<span class="number">25</span>) = <span class="number">0</span></span><br><span class="line">AList(<span class="number">3</span>) = <span class="string">"D"</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nList[<span class="number">25</span>] = <span class="number">0</span>;</span><br><span class="line">aList[<span class="number">3</span>] = <span class="string">"D"</span>;</span><br></pre></td></tr></table></figure>
<p>在Python中，可使用<code>print(&lt;list&gt;)</code>打印列表的全部内容。<br>在VB.NET和Java中，你需要使用循环来打印数组中的所有元素。  </p>
<p><br></p>
<hr>
<h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a><strong>创建二维数组</strong></h3><p>伪代码be like:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE &lt;identifier&gt; : ARRAY[&lt;lBound1&gt;:&lt;uBound1&gt;,&lt;lBound2&gt;:&lt;uBound2&gt;] OF &lt;dataType&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h3 id="语法定义和例子-16"><a href="#语法定义和例子-16" class="headerlink" title="语法定义和例子"></a><strong>语法定义和例子</strong></h3><p>下表展示了语法定义：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:left">~</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left">在Python中没有数组。等价的数据结构称为<strong>列表 (list)</strong>。</td>
</tr>
<tr>
<td style="text-align:left">VB.NET</td>
<td style="text-align:left"><code>Dim &lt;arrayIdentifier&gt;(&lt;uBound1, uBound2&gt;) As &lt;dataType&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:left"><code>&lt;datatype&gt; &lt;arrayIdentifier&gt;;</code> <br> <code>&lt;arrayIdentifier&gt; = new &lt;datatype&gt;[uBound1][uBound2];</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><br></p>
<p>举出一些例子：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE Board : ARRAY[1:6, 1:7] OF INTEGER</span><br></pre></td></tr></table></figure>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Board = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">Board = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">Board = [[<span class="number">0</span>] * <span class="number">7</span>] * 6R</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> Board(<span class="number">6</span>, <span class="number">7</span>) <span class="keyword">As</span> <span class="type">Integer</span></span><br></pre></td></tr></table></figure>
<p>元素的编号从0到给定的数字。这个声明多了一行和一列。<br>然而，如果忽略第0行和第0列，该算法可能更容易转换为程序代码。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] board = {</span><br><span class="line">    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},</span><br><span class="line">    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},</span><br><span class="line">    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},</span><br><span class="line">    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},</span><br><span class="line">    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},</span><br><span class="line">    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] board;</span><br><span class="line">board = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>][<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>2维数组的初始化方式与一位数组类似。记住元素都是从0开始编号的。  </p>
<p><br></p>
<hr>
<h3 id="访问二维数组"><a href="#访问二维数组" class="headerlink" title="访问二维数组"></a><strong>访问二维数组</strong></h3><p>在伪代码中，需要使用一个<strong>索引值 (Index value)</strong>来访问数组中的一个特定内容：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;arrayIdentifier&gt;[x,y]</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p>下面开始举例：  </p>
<p>    <strong>伪代码</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board[3,4] ← 0 // sets the element in row 3 and column 4 to zero</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在Python中，元素从0开始编号，因此[3]访问的是第四个元素。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong></p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board(<span class="number">3</span>, <span class="number">4</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们忽略第0行和第0列：这里说的就是第三行第四列。  </p>
<p><br></p>
<p>    <strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>同样在Java中，元素从0开始编号，因此[3]访问的是第四个元素。  </p>
<p><br></p>
<hr>
<h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a><strong>文本文件</strong></h2><h3 id="向文本文件中写入"><a href="#向文本文件中写入" class="headerlink" title="向文本文件中写入"></a><strong>向文本文件中写入</strong></h3><p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPENFILE &lt;filename&gt; FOR WRITE          // open the file for writing</span><br><span class="line">WRITEFILE &lt;filename&gt;, &lt;stringValue&gt;    // write a line of text to the file</span><br><span class="line">CLOSEFILE &lt;filename&gt;                   // close file</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>下面的代码示例演示了如何用这三种语言分别打开、写入和关闭名为<code>SampleFile.txt</code>的文件。<br>如果文件已经存在，只要<code>open file</code>命令分配了文件句柄，它就会被覆盖。</p>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandle = <span class="built_in">open</span>(<span class="string">"SampleFile.TXT"</span>, <span class="string">"w"</span>)</span><br><span class="line">FileHandle.write(LineOfText)</span><br><span class="line">FileHandle.close()</span><br></pre></td></tr></table></figure>
<p>调用<code>open</code>函数时要指定文件名和模式(‘w’表示写入)。<br>要写入到文件中的文本行必须包含换行符<code>\n</code>，以便移动到文本文件的下一行。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> FileHandle <span class="keyword">As</span> IO.StreamWriter</span><br><span class="line"><span class="keyword">Dim</span> LineOfText <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line">FileHandle = <span class="built_in">New</span></span><br><span class="line">IO.StreamWriter(<span class="string">"SampleFile.TXT"</span>)</span><br><span class="line">FileHandle.WriteLine(LineOfText)</span><br><span class="line">FileHandle.Close()</span><br></pre></td></tr></table></figure>
<p>可以通过一个名为<code>StreamWriter</code>的对象访问该文件。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fileHandle</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileWriter</span>(<span class="string">"SampleFile.TXT"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">printLine</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">PrintWriter</span> (fileHandle)l</span><br><span class="line">String lineOfText;</span><br><span class="line">printLine.printf(<span class="string">"%s"</span>+<span class="string">"%n"</span>, lineOfText);</span><br><span class="line">printLine.close();</span><br></pre></td></tr></table></figure>
<p>输入输出操作会抛出异常。<br>管理它们的最简单方法是将你的主标题更改为: <code>public static void main(String[] args); throws IOException</code></p>
<p><br></p>
<hr>
<h3 id="从文本文件中读取"><a href="#从文本文件中读取" class="headerlink" title="从文本文件中读取"></a><strong>从文本文件中读取</strong></h3><p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPENFILE &lt;filename&gt; FOR READ             // open the file for writing</span><br><span class="line">READFILE &lt;filename&gt;, &lt;stringVariable&gt;    // read a line of text from the file</span><br><span class="line">CLOSEFILE &lt;filename&gt;                     // close file</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>继续用<code>SampleFile.txt</code>举例：    </p>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandle = <span class="built_in">open</span>(<span class="string">"SampleFile.TXT"</span>, <span class="string">"r"</span>)</span><br><span class="line">LineOfText = FileHandle.readline()</span><br><span class="line">FileHandle.close()</span><br></pre></td></tr></table></figure>
<p>调用<code>open</code>函数时要指定文件名和模式(‘r’表示读取)。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> FileHandle <span class="keyword">As</span> IO.StreamWriter</span><br><span class="line"><span class="keyword">Dim</span> LineOfText <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line">FileHandle = <span class="built_in">New</span> IO.StreamReader(<span class="string">"SampleFile.TXT"</span>)</span><br><span class="line">LineOfText = FileHandle.ReadLine()</span><br><span class="line">FileHandle.Close()</span><br></pre></td></tr></table></figure>
<p>同样，通过一个名为<code>StreamWriter</code>的对象访问该文件。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fileHandle</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileReader</span>(<span class="string">"SampleFile.TXT"</span>);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">textReader</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">BufferedReader</span>(fileHandle);</span><br><span class="line"><span class="type">String</span> <span class="variable">lineOfText</span> <span class="operator">=</span> textReader.readLine();</span><br><span class="line">textReader.close()</span><br></pre></td></tr></table></figure>
<p>还有其他库类可用于输入/输出，例如Scanner。  </p>
<p><br></p>
<hr>
<h3 id="追加到文本文件"><a href="#追加到文本文件" class="headerlink" title="追加到文本文件"></a><strong>追加到文本文件</strong></h3><p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPENFILE &lt;filename&gt; FOR APPEND        // open the file for append</span><br><span class="line">READFILE &lt;filename&gt;, &lt;stringValue&gt;    // write a line of text from the file</span><br><span class="line">CLOSEFILE &lt;filename&gt;                  // close file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>继续用<code>SampleFile.txt</code>举例：    </p>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandle = <span class="built_in">open</span>(<span class="string">"SampleFile.TXT"</span>, <span class="string">"a"</span>)</span><br><span class="line">FileHandle.write(LineOfText)</span><br><span class="line">FileHandle.close()</span><br></pre></td></tr></table></figure>
<p>调用<code>open</code>函数时要指定文件名和模式(‘a’表示附加)。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> FileHandle <span class="keyword">As</span> IO.StreamWriter</span><br><span class="line">FileHandle = <span class="built_in">New</span></span><br><span class="line">IO.StreamWriter(<span class="string">"SampleFile.TXT"</span>, <span class="literal">True</span>)</span><br><span class="line">FileHandle.WriteLine(LineOfText)</span><br><span class="line">FileHandle.Close()</span><br></pre></td></tr></table></figure>
<p>同样，通过一个名为<code>StreamWriter</code>的对象访问该文件。<br>额外的参数<code>True</code>告诉系统我们需要将元素添加到对象中。</p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fileHandle</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileReader</span>(<span class="string">"SampleFile.TXT"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">printLine</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">PrintWriter</span>(fileHandle);</span><br><span class="line">String lineOfText;</span><br><span class="line">printLine.printf(<span class="string">"%s"</span>+<span class="string">"%n"</span>, lineOfText);</span><br><span class="line">printLine.close();</span><br></pre></td></tr></table></figure>
<p>输入输出操作会抛出异常。<br>最简单的方法是将你的主标题改为:  <code>public static void main(String[] args) throws IOException</code></p>
<p><br></p>
<hr>
<h3 id="文件结束标记-EOF"><a href="#文件结束标记-EOF" class="headerlink" title="文件结束标记 (EOF)"></a><strong>文件结束标记 (EOF)</strong></h3><p><strong>EOF，为End Of File的缩写，通常在文本的最后存在此字符表示资料结束。</strong></p>
<p>伪代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OPENFILE "Test.txt" FOR READ</span><br><span class="line">WHILE NOT EOF("Test.txt") DO</span><br><span class="line">    READFILE "Test.txt", TextString</span><br><span class="line">    OUTPUT TextString</span><br><span class="line">ENDWHILE</span><br><span class="line">CLOSEFILE "Test.txt"</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>下面的代码示例演示了如何用这三种语言分别读取和输出文件的内容。三段语言都需要当碰到EOF后终止读取：  </p>
<p><br></p>
<p>    <strong>Python</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileHandle = <span class="built_in">open</span>(<span class="string">"Test.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">LineOfText = FileHandle.readline()</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(LineOfText) &gt; <span class="number">0</span>:</span><br><span class="line">    LineOfText = FileHandle.readline()</span><br><span class="line">    <span class="built_in">print</span>(LineOfText)</span><br><span class="line">FileHandle.close()</span><br></pre></td></tr></table></figure>
<p>在Python中没有显式的EOF函数。<br>但是，当读取的文本行只包含文件结束标记时，该文本行的长度为0。可以运用这点达成同样的效果。  </p>
<p><br></p>
<p>    <strong>VB.NET</strong>  </p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> LineOfText <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> FileHandle <span class="keyword">As</span> System.IO.StreamReader</span><br><span class="line">FileHandle = <span class="built_in">New</span></span><br><span class="line">System.IO.StreamReader(<span class="string">"Test.txt"</span>)</span><br><span class="line"><span class="keyword">Do</span> <span class="keyword">Until</span> FileHandle.EndOfStream</span><br><span class="line">    LineOfText = FileHandle.ReadLine()</span><br><span class="line">    Console.WriteLine(LineOfText)</span><br><span class="line"><span class="keyword">Loop</span></span><br><span class="line">FileHandle.Close()</span><br></pre></td></tr></table></figure>
<p>当检测到文件结束标记时，<code>EndOfStream</code>就会返回True，循环就会结束。  </p>
<p><br></p>
<p>    <strong>Java</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fileHandle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"Test.txt"</span>);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">textReader</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">BufferedReader</span>(fileHandle);</span><br><span class="line"><span class="type">String</span> <span class="variable">lineOfText</span> <span class="operator">=</span> textReader.readLine();</span><br><span class="line"><span class="keyword">while</span> (lineOfText != <span class="literal">null</span>)</span><br><span class="line">{</span><br><span class="line">    System.out.printIn(lineOfText);</span><br><span class="line">    lineOfText = textReader.readLine();</span><br><span class="line">}</span><br><span class="line">textReader.close();</span><br></pre></td></tr></table></figure>
<p>在Java里面也没有专门用于EOF函数。<br>但是，当读取的文本行只包含文件结束标记时，该文本行实际上是空的。我们可以运用这点达成同样的效果。    </p>
<p><br></p>
<hr>
<h1 id="第十五章：软件开发"><a href="#第十五章：软件开发" class="headerlink" title="第十五章：软件开发"></a><strong>第十五章：软件开发</strong></h1><h2 id="程序开发周期"><a href="#程序开发周期" class="headerlink" title="程序开发周期"></a><strong>程序开发周期</strong></h2><p>开发软件需要经历很多不同的阶段。<br>首先我们可以使用结构化英语，伪代码或者流程图来帮助我们理清程序的结构，然后再使用实际的语言编写。  </p>
<p>当需要大型软件系统来解决大问题时，这些阶段就会变得更加正式，特别是当更多的人参与开发时。<br>在设计解决方案之前，需要首先对问题进行分析。<br>当程序正常工作并被使用时，可能会出现需要修改的问题，这就是所谓的<strong>维护 (Maintenance)</strong>。  </p>
<p>下面来介绍程序开发周期中的每一步：</p>
<p><br></p>
<h3 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析 (Analysis)"></a><strong>分析 (Analysis)</strong></h3><p>解决问题的第一步是调查问题和当前的系统(如果存在的话)。<br>这个问题需要明确而精确地定义，然后再起草一份“需求说明书”。  </p>
<p>下一步就是思考解决方案。一个问题可能会有很多不同的解决方案。再分析这一步，我们有必要去思考这些解决方案中，哪一个是最合适，最有效的。  </p>
<p>第三步就是决定如何解决问题：  </p>
<ul>
<li><strong>Bottom-up</strong>：从一个小问题开始，然后在它的接触上一直向上构建新的内容。  </li>
<li><strong>Top-down</strong>：使用伪代码，流程图或者结构图逐步细化你的代码。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="设计-Design"><a href="#设计-Design" class="headerlink" title="设计 (Design)"></a><strong>设计 (Design)</strong></h3><p>到这一步你的心中应该已经有了一个确切的解决方案了。但是我们如何细致的设计解决方案？  </p>
<p>我们可以使用一个<strong>标识表 (Identifier table)</strong>，把我们需要考虑的数据全部写进表里。这有助于我们去考虑所有的数据以及它们的结构。比如说，我们到底是需要一个一维数组或者二维数组处理数据？我们是不是需要创立一个文件夹来专门存放长期数据？  </p>
<p>随后使用伪代码或者流程图来写出你的程序。</p>
<p>这些都是设计这一步的任务。  </p>
<p><br></p>
<hr>
<h3 id="编程-Coding"><a href="#编程-Coding" class="headerlink" title="编程 (Coding)"></a><strong>编程 (Coding)</strong></h3><p>设计解决方案后，可能需要选择合适的高级编程语言。<br>如果你会一种以上的编程语言，你必须权衡每一种语言的利弊。<br>上一章提到了各种语言 <em>(实际上只有三种语言)</em> 的强项与弱项。  </p>
<p>在这一步，我们会将伪代码转化成真真切切的代码。<br>当你开始编写程序时，你可能会发现程序在编译之前需要尝试好几次。当它最终完成时，我们就可以执行它。<br>有些时候程序可能会炸，在这种情况下，我们需要调试代码。<br>但是当我们的程序已经成功运行没有问题的时候，我们还需要考虑程序是否做了它应该做的事情。  </p>
<p><br></p>
<hr>
<h3 id="测试-Testing"><a href="#测试-Testing" class="headerlink" title="测试 (Testing)"></a><strong>测试 (Testing)</strong></h3><p>只有彻底的测试程序才能确保程序在所有情况下都能正常工作。  </p>
<p><br></p>
<hr>
<h3 id="程序开发生命周期"><a href="#程序开发生命周期" class="headerlink" title="程序开发生命周期"></a><strong>程序开发生命周期</strong></h3><p>有几种不同的开发方法。这包括<strong>瀑布式 (Waterfall)</strong>、<strong>迭代式 (Iterative)</strong>和<strong>快速应用程序开发模型 (Rapid application development model)</strong>。  </p>
<p>程序开发生命周期遵循分析、设计、编码(实现)、测试和维护的定义阶段。<br>当维护时需要对程序做出进一步调整时，开发就会重新开始，从而形成一个循环。如下图所示：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB60da65bc6e27483d4d0a78ea394c3791?method=download&amp;shareKey=fbf82d48e43b6264e620741c2af24167" alt=""></p>
<p><br></p>
<hr>
<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h3><p>下图展示了瀑布式开发周期的示意图：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe697a810daebb8e229ec272ace953615?method=download&amp;shareKey=8dac70db8706273056bfe209cffc1ce8" alt=""></p>
<p>图中向下的箭头表示一个阶段的结果被输入到下一个阶段。<br>返回到早期阶段的箭头反映了这样一个事实:在早期的开发阶段需要完成当前阶段更多的工作。</p>
<p>瀑布模型的好处有：  </p>
<ul>
<li>简单易懂，因为模型的每一个阶段都定义的十分清楚。  </li>
<li>由于模型中阶段的固定性，整个周期易于管理，而且每一个阶段都有特定的结果和成果。  </li>
<li>每一个阶段都需要被处理并完成。 </li>
<li>瀑布模型适用于<strong>需求被充分理解的小型项目</strong>。  </li>
</ul>
<p><br></p>
<p>瀑布模型的坏处有：  </p>
<ul>
<li>再整个开发周期的后期才能出现一个完全可用的软件。  </li>
<li>对于复杂并面向对象的项目来说，这个开发模式不是特别的适合。  </li>
<li>对于需要长期进行的项目来说，这个开发模式也不是很适合。  </li>
<li>没法适应不断变化的需求。  </li>
<li>很难衡量阶段性的发展。  </li>
<li>集成部分是在最后完成的，也就是说，如果有潜在的问题或者漏洞是很难发现的。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a><strong>迭代模型</strong></h3><p>迭代生命周期模型并不试图从完整的需求规范开始。相反，开发从实现程序需求的一个小子集开始。<br>重复的(迭代的)评审以确定进一步的需求，最终形成完整的系统。</p>
<p>好处如下：  </p>
<ul>
<li>在开发的早期阶段有一个早期Demo这就允许团队更容易找到功能或者设计缺陷。在开发的早期阶段发现问题意味着可以更快地采取纠正措施。  </li>
<li>有些功能可以在周期的早期快速开发。  </li>
<li>我们在早期可以周期性的获得结果。  </li>
<li>我们甚至可以规划并行发展。 </li>
<li>易于衡量进步和进展。 </li>
<li>变更项目范围或者需求的成本更低。  </li>
<li>测试和调试较小的程序子集十分的容易。 </li>
<li>在迭代过程中可以很轻易地识别并解决风险。  </li>
<li>更容易管理风险，因为较高风险的风险会被优先考虑。  </li>
<li>每一次增量更新都可以向客户交付产品。  </li>
<li>在每个增量更新中确定的问题，挑战和风险都可以被应用到下一个增量更新中。  </li>
<li>更适合<strong>大型和关键任务项目</strong>。  </li>
<li>在这个生命周期中，软件会被尽早地生产出来。这有助于团队从客户那里听到有关产品的评估和反馈。  </li>
</ul>
<p><br></p>
<p>当然也有坏处：  </p>
<ul>
<li>只有大型软件开发项目才会从这个生命周期中收益。因为很难再将小型软件系统继续拆拆拆成更小的部分了。  </li>
<li>可能会需要很多的资源，包括人力物力。  </li>
<li>可能会出现设计问题，因为并非所有需求都在整个生命周期的开始时收集。  </li>
<li>定义增量的时候可能需要定义整个系统。  </li>
</ul>
<p><br></p>
<hr>
<h3 id="快速应用程序开发模型"><a href="#快速应用程序开发模型" class="headerlink" title="快速应用程序开发模型"></a><strong>快速应用程序开发模型</strong></h3><p>RAD是一种使用最小计划的软件开发方法。相反，它规划原型来解决问题。<br><strong>原型 (Prototype)</strong>是解决方案的一部分的工作模型。</p>
<p>在快速应用开发模型中，模块作为原型并行开发，并集成以形成完整的产品，从而更快地交付产品。没有详细的预先规划，并且随时可以在开发过程中进行更改。  </p>
<p>特点就是分析、设计、编码和测试阶段被合并到一系列短的迭代开发周期中。  </p>
<p>优点：  </p>
<ul>
<li>可以适应不断变化的需求。</li>
<li>易于衡量进步。  </li>
<li>在短时间内，人越少，生产力越高。</li>
<li>开发时间可以大幅减少。</li>
<li>组建的可复用性大大增加。  </li>
<li>适用于<strong>基于组件和可扩展的程序</strong>。 </li>
<li>可以进行快速的审查。  </li>
<li>该模型鼓励用户去积极反馈问题。</li>
<li>在集成所有模块之间就解决了许多集成中可能出现的问题。  </li>
</ul>
<p><br></p>
<p>缺点：  </p>
<ul>
<li>只有模块化的程序才能够使用RAD构建。  </li>
<li>需要高水平的开发人员和设计师。  </li>
<li>需要客户在开发的过程中全程参与。  </li>
<li>仅适合开发时间较短的项目。</li>
</ul>
<p><br></p>
<hr>
<h2 id="使用结构图设计程序"><a href="#使用结构图设计程序" class="headerlink" title="使用结构图设计程序"></a><strong>使用结构图设计程序</strong></h2><p>另一种模块化设计方法是选择子任务，然后构建一个<strong>结构图 (Structure chart)</strong>来显示模块之间的相互关系。<br>结构图中的每个框代表一个模块，其中的每一层都是上一层的细化。</p>
<p>结构图还显示了模块之间的接口，变量。这些变量被称为<strong>参数 (Parameters)</strong>。<br>向下层模块传参显示为向下指向的箭头。<br>向上层模块传参显示为向上指向的箭头。</p>
<article class="message is-info"><div class="message-body">

<b>Structure chart: a graphical representation of the modular structure of a solution.</b>

<br>

<b>Parameter: a value passed between modules</b>

</div></article> 


<p><br></p>
<p>下图显示了计算两个数字平均值的模块的结构图。<br>顶层的方框是模块的名称，它被细化成了下一级的三个子任务。<br><code>INPUT numbers</code>(参数<code>Number1</code>和<code>Number2</code>)被传递到<code>Calculate average</code>子任务中，然后<code>Average</code>参数被传递到<code>OUTPUT average</code>子任务中。<br>箭头显示了参数如何在模块之间传递。传参的层级被称为”interface”。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc564ae4358133cb655f147a2b2760aa4?method=download&amp;shareKey=9aabe1c235840cc0a405704fa2a96bba" alt=""></p>
<p><br></p>
<p>结构图还可以显示控制信息，比如选择和重复。<br>在第十二章我们举过一个有关于猜数字的例子，这里我们把它模块化先：  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5999b0d7e2cec85554d922cbfe494b9f?method=download&amp;shareKey=c937693c229fa4e1ed50e4704de0e9f5" alt=""></p>
<p>其中的<strong>菱形表示一个条件，要么为真，要么为假。</strong></p>
<p><br></p>
<p>下图显示了绘制金字塔程序的结构图。<br>最上面的半圆形箭头表示箭头下方模块的重复，标签显示重复发生时的情况。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c8a00096191e1b7fcdfac95b8bfe82b?method=download&amp;shareKey=def37509a231ad83a03421f6a279500d" alt=""></p>
<p><br></p>
<p>结构图帮助程序员可视化模块如何相互关联以及它们如何相互连接。当考虑一个更大的问题时，这变得更加重要。<br>下面给出了名为”Connect 4”游戏的程序的结构图。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB26b804f3801358c6a5c4b7934697dc1e?method=download&amp;shareKey=2f051cd5f32512d0e3bb99aab1bac796" alt=""></p>
<p>在图片中我们能看见传参过程中有不同的箭头。  </p>
<ul>
<li>实心圆箭头表示传递的值是一个布尔值。  </li>
<li>双头箭头表示变量值在模块内更新。  </li>
</ul>
<p><br></p>
<hr>
<h2 id="从结构图中写出伪代码"><a href="#从结构图中写出伪代码" class="headerlink" title="从结构图中写出伪代码"></a><strong>从结构图中写出伪代码</strong></h2><p>让我们再来将目光聚集到上面的金字塔问题。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c8a00096191e1b7fcdfac95b8bfe82b?method=download&amp;shareKey=def37509a231ad83a03421f6a279500d" alt=""></p>
<p>在原来的例子中，创建模块时没有使用结构图，所有变量都是全局变量。<br>现在我们将使用局部变量和参数。<br>使用局部变量和参数的原因是因为模块是自包含的，对变量的任何更改不会对其他地方的变量值产生意外的影响。  </p>
<p>顶层模块<code>Pyramid</code>调用了4个模块。<br>当一个模块被调用时，我们在模块标识符后面的括号中提供参数。伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">MODULE Pyramid</span><br><span class="line">    CALL SetValues(NumberOfSymbols, NumberOfSpaces, Symbol, MaxNumberOfSymbols)</span><br><span class="line">    REPEAT</span><br><span class="line">        CALL OutputSpaces(NumberOfSpaces)</span><br><span class="line">        CALL OutputSymbols(NumberOfSymbols, Symbol)</span><br><span class="line">        CALL AdjustValesForNextRow(NumberOfSpaces, NumberOfSymbols)</span><br><span class="line">    UNTIL NumberOfSymbols &gt; MaxNumberOfSymbols</span><br><span class="line">ENDMODULE</span><br><span class="line"></span><br><span class="line">PROCUDURE SetValues(NumberOfSymbols, NumberOfSpaces, Symbol, MaxNumberOfSymbols)</span><br><span class="line">    INPUT Symbol</span><br><span class="line">    CALL InputMaxNumberOfSymbols</span><br><span class="line">    NumberOfSpaces ← (MaxNumberOfSymbols - 1) / 2</span><br><span class="line">    NumberOfSymbols ← 1</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCEDURE InputMaxNumberOfSymbols(MaxNumberOfSymbols)</span><br><span class="line">    REPEAT</span><br><span class="line">        INPUT MaxNumberOfSymbols</span><br><span class="line">    UNTIL MaxNumberOfSymbols MOD 2 = 1</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCUDURE OutputSpaces(NumberOfSpaces)</span><br><span class="line">    FOR Count ← 1 TO NumberOfSpaces</span><br><span class="line">        OUTPUT Space // without moving to next line</span><br><span class="line">    NEXT Count</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCEDURE OutputSymbols(NumberOfSYMBOLS, Symbol)</span><br><span class="line">    FOR Count ← 1 TO NumberOfSymbols</span><br><span class="line">        OUTPUT Symbol // without moving to next line</span><br><span class="line">    NEXT Count</span><br><span class="line">    OUTPUT Newline // move to the next line</span><br><span class="line">ENDPROCEDURE</span><br><span class="line"></span><br><span class="line">PROCEDURE AdjustValuesForNextRow(NumberOfSpaces, NumberOfSymbols)</span><br><span class="line">    NumberOfSpaces ← NumberOfSpaces - 1</span><br><span class="line">    NumberOfSymbols ← NumberOfSymbols + 2</span><br><span class="line">ENDPROCEDURE</span><br></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="状态转换图与程序设计"><a href="#状态转换图与程序设计" class="headerlink" title="状态转换图与程序设计"></a><strong>状态转换图与程序设计</strong></h2><p>我们的计算机系统可以看作是一个<strong>有限状态机(Finite State Machine, FSM)</strong>。<br>FSM有一个叫做start的状态。输入进FSM的指令会导致一种状态到另一种状态的转换。  </p>
<p>FSM的状态信息可以用<strong>状态转换表 (State-transition table)</strong>来表示。  </p>
<article class="message is-info"><div class="message-body">

<b>Finite state machine (FSM): a machine that consists of a fixed set of possible states with a set of inputs that change the state and a set of possible outputs.</b>

<br>

<b>State-transition table: a table that gives information about the states of an FSM</b>

</div></article> 

<p><br></p>
<p>下表展示了一个展示FSM状态的状态转换表：  </p>
<ul>
<li>如果状态为S1，则a的输入不会导致状态改变。  </li>
<li>如果状态为S1，则b的一个输入将S1转换为S2。  </li>
<li>如果状态为S2，则b的输入不会改变状态。  </li>
<li>如果处于S2状态，则a的输入将S2转换为Sl。  </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">input</th>
<th style="text-align:center">input name</th>
<th style="text-align:left">current state</th>
<th style="text-align:left">current state</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
<td style="text-align:left">S1</td>
<td style="text-align:left">S2</td>
</tr>
<tr>
<td style="text-align:left">input</td>
<td style="text-align:center">a</td>
<td style="text-align:left"><code>S1</code></td>
<td style="text-align:left"><code>S1</code></td>
</tr>
<tr>
<td style="text-align:left">input</td>
<td style="text-align:center">b</td>
<td style="text-align:left"><code>S2</code></td>
<td style="text-align:left"><code>S2</code></td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p><strong>状态转移图 (State-transition graph)</strong>可以用来描述有限状态机的行为。<br>下图开始状态为S1。开始状态会用一个实心圆球的箭头表示。<br>如果有限状态机有一个最终状态(也称为<strong>停机状态 (Halting state)</strong>)，则用一个双圆圈状态来表示。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB0d67ad6b45126f4a8ee3d887d532aee0?method=download&amp;shareKey=1e3092bc349c47a581a15704ae2efa00" alt=""></p>
<p><br></p>
<article class="message is-info"><div class="message-body">

<b>State-transition diagram: a diagram that describes the behaviour of an FSM.</b>

</div></article> 

<p><br></p>
<p>如果输入产生输出，则用竖线表示。<br>例如，如果当前状态为S1，b的输入产生了一个输出c，并将FSM转换为S2状态。这时候就会使用竖线隔开，表示输入输出。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBecea7fbf819b6c12f2ae69defd98f4d0?method=download&amp;shareKey=43b2f21937b18d3a84fe167e48bc1d39" alt=""></p>
<p>FSM还有一个别称：”Mealy Machine”。  </p>
<p><br></p>
<hr>
<h2 id="错误的类型"><a href="#错误的类型" class="headerlink" title="错误的类型"></a><strong>错误的类型</strong></h2><h3 id="为什么会发生错误-amp-我们如何找到它们"><a href="#为什么会发生错误-amp-我们如何找到它们" class="headerlink" title="为什么会发生错误 & 我们如何找到它们"></a><strong>为什么会发生错误 &amp; 我们如何找到它们</strong></h3><p>软件可能会因为下面的这些因素而没有按照预期的想法工作：  </p>
<ul>
<li>程序员在编程序的时候出现了错误。  </li>
<li>没有科学的在规划阶段指定需求。  </li>
<li>软件设计师犯了一个设计错误。  </li>
<li>UI设计的贼差，所以说用户可能会在使用时使程序出现问题。  </li>
<li>计算机硬件故障。  </li>
</ul>
<p><br></p>
<p>如何发现错误?<br>最终用户可能会报告一个错误，这无疑是不利于软件开发人员的声誉的。所以说，我们需要尽可能在软件发布之前进行测试，并修复尽可能多的漏洞。<br>研究表明，错误发现得越早，修复它的成本就越低。<br>软件在整个开发过程中都进行测试是非常重要的。</p>
<p>测试的目的是发现错误。著名的荷兰计算机科学家Edsger Dijkstra说:“程序测试可以用来显示bug的存在，但永远不能显示它们的不存在”。 (<em>每日名言</em>)  </p>
<p>查找<strong>语法错误 (Syntax errors)</strong>很容易。编译器/解释器会为你找到它们，并且通常会给你一个提示，告诉你哪里出了问题。  </p>
<p>根据开发环境编辑器的不同，编辑器可能会标记出一些语法错误，因此您可以在开发过程中纠正这些错误。<br>语法错误是一种“语法 (grammatical)”错误，指的是程序语句没有遵循高级语言结构的规则。</p>
<article class="message is-info"><div class="message-body">

<b>Syntax error: an error in which a program statement does not follow the rules of the language.</b>

</div></article> 

<p><br></p>
<p>有些语法错误可能只有在使用解释器或编译器翻译程序时才会变得明显。<br>解释器和编译器的工作方式不同。一旦程序成功编译后，你就知道不会再有语法错误了。</p>
<p>但是对于解释型程序，情况并非如此：只有即将执行的语句才会进行语法检查。<br>因此，如果你的程序没有经过彻底的测试，它甚至可能还有语法错误。</p>
<p>更难以发现的是<strong>逻辑错误 (Logic errors)</strong>和<strong>运行时错误 (Runtime errors)</strong>。<br>当程序执行意外停止或“崩溃”或进入无限循环并“冻结”时，发生的就是运行时错误。</p>
<article class="message is-info"><div class="message-body">

<b>Logic error: an error in the logic of the solution that causes it not to behave as intended.</b>

<br>

<b>Run-time error: an error that causes program execution to crash or freeze.</b>

</div></article> 

<p><br></p>
<p>这两种类型的错误都只能通过仔细的测试才能找到。<br>这种错误的危险在于，它们可能只会在某些情况下出现。<br>如果一个程序每次执行时都崩溃，那么很明显有错误。<br>如果程序被频繁地使用，并且看起来一直在工作，直到某组数据导致了故障，那么在不造成严重后果的情况下很难发现故障。  </p>
<p><br></p>
<hr>
<h2 id="测试程序的方法"><a href="#测试程序的方法" class="headerlink" title="测试程序的方法"></a><strong>测试程序的方法</strong></h2><h3 id="存根测试"><a href="#存根测试" class="headerlink" title="存根测试"></a><strong>存根测试</strong></h3><p><strong>存根测试 (Stub testing)</strong></p>
<p>在开发用户界面时，您可能希望在实现所有功能之前对其进行测试。<br>你可以为每个过程编写一个”存根 (Stub)”。  </p>
<p>存根(stub)和模拟(mocking)一样，意味着创建一个替身，但存根只模拟行为，而不是整个对象。<br>当你的实现只与对象的特定行为交互时，可以使用此方法。<br>比如说你想要测试你的主程序，但是你的每一个模块还没有完成，就可以使用Stub testing，通过定义每一个模块应输出的内容，来做到测试主程序的目的。  </p>
<p>每一个分叉只包含一条output语句，以确认进行了调用。<br>用户在主程序中选择的每个选项都将调用相关的过程。</p>
<p><br></p>
<hr>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a><strong>黑盒测试</strong></h3><p>作为程序员，你可以看到你的程序代码，你的测试将涉及代码的知识(参见白盒测试)。作为全面测试的一部分，程序还应该由其他人进行测试，他们看不到程序代码，也不知道解决方案是如何编码的。  </p>
<p>这样的程序测试人员将查看程序规范，以了解程序要做什么，设计测试数据并计算出预期的结果。<br><strong>测试数据 (Test data)</strong>通常由<strong>正常数据值</strong>、<strong>极端/边界数据值</strong>和<strong>错误/异常数据值</strong>组成。  </p>
<p>测试人员然后用测试数据运行程序并记录结果。<br>这种测试方法被称为黑盒测试，因为测试人员看不到程序代码的内部，程序对他们来说就像一个黑盒。  </p>
<p>当实际结果与预期结果不匹配时，就存在问题。<br>在修改程序之前，程序员需要找到这种差异的原因。<br>一旦黑盒测试确定存在错误，就必须使用调试软件或干式运行来找到需要更正的代码行。  </p>
<article class="message is-info"><div class="message-body">

<b>Test data: carefully chosen values that will test a program.</b>

<br>

<b>Black-box testing: comparing expected results with actual results when a program is running.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a><strong>白盒测试</strong></h3><p>我们如何检查代码是否正确工作?<br>我们选择合适的测试数据来检查代码中的每一条路径。这被称为<strong>白盒测试 (White-box testing)</strong>。  </p>
<article class="message is-info"><div class="message-body">

<b>White-box testing: testing every path through the program code</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="干式运行算法"><a href="#干式运行算法" class="headerlink" title="干式运行算法"></a><strong>干式运行算法</strong></h3><p>检查算法是否按预期工作的一种好方法是使用跟踪表和不同的测试数据来运行算法。<br>这也被称为walk through。  </p>
<p>其思想是在算法的每一步写下所有变量和条件值的当前内容。  </p>
<article class="message is-info"><div class="message-body">

<b>Dry-run (walk through): the process of checking the execution of an algorithm or program by recording variable values in a trace table.</b>

<br>

<b>Trace table: a table with a column for each variable that records their changing values.</b>

</div></article> 

<p><br></p>
<hr>
<h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a><strong>测试阶段</strong></h3><p>这些测试方法在软件开发的早期使用，例如在编写单个模块时。<br>有时程序员自己也会使用这些测试方法。<br>在较大的软件开发组织中，一般来说会有全职的软件测试人员。  </p>
<p>软件通常由许多模块组成，有时由不同的程序员编写。<br>每个单独的模块可能已经通过了所有测试，但当模块合并成一个程序时，测试整个程序至关重要。这就是所谓的<strong>集成测试 (Integration testing)</strong>。<br>集成测试通常是增量式的。这意味着每次添加一个模块就会完成一次测试，并在添加下一个模块之前进行进一步的测试。  </p>
<p>软件在发布给客户之前，将由软件测试人员进行内部测试。这种类型的测试称为<strong>Alpha测试 (Alpha testing)</strong>。  </p>
<p>定制软件(为特定客户编写的)将随后发布给客户。客户将检查它是否符合他们的要求并按预期工作。这个阶段称为<strong>验收测试 (Acceptance testing)</strong>。<br>这通常是交接过程的一部分。在成功的验收测试之后，客户将签署软件。  </p>
<p>当软件不是为销售而生产时，没有特定的客户来执行验收测试和签署软件。所以，在alpha测试之后，一个版本将发布给有限的潜在用户受众，即所谓的“beta测试者”。<br>这些测试人员将使用软件并在他们自己的环境中进行测试。这个早期的发布版本被称为beta版本，被选中的用户执行<strong>Beta测试 (Beta testing)</strong>。<br>在beta测试期间，用户将向软件库反馈他们发现的任何问题，以便软件库可以纠正任何报告的错误。</p>
<article class="message is-info"><div class="message-body">

<b>Integration testing: individually tested modules are joined into one program and tested to ensure the modules interact correctly.</b>

<br>

<b>Alpha testing: testing of software in-house by dedicated testers</b>

<br>

<b>Acceptance testing: testing of software by customers before sign-off.</b>

<br>

<b>Beta testing: testing of software by a limited number of chosen users before general release.</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="测试策略，测试计划和测试数据"><a href="#测试策略，测试计划和测试数据" class="headerlink" title="测试策略，测试计划和测试数据"></a><strong>测试策略，测试计划和测试数据</strong></h2><p>在软件项目的设计阶段，我们需要制定合适的测试策略，以确保从一开始就对软件进行严格的测试。<br>我们应考虑哪些测试方法适用于所述项目，因为必须制定一个精心设计的测试计划来确保最终程序的质量。  </p>
<p>一些时候，大型程序不能进行详尽的测试，但重要的是系统测试可以发现尽可能多的错误，因此我们需要一个测试计划。  </p>
<p>在第一个例子中，我们设计了一个大纲规划，如下：  </p>
<ul>
<li>控制流：用户是否已经得到了适当的选择？所选的选项是否导致特定模块正常工作？  </li>
<li>输入验证：所有的数据是否已经正确地输入进系统？  </li>
<li>循环和决策：循环和决策是否正确？  </li>
<li>存储：数据是否保存在正确的文件当中？  </li>
<li>输出验证：程序是否能够产生正确的输出？  </li>
</ul>
<p>列出这份大纲之后，我们还要逐步细化，直到做成一个详细的测试计划。  </p>
<p>我们如何进行这些测试?<br>首先我们需要选择能够让我们看到它是否被正确处理的数据，这种类型的数据称为“测试数据 (Test data)”。<br>它与真实的、实时的数据不同，因为它是为了测试不同的可能性而特意选择的。<br>我们区分不同类型的测试数据，如下表所示：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">测试数据类型</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Normal</strong> (valid)</td>
<td style="text-align:left">正常的，有效的，合理的数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Abnormal</strong> (erroneous)</td>
<td style="text-align:left">程序不应该接受的数据值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Boundary</strong> (extreme)</td>
<td style="text-align:left">处于正常数据范围的边界或者极端的数据值 <br> 测试数据应该包括恰好在边界内的值(即有效数据)和恰好在边界外的值(即无效数据)。</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<hr>
<h3 id="如何预防错误"><a href="#如何预防错误" class="headerlink" title="如何预防错误"></a><strong>如何预防错误</strong></h3><p>编写能正确工作的程序的最好方法，就是从一开始就防止错误。<br>我们如何将程序中的错误最小化? 产生错误的一个主要原因是贫乏的需求分析。<br>在设计解决方案时，理解问题以及系统的用户想要或需要什么是非常重要的。<br>我们应该使用如下方案来达成这一目的:  </p>
<ul>
<li>使用久经沙场的，主流的语言和语言结构，如结构化变成或者面向语言的设计。</li>
<li>使用业内约定俗成的规定，如标识符表，数据结构，或者使用标准的算法。  </li>
<li>使用程序库 (Program libraries)中经过验证的模块和对象。  </li>
</ul>
<p><br></p>
<hr>
<h2 id="纠正性维护"><a href="#纠正性维护" class="headerlink" title="纠正性维护"></a><strong>纠正性维护</strong></h2><p>维护程序不像维护机械设备那样：它不需要润滑，零件也不会磨损。<br><strong>纠正性维护 (Corrective maintenance)</strong>指的是当程序由于逻辑错误或运行时错误而不能正确工作时所需要的工作。  </p>
<p>有时，程序错误在很长一段时间内都不会变得明显，因为只有在非常罕见的情况下才会出现意外结果或程序崩溃。<br>这些情况可能是因为程序的某些部分不经常使用，或者因为某些情况下的数据包含极端值。过于早期的纠正性维护也可能引入其他错误。</p>
<article class="message is-info"><div class="message-body">

<b>Corrective maintenance: correcting identified errors.</b>

</div></article> 

<p><br></p>
<p>在报告问题时，程序员需要找出导致bug的原因。<br>为了找到bug，程序员要么使用程序调试软件，要么使用跟踪表。  </p>
<p><br></p>
<hr>
<h2 id="适应性维护"><a href="#适应性维护" class="headerlink" title="适应性维护"></a><strong>适应性维护</strong></h2><p>有时程序经常需要修改，以使其执行原本执行不了的功能。  </p>
<p>例如，第十三章介绍的Connect 4游戏允许O和X两个玩家对战。<br>修改后的版本将是一个玩家成为电脑。这意味着单个玩家与电脑下棋，尝试战胜计算机。  </p>
<p><strong>适应性维护 (Adaptive maintenance)</strong>是对程序进行修改以<strong>增强功能或响应规格变化</strong>的行为。  </p>
<article class="message is-info"><div class="message-body">

<b>Adaptive maintenance: amending a program to enhance functionality or in response to specification changes</b>

</div></article> 

<p><br></p>
<hr>
<h2 id="改善性维护"><a href="#改善性维护" class="headerlink" title="改善性维护"></a><strong>改善性维护</strong></h2><p>如果你的程序运行得令人满意，但是你发现仍有改进的空间。<br>例如，如果文件处理由顺序访问改为直接访问，程序可能运行得更快。  </p>
<p><strong>改善型维护 (Perfective maintenance)</strong>的目标是修改程序以提高性能或可维护性。  </p>
<article class="message is-info"><div class="message-body">

<b>Perfective maintenance: modifying a program to improve performance or maintainability.</b>

</div></article> 

<p><br></p>
<hr>
<p><strong>AS部分完结撒花</strong>  </p>
<p>(花)(花)(花)</p>
<p>最后更新于：<strong>2023.4.28</strong>  </p>
</div><div class="article-licensing box"><div class="licensing-title"><p>ASCS笔记</p><p><a href="http://naughtychas.github.io/2022/09/01/ASCS笔记/">http://naughtychas.github.io/2022/09/01/ASCS笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://NaughtyChas.github.io"><p>MXK</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-09-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-05-14</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2024/02/25/AL%20CS%20%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/" target="_blank" rel="noreferrer">AL CS 题目总结</a><br></span><span>  2.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2022/08/12/%E9%82%88%E6%83%B3%E6%97%A5%E9%9B%86/" target="_blank" rel="noreferrer">邈想日集</a><br></span><span>  2.<a class="is-size-6" href="/2022/08/24/Latex%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">LaTeX自学笔记</a><br></span><span>  3.<a class="is-size-6" href="/2024/02/25/AL%20CS%20%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/" target="_blank" rel="noreferrer">AL CS 题目总结</a><br></span><span>  4.<a class="is-size-6" href="/2022/09/01/ASCS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">ASCS笔记</a><br></span><span>  5.<a class="is-size-6" href="/2023/07/01/A2CS%E7%AC%94%E8%AE%B0/" target="_blank" rel="noreferrer">A2CS笔记</a><br></span><span>  6.<a class="is-size-6" href="/2022/08/12/%E6%B5%85%E8%B0%88%E4%BB%8A%E5%B9%B4CAIE%E7%9A%84POE%E8%80%83%E8%AF%95/" target="_blank" rel="noreferrer">浅谈今年CAIE的POE考试</a><br></span></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/09/05/%E4%BD%A0%E8%AF%B4%E5%BE%97%E5%AF%B9/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">收集&quot;你说得对&quot;</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/08/24/Latex%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"><span class="level-item">LaTeX自学笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'cd3959d276fa3caf2a7f842749b93dc0',
            repo: 'Blog-Comment',
            owner: 'NaughtyChas',
            clientID: 'b602cb01d4c2668b35ae',
            clientSecret: '0a26ed5993551a9754281410ba3aa5f772dfbdf2',
            admin: ["","NaughtyChas"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            proxy: 'https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1</span><span>写在前面</span></a></li><li><a class="is-flex is-mobile" href="#PART-ONE：理论基础"><span class="mr-2">2</span><span>PART ONE：理论基础</span></a></li><li><a class="is-flex is-mobile" href="#第一章：数据的表示"><span class="mr-2">3</span><span>第一章：数据的表示</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数字的内部编码"><span class="mr-2">3.1</span><span>数字的内部编码</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#编码"><span class="mr-2">3.1.1</span><span>编码</span></a></li><li><a class="is-flex is-mobile" href="#有关减法"><span class="mr-2">3.1.2</span><span>有关减法</span></a></li><li><a class="is-flex is-mobile" href="#Two’s-Complement"><span class="mr-2">3.1.3</span><span>Two’s Complement</span></a></li><li><a class="is-flex is-mobile" href="#有关数据溢出"><span class="mr-2">3.1.4</span><span>有关数据溢出</span></a></li><li><a class="is-flex is-mobile" href="#单位转换"><span class="mr-2">3.1.5</span><span>单位转换</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#字符集"><span class="mr-2">3.2</span><span>字符集</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#BCD"><span class="mr-2">3.2.1</span><span>BCD</span></a></li><li><a class="is-flex is-mobile" href="#ASCII-Code"><span class="mr-2">3.2.2</span><span>ASCII Code</span></a></li><li><a class="is-flex is-mobile" href="#Unicode"><span class="mr-2">3.2.3</span><span>Unicode</span></a></li><li><a class="is-flex is-mobile" href="#UTF-8"><span class="mr-2">3.2.4</span><span>UTF-8</span></a></li><li><a class="is-flex is-mobile" href="#图像"><span class="mr-2">3.2.5</span><span>图像</span></a></li><li><a class="is-flex is-mobile" href="#File-Header"><span class="mr-2">3.2.6</span><span>File Header</span></a></li><li><a class="is-flex is-mobile" href="#声音"><span class="mr-2">3.2.7</span><span>声音</span></a></li><li><a class="is-flex is-mobile" href="#压缩"><span class="mr-2">3.2.8</span><span>压缩</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第二章：通信与网络技术"><span class="mr-2">4</span><span>第二章：通信与网络技术</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#网络的目标与演变"><span class="mr-2">4.1</span><span>网络的目标与演变</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#广域网-WAN"><span class="mr-2">4.1.1</span><span>广域网 (WAN) </span></a></li><li><a class="is-flex is-mobile" href="#局域网-LAN"><span class="mr-2">4.1.2</span><span>局域网 (LAN)</span></a></li><li><a class="is-flex is-mobile" href="#客户机-服务器模型"><span class="mr-2">4.1.3</span><span>客户机-服务器模型</span></a></li><li><a class="is-flex is-mobile" href="#文件的分享"><span class="mr-2">4.1.4</span><span>文件的分享</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#网络拓扑结构"><span class="mr-2">4.2</span><span>网络拓扑结构</span></a></li><li><a class="is-flex is-mobile" href="#传输载体"><span class="mr-2">4.3</span><span>传输载体</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#线缆"><span class="mr-2">4.3.1</span><span>线缆</span></a></li><li><a class="is-flex is-mobile" href="#无线"><span class="mr-2">4.3.2</span><span>无线</span></a></li><li><a class="is-flex is-mobile" href="#有线-VS-无线"><span class="mr-2">4.3.3</span><span>有线 VS 无线</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#局域网硬件"><span class="mr-2">4.4</span><span>局域网硬件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#有线局域网"><span class="mr-2">4.4.1</span><span>有线局域网</span></a></li><li><a class="is-flex is-mobile" href="#无线局域网"><span class="mr-2">4.4.2</span><span>无线局域网</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#以太网"><span class="mr-2">4.5</span><span>以太网</span></a></li><li><a class="is-flex is-mobile" href="#互联网基础设施"><span class="mr-2">4.6</span><span>互联网基础设施</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#互联网服务提供商-ISP"><span class="mr-2">4.6.1</span><span>互联网服务提供商 (ISP)</span></a></li><li><a class="is-flex is-mobile" href="#路由器"><span class="mr-2">4.6.2</span><span>路由器</span></a></li><li><a class="is-flex is-mobile" href="#公共交换电话网-PSTN"><span class="mr-2">4.6.3</span><span>公共交换电话网 (PSTN)</span></a></li><li><a class="is-flex is-mobile" href="#移动电话网络"><span class="mr-2">4.6.4</span><span>移动电话网络</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#网络应用"><span class="mr-2">4.7</span><span>网络应用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#万维网-WWW"><span class="mr-2">4.7.1</span><span>万维网 (WWW)</span></a></li><li><a class="is-flex is-mobile" href="#云计算"><span class="mr-2">4.7.2</span><span>云计算</span></a></li><li><a class="is-flex is-mobile" href="#比特流"><span class="mr-2">4.7.3</span><span>比特流</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#IP"><span class="mr-2">4.8</span><span>IP</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#IP寻址"><span class="mr-2">4.8.1</span><span>IP寻址</span></a></li><li><a class="is-flex is-mobile" href="#无类域间路由（CIDR）"><span class="mr-2">4.8.2</span><span>无类域间路由（CIDR）</span></a></li><li><a class="is-flex is-mobile" href="#子网"><span class="mr-2">4.8.3</span><span>子网</span></a></li><li><a class="is-flex is-mobile" href="#网络桥接-NAT"><span class="mr-2">4.8.4</span><span>网络桥接 (NAT)</span></a></li><li><a class="is-flex is-mobile" href="#动态和静态IP地址"><span class="mr-2">4.8.5</span><span>动态和静态IP地址</span></a></li><li><a class="is-flex is-mobile" href="#IPv6"><span class="mr-2">4.8.6</span><span>IPv6</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#域名"><span class="mr-2">4.9</span><span>域名</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第三章：硬件"><span class="mr-2">5</span><span>第三章：硬件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#关于计算机"><span class="mr-2">5.1</span><span>关于计算机</span></a></li><li><a class="is-flex is-mobile" href="#数据的存储，输入与输出"><span class="mr-2">5.2</span><span>数据的存储，输入与输出</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#存储"><span class="mr-2">5.2.1</span><span>存储</span></a></li><li><a class="is-flex is-mobile" href="#输入"><span class="mr-2">5.2.2</span><span>输入</span></a></li><li><a class="is-flex is-mobile" href="#输出"><span class="mr-2">5.2.3</span><span>输出</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#嵌入式系统"><span class="mr-2">5.3</span><span>嵌入式系统</span></a></li><li><a class="is-flex is-mobile" href="#内存组件"><span class="mr-2">5.4</span><span>内存组件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#缓存"><span class="mr-2">5.4.1</span><span>缓存</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#二级存储"><span class="mr-2">5.5</span><span>二级存储</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#磁性介质"><span class="mr-2">5.5.1</span><span>磁性介质</span></a></li><li><a class="is-flex is-mobile" href="#光学介质"><span class="mr-2">5.5.2</span><span>光学介质</span></a></li><li><a class="is-flex is-mobile" href="#固体介质"><span class="mr-2">5.5.3</span><span>固体介质</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#通用输出设备"><span class="mr-2">5.6</span><span>通用输出设备</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#显示"><span class="mr-2">5.6.1</span><span>显示</span></a></li><li><a class="is-flex is-mobile" href="#文本输出"><span class="mr-2">5.6.2</span><span>文本输出</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#通用输入设备"><span class="mr-2">5.7</span><span>通用输入设备</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#GUI"><span class="mr-2">5.7.1</span><span>GUI</span></a></li><li><a class="is-flex is-mobile" href="#触摸屏"><span class="mr-2">5.7.2</span><span>触摸屏</span></a></li><li><a class="is-flex is-mobile" href="#影像输入"><span class="mr-2">5.7.3</span><span>影像输入</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#声音的输入与输出"><span class="mr-2">5.8</span><span>声音的输入与输出</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#语音输入输出"><span class="mr-2">5.8.1</span><span>语音输入输出</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第四章：逻辑门与逻辑电路"><span class="mr-2">6</span><span>第四章：逻辑门与逻辑电路</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#布尔逻辑与问题陈述"><span class="mr-2">6.1</span><span>布尔逻辑与问题陈述</span></a></li><li><a class="is-flex is-mobile" href="#布尔运算器"><span class="mr-2">6.2</span><span>布尔运算器</span></a></li><li><a class="is-flex is-mobile" href="#真值表"><span class="mr-2">6.3</span><span>真值表</span></a></li><li><a class="is-flex is-mobile" href="#逻辑电路与逻辑门"><span class="mr-2">6.4</span><span>逻辑电路与逻辑门</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第五章：处理器基本原理"><span class="mr-2">7</span><span>第五章：处理器基本原理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#冯·诺依曼结构"><span class="mr-2">7.1</span><span>冯·诺依曼结构</span></a></li><li><a class="is-flex is-mobile" href="#中央处理器（CPU）的结构"><span class="mr-2">7.2</span><span>中央处理器（CPU）的结构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#CPU的活动部分"><span class="mr-2">7.2.1</span><span>CPU的活动部分</span></a></li><li><a class="is-flex is-mobile" href="#寄存器"><span class="mr-2">7.2.2</span><span>寄存器</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#系统总线"><span class="mr-2">7.3</span><span>系统总线</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#地址总线"><span class="mr-2">7.3.1</span><span>地址总线</span></a></li><li><a class="is-flex is-mobile" href="#数据总线"><span class="mr-2">7.3.2</span><span>数据总线</span></a></li><li><a class="is-flex is-mobile" href="#控制总线"><span class="mr-2">7.3.3</span><span>控制总线</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#左右系统性能的因素"><span class="mr-2">7.4</span><span>左右系统性能的因素</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#字"><span class="mr-2">7.4.1</span><span>字</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#I-O"><span class="mr-2">7.5</span><span>I/O</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#USB"><span class="mr-2">7.5.1</span><span>USB</span></a></li><li><a class="is-flex is-mobile" href="#专用多媒体端口"><span class="mr-2">7.5.2</span><span>专用多媒体端口</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#指令周期"><span class="mr-2">7.6</span><span>指令周期</span></a></li><li><a class="is-flex is-mobile" href="#寄存器传输语言"><span class="mr-2">7.7</span><span>寄存器传输语言</span></a></li><li><a class="is-flex is-mobile" href="#中断处理"><span class="mr-2">7.8</span><span>中断处理</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第六章：汇编语言程序设计"><span class="mr-2">8</span><span>第六章：汇编语言程序设计</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#机器码"><span class="mr-2">8.1</span><span>机器码</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#操作码与操作数"><span class="mr-2">8.1.1</span><span>操作码与操作数</span></a></li><li><a class="is-flex is-mobile" href="#机器码-1"><span class="mr-2">8.1.2</span><span>机器码</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#汇编语言"><span class="mr-2">8.2</span><span>汇编语言</span></a></li><li><a class="is-flex is-mobile" href="#寻址类型"><span class="mr-2">8.3</span><span>寻址类型</span></a></li><li><a class="is-flex is-mobile" href="#两步汇编程序的汇编过程"><span class="mr-2">8.4</span><span>两步汇编程序的汇编过程</span></a></li><li><a class="is-flex is-mobile" href="#寻址模式"><span class="mr-2">8.5</span><span>寻址模式</span></a></li><li><a class="is-flex is-mobile" href="#汇编语言指令"><span class="mr-2">8.6</span><span>汇编语言指令</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数据的移动"><span class="mr-2">8.6.1</span><span>数据的移动</span></a></li><li><a class="is-flex is-mobile" href="#输入和输出"><span class="mr-2">8.6.2</span><span>输入和输出</span></a></li><li><a class="is-flex is-mobile" href="#比较和跳步"><span class="mr-2">8.6.3</span><span>比较和跳步</span></a></li><li><a class="is-flex is-mobile" href="#数学运算"><span class="mr-2">8.6.4</span><span>数学运算</span></a></li><li><a class="is-flex is-mobile" href="#移位运算"><span class="mr-2">8.6.5</span><span>移位运算</span></a></li><li><a class="is-flex is-mobile" href="#按位逻辑操作"><span class="mr-2">8.6.6</span><span>按位逻辑操作</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第七章：控制与监控系统"><span class="mr-2">9</span><span>第七章：控制与监控系统</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#监控系统"><span class="mr-2">9.1</span><span>监控系统</span></a></li><li><a class="is-flex is-mobile" href="#控制系统"><span class="mr-2">9.2</span><span>控制系统</span></a></li><li><a class="is-flex is-mobile" href="#控制设备的位操作"><span class="mr-2">9.3</span><span>控制设备的位操作</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第八章：系统软件"><span class="mr-2">10</span><span>第八章：系统软件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#操作系统"><span class="mr-2">10.1</span><span>操作系统</span></a></li><li><a class="is-flex is-mobile" href="#操作系统活动"><span class="mr-2">10.2</span><span>操作系统活动</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#用户界面"><span class="mr-2">10.2.1</span><span>用户界面</span></a></li><li><a class="is-flex is-mobile" href="#程序硬件接口"><span class="mr-2">10.2.2</span><span>程序硬件接口</span></a></li><li><a class="is-flex is-mobile" href="#资源管理"><span class="mr-2">10.2.3</span><span>资源管理</span></a></li><li><a class="is-flex is-mobile" href="#内存管理"><span class="mr-2">10.2.4</span><span>内存管理</span></a></li><li><a class="is-flex is-mobile" href="#设备管理"><span class="mr-2">10.2.5</span><span>设备管理</span></a></li><li><a class="is-flex is-mobile" href="#文件管理"><span class="mr-2">10.2.6</span><span>文件管理</span></a></li><li><a class="is-flex is-mobile" href="#安全控制"><span class="mr-2">10.2.7</span><span>安全控制</span></a></li><li><a class="is-flex is-mobile" href="#错误检测与恢复"><span class="mr-2">10.2.8</span><span>错误检测与恢复</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#应用程序软件"><span class="mr-2">10.3</span><span>应用程序软件</span></a></li><li><a class="is-flex is-mobile" href="#Program-libraries-程序库"><span class="mr-2">10.4</span><span>Program libraries 程序库</span></a></li><li><a class="is-flex is-mobile" href="#计算机语言转换"><span class="mr-2">10.5</span><span>计算机语言转换</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#编译器和解释器"><span class="mr-2">10.5.1</span><span>编译器和解释器</span></a></li><li><a class="is-flex is-mobile" href="#Java"><span class="mr-2">10.5.2</span><span>Java</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#集成开发环境-IDE"><span class="mr-2">10.6</span><span>集成开发环境(IDE)</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#代码高亮-Prettyprinting"><span class="mr-2">10.6.1</span><span>代码高亮 (Prettyprinting)</span></a></li><li><a class="is-flex is-mobile" href="#上下文敏感提示-Context-sensitive-prompts"><span class="mr-2">10.6.2</span><span>上下文敏感提示 (Context-sensitive prompts)</span></a></li><li><a class="is-flex is-mobile" href="#语法检查-Syntax-check"><span class="mr-2">10.6.3</span><span>语法检查 (Syntax check)</span></a></li><li><a class="is-flex is-mobile" href="#代码折叠-Expanding-and-collapsing-code-blocks"><span class="mr-2">10.6.4</span><span>代码折叠 (Expanding and collapsing code blocks)</span></a></li><li><a class="is-flex is-mobile" href="#Debug"><span class="mr-2">10.6.5</span><span>Debug</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第九章：安全、隐私和数据完整性"><span class="mr-2">11</span><span>第九章：安全、隐私和数据完整性</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#定义"><span class="mr-2">11.1</span><span>定义</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数据完整性"><span class="mr-2">11.1.1</span><span>数据完整性</span></a></li><li><a class="is-flex is-mobile" href="#数据隐私"><span class="mr-2">11.1.2</span><span>数据隐私</span></a></li><li><a class="is-flex is-mobile" href="#数据安全"><span class="mr-2">11.1.3</span><span>数据安全</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#对计算机系统及其存储数据安全的威胁"><span class="mr-2">11.2</span><span>对计算机系统及其存储数据安全的威胁</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#网络和互联网对计算机和数据安全的威胁"><span class="mr-2">11.2.1</span><span>网络和互联网对计算机和数据安全的威胁</span></a></li><li><a class="is-flex is-mobile" href="#恶意软件"><span class="mr-2">11.2.2</span><span>恶意软件</span></a></li><li><a class="is-flex is-mobile" href="#由用户活动引起的系统漏洞"><span class="mr-2">11.2.3</span><span>由用户活动引起的系统漏洞</span></a></li><li><a class="is-flex is-mobile" href="#系统本身产生的漏洞"><span class="mr-2">11.2.4</span><span>系统本身产生的漏洞</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#保持计算机数据良好的措施"><span class="mr-2">11.3</span><span>保持计算机数据良好的措施</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#灾难恢复"><span class="mr-2">11.3.1</span><span>灾难恢复</span></a></li><li><a class="is-flex is-mobile" href="#安全更新系统"><span class="mr-2">11.3.2</span><span>安全更新系统</span></a></li><li><a class="is-flex is-mobile" href="#用户身份验证"><span class="mr-2">11.3.3</span><span>用户身份验证</span></a></li><li><a class="is-flex is-mobile" href="#良好的使用习惯"><span class="mr-2">11.3.4</span><span>良好的使用习惯</span></a></li><li><a class="is-flex is-mobile" href="#防火墙"><span class="mr-2">11.3.5</span><span>防火墙</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#数据的安全性与完整性"><span class="mr-2">11.4</span><span>数据的安全性与完整性</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#输入数据验证"><span class="mr-2">11.4.1</span><span>输入数据验证</span></a></li><li><a class="is-flex is-mobile" href="#验证输入的数据"><span class="mr-2">11.4.2</span><span>验证输入的数据</span></a></li><li><a class="is-flex is-mobile" href="#按位检查"><span class="mr-2">11.4.3</span><span>按位检查</span></a></li><li><a class="is-flex is-mobile" href="#数据传输过程中的验证"><span class="mr-2">11.4.4</span><span>数据传输过程中的验证</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第十章：道德与所有权"><span class="mr-2">12</span><span>第十章：道德与所有权</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#道德-Ethics"><span class="mr-2">12.1</span><span>道德(Ethics)</span></a></li><li><a class="is-flex is-mobile" href="#计算机专业人员"><span class="mr-2">12.2</span><span>计算机专业人员</span></a></li><li><a class="is-flex is-mobile" href="#所有权与版权"><span class="mr-2">12.3</span><span>所有权与版权</span></a></li><li><a class="is-flex is-mobile" href="#软件许可"><span class="mr-2">12.4</span><span>软件许可</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#商业软件"><span class="mr-2">12.4.1</span><span>商业软件</span></a></li><li><a class="is-flex is-mobile" href="#开源软件或自由软件"><span class="mr-2">12.4.2</span><span>开源软件或自由软件</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#人工智能-AI"><span class="mr-2">12.5</span><span>人工智能(AI)</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#解决问题"><span class="mr-2">12.5.1</span><span>解决问题</span></a></li><li><a class="is-flex is-mobile" href="#语言学"><span class="mr-2">12.5.2</span><span>语言学</span></a></li><li><a class="is-flex is-mobile" href="#自动化"><span class="mr-2">12.5.3</span><span>自动化</span></a></li><li><a class="is-flex is-mobile" href="#推理"><span class="mr-2">12.5.4</span><span>推理</span></a></li><li><a class="is-flex is-mobile" href="#机器学习"><span class="mr-2">12.5.5</span><span>机器学习</span></a></li><li><a class="is-flex is-mobile" href="#AI的影响"><span class="mr-2">12.5.6</span><span>AI的影响</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第十一章：数据库"><span class="mr-2">13</span><span>第十一章：数据库</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#关于数据库"><span class="mr-2">13.1</span><span>关于数据库</span></a></li><li><a class="is-flex is-mobile" href="#数据库的标准"><span class="mr-2">13.2</span><span>数据库的标准</span></a></li><li><a class="is-flex is-mobile" href="#关系型数据库内容"><span class="mr-2">13.3</span><span>关系型数据库内容</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#table"><span class="mr-2">13.3.1</span><span>table</span></a></li><li><a class="is-flex is-mobile" href="#key"><span class="mr-2">13.3.2</span><span>key</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#三范式"><span class="mr-2">13.4</span><span>三范式</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#第一范式-1NF"><span class="mr-2">13.4.1</span><span>第一范式(1NF)</span></a></li><li><a class="is-flex is-mobile" href="#第二范式-2NF"><span class="mr-2">13.4.2</span><span>第二范式(2NF)</span></a></li><li><a class="is-flex is-mobile" href="#第三范式-3NF"><span class="mr-2">13.4.3</span><span>第三范式(3NF)</span></a></li><li><a class="is-flex is-mobile" href="#使用三范式规范化数据库"><span class="mr-2">13.4.4</span><span>使用三范式规范化数据库</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#数据库管理系统-DBMS"><span class="mr-2">13.5</span><span>数据库管理系统 (DBMS)</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#有关DBMS"><span class="mr-2">13.5.1</span><span>有关DBMS</span></a></li><li><a class="is-flex is-mobile" href="#DBMS提供的功能"><span class="mr-2">13.5.2</span><span>DBMS提供的功能</span></a></li><li><a class="is-flex is-mobile" href="#被DBA使用的DBMS功能"><span class="mr-2">13.5.3</span><span>被DBA使用的DBMS功能</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#MySQL及命令及语法"><span class="mr-2">13.6</span><span>MySQL及命令及语法</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数据定义语言-DDL"><span class="mr-2">13.6.1</span><span>数据定义语言 (DDL)</span></a></li><li><a class="is-flex is-mobile" href="#数据操作语言-DML"><span class="mr-2">13.6.2</span><span>数据操作语言 (DML)</span></a></li><li><a class="is-flex is-mobile" href="#命令基本操作"><span class="mr-2">13.6.3</span><span>命令基本操作</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#PART-TWO：基本问题的解决与编程技能"><span class="mr-2">14</span><span>PART TWO：基本问题的解决与编程技能</span></a></li><li><a class="is-flex is-mobile" href="#第十二章：算法设计与解决问题"><span class="mr-2">15</span><span>第十二章：算法设计与解决问题</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#计算思维"><span class="mr-2">15.1</span><span>计算思维</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#抽象问题"><span class="mr-2">15.1.1</span><span>抽象问题</span></a></li><li><a class="is-flex is-mobile" href="#分解问题"><span class="mr-2">15.1.2</span><span>分解问题</span></a></li><li><a class="is-flex is-mobile" href="#数据建模"><span class="mr-2">15.1.3</span><span>数据建模</span></a></li><li><a class="is-flex is-mobile" href="#样式识别"><span class="mr-2">15.1.4</span><span>样式识别</span></a></li><li><a class="is-flex is-mobile" href="#算法设计"><span class="mr-2">15.1.5</span><span>算法设计</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#算法"><span class="mr-2">15.2</span><span>算法</span></a></li><li><a class="is-flex is-mobile" href="#算法的表示"><span class="mr-2">15.3</span><span>算法的表示</span></a></li><li><a class="is-flex is-mobile" href="#变量"><span class="mr-2">15.4</span><span>变量</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#定义-1"><span class="mr-2">15.4.1</span><span>定义</span></a></li><li><a class="is-flex is-mobile" href="#标识符表"><span class="mr-2">15.4.2</span><span>标识符表</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#赋值"><span class="mr-2">15.5</span><span>赋值</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#向变量中赋值"><span class="mr-2">15.5.1</span><span>向变量中赋值</span></a></li><li><a class="is-flex is-mobile" href="#更新值"><span class="mr-2">15.5.2</span><span>更新值</span></a></li><li><a class="is-flex is-mobile" href="#复制值"><span class="mr-2">15.5.3</span><span>复制值</span></a></li><li><a class="is-flex is-mobile" href="#交换值"><span class="mr-2">15.5.4</span><span>交换值</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#逻辑表达式"><span class="mr-2">15.6</span><span>逻辑表达式</span></a></li><li><a class="is-flex is-mobile" href="#循环"><span class="mr-2">15.7</span><span>循环</span></a></li><li><a class="is-flex is-mobile" href="#逐步求精法"><span class="mr-2">15.8</span><span>逐步求精法</span></a></li><li><a class="is-flex is-mobile" href="#模块"><span class="mr-2">15.9</span><span>模块</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十三章：数据类型与结构"><span class="mr-2">16</span><span>第十三章：数据类型与结构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数据类型"><span class="mr-2">16.1</span><span>数据类型</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#基本数据类型"><span class="mr-2">16.1.1</span><span>基本数据类型</span></a></li><li><a class="is-flex is-mobile" href="#其他数据类型"><span class="mr-2">16.1.2</span><span>其他数据类型</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#记录类型"><span class="mr-2">16.2</span><span>记录类型</span></a></li><li><a class="is-flex is-mobile" href="#数组"><span class="mr-2">16.3</span><span>数组</span></a></li><li><a class="is-flex is-mobile" href="#一维数组"><span class="mr-2">16.4</span><span>一维数组</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#访问一维数组"><span class="mr-2">16.4.1</span><span>访问一维数组</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#二维数组"><span class="mr-2">16.5</span><span>二维数组</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#访问二维数列"><span class="mr-2">16.5.1</span><span>访问二维数列</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文本文档"><span class="mr-2">16.6</span><span>文本文档</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#向文本文档中写入"><span class="mr-2">16.6.1</span><span>向文本文档中写入</span></a></li><li><a class="is-flex is-mobile" href="#从文本文档中读取"><span class="mr-2">16.6.2</span><span>从文本文档中读取</span></a></li><li><a class="is-flex is-mobile" href="#向文本文档中追加内容"><span class="mr-2">16.6.3</span><span>向文本文档中追加内容</span></a></li><li><a class="is-flex is-mobile" href="#文件终止符-EOF"><span class="mr-2">16.6.4</span><span>文件终止符 (EOF)</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#抽象数据类型-ADT"><span class="mr-2">16.7</span><span>抽象数据类型 (ADT)</span></a></li><li><a class="is-flex is-mobile" href="#栈"><span class="mr-2">16.8</span><span>栈</span></a></li><li><a class="is-flex is-mobile" href="#队列"><span class="mr-2">16.9</span><span>队列</span></a></li><li><a class="is-flex is-mobile" href="#链表"><span class="mr-2">16.10</span><span>链表</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第十四章：编程与数据的表示"><span class="mr-2">17</span><span>第十四章：编程与数据的表示</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#编程语言"><span class="mr-2">17.1</span><span>编程语言</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Python"><span class="mr-2">17.1.1</span><span>Python</span></a></li><li><a class="is-flex is-mobile" href="#Visual-Basic-Console-Mode-VB-NET"><span class="mr-2">17.1.2</span><span>Visual Basic Console Mode (VB.NET)</span></a></li><li><a class="is-flex is-mobile" href="#Java-1"><span class="mr-2">17.1.3</span><span>Java</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#编程基础"><span class="mr-2">17.2</span><span>编程基础</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#变量的声明"><span class="mr-2">17.2.1</span><span>变量的声明</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子"><span class="mr-2">17.2.2</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#常量的声明和赋值"><span class="mr-2">17.2.3</span><span>常量的声明和赋值</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-1"><span class="mr-2">17.2.4</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#变量的赋值"><span class="mr-2">17.2.5</span><span>变量的赋值</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-2"><span class="mr-2">17.2.6</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#算数运算符"><span class="mr-2">17.2.7</span><span>算数运算符</span></a></li><li><a class="is-flex is-mobile" href="#输出信息"><span class="mr-2">17.2.8</span><span>输出信息</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-3"><span class="mr-2">17.2.9</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#从用户获取输入"><span class="mr-2">17.2.10</span><span>从用户获取输入</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-4"><span class="mr-2">17.2.11</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#注释"><span class="mr-2">17.2.12</span><span>注释</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-5"><span class="mr-2">17.2.13</span><span>语法定义和例子</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#数据类型-1"><span class="mr-2">17.3</span><span>数据类型</span></a></li><li><a class="is-flex is-mobile" href="#布尔表达式"><span class="mr-2">17.4</span><span>布尔表达式</span></a></li><li><a class="is-flex is-mobile" href="#选择语句"><span class="mr-2">17.5</span><span>选择语句</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#If…Then语句"><span class="mr-2">17.5.1</span><span>If…Then语句</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-6"><span class="mr-2">17.5.2</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#If…Then…Else语句"><span class="mr-2">17.5.3</span><span>If…Then…Else语句</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-7"><span class="mr-2">17.5.4</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#嵌套IF语句"><span class="mr-2">17.5.5</span><span>嵌套IF语句</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-8"><span class="mr-2">17.5.6</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#CASE语句"><span class="mr-2">17.5.7</span><span>CASE语句</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-9"><span class="mr-2">17.5.8</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#迭代"><span class="mr-2">17.5.9</span><span>迭代</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-10"><span class="mr-2">17.5.10</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#后置条件循环"><span class="mr-2">17.5.11</span><span>后置条件循环</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-11"><span class="mr-2">17.5.12</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#前置条件语句"><span class="mr-2">17.5.13</span><span>前置条件语句</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-12"><span class="mr-2">17.5.14</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#如何决定使用哪个循环？"><span class="mr-2">17.5.15</span><span>如何决定使用哪个循环？</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#内置函数"><span class="mr-2">17.6</span><span>内置函数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#字符串操作函数"><span class="mr-2">17.6.1</span><span>字符串操作函数</span></a></li><li><a class="is-flex is-mobile" href="#Python中的切片操作"><span class="mr-2">17.6.2</span><span>Python中的切片操作</span></a></li><li><a class="is-flex is-mobile" href="#数据截断"><span class="mr-2">17.6.3</span><span>数据截断</span></a></li><li><a class="is-flex is-mobile" href="#将字符串转换为数字"><span class="mr-2">17.6.4</span><span>将字符串转换为数字</span></a></li><li><a class="is-flex is-mobile" href="#生成随机数"><span class="mr-2">17.6.5</span><span>生成随机数</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#过程"><span class="mr-2">17.7</span><span>过程</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#语法定义和例子-13"><span class="mr-2">17.7.1</span><span>语法定义和例子</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#函数"><span class="mr-2">17.8</span><span>函数</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#语法定义和例子-14"><span class="mr-2">17.8.1</span><span>语法定义和例子</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#向子程序传参"><span class="mr-2">17.9</span><span>向子程序传参</span></a></li><li><a class="is-flex is-mobile" href="#向函数中传参"><span class="mr-2">17.10</span><span>向函数中传参</span></a></li><li><a class="is-flex is-mobile" href="#向过程中传参"><span class="mr-2">17.11</span><span>向过程中传参</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#按值传递参数"><span class="mr-2">17.11.1</span><span>按值传递参数</span></a></li><li><a class="is-flex is-mobile" href="#按引用传递参数"><span class="mr-2">17.11.2</span><span>按引用传递参数</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#数组-1"><span class="mr-2">17.12</span><span>数组</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#创建一维数组"><span class="mr-2">17.12.1</span><span>创建一维数组</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-15"><span class="mr-2">17.12.2</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#访问一维数组-1"><span class="mr-2">17.12.3</span><span>访问一维数组</span></a></li><li><a class="is-flex is-mobile" href="#创建二维数组"><span class="mr-2">17.12.4</span><span>创建二维数组</span></a></li><li><a class="is-flex is-mobile" href="#语法定义和例子-16"><span class="mr-2">17.12.5</span><span>语法定义和例子</span></a></li><li><a class="is-flex is-mobile" href="#访问二维数组"><span class="mr-2">17.12.6</span><span>访问二维数组</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文本文件"><span class="mr-2">17.13</span><span>文本文件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#向文本文件中写入"><span class="mr-2">17.13.1</span><span>向文本文件中写入</span></a></li><li><a class="is-flex is-mobile" href="#从文本文件中读取"><span class="mr-2">17.13.2</span><span>从文本文件中读取</span></a></li><li><a class="is-flex is-mobile" href="#追加到文本文件"><span class="mr-2">17.13.3</span><span>追加到文本文件</span></a></li><li><a class="is-flex is-mobile" href="#文件结束标记-EOF"><span class="mr-2">17.13.4</span><span>文件结束标记 (EOF)</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第十五章：软件开发"><span class="mr-2">18</span><span>第十五章：软件开发</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#程序开发周期"><span class="mr-2">18.1</span><span>程序开发周期</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#分析-Analysis"><span class="mr-2">18.1.1</span><span>分析 (Analysis)</span></a></li><li><a class="is-flex is-mobile" href="#设计-Design"><span class="mr-2">18.1.2</span><span>设计 (Design)</span></a></li><li><a class="is-flex is-mobile" href="#编程-Coding"><span class="mr-2">18.1.3</span><span>编程 (Coding)</span></a></li><li><a class="is-flex is-mobile" href="#测试-Testing"><span class="mr-2">18.1.4</span><span>测试 (Testing)</span></a></li><li><a class="is-flex is-mobile" href="#程序开发生命周期"><span class="mr-2">18.1.5</span><span>程序开发生命周期</span></a></li><li><a class="is-flex is-mobile" href="#瀑布模型"><span class="mr-2">18.1.6</span><span>瀑布模型</span></a></li><li><a class="is-flex is-mobile" href="#迭代模型"><span class="mr-2">18.1.7</span><span>迭代模型</span></a></li><li><a class="is-flex is-mobile" href="#快速应用程序开发模型"><span class="mr-2">18.1.8</span><span>快速应用程序开发模型</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#使用结构图设计程序"><span class="mr-2">18.2</span><span>使用结构图设计程序</span></a></li><li><a class="is-flex is-mobile" href="#从结构图中写出伪代码"><span class="mr-2">18.3</span><span>从结构图中写出伪代码</span></a></li><li><a class="is-flex is-mobile" href="#状态转换图与程序设计"><span class="mr-2">18.4</span><span>状态转换图与程序设计</span></a></li><li><a class="is-flex is-mobile" href="#错误的类型"><span class="mr-2">18.5</span><span>错误的类型</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#为什么会发生错误-amp-我们如何找到它们"><span class="mr-2">18.5.1</span><span>为什么会发生错误 &amp; 我们如何找到它们</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#测试程序的方法"><span class="mr-2">18.6</span><span>测试程序的方法</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#存根测试"><span class="mr-2">18.6.1</span><span>存根测试</span></a></li><li><a class="is-flex is-mobile" href="#黑盒测试"><span class="mr-2">18.6.2</span><span>黑盒测试</span></a></li><li><a class="is-flex is-mobile" href="#白盒测试"><span class="mr-2">18.6.3</span><span>白盒测试</span></a></li><li><a class="is-flex is-mobile" href="#干式运行算法"><span class="mr-2">18.6.4</span><span>干式运行算法</span></a></li><li><a class="is-flex is-mobile" href="#测试阶段"><span class="mr-2">18.6.5</span><span>测试阶段</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#测试策略，测试计划和测试数据"><span class="mr-2">18.7</span><span>测试策略，测试计划和测试数据</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#如何预防错误"><span class="mr-2">18.7.1</span><span>如何预防错误</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#纠正性维护"><span class="mr-2">18.8</span><span>纠正性维护</span></a></li><li><a class="is-flex is-mobile" href="#适应性维护"><span class="mr-2">18.9</span><span>适应性维护</span></a></li><li><a class="is-flex is-mobile" href="#改善性维护"><span class="mr-2">18.10</span><span>改善性维护</span></a></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="ntcs&#039; blog" height="28"></a><p class="size-small"><span>&copy; 2024 MXK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noreferrer">Icarus</a> &amp; <a href="https://github.com/LittleYe233/hexo-theme-amazingremake" target="_blank" rel="noreferrer">Amazing-Remake</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022.8.11 17:07:12')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/LittleYe233/hexo-theme-amazingremake"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    enabled: true,
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { // 加载mathjax
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$']],
                    autoload: {
                        color: [],
                        colorv2: ['color']
                    },
                    packages: {'[+]': ['noerrors']}
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                },
                loader: {
                    load: ['input/asciimath', '[tex]/noerrors']
                }
            };
            $.getScript('//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('b602cb01d4c2668b35ae','0a26ed5993551a9754281410ba3aa5f772dfbdf2','NaughtyChas','Blog-Comment',false);});
            }
            if('undefined' === 'mathjax'){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>